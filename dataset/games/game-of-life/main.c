#include "/usr/local/bin/tigress/3.3.2/tigress.h"
/* Generated by CIL v. %%VERSION_NUM%% */
/* print_CIL_Input is true */

#include <stdlib.h>
#include <stdio.h>


#line 5 "../src/game.h"
struct Game ;
#line 7 "../src/game.h"
typedef int Cell;
#line 9 "../src/engine.h"
struct Engine ;
#line 180 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef short int16_t;
#line 185 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef int int32_t;
#line 190 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long int64_t;
#line 205 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned short uint16_t;
#line 210 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int uint32_t;
#line 46 "/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h"
typedef unsigned long size_t___0;
#line 200 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned char uint8_t;
#line 398
struct _IO_FILE ;
#line 398 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef struct _IO_FILE FILE;
#line 202 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef uint8_t Uint8;
#line 208 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef int16_t Sint16;
#line 214 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef uint16_t Uint16;
#line 220 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef int32_t Sint32;
#line 226 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef uint32_t Uint32;
#line 233 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef int64_t Sint64;
#line 78 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_rect.h"
struct SDL_Rect {
   int x ;
   int y ;
   int w ;
   int h ;
};
#line 78 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_rect.h"
typedef struct SDL_Rect SDL_Rect;
#line 40 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_blendmode.h"
enum __anonenum_SDL_BlendMode_930361395 {
    SDL_BLENDMODE_NONE = 0,
    SDL_BLENDMODE_BLEND = 1,
    SDL_BLENDMODE_ADD = 2,
    SDL_BLENDMODE_MOD = 4,
    SDL_BLENDMODE_MUL = 8,
    SDL_BLENDMODE_INVALID = 2147483647
} ;
#line 40 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_blendmode.h"
typedef enum __anonenum_SDL_BlendMode_930361395 SDL_BlendMode;
#line 95 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_video.h"
struct SDL_Window ;
#line 95 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_video.h"
typedef struct SDL_Window SDL_Window;
#line 43 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_scancode.h"
enum __anonenum_SDL_Scancode_605597982 {
    SDL_SCANCODE_UNKNOWN = 0,
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,
    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,
    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,
    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    SDL_SCANCODE_BACKSLASH = 49,
    SDL_SCANCODE_NONUSHASH = 50,
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    SDL_SCANCODE_GRAVE = 53,
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,
    SDL_SCANCODE_CAPSLOCK = 57,
    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,
    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    SDL_SCANCODE_INSERT = 73,
    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,
    SDL_SCANCODE_NUMLOCKCLEAR = 83,
    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,
    SDL_SCANCODE_NONUSBACKSLASH = 100,
    SDL_SCANCODE_APPLICATION = 101,
    SDL_SCANCODE_POWER = 102,
    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,
    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,
    SDL_SCANCODE_INTERNATIONAL1 = 135,
    SDL_SCANCODE_INTERNATIONAL2 = 136,
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    SDL_SCANCODE_LANG1 = 144,
    SDL_SCANCODE_LANG2 = 145,
    SDL_SCANCODE_LANG3 = 146,
    SDL_SCANCODE_LANG4 = 147,
    SDL_SCANCODE_LANG5 = 148,
    SDL_SCANCODE_LANG6 = 149,
    SDL_SCANCODE_LANG7 = 150,
    SDL_SCANCODE_LANG8 = 151,
    SDL_SCANCODE_LANG9 = 152,
    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,
    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,
    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    SDL_SCANCODE_LALT = 226,
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    SDL_SCANCODE_RALT = 230,
    SDL_SCANCODE_RGUI = 231,
    SDL_SCANCODE_MODE = 257,
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    SDL_SCANCODE_DISPLAYSWITCH = 277,
    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,
    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
    SDL_SCANCODE_AUDIOREWIND = 285,
    SDL_SCANCODE_AUDIOFASTFORWARD = 286,
    SDL_SCANCODE_SOFTLEFT = 287,
    SDL_SCANCODE_SOFTRIGHT = 288,
    SDL_SCANCODE_CALL = 289,
    SDL_SCANCODE_ENDCALL = 290,
    SDL_NUM_SCANCODES = 512
} ;
#line 43 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_scancode.h"
typedef enum __anonenum_SDL_Scancode_605597982 SDL_Scancode;
#line 45 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_keycode.h"
typedef Sint32 SDL_Keycode;
#line 47 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_keyboard.h"
struct SDL_Keysym {
   SDL_Scancode scancode ;
   SDL_Keycode sym ;
   Uint16 mod ;
   Uint32 unused ;
};
#line 47 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_keyboard.h"
typedef struct SDL_Keysym SDL_Keysym;
#line 82 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_joystick.h"
typedef Sint32 SDL_JoystickID;
#line 98
enum __anonenum_SDL_JoystickPowerLevel_945502366 {
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY = 0,
    SDL_JOYSTICK_POWER_LOW = 1,
    SDL_JOYSTICK_POWER_MEDIUM = 2,
    SDL_JOYSTICK_POWER_FULL = 3,
    SDL_JOYSTICK_POWER_WIRED = 4,
    SDL_JOYSTICK_POWER_MAX = 5
} ;
#line 98 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_joystick.h"
typedef enum __anonenum_SDL_JoystickPowerLevel_945502366 SDL_JoystickPowerLevel;
#line 41 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_touch.h"
typedef Sint64 SDL_TouchID;
#line 42 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_touch.h"
typedef Sint64 SDL_FingerID;
#line 44 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_gesture.h"
typedef Sint64 SDL_GestureID;
#line 182 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_CommonEvent {
   Uint32 type ;
   Uint32 timestamp ;
};
#line 182 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_CommonEvent SDL_CommonEvent;
#line 191 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_DisplayEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 display ;
   Uint8 event ;
   Uint8 padding1 ;
   Uint8 padding2 ;
   Uint8 padding3 ;
   Sint32 data1 ;
};
#line 191 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_DisplayEvent SDL_DisplayEvent;
#line 206 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_WindowEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   Uint8 event ;
   Uint8 padding1 ;
   Uint8 padding2 ;
   Uint8 padding3 ;
   Sint32 data1 ;
   Sint32 data2 ;
};
#line 206 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_WindowEvent SDL_WindowEvent;
#line 222 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_KeyboardEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   Uint8 state ;
   Uint8 repeat ;
   Uint8 padding2 ;
   Uint8 padding3 ;
   SDL_Keysym keysym ;
};
#line 222 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_KeyboardEvent SDL_KeyboardEvent;
#line 238 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TextEditingEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   char text[32] ;
   Sint32 start ;
   Sint32 length ;
};
#line 238 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TextEditingEvent SDL_TextEditingEvent;
#line 252 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TextEditingExtEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   char *text ;
   Sint32 start ;
   Sint32 length ;
};
#line 252 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TextEditingExtEvent SDL_TextEditingExtEvent;
#line 266 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TextInputEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   char text[32] ;
};
#line 266 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TextInputEvent SDL_TextInputEvent;
#line 277 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MouseMotionEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   Uint32 which ;
   Uint32 state ;
   Sint32 x ;
   Sint32 y ;
   Sint32 xrel ;
   Sint32 yrel ;
};
#line 277 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MouseMotionEvent SDL_MouseMotionEvent;
#line 293 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MouseButtonEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   Uint32 which ;
   Uint8 button ;
   Uint8 state ;
   Uint8 clicks ;
   Uint8 padding1 ;
   Sint32 x ;
   Sint32 y ;
};
#line 293 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MouseButtonEvent SDL_MouseButtonEvent;
#line 310 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MouseWheelEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   Uint32 which ;
   Sint32 x ;
   Sint32 y ;
   Uint32 direction ;
   float preciseX ;
   float preciseY ;
};
#line 310 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MouseWheelEvent SDL_MouseWheelEvent;
#line 326 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyAxisEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Uint8 axis ;
   Uint8 padding1 ;
   Uint8 padding2 ;
   Uint8 padding3 ;
   Sint16 value ;
   Uint16 padding4 ;
};
#line 326 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyAxisEvent SDL_JoyAxisEvent;
#line 342 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyBallEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Uint8 ball ;
   Uint8 padding1 ;
   Uint8 padding2 ;
   Uint8 padding3 ;
   Sint16 xrel ;
   Sint16 yrel ;
};
#line 342 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyBallEvent SDL_JoyBallEvent;
#line 358 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyHatEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Uint8 hat ;
   Uint8 value ;
   Uint8 padding1 ;
   Uint8 padding2 ;
};
#line 358 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyHatEvent SDL_JoyHatEvent;
#line 378 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyButtonEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Uint8 button ;
   Uint8 state ;
   Uint8 padding1 ;
   Uint8 padding2 ;
};
#line 378 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyButtonEvent SDL_JoyButtonEvent;
#line 392 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyDeviceEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Sint32 which ;
};
#line 392 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyDeviceEvent SDL_JoyDeviceEvent;
#line 402 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyBatteryEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   SDL_JoystickPowerLevel level ;
};
#line 402 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyBatteryEvent SDL_JoyBatteryEvent;
#line 413 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerAxisEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Uint8 axis ;
   Uint8 padding1 ;
   Uint8 padding2 ;
   Uint8 padding3 ;
   Sint16 value ;
   Uint16 padding4 ;
};
#line 413 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerAxisEvent SDL_ControllerAxisEvent;
#line 430 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerButtonEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Uint8 button ;
   Uint8 state ;
   Uint8 padding1 ;
   Uint8 padding2 ;
};
#line 430 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerButtonEvent SDL_ControllerButtonEvent;
#line 445 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerDeviceEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Sint32 which ;
};
#line 445 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerDeviceEvent SDL_ControllerDeviceEvent;
#line 455 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerTouchpadEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Sint32 touchpad ;
   Sint32 finger ;
   float x ;
   float y ;
   float pressure ;
};
#line 455 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerTouchpadEvent SDL_ControllerTouchpadEvent;
#line 470 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerSensorEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_JoystickID which ;
   Sint32 sensor ;
   float data[3] ;
};
#line 470 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerSensorEvent SDL_ControllerSensorEvent;
#line 482 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_AudioDeviceEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 which ;
   Uint8 iscapture ;
   Uint8 padding1 ;
   Uint8 padding2 ;
   Uint8 padding3 ;
};
#line 482 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_AudioDeviceEvent SDL_AudioDeviceEvent;
#line 497 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TouchFingerEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_TouchID touchId ;
   SDL_FingerID fingerId ;
   float x ;
   float y ;
   float dx ;
   float dy ;
   float pressure ;
   Uint32 windowID ;
};
#line 497 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TouchFingerEvent SDL_TouchFingerEvent;
#line 515 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MultiGestureEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_TouchID touchId ;
   float dTheta ;
   float dDist ;
   float x ;
   float y ;
   Uint16 numFingers ;
   Uint16 padding ;
};
#line 515 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MultiGestureEvent SDL_MultiGestureEvent;
#line 532 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_DollarGestureEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_TouchID touchId ;
   SDL_GestureID gestureId ;
   Uint32 numFingers ;
   float error ;
   float x ;
   float y ;
};
#line 532 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_DollarGestureEvent SDL_DollarGestureEvent;
#line 550 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_DropEvent {
   Uint32 type ;
   Uint32 timestamp ;
   char *file ;
   Uint32 windowID ;
};
#line 550 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_DropEvent SDL_DropEvent;
#line 562 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_SensorEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Sint32 which ;
   float data[6] ;
};
#line 562 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_SensorEvent SDL_SensorEvent;
#line 573 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_QuitEvent {
   Uint32 type ;
   Uint32 timestamp ;
};
#line 573 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_QuitEvent SDL_QuitEvent;
#line 591 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_UserEvent {
   Uint32 type ;
   Uint32 timestamp ;
   Uint32 windowID ;
   Sint32 code ;
   void *data1 ;
   void *data2 ;
};
#line 591 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_UserEvent SDL_UserEvent;
#line 602
struct SDL_SysWMmsg ;
#line 603 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_SysWMmsg SDL_SysWMmsg;
#line 611 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_SysWMEvent {
   Uint32 type ;
   Uint32 timestamp ;
   SDL_SysWMmsg *msg ;
};
#line 611 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_SysWMEvent SDL_SysWMEvent;
#line 621 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
union SDL_Event {
   Uint32 type ;
   SDL_CommonEvent common ;
   SDL_DisplayEvent display ;
   SDL_WindowEvent window ;
   SDL_KeyboardEvent key ;
   SDL_TextEditingEvent edit ;
   SDL_TextEditingExtEvent editExt ;
   SDL_TextInputEvent text ;
   SDL_MouseMotionEvent motion ;
   SDL_MouseButtonEvent button ;
   SDL_MouseWheelEvent wheel ;
   SDL_JoyAxisEvent jaxis ;
   SDL_JoyBallEvent jball ;
   SDL_JoyHatEvent jhat ;
   SDL_JoyButtonEvent jbutton ;
   SDL_JoyDeviceEvent jdevice ;
   SDL_JoyBatteryEvent jbattery ;
   SDL_ControllerAxisEvent caxis ;
   SDL_ControllerButtonEvent cbutton ;
   SDL_ControllerDeviceEvent cdevice ;
   SDL_ControllerTouchpadEvent ctouchpad ;
   SDL_ControllerSensorEvent csensor ;
   SDL_AudioDeviceEvent adevice ;
   SDL_SensorEvent sensor ;
   SDL_QuitEvent quit ;
   SDL_UserEvent user ;
   SDL_SysWMEvent syswm ;
   SDL_TouchFingerEvent tfinger ;
   SDL_MultiGestureEvent mgesture ;
   SDL_DollarGestureEvent dgesture ;
   SDL_DropEvent drop ;
   Uint8 padding[56UL] ;
};
#line 621 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef union SDL_Event SDL_Event;
#line 141 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_render.h"
struct SDL_Renderer ;
#line 142 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_render.h"
typedef struct SDL_Renderer SDL_Renderer;
#line 7 "../src/engine.c"
struct Engine {
   int width ;
   int height ;
   int delay ;
   int done ;
   int paused ;
   int focused_x ;
   int focused_y ;
   struct Game *game ;
   SDL_Window *sdl_window ;
   SDL_Renderer *sdl_renderer ;
   Uint32 last_step_at ;
};
#line 7 "../src/field.c"
struct Field {
   int *grid ;
   int width ;
   int height ;
};
#line 9 "../src/game.c"
struct Game {
   struct Field *field ;
};
#line 81 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long time_t;
#line 1 "cil-Xb8HKHnD.o"
#pragma merger("0","/tmp/cil-lFc7Mti0.i","-sUSE_SDL=2,-sUSE_SDL=2")
#line 18 "../src/game.h"
int game_width(struct Game *g ) ;
#line 20
int game_height(struct Game *g ) ;
#line 22
int game_step(struct Game *g ) ;
#line 24
Cell game_cell_get(struct Game *g , int x , int y ) ;
#line 26
void game_cell_spawn(struct Game *g , int x , int y ) ;
#line 28
void game_cell_kill(struct Game *g , int x , int y ) ;
#line 11 "../src/engine.h"
struct Engine *engine_new(int width , int height , int delay , struct Game *game ) ;
#line 13
void engine_destroy(struct Engine *e ) ;
#line 15
int engine_step(struct Engine *e ) ;
#line 74 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
#line 120
extern int fprintf(FILE * , char const   *  , ...) ;
#line 40 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern void *malloc(size_t___0  ) ;
#line 43
extern void free(void * ) ;
#line 103 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_error.h"
extern char const __attribute__((__visibility__("default")))  *SDL_GetError(void) ;
#line 1756 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_video.h"
extern void __attribute__((__visibility__("default")))  SDL_DestroyWindow(SDL_Window *window ) ;
#line 104 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_mouse.h"
extern Uint32 __attribute__((__visibility__("default")))  SDL_GetMouseState(int *x ,
                                                                            int *y ) ;
#line 879 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
extern int __attribute__((__visibility__("default")))  SDL_PollEvent(SDL_Event *event ) ;
#line 205 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_render.h"
extern int __attribute__((__visibility__("default")))  SDL_CreateWindowAndRenderer(int width ,
                                                                                   int height ,
                                                                                   Uint32 window_flags ,
                                                                                   SDL_Window **window ,
                                                                                   SDL_Renderer **renderer ) ;
#line 1079
extern int __attribute__((__visibility__("default")))  SDL_SetRenderDrawColor(SDL_Renderer *renderer ,
                                                                              Uint8 r ,
                                                                              Uint8 g ,
                                                                              Uint8 b ,
                                                                              Uint8 a ) ;
#line 1128
extern int __attribute__((__visibility__("default")))  SDL_SetRenderDrawBlendMode(SDL_Renderer *renderer ,
                                                                                  SDL_BlendMode blendMode ) ;
#line 1160
extern int __attribute__((__visibility__("default")))  SDL_RenderClear(SDL_Renderer *renderer ) ;
#line 1244
extern int __attribute__((__visibility__("default")))  SDL_RenderDrawLine(SDL_Renderer *renderer ,
                                                                          int x1 ,
                                                                          int y1 ,
                                                                          int x2 ,
                                                                          int y2 ) ;
#line 1352
extern int __attribute__((__visibility__("default")))  SDL_RenderFillRect(SDL_Renderer *renderer ,
                                                                          SDL_Rect const   *rect ) ;
#line 1748
extern void __attribute__((__visibility__("default")))  SDL_RenderPresent(SDL_Renderer *renderer ) ;
#line 1774
extern void __attribute__((__visibility__("default")))  SDL_DestroyRenderer(SDL_Renderer *renderer ) ;
#line 58 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL_timer.h"
extern Uint32 __attribute__((__visibility__("default")))  SDL_GetTicks(void) ;
#line 144 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/SDL2/SDL.h"
extern int __attribute__((__visibility__("default")))  SDL_Init(Uint32 flags ) ;
#line 223
extern void __attribute__((__visibility__("default")))  SDL_Quit(void) ;
#line 23 "../src/engine.c"
struct Engine *engine_new(int width , int height , int delay , struct Game *game ) 
{ 
  char const __attribute__((__visibility__("default")))  *tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  struct Engine *e ;
  void *tmp___1 ;
  char const __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;

  {
#line 24
  tmp___0 = SDL_Init(0x00000020u);
#line 24
  if (tmp___0 != (int __attribute__((__visibility__("default")))  )0) {
#line 25
    tmp = SDL_GetError();
#line 25
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_Init failed: %s\n",
            tmp);
#line 26
    return ((struct Engine *)((void *)0));
  }
#line 29
  tmp___1 = malloc(sizeof(struct Engine ));
#line 29
  e = (struct Engine *)tmp___1;
#line 30
  if (! e) {
#line 31
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"engine::malloc failed\n");
#line 32
    return ((struct Engine *)((void *)0));
  }
#line 35
  e->width = width;
#line 36
  e->height = height;
#line 37
  e->delay = delay;
#line 38
  e->done = 0;
#line 39
  e->paused = 0;
#line 40
  e->focused_x = -1;
#line 41
  e->focused_y = -1;
#line 42
  e->game = game;
#line 44
  e->sdl_window = (SDL_Window *)((void *)0);
#line 45
  e->sdl_renderer = (SDL_Renderer *)((void *)0);
#line 47
  e->last_step_at = (Uint32 )0;
#line 49
  tmp___3 = SDL_CreateWindowAndRenderer(width, height, (Uint32 )0, & e->sdl_window,
                                        & e->sdl_renderer);
#line 49
  if (tmp___3 != (int __attribute__((__visibility__("default")))  )0) {
#line 50
    tmp___2 = SDL_GetError();
#line 50
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_CreateWindowAndRenderer failed: %s\n",
            tmp___2);
#line 51
    return ((struct Engine *)((void *)0));
  }
#line 54
  return (e);
}
}
#line 57 "../src/engine.c"
void engine_destroy(struct Engine *e ) 
{ 


  {
#line 58
  if (e) {
#line 59
    if (e->sdl_renderer) {
#line 60
      SDL_DestroyRenderer(e->sdl_renderer);
    }
#line 62
    if (e->sdl_window) {
#line 63
      SDL_DestroyWindow(e->sdl_window);
    }
#line 66
    SDL_Quit();
#line 67
    free((void *)e);
  }
#line 69
  return;
}
}
#line 71 "../src/engine.c"
static int screen_clear(struct Engine *e ) 
{ 
  int err ;
  char const __attribute__((__visibility__("default")))  *tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  char const __attribute__((__visibility__("default")))  *tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;

  {
#line 73
  tmp___0 = SDL_SetRenderDrawColor(e->sdl_renderer, (Uint8 )0, (Uint8 )0, (Uint8 )0,
                                   (Uint8 )255);
#line 73
  err = (int )tmp___0;
#line 73
  if (err != 0) {
#line 74
    tmp = SDL_GetError();
#line 74
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_SetRenderDrawColor failed: %s\n",
            tmp);
#line 75
    return (err);
  }
#line 77
  tmp___2 = SDL_RenderClear(e->sdl_renderer);
#line 77
  err = (int )tmp___2;
#line 77
  if (err != 0) {
#line 78
    tmp___1 = SDL_GetError();
#line 78
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_RenderClear failed: %s\n",
            tmp___1);
#line 79
    return (err);
  }
#line 81
  return (0);
}
}
#line 84 "../src/engine.c"
static void screen_present(struct Engine *e ) 
{ 


  {
#line 85
  SDL_RenderPresent(e->sdl_renderer);
#line 86
  return;
}
}
#line 88 "../src/engine.c"
__inline static int calc_cell_width(struct Engine *e ) 
{ 
  int tmp ;

  {
#line 89
  tmp = game_width(e->game);
#line 89
  return (e->width / tmp);
}
}
#line 92 "../src/engine.c"
__inline static int calc_cell_height(struct Engine *e ) 
{ 
  int tmp ;

  {
#line 93
  tmp = game_height(e->game);
#line 93
  return (e->height / tmp);
}
}
#line 96 "../src/engine.c"
static int draw_grid(struct Engine *e ) 
{ 
  int err ;
  int cell_width ;
  int tmp ;
  int cell_height ;
  int tmp___0 ;
  char const __attribute__((__visibility__("default")))  *tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  int x ;
  char const __attribute__((__visibility__("default")))  *tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int y ;
  char const __attribute__((__visibility__("default")))  *tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;

  {
#line 98
  tmp = calc_cell_width(e);
#line 98
  cell_width = tmp;
#line 99
  tmp___0 = calc_cell_height(e);
#line 99
  cell_height = tmp___0;
#line 101
  tmp___2 = SDL_SetRenderDrawColor(e->sdl_renderer, (Uint8 )128, (Uint8 )128, (Uint8 )128,
                                   (Uint8 )255);
#line 101
  err = (int )tmp___2;
#line 101
  if (err != 0) {
#line 102
    tmp___1 = SDL_GetError();
#line 102
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_SetRenderDrawColor failed: %s\n",
            tmp___1);
#line 103
    return (err);
  }
#line 106
  x = 0;
#line 107
  while (x < e->width) {
#line 108
    tmp___4 = SDL_RenderDrawLine(e->sdl_renderer, x, 0, x, e->height);
#line 108
    err = (int )tmp___4;
#line 108
    if (err != 0) {
#line 109
      tmp___3 = SDL_GetError();
#line 109
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_RenderDrawLine failed: %s\n",
              tmp___3);
#line 110
      return (err);
    }
#line 112
    x += cell_width;
  }
#line 115
  y = 0;
#line 116
  while (y < e->height) {
#line 117
    tmp___6 = SDL_RenderDrawLine(e->sdl_renderer, 0, y, e->width, y);
#line 117
    err = (int )tmp___6;
#line 117
    if (err != 0) {
#line 118
      tmp___5 = SDL_GetError();
#line 118
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_RenderDrawLine failed: %s\n",
              tmp___5);
#line 119
      return (err);
    }
#line 121
    y += cell_height;
  }
#line 124
  return (0);
}
}
#line 127 "../src/engine.c"
static int draw_cells(struct Engine *e ) 
{ 
  int err ;
  int cell_width ;
  int tmp ;
  int margin_left ;
  int cell_height ;
  int tmp___0 ;
  int margin_top ;
  SDL_Rect cell_rect ;
  char const __attribute__((__visibility__("default")))  *tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  int x ;
  int gw ;
  int tmp___3 ;
  int y ;
  int gh ;
  int tmp___4 ;
  Cell cell ;
  Cell tmp___5 ;
  char const __attribute__((__visibility__("default")))  *tmp___6 ;
  int __attribute__((__visibility__("default")))  tmp___7 ;
  char const __attribute__((__visibility__("default")))  *tmp___8 ;
  int __attribute__((__visibility__("default")))  tmp___9 ;
  char const __attribute__((__visibility__("default")))  *tmp___10 ;
  int __attribute__((__visibility__("default")))  tmp___11 ;
  char const __attribute__((__visibility__("default")))  *tmp___12 ;
  int __attribute__((__visibility__("default")))  tmp___13 ;

  {
#line 129
  tmp = calc_cell_width(e);
#line 129
  cell_width = tmp;
#line 130
  margin_left = cell_width / 8;
#line 131
  tmp___0 = calc_cell_height(e);
#line 131
  cell_height = tmp___0;
#line 132
  margin_top = cell_height / 8;
#line 135
  tmp___2 = SDL_SetRenderDrawBlendMode(e->sdl_renderer, (SDL_BlendMode )1);
#line 135
  err = (int )tmp___2;
#line 135
  if (err != 0) {
#line 136
    tmp___1 = SDL_GetError();
#line 136
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_SetRenderDrawBlendMode failed: %s\n",
            tmp___1);
#line 137
    return (err);
  }
#line 140
  x = 0;
#line 140
  tmp___3 = game_width(e->game);
#line 140
  gw = tmp___3;
#line 140
  while (x < gw) {
#line 141
    y = 0;
#line 141
    tmp___4 = game_height(e->game);
#line 141
    gh = tmp___4;
#line 141
    while (y < gh) {
#line 142
      tmp___5 = game_cell_get(e->game, x, y);
#line 142
      cell = tmp___5;
#line 143
      if (cell) {
#line 144
        tmp___7 = SDL_SetRenderDrawColor(e->sdl_renderer, (Uint8 )0, (Uint8 )255,
                                         (Uint8 )0, (Uint8 )127);
#line 144
        err = (int )tmp___7;
#line 144
        if (err != 0) {
#line 145
          tmp___6 = SDL_GetError();
#line 145
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_SetRenderDrawColor failed: %s\n",
                  tmp___6);
#line 146
          return (err);
        }
#line 149
        cell_rect.x = x * cell_width + margin_left;
#line 150
        cell_rect.y = y * cell_height + margin_top;
#line 151
        cell_rect.w = cell_width - 2 * margin_left;
#line 152
        cell_rect.h = cell_height - 2 * margin_top;
#line 154
        tmp___9 = SDL_RenderFillRect(e->sdl_renderer, (SDL_Rect const   *)(& cell_rect));
#line 154
        err = (int )tmp___9;
#line 154
        if (err != 0) {
#line 155
          tmp___8 = SDL_GetError();
#line 155
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_RenderFillRect failed: %s\n",
                  tmp___8);
#line 156
          return (err);
        }
      }
#line 160
      if (x == e->focused_x) {
#line 160
        if (y == e->focused_y) {
#line 161
          tmp___11 = SDL_SetRenderDrawColor(e->sdl_renderer, (Uint8 )(cell * 255),
                                            (Uint8 )(! cell * 255), (Uint8 )0, (Uint8 )127);
#line 161
          err = (int )tmp___11;
#line 161
          if (err != 0) {
#line 162
            tmp___10 = SDL_GetError();
#line 162
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_SetRenderDrawColor failed: %s\n",
                    tmp___10);
#line 163
            return (err);
          }
#line 166
          cell_rect.x = x * cell_width;
#line 167
          cell_rect.y = y * cell_height;
#line 168
          cell_rect.w = cell_width;
#line 169
          cell_rect.h = cell_height;
#line 171
          tmp___13 = SDL_RenderFillRect(e->sdl_renderer, (SDL_Rect const   *)(& cell_rect));
#line 171
          err = (int )tmp___13;
#line 171
          if (err != 0) {
#line 172
            tmp___12 = SDL_GetError();
#line 172
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SDL_RenderFillRect failed: %s\n",
                    tmp___12);
#line 173
            return (err);
          }
        }
      }
#line 141
      y ++;
    }
#line 140
    x ++;
  }
#line 179
  return (0);
}
}
#line 182 "../src/engine.c"
static int draw_scene(struct Engine *e ) 
{ 
  int err ;

  {
#line 184
  err = screen_clear(e);
#line 184
  if (err != 0) {
#line 185
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"engine::screen_clear failed: %d\n",
            err);
#line 186
    return (err);
  }
#line 189
  err = draw_grid(e);
#line 189
  if (err != 0) {
#line 190
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"engine::draw_grid failed: %d\n",
            err);
#line 191
    return (err);
  }
#line 194
  err = draw_cells(e);
#line 194
  if (err != 0) {
#line 195
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"engine::draw_cells failed: %d\n",
            err);
#line 196
    return (err);
  }
#line 199
  screen_present(e);
#line 200
  return (0);
}
}
#line 203 "../src/engine.c"
static int handle_user_input(struct Engine *e ) 
{ 
  SDL_Event event ;
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;
  int x___0 ;
  int y___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Cell tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;

  {
#line 206
  while (1) {
#line 206
    tmp___4 = SDL_PollEvent(& event);
#line 206
    if (! tmp___4) {
#line 206
      break;
    }
#line 207
    if (event.type == 256U) {
#line 208
      e->done = 1;
#line 209
      break;
    }
#line 211
    if (event.type == 769U) {
#line 212
      if ((unsigned int )event.key.keysym.scancode == 44U) {
#line 213
        e->paused = ! e->paused;
      }
    }
#line 216
    if (event.type == 1024U) {
#line 218
      SDL_GetMouseState(& x, & y);
#line 219
      tmp = calc_cell_width(e);
#line 219
      e->focused_x = x / tmp;
#line 220
      tmp___0 = calc_cell_height(e);
#line 220
      e->focused_y = y / tmp___0;
    }
#line 222
    if (event.type == 1025U) {
#line 223
      if ((int )event.button.clicks == 1) {
#line 224
        e->paused = 1;
      } else {
#line 226
        e->paused = ! e->paused;
      }
    }
#line 229
    if (event.type == 1026U) {
#line 231
      SDL_GetMouseState(& x___0, & y___0);
#line 232
      tmp___1 = calc_cell_width(e);
#line 232
      e->focused_x = x___0 / tmp___1;
#line 233
      tmp___2 = calc_cell_height(e);
#line 233
      e->focused_y = y___0 / tmp___2;
#line 234
      tmp___3 = game_cell_get(e->game, e->focused_x, e->focused_y);
#line 234
      if (tmp___3) {
#line 235
        game_cell_kill(e->game, e->focused_x, e->focused_y);
      } else {
#line 237
        game_cell_spawn(e->game, e->focused_x, e->focused_y);
      }
    }
  }
#line 242
  return (0);
}
}
#line 245 "../src/engine.c"
int engine_step(struct Engine *e ) 
{ 
  int err ;
  int tmp ;
  Uint32 now ;
  Uint32 __attribute__((__visibility__("default")))  tmp___0 ;

  {
#line 247
  tmp = draw_scene(e);
#line 247
  err = tmp != 0;
#line 247
  if (err) {
#line 248
    return (err);
  }
#line 251
  if (! e->paused) {
#line 252
    tmp___0 = SDL_GetTicks();
#line 252
    now = (Uint32 )tmp___0;
#line 253
    if (now - e->last_step_at >= (Uint32 )e->delay) {
#line 254
      err = game_step(e->game);
#line 254
      if (err != 0) {
#line 255
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"engine::game_step failed: %d\n",
                err);
#line 256
        return (err);
      }
#line 258
      e->last_step_at = now;
    }
  }
#line 262
  err = handle_user_input(e);
#line 262
  if (err != 0) {
#line 263
    return (err);
  }
#line 265
  if (e->done) {
#line 266
    return (255);
  }
#line 269
  return (0);
}
}
#line 1 "cil-eb2ttZaf.o"
#pragma merger("0","/tmp/cil-sFo67flO.i","-sUSE_SDL=2,-sUSE_SDL=2")
#line 19 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h"
extern void __assert_fail(char const   * , char const   * , int  , char const   * ) ;
#line 27 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
#line 29
extern void *memset(void * , int  , size_t___0  ) ;
#line 13 "../src/field.c"
int *grid_new(int width , int height ) 
{ 
  int nobytes ;
  int *grid ;
  void *tmp ;

  {
#line 14
  nobytes = (int )((unsigned long )(width * height) * sizeof(int ));
#line 15
  tmp = malloc((size_t___0 )nobytes);
#line 15
  grid = (int *)tmp;
#line 16
  if (! grid) {
#line 17
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"grid::malloc failed\n");
#line 18
    return ((int *)((void *)0));
  }
#line 21
  memset((void *)grid, 0, (size_t___0 )nobytes);
#line 22
  return (grid);
}
}
#line 25 "../src/field.c"
void grid_destroy(int *grid ) 
{ 


  {
#line 26
  free((void *)grid);
#line 27
  return;
}
}
#line 29 "../src/field.c"
struct Field *field_new(int width , int height ) 
{ 
  struct Field *f ;
  void *tmp ;

  {
#line 30
  tmp = malloc(sizeof(struct Field ));
#line 30
  f = (struct Field *)tmp;
#line 31
  if (! f) {
#line 32
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"field::malloc failed\n");
#line 33
    return ((struct Field *)((void *)0));
  }
#line 36
  f->grid = grid_new(width, height);
#line 37
  if (! f->grid) {
#line 38
    free((void *)f);
#line 39
    return ((struct Field *)((void *)0));
  }
#line 42
  f->width = width;
#line 43
  f->height = height;
#line 44
  return (f);
}
}
#line 47 "../src/field.c"
void field_destroy(struct Field *f ) 
{ 


  {
#line 48
  if (f) {
#line 49
    grid_destroy(f->grid);
#line 50
    free((void *)f);
  }
#line 52
  return;
}
}
#line 54 "../src/field.c"
struct Field *field_copy(struct Field *other ) 
{ 
  struct Field *f ;
  struct Field *tmp ;

  {
#line 55
  tmp = field_new(other->width, other->height);
#line 55
  f = tmp;
#line 56
  if (! f) {
#line 57
    return ((struct Field *)((void *)0));
  }
#line 59
  memcpy((void * __restrict  )f->grid, (void const   * __restrict  )other->grid, (unsigned long )(other->width * other->height) * sizeof(int ));
#line 60
  return (f);
}
}
#line 63 "../src/field.c"
__inline static int max(int x , int y ) 
{ 
  int tmp ;

  {
#line 64
  if (x > y) {
#line 64
    tmp = x;
  } else {
#line 64
    tmp = y;
  }
#line 64
  return (tmp);
}
}
#line 67 "../src/field.c"
__inline static int min(int x , int y ) 
{ 
  int tmp ;

  {
#line 68
  if (x > y) {
#line 68
    tmp = y;
  } else {
#line 68
    tmp = x;
  }
#line 68
  return (tmp);
}
}
#line 71 "../src/field.c"
int field_adjust_size(struct Field *f ) 
{ 
  int left ;
  int top ;
  int right ;
  int bottom ;
  int x ;
  int y ;
  int add_left ;
  int add_top ;
  int add_right ;
  int add_bottom ;
  int width ;
  int height ;
  int *grid ;
  int *tmp ;
  int x___0 ;
  int y___0 ;

  {
#line 72
  left = f->width;
#line 72
  top = f->height;
#line 72
  right = -1;
#line 72
  bottom = -1;
#line 73
  x = 0;
#line 73
  while (x < f->width) {
#line 74
    y = 0;
#line 74
    while (y < f->height) {
#line 75
      if (*(f->grid + (y * f->width + x))) {
#line 76
        left = min(left, x);
#line 77
        top = min(top, y);
#line 78
        right = max(right, x);
#line 79
        bottom = max(bottom, y);
      }
#line 74
      y ++;
    }
#line 73
    x ++;
  }
#line 84
  add_left = left < 2;
#line 85
  add_top = top < 2;
#line 86
  add_right = right >= f->width - 2;
#line 87
  add_bottom = bottom >= f->height - 2;
#line 91
  width = (f->width + add_left) + add_right;
#line 92
  height = (f->height + add_top) + add_bottom;
#line 93
  if (width == f->width) {
#line 93
    if (height == f->height) {
#line 94
      return (0);
    }
  }
#line 97
  tmp = grid_new(width, height);
#line 97
  grid = tmp;
#line 98
  if (! grid) {
#line 99
    return (-1);
  }
#line 102
  x___0 = 0;
#line 102
  while (x___0 < f->width) {
#line 103
    y___0 = 0;
#line 103
    while (y___0 < f->height) {
#line 104
      *(grid + ((y___0 + add_top) * width + (x___0 + add_left))) = *(f->grid + (y___0 * f->width + x___0));
#line 103
      y___0 ++;
    }
#line 102
    x___0 ++;
  }
#line 108
  grid_destroy(f->grid);
#line 110
  f->grid = grid;
#line 111
  f->width = width;
#line 112
  f->height = height;
#line 114
  return (0);
}
}
#line 117 "../src/field.c"
int field_width(struct Field *f ) 
{ 


  {
#line 118
  return (f->width);
}
}
#line 121 "../src/field.c"
int field_height(struct Field *f ) 
{ 


  {
#line 122
  return (f->height);
}
}
#line 125 "../src/field.c"
__inline static void assert_valid_pos(struct Field *f , int x , int y ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 126
  if (0 <= x) {
#line 126
    tmp = 1;
  } else {
#line 126
    __assert_fail((char const   *)"0 <= x", (char const   *)"../src/field.c", 126,
                  (char const   *)"assert_valid_pos");
#line 126
    tmp = 0;
  }
#line 126
  if (x < f->width) {
#line 126
    tmp___0 = 1;
  } else {
#line 126
    __assert_fail((char const   *)"x < f->width", (char const   *)"../src/field.c",
                  126, (char const   *)"assert_valid_pos");
#line 126
    tmp___0 = 0;
  }
#line 127
  if (0 <= y) {
#line 127
    tmp___1 = 1;
  } else {
#line 127
    __assert_fail((char const   *)"0 <= y", (char const   *)"../src/field.c", 127,
                  (char const   *)"assert_valid_pos");
#line 127
    tmp___1 = 0;
  }
#line 127
  if (y < f->height) {
#line 127
    tmp___2 = 1;
  } else {
#line 127
    __assert_fail((char const   *)"y < f->height", (char const   *)"../src/field.c",
                  127, (char const   *)"assert_valid_pos");
#line 127
    tmp___2 = 0;
  }
#line 128
  return;
}
}
#line 130 "../src/field.c"
int field_cell_get(struct Field *f , int x , int y ) 
{ 


  {
#line 131
  assert_valid_pos(f, x, y);
#line 132
  return (*(f->grid + (y * f->width + x)));
}
}
#line 135 "../src/field.c"
void field_cell_set(struct Field *f , int x , int y , int val ) 
{ 


  {
#line 136
  assert_valid_pos(f, x, y);
#line 137
  *(f->grid + (y * f->width + x)) = val;
#line 138
  return;
}
}
#line 140 "../src/field.c"
int field_count_alive_cells_around(struct Field *f , int x , int y ) 
{ 
  int result ;
  int xx ;
  int tmp ;
  int yy ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 141
  result = 0;
#line 142
  tmp = max(0, x - 1);
#line 142
  xx = tmp;
#line 142
  while (1) {
#line 142
    tmp___4 = min(f->width, x + 2);
#line 142
    if (! (xx < tmp___4)) {
#line 142
      break;
    }
#line 143
    tmp___0 = max(0, y - 1);
#line 143
    yy = tmp___0;
#line 143
    while (1) {
#line 143
      tmp___3 = min(f->height, y + 2);
#line 143
      if (! (yy < tmp___3)) {
#line 143
        break;
      }
#line 144
      if (xx != x) {
#line 144
        goto _L;
      } else
#line 144
      if (yy != y) {
        _L: /* CIL Label */ 
#line 144
        tmp___1 = field_cell_get(f, xx, yy);
#line 144
        if (tmp___1) {
#line 144
          tmp___2 = 1;
        } else {
#line 144
          tmp___2 = 0;
        }
      } else {
#line 144
        tmp___2 = 0;
      }
#line 144
      result += tmp___2;
#line 143
      yy ++;
    }
#line 142
    xx ++;
  }
#line 147
  return (result);
}
}
#line 1 "cil-TWNYGP4_.o"
#pragma merger("0","/tmp/cil-wfobnkKy.i","-sUSE_SDL=2,-sUSE_SDL=2")
#line 12 "../src/game.h"
struct Game *game_new_random(int width , int height ) ;
#line 14
struct Game *game_load(char *state ) ;
#line 16
void game_destroy(struct Game *g ) ;
#line 37 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern int rand(void) ;
#line 45 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern char *strchr(char const   * , int  ) ;
#line 54
extern size_t___0 strlen(char const   * ) ;
#line 13 "../src/game.c"
struct Game *game_new_random(int width , int height ) 
{ 
  struct Game *g ;
  void *tmp ;
  int alive ;
  int x ;
  int tmp___0 ;
  int y ;
  int tmp___1 ;
  Cell tmp___2 ;
  int tmp___3 ;

  {
#line 14
  tmp = malloc(sizeof(struct Game ));
#line 14
  g = (struct Game *)tmp;
#line 15
  if (! g) {
#line 16
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"game::malloc failed\n");
#line 17
    return ((struct Game *)((void *)0));
  }
#line 20
  g->field = field_new(width, height);
#line 21
  if (! g->field) {
#line 22
    free((void *)g);
#line 23
    return ((struct Game *)((void *)0));
  }
#line 26
  alive = (int )((double )(width * height) * 0.15);
#line 27
  while (alive) {
#line 28
    tmp___0 = rand();
#line 28
    x = tmp___0 % width;
#line 29
    tmp___1 = rand();
#line 29
    y = tmp___1 % height;
#line 31
    tmp___2 = game_cell_get(g, x, y);
#line 31
    if (! tmp___2) {
#line 32
      game_cell_spawn(g, x, y);
#line 33
      alive --;
    }
  }
#line 37
  tmp___3 = field_adjust_size(g->field);
#line 37
  if (tmp___3 != 0) {
#line 38
    field_destroy(g->field);
#line 39
    free((void *)g);
#line 40
    return ((struct Game *)((void *)0));
  }
#line 43
  return (g);
}
}
#line 46 "../src/game.c"
struct Game *game_load(char *state ) 
{ 
  struct Game *g ;
  void *tmp ;
  int width ;
  char *tmp___0 ;
  int len ;
  size_t___0 tmp___1 ;
  int tmp___2 ;
  int height ;
  int correction ;
  int i ;
  int tmp___3 ;

  {
#line 47
  tmp = malloc(sizeof(struct Game ));
#line 47
  g = (struct Game *)tmp;
#line 48
  if (! g) {
#line 49
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"game::malloc failed\n");
#line 50
    return ((struct Game *)((void *)0));
  }
#line 53
  tmp___0 = strchr((char const   *)state, '\n');
#line 53
  width = (int )(tmp___0 - state);
#line 54
  tmp___1 = strlen((char const   *)state);
#line 54
  len = (int )tmp___1;
#line 55
  if ((len + 1) % (width + 1) == 0) {
#line 55
    tmp___2 = 1;
  } else {
#line 55
    __assert_fail((char const   *)"(len + 1) % (width + 1) == 0", (char const   *)"../src/game.c",
                  55, (char const   *)"game_load");
#line 55
    tmp___2 = 0;
  }
#line 56
  height = (len + 1) / (width + 1);
#line 58
  g->field = field_new(width, height);
#line 59
  if (! g->field) {
#line 60
    free((void *)g);
#line 61
    return ((struct Game *)((void *)0));
  }
#line 64
  correction = 0;
#line 65
  i = 0;
#line 65
  while (i < len) {
#line 66
    correction += (int )*(state + i) == 10;
#line 67
    if ((int )*(state + i) == 49) {
#line 68
      game_cell_spawn(g, (i - correction) % width, (i - correction) / width);
    }
#line 65
    i ++;
  }
#line 72
  tmp___3 = field_adjust_size(g->field);
#line 72
  if (tmp___3 != 0) {
#line 73
    field_destroy(g->field);
#line 74
    free((void *)g);
#line 75
    return ((struct Game *)((void *)0));
  }
#line 78
  return (g);
}
}
#line 81 "../src/game.c"
void game_destroy(struct Game *g ) 
{ 


  {
#line 82
  if (g) {
#line 83
    field_destroy(g->field);
#line 84
    free((void *)g);
  }
#line 86
  return;
}
}
#line 88 "../src/game.c"
int game_width(struct Game *g ) 
{ 
  int tmp ;

  {
#line 89
  tmp = field_width(g->field);
#line 89
  return (tmp);
}
}
#line 92 "../src/game.c"
int game_height(struct Game *g ) 
{ 
  int tmp ;

  {
#line 93
  tmp = field_height(g->field);
#line 93
  return (tmp);
}
}
#line 96 "../src/game.c"
int game_step(struct Game *g ) 
{ 
  struct Field *tmp_field ;
  struct Field *tmp ;
  int x ;
  int w ;
  int tmp___0 ;
  int y ;
  int h ;
  int tmp___1 ;
  int cell ;
  int tmp___2 ;
  int noalives ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 97
  tmp = field_copy(g->field);
#line 97
  tmp_field = tmp;
#line 98
  x = 0;
#line 98
  tmp___0 = game_width(g);
#line 98
  w = tmp___0;
#line 98
  while (x < w) {
#line 99
    y = 0;
#line 99
    tmp___1 = game_height(g);
#line 99
    h = tmp___1;
#line 99
    while (y < h) {
#line 100
      tmp___2 = field_cell_get(tmp_field, x, y);
#line 100
      cell = tmp___2;
#line 101
      tmp___3 = field_count_alive_cells_around(tmp_field, x, y);
#line 101
      noalives = tmp___3;
#line 102
      if (cell) {
#line 103
        if (noalives != 2) {
#line 103
          if (noalives != 3) {
#line 104
            game_cell_kill(g, x, y);
          }
        }
      } else
#line 107
      if (noalives == 3) {
#line 108
        game_cell_spawn(g, x, y);
      }
#line 99
      y ++;
    }
#line 98
    x ++;
  }
#line 113
  field_destroy(tmp_field);
#line 115
  tmp___4 = field_adjust_size(g->field);
#line 115
  return (tmp___4);
}
}
#line 118 "../src/game.c"
Cell game_cell_get(struct Game *g , int x , int y ) 
{ 
  int tmp ;

  {
#line 119
  tmp = field_cell_get(g->field, x, y);
#line 119
  return (tmp);
}
}
#line 122 "../src/game.c"
void game_cell_spawn(struct Game *g , int x , int y ) 
{ 


  {
#line 123
  field_cell_set(g->field, x, y, 1);
#line 124
  return;
}
}
#line 126 "../src/game.c"
void game_cell_kill(struct Game *g , int x , int y ) 
{ 


  {
#line 127
  field_cell_set(g->field, x, y, 0);
#line 128
  return;
}
}
#line 1 "cil-upN4sIhj.o"
#pragma merger("0","/tmp/cil-cMRiFSv4.i","-sUSE_SDL=2,-sUSE_SDL=2")
#line 38 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern void srand(unsigned int  ) ;
#line 55 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h"
extern time_t time(time_t * ) ;
#line 49 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/emscripten/emscripten.h"
extern void emscripten_set_main_loop_arg(void (*func)(void * ) , void *arg , int fps ,
                                         int simulate_infinite_loop ) ;
#line 10 "../src/main.c"
void main_loop(void *engine ) 
{ 


  {
#line 11
  engine_step((struct Engine *)engine);
#line 12
  return;
}
}
#line 15 "../src/main.c"
int main(int argc , char **argv ) 
{ 
  time_t tmp ;
  struct Game *game ;
  struct Game *tmp___0 ;
  struct Game *tmp___1 ;
  struct Game *tmp___2 ;
  struct Engine *engine ;
  struct Engine *tmp___3 ;

  {
#line 16
  tmp = time((time_t *)((void *)0));
#line 16
  srand((unsigned int )tmp);
#line 18
  if (argc == 1) {
#line 18
    tmp___0 = game_new_random(80, 60);
#line 18
    tmp___2 = tmp___0;
  } else {
#line 18
    tmp___1 = game_load(*(argv + 1));
#line 18
    tmp___2 = tmp___1;
  }
#line 18
  game = tmp___2;
#line 21
  if (! game) {
#line 22
    return (1);
  }
#line 25
  tmp___3 = engine_new(800, 600, 100, game);
#line 25
  engine = tmp___3;
#line 26
  if (! engine) {
#line 27
    game_destroy(game);
#line 28
    return (2);
  }
#line 32
  emscripten_set_main_loop_arg(& main_loop, (void *)engine, 0, 1);
#line 38
  engine_destroy(engine);
#line 39
  game_destroy(game);
#line 41
  return (0);
}
}
