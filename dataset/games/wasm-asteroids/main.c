/* Generated by CIL v. %%VERSION_NUM%% */
/* print_CIL_Input is true */

#include "/usr/local/bin/tigress/3.3.2/tigress.h"
#include <stdlib.h>
#include <string.h>
#include <time.h>
#line 210 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int uint32_t;
#line 7 "../asteroids/vector.h"
struct vector2d {
  float x;
  float y;
};
#line 6 "../asteroids/asteroids.h"
enum sizes { SMALL = 0, MEDIUM = 1, LARGE = 2 };
#line 8 "../asteroids/asteroids.h"
struct asteroid {
  int alive;
  enum sizes size;
  float hit_radius;
  float rotation;
  struct vector2d location;
  struct vector2d velocity;
  struct vector2d obj_vert[10];
  struct vector2d world_vert[10];
};
#line 180 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef short int16_t;
#line 185 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef int int32_t;
#line 190 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long int64_t;
#line 205 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned short uint16_t;
#line 46 "/usr/lib/emsdk/upstream/lib/clang/17/include/stddef.h"
typedef unsigned long size_t___0;
#line 200 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned char uint8_t;
#line 202 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef uint8_t Uint8;
#line 208 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef int16_t Sint16;
#line 214 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef uint16_t Uint16;
#line 220 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef int32_t Sint32;
#line 226 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef uint32_t Uint32;
#line 233 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_stdinc.h"
typedef int64_t Sint64;
#line 78 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_rect.h"
struct SDL_Rect {
  int x;
  int y;
  int w;
  int h;
};
#line 78 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_rect.h"
typedef struct SDL_Rect SDL_Rect;
#line 95 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_video.h"
struct SDL_Window;
#line 95 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_video.h"
typedef struct SDL_Window SDL_Window;
#line 43 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_scancode.h"
enum __anonenum_SDL_Scancode_605597982 {
  SDL_SCANCODE_UNKNOWN = 0,
  SDL_SCANCODE_A = 4,
  SDL_SCANCODE_B = 5,
  SDL_SCANCODE_C = 6,
  SDL_SCANCODE_D = 7,
  SDL_SCANCODE_E = 8,
  SDL_SCANCODE_F = 9,
  SDL_SCANCODE_G = 10,
  SDL_SCANCODE_H = 11,
  SDL_SCANCODE_I = 12,
  SDL_SCANCODE_J = 13,
  SDL_SCANCODE_K = 14,
  SDL_SCANCODE_L = 15,
  SDL_SCANCODE_M = 16,
  SDL_SCANCODE_N = 17,
  SDL_SCANCODE_O = 18,
  SDL_SCANCODE_P = 19,
  SDL_SCANCODE_Q = 20,
  SDL_SCANCODE_R = 21,
  SDL_SCANCODE_S = 22,
  SDL_SCANCODE_T = 23,
  SDL_SCANCODE_U = 24,
  SDL_SCANCODE_V = 25,
  SDL_SCANCODE_W = 26,
  SDL_SCANCODE_X = 27,
  SDL_SCANCODE_Y = 28,
  SDL_SCANCODE_Z = 29,
  SDL_SCANCODE_1 = 30,
  SDL_SCANCODE_2 = 31,
  SDL_SCANCODE_3 = 32,
  SDL_SCANCODE_4 = 33,
  SDL_SCANCODE_5 = 34,
  SDL_SCANCODE_6 = 35,
  SDL_SCANCODE_7 = 36,
  SDL_SCANCODE_8 = 37,
  SDL_SCANCODE_9 = 38,
  SDL_SCANCODE_0 = 39,
  SDL_SCANCODE_RETURN = 40,
  SDL_SCANCODE_ESCAPE = 41,
  SDL_SCANCODE_BACKSPACE = 42,
  SDL_SCANCODE_TAB = 43,
  SDL_SCANCODE_SPACE = 44,
  SDL_SCANCODE_MINUS = 45,
  SDL_SCANCODE_EQUALS = 46,
  SDL_SCANCODE_LEFTBRACKET = 47,
  SDL_SCANCODE_RIGHTBRACKET = 48,
  SDL_SCANCODE_BACKSLASH = 49,
  SDL_SCANCODE_NONUSHASH = 50,
  SDL_SCANCODE_SEMICOLON = 51,
  SDL_SCANCODE_APOSTROPHE = 52,
  SDL_SCANCODE_GRAVE = 53,
  SDL_SCANCODE_COMMA = 54,
  SDL_SCANCODE_PERIOD = 55,
  SDL_SCANCODE_SLASH = 56,
  SDL_SCANCODE_CAPSLOCK = 57,
  SDL_SCANCODE_F1 = 58,
  SDL_SCANCODE_F2 = 59,
  SDL_SCANCODE_F3 = 60,
  SDL_SCANCODE_F4 = 61,
  SDL_SCANCODE_F5 = 62,
  SDL_SCANCODE_F6 = 63,
  SDL_SCANCODE_F7 = 64,
  SDL_SCANCODE_F8 = 65,
  SDL_SCANCODE_F9 = 66,
  SDL_SCANCODE_F10 = 67,
  SDL_SCANCODE_F11 = 68,
  SDL_SCANCODE_F12 = 69,
  SDL_SCANCODE_PRINTSCREEN = 70,
  SDL_SCANCODE_SCROLLLOCK = 71,
  SDL_SCANCODE_PAUSE = 72,
  SDL_SCANCODE_INSERT = 73,
  SDL_SCANCODE_HOME = 74,
  SDL_SCANCODE_PAGEUP = 75,
  SDL_SCANCODE_DELETE = 76,
  SDL_SCANCODE_END = 77,
  SDL_SCANCODE_PAGEDOWN = 78,
  SDL_SCANCODE_RIGHT = 79,
  SDL_SCANCODE_LEFT = 80,
  SDL_SCANCODE_DOWN = 81,
  SDL_SCANCODE_UP = 82,
  SDL_SCANCODE_NUMLOCKCLEAR = 83,
  SDL_SCANCODE_KP_DIVIDE = 84,
  SDL_SCANCODE_KP_MULTIPLY = 85,
  SDL_SCANCODE_KP_MINUS = 86,
  SDL_SCANCODE_KP_PLUS = 87,
  SDL_SCANCODE_KP_ENTER = 88,
  SDL_SCANCODE_KP_1 = 89,
  SDL_SCANCODE_KP_2 = 90,
  SDL_SCANCODE_KP_3 = 91,
  SDL_SCANCODE_KP_4 = 92,
  SDL_SCANCODE_KP_5 = 93,
  SDL_SCANCODE_KP_6 = 94,
  SDL_SCANCODE_KP_7 = 95,
  SDL_SCANCODE_KP_8 = 96,
  SDL_SCANCODE_KP_9 = 97,
  SDL_SCANCODE_KP_0 = 98,
  SDL_SCANCODE_KP_PERIOD = 99,
  SDL_SCANCODE_NONUSBACKSLASH = 100,
  SDL_SCANCODE_APPLICATION = 101,
  SDL_SCANCODE_POWER = 102,
  SDL_SCANCODE_KP_EQUALS = 103,
  SDL_SCANCODE_F13 = 104,
  SDL_SCANCODE_F14 = 105,
  SDL_SCANCODE_F15 = 106,
  SDL_SCANCODE_F16 = 107,
  SDL_SCANCODE_F17 = 108,
  SDL_SCANCODE_F18 = 109,
  SDL_SCANCODE_F19 = 110,
  SDL_SCANCODE_F20 = 111,
  SDL_SCANCODE_F21 = 112,
  SDL_SCANCODE_F22 = 113,
  SDL_SCANCODE_F23 = 114,
  SDL_SCANCODE_F24 = 115,
  SDL_SCANCODE_EXECUTE = 116,
  SDL_SCANCODE_HELP = 117,
  SDL_SCANCODE_MENU = 118,
  SDL_SCANCODE_SELECT = 119,
  SDL_SCANCODE_STOP = 120,
  SDL_SCANCODE_AGAIN = 121,
  SDL_SCANCODE_UNDO = 122,
  SDL_SCANCODE_CUT = 123,
  SDL_SCANCODE_COPY = 124,
  SDL_SCANCODE_PASTE = 125,
  SDL_SCANCODE_FIND = 126,
  SDL_SCANCODE_MUTE = 127,
  SDL_SCANCODE_VOLUMEUP = 128,
  SDL_SCANCODE_VOLUMEDOWN = 129,
  SDL_SCANCODE_KP_COMMA = 133,
  SDL_SCANCODE_KP_EQUALSAS400 = 134,
  SDL_SCANCODE_INTERNATIONAL1 = 135,
  SDL_SCANCODE_INTERNATIONAL2 = 136,
  SDL_SCANCODE_INTERNATIONAL3 = 137,
  SDL_SCANCODE_INTERNATIONAL4 = 138,
  SDL_SCANCODE_INTERNATIONAL5 = 139,
  SDL_SCANCODE_INTERNATIONAL6 = 140,
  SDL_SCANCODE_INTERNATIONAL7 = 141,
  SDL_SCANCODE_INTERNATIONAL8 = 142,
  SDL_SCANCODE_INTERNATIONAL9 = 143,
  SDL_SCANCODE_LANG1 = 144,
  SDL_SCANCODE_LANG2 = 145,
  SDL_SCANCODE_LANG3 = 146,
  SDL_SCANCODE_LANG4 = 147,
  SDL_SCANCODE_LANG5 = 148,
  SDL_SCANCODE_LANG6 = 149,
  SDL_SCANCODE_LANG7 = 150,
  SDL_SCANCODE_LANG8 = 151,
  SDL_SCANCODE_LANG9 = 152,
  SDL_SCANCODE_ALTERASE = 153,
  SDL_SCANCODE_SYSREQ = 154,
  SDL_SCANCODE_CANCEL = 155,
  SDL_SCANCODE_CLEAR = 156,
  SDL_SCANCODE_PRIOR = 157,
  SDL_SCANCODE_RETURN2 = 158,
  SDL_SCANCODE_SEPARATOR = 159,
  SDL_SCANCODE_OUT = 160,
  SDL_SCANCODE_OPER = 161,
  SDL_SCANCODE_CLEARAGAIN = 162,
  SDL_SCANCODE_CRSEL = 163,
  SDL_SCANCODE_EXSEL = 164,
  SDL_SCANCODE_KP_00 = 176,
  SDL_SCANCODE_KP_000 = 177,
  SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
  SDL_SCANCODE_DECIMALSEPARATOR = 179,
  SDL_SCANCODE_CURRENCYUNIT = 180,
  SDL_SCANCODE_CURRENCYSUBUNIT = 181,
  SDL_SCANCODE_KP_LEFTPAREN = 182,
  SDL_SCANCODE_KP_RIGHTPAREN = 183,
  SDL_SCANCODE_KP_LEFTBRACE = 184,
  SDL_SCANCODE_KP_RIGHTBRACE = 185,
  SDL_SCANCODE_KP_TAB = 186,
  SDL_SCANCODE_KP_BACKSPACE = 187,
  SDL_SCANCODE_KP_A = 188,
  SDL_SCANCODE_KP_B = 189,
  SDL_SCANCODE_KP_C = 190,
  SDL_SCANCODE_KP_D = 191,
  SDL_SCANCODE_KP_E = 192,
  SDL_SCANCODE_KP_F = 193,
  SDL_SCANCODE_KP_XOR = 194,
  SDL_SCANCODE_KP_POWER = 195,
  SDL_SCANCODE_KP_PERCENT = 196,
  SDL_SCANCODE_KP_LESS = 197,
  SDL_SCANCODE_KP_GREATER = 198,
  SDL_SCANCODE_KP_AMPERSAND = 199,
  SDL_SCANCODE_KP_DBLAMPERSAND = 200,
  SDL_SCANCODE_KP_VERTICALBAR = 201,
  SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
  SDL_SCANCODE_KP_COLON = 203,
  SDL_SCANCODE_KP_HASH = 204,
  SDL_SCANCODE_KP_SPACE = 205,
  SDL_SCANCODE_KP_AT = 206,
  SDL_SCANCODE_KP_EXCLAM = 207,
  SDL_SCANCODE_KP_MEMSTORE = 208,
  SDL_SCANCODE_KP_MEMRECALL = 209,
  SDL_SCANCODE_KP_MEMCLEAR = 210,
  SDL_SCANCODE_KP_MEMADD = 211,
  SDL_SCANCODE_KP_MEMSUBTRACT = 212,
  SDL_SCANCODE_KP_MEMMULTIPLY = 213,
  SDL_SCANCODE_KP_MEMDIVIDE = 214,
  SDL_SCANCODE_KP_PLUSMINUS = 215,
  SDL_SCANCODE_KP_CLEAR = 216,
  SDL_SCANCODE_KP_CLEARENTRY = 217,
  SDL_SCANCODE_KP_BINARY = 218,
  SDL_SCANCODE_KP_OCTAL = 219,
  SDL_SCANCODE_KP_DECIMAL = 220,
  SDL_SCANCODE_KP_HEXADECIMAL = 221,
  SDL_SCANCODE_LCTRL = 224,
  SDL_SCANCODE_LSHIFT = 225,
  SDL_SCANCODE_LALT = 226,
  SDL_SCANCODE_LGUI = 227,
  SDL_SCANCODE_RCTRL = 228,
  SDL_SCANCODE_RSHIFT = 229,
  SDL_SCANCODE_RALT = 230,
  SDL_SCANCODE_RGUI = 231,
  SDL_SCANCODE_MODE = 257,
  SDL_SCANCODE_AUDIONEXT = 258,
  SDL_SCANCODE_AUDIOPREV = 259,
  SDL_SCANCODE_AUDIOSTOP = 260,
  SDL_SCANCODE_AUDIOPLAY = 261,
  SDL_SCANCODE_AUDIOMUTE = 262,
  SDL_SCANCODE_MEDIASELECT = 263,
  SDL_SCANCODE_WWW = 264,
  SDL_SCANCODE_MAIL = 265,
  SDL_SCANCODE_CALCULATOR = 266,
  SDL_SCANCODE_COMPUTER = 267,
  SDL_SCANCODE_AC_SEARCH = 268,
  SDL_SCANCODE_AC_HOME = 269,
  SDL_SCANCODE_AC_BACK = 270,
  SDL_SCANCODE_AC_FORWARD = 271,
  SDL_SCANCODE_AC_STOP = 272,
  SDL_SCANCODE_AC_REFRESH = 273,
  SDL_SCANCODE_AC_BOOKMARKS = 274,
  SDL_SCANCODE_BRIGHTNESSDOWN = 275,
  SDL_SCANCODE_BRIGHTNESSUP = 276,
  SDL_SCANCODE_DISPLAYSWITCH = 277,
  SDL_SCANCODE_KBDILLUMTOGGLE = 278,
  SDL_SCANCODE_KBDILLUMDOWN = 279,
  SDL_SCANCODE_KBDILLUMUP = 280,
  SDL_SCANCODE_EJECT = 281,
  SDL_SCANCODE_SLEEP = 282,
  SDL_SCANCODE_APP1 = 283,
  SDL_SCANCODE_APP2 = 284,
  SDL_SCANCODE_AUDIOREWIND = 285,
  SDL_SCANCODE_AUDIOFASTFORWARD = 286,
  SDL_SCANCODE_SOFTLEFT = 287,
  SDL_SCANCODE_SOFTRIGHT = 288,
  SDL_SCANCODE_CALL = 289,
  SDL_SCANCODE_ENDCALL = 290,
  SDL_NUM_SCANCODES = 512
};
#line 43 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_scancode.h"
typedef enum __anonenum_SDL_Scancode_605597982 SDL_Scancode;
#line 45 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_keycode.h"
typedef Sint32 SDL_Keycode;
#line 47 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_keyboard.h"
struct SDL_Keysym {
  SDL_Scancode scancode;
  SDL_Keycode sym;
  Uint16 mod;
  Uint32 unused;
};
#line 47 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_keyboard.h"
typedef struct SDL_Keysym SDL_Keysym;
#line 82 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_joystick.h"
typedef Sint32 SDL_JoystickID;
#line 98
enum __anonenum_SDL_JoystickPowerLevel_945502366 {
  SDL_JOYSTICK_POWER_UNKNOWN = -1,
  SDL_JOYSTICK_POWER_EMPTY = 0,
  SDL_JOYSTICK_POWER_LOW = 1,
  SDL_JOYSTICK_POWER_MEDIUM = 2,
  SDL_JOYSTICK_POWER_FULL = 3,
  SDL_JOYSTICK_POWER_WIRED = 4,
  SDL_JOYSTICK_POWER_MAX = 5
};
#line 98 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_joystick.h"
typedef enum __anonenum_SDL_JoystickPowerLevel_945502366 SDL_JoystickPowerLevel;
#line 41 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_touch.h"
typedef Sint64 SDL_TouchID;
#line 42 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_touch.h"
typedef Sint64 SDL_FingerID;
#line 44 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_gesture.h"
typedef Sint64 SDL_GestureID;
#line 182 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_CommonEvent {
  Uint32 type;
  Uint32 timestamp;
};
#line 182 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_CommonEvent SDL_CommonEvent;
#line 191 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_DisplayEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 display;
  Uint8 event;
  Uint8 padding1;
  Uint8 padding2;
  Uint8 padding3;
  Sint32 data1;
};
#line 191 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_DisplayEvent SDL_DisplayEvent;
#line 206 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_WindowEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  Uint8 event;
  Uint8 padding1;
  Uint8 padding2;
  Uint8 padding3;
  Sint32 data1;
  Sint32 data2;
};
#line 206 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_WindowEvent SDL_WindowEvent;
#line 222 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_KeyboardEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  Uint8 state;
  Uint8 repeat;
  Uint8 padding2;
  Uint8 padding3;
  SDL_Keysym keysym;
};
#line 222 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_KeyboardEvent SDL_KeyboardEvent;
#line 238 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TextEditingEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  char text[32];
  Sint32 start;
  Sint32 length;
};
#line 238 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TextEditingEvent SDL_TextEditingEvent;
#line 252 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TextEditingExtEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  char *text;
  Sint32 start;
  Sint32 length;
};
#line 252 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TextEditingExtEvent SDL_TextEditingExtEvent;
#line 266 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TextInputEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  char text[32];
};
#line 266 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TextInputEvent SDL_TextInputEvent;
#line 277 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MouseMotionEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  Uint32 which;
  Uint32 state;
  Sint32 x;
  Sint32 y;
  Sint32 xrel;
  Sint32 yrel;
};
#line 277 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MouseMotionEvent SDL_MouseMotionEvent;
#line 293 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MouseButtonEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  Uint32 which;
  Uint8 button;
  Uint8 state;
  Uint8 clicks;
  Uint8 padding1;
  Sint32 x;
  Sint32 y;
};
#line 293 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MouseButtonEvent SDL_MouseButtonEvent;
#line 310 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MouseWheelEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  Uint32 which;
  Sint32 x;
  Sint32 y;
  Uint32 direction;
  float preciseX;
  float preciseY;
};
#line 310 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MouseWheelEvent SDL_MouseWheelEvent;
#line 326 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyAxisEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Uint8 axis;
  Uint8 padding1;
  Uint8 padding2;
  Uint8 padding3;
  Sint16 value;
  Uint16 padding4;
};
#line 326 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyAxisEvent SDL_JoyAxisEvent;
#line 342 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyBallEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Uint8 ball;
  Uint8 padding1;
  Uint8 padding2;
  Uint8 padding3;
  Sint16 xrel;
  Sint16 yrel;
};
#line 342 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyBallEvent SDL_JoyBallEvent;
#line 358 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyHatEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Uint8 hat;
  Uint8 value;
  Uint8 padding1;
  Uint8 padding2;
};
#line 358 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyHatEvent SDL_JoyHatEvent;
#line 378 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyButtonEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Uint8 button;
  Uint8 state;
  Uint8 padding1;
  Uint8 padding2;
};
#line 378 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyButtonEvent SDL_JoyButtonEvent;
#line 392 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyDeviceEvent {
  Uint32 type;
  Uint32 timestamp;
  Sint32 which;
};
#line 392 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyDeviceEvent SDL_JoyDeviceEvent;
#line 402 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_JoyBatteryEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  SDL_JoystickPowerLevel level;
};
#line 402 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_JoyBatteryEvent SDL_JoyBatteryEvent;
#line 413 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerAxisEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Uint8 axis;
  Uint8 padding1;
  Uint8 padding2;
  Uint8 padding3;
  Sint16 value;
  Uint16 padding4;
};
#line 413 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerAxisEvent SDL_ControllerAxisEvent;
#line 430 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerButtonEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Uint8 button;
  Uint8 state;
  Uint8 padding1;
  Uint8 padding2;
};
#line 430 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerButtonEvent SDL_ControllerButtonEvent;
#line 445 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerDeviceEvent {
  Uint32 type;
  Uint32 timestamp;
  Sint32 which;
};
#line 445 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerDeviceEvent SDL_ControllerDeviceEvent;
#line 455 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerTouchpadEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Sint32 touchpad;
  Sint32 finger;
  float x;
  float y;
  float pressure;
};
#line 455 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerTouchpadEvent SDL_ControllerTouchpadEvent;
#line 470 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_ControllerSensorEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_JoystickID which;
  Sint32 sensor;
  float data[3];
};
#line 470 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_ControllerSensorEvent SDL_ControllerSensorEvent;
#line 482 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_AudioDeviceEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 which;
  Uint8 iscapture;
  Uint8 padding1;
  Uint8 padding2;
  Uint8 padding3;
};
#line 482 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_AudioDeviceEvent SDL_AudioDeviceEvent;
#line 497 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_TouchFingerEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_TouchID touchId;
  SDL_FingerID fingerId;
  float x;
  float y;
  float dx;
  float dy;
  float pressure;
  Uint32 windowID;
};
#line 497 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_TouchFingerEvent SDL_TouchFingerEvent;
#line 515 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_MultiGestureEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_TouchID touchId;
  float dTheta;
  float dDist;
  float x;
  float y;
  Uint16 numFingers;
  Uint16 padding;
};
#line 515 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_MultiGestureEvent SDL_MultiGestureEvent;
#line 532 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_DollarGestureEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_TouchID touchId;
  SDL_GestureID gestureId;
  Uint32 numFingers;
  float error;
  float x;
  float y;
};
#line 532 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_DollarGestureEvent SDL_DollarGestureEvent;
#line 550 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_DropEvent {
  Uint32 type;
  Uint32 timestamp;
  char *file;
  Uint32 windowID;
};
#line 550 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_DropEvent SDL_DropEvent;
#line 562 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_SensorEvent {
  Uint32 type;
  Uint32 timestamp;
  Sint32 which;
  float data[6];
};
#line 562 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_SensorEvent SDL_SensorEvent;
#line 573 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_QuitEvent {
  Uint32 type;
  Uint32 timestamp;
};
#line 573 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_QuitEvent SDL_QuitEvent;
#line 591 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_UserEvent {
  Uint32 type;
  Uint32 timestamp;
  Uint32 windowID;
  Sint32 code;
  void *data1;
  void *data2;
};
#line 591 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_UserEvent SDL_UserEvent;
#line 602
struct SDL_SysWMmsg;
#line 603 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_SysWMmsg SDL_SysWMmsg;
#line 611 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
struct SDL_SysWMEvent {
  Uint32 type;
  Uint32 timestamp;
  SDL_SysWMmsg *msg;
};
#line 611 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef struct SDL_SysWMEvent SDL_SysWMEvent;
#line 621 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
union SDL_Event {
  Uint32 type;
  SDL_CommonEvent common;
  SDL_DisplayEvent display;
  SDL_WindowEvent window;
  SDL_KeyboardEvent key;
  SDL_TextEditingEvent edit;
  SDL_TextEditingExtEvent editExt;
  SDL_TextInputEvent text;
  SDL_MouseMotionEvent motion;
  SDL_MouseButtonEvent button;
  SDL_MouseWheelEvent wheel;
  SDL_JoyAxisEvent jaxis;
  SDL_JoyBallEvent jball;
  SDL_JoyHatEvent jhat;
  SDL_JoyButtonEvent jbutton;
  SDL_JoyDeviceEvent jdevice;
  SDL_JoyBatteryEvent jbattery;
  SDL_ControllerAxisEvent caxis;
  SDL_ControllerButtonEvent cbutton;
  SDL_ControllerDeviceEvent cdevice;
  SDL_ControllerTouchpadEvent ctouchpad;
  SDL_ControllerSensorEvent csensor;
  SDL_AudioDeviceEvent adevice;
  SDL_SensorEvent sensor;
  SDL_QuitEvent quit;
  SDL_UserEvent user;
  SDL_SysWMEvent syswm;
  SDL_TouchFingerEvent tfinger;
  SDL_MultiGestureEvent mgesture;
  SDL_DollarGestureEvent dgesture;
  SDL_DropEvent drop;
  Uint8 padding[56UL];
};
#line 621 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
typedef union SDL_Event SDL_Event;
#line 141 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_render.h"
struct SDL_Renderer;
#line 142 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_render.h"
typedef struct SDL_Renderer SDL_Renderer;
#line 147
struct SDL_Texture;
#line 148 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_render.h"
typedef struct SDL_Texture SDL_Texture;
#line 9 "../asteroids/player.h"
enum boolean { TRUE = 0, FALSE = 1 };
#line 11 "../asteroids/player.h"
struct bullet {
  struct vector2d location;
  struct vector2d velocity;
  enum boolean alive;
};
#line 18 "../asteroids/player.h"
struct player {
  float hit_radius;
  int lives;
  struct vector2d location;
  struct vector2d velocity;
  struct vector2d obj_vert[3];
  struct vector2d world_vert[3];
  struct bullet bullets[3];
};
#line 1 "cil-TOC9ro0G.o"
#pragma merger("0", "/tmp/cil-Qg7HoAV6.i", "-sUSE_SDL=2,-sUSE_SDL=2")
#line 37 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h"
extern int rand(void);
#line 307 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/math.h"
extern double pow(double, double);
#line 343
extern double sqrt(double);
#line 14 "../asteroids/renderer.h"
int draw_line(uint32_t *pixel_buffer, int x1, int y1___0, int x2, int y2,
              uint32_t colour);
#line 13 "../asteroids/vector.h"
void add_vector(struct vector2d *a, struct vector2d *b);
#line 15
struct vector2d add_vector_new(struct vector2d *a, struct vector2d *b);
#line 17
void multiply_vector(struct vector2d *v, float n);
#line 19
void divide_vector(struct vector2d *v, float n);
#line 23
void rotate_vector(struct vector2d *v, float degrees);
#line 20 "../asteroids/asteroids.h"
void init_asteroids(struct asteroid *asteroids___0, int size);
#line 21
void update_asteroids(struct asteroid *asteroids___0, int size);
#line 22
void draw_asteroids(uint32_t *pixel_buffer, struct asteroid *asteroids___0,
                    int size);
#line 23
int shrink_asteroid(struct asteroid *a, int size);
#line 24
void spawn_asteroids(struct asteroid *a, int length, int size,
                     struct vector2d v);
#line 25
void bounds_asteroids(struct asteroid *asteroids___0, int size);
#line 26
int collision_asteroids(struct asteroid *asteroids___0, int size,
                        struct vector2d *v, float radius);
#line 10 "../asteroids/asteroids.c"
void init_asteroids(struct asteroid *asteroids___0, int size) {
  int i;
  int j;
  struct vector2d translation;
  int sign_x;
  int tmp;
  int sign_y;
  int tmp___0;
  int lx;
  int tmp___1;
  int ly;
  int tmp___2;
  float vx;
  int tmp___3;
  float vy;
  int tmp___4;
  float degrees;
  int tmp___5;

  {
#line 12
    i = 0;
#line 13
    j = 0;
#line 14
    translation.x = (float)320;
#line 14
    translation.y = (float)240;
#line 16
    i = 0;
#line 16
    while (i < size) {
#line 18
      tmp = rand();
#line 18
      sign_x = tmp % 100;
#line 19
      tmp___0 = rand();
#line 19
      sign_y = tmp___0 % 100;
#line 22
      tmp___1 = rand();
#line 22
      lx = (tmp___1 % 640) / 2;
#line 23
      tmp___2 = rand();
#line 23
      ly = (tmp___2 % 480) / 2;
#line 26
      tmp___3 = rand();
#line 26
      vx = (float)(tmp___3 % 500) / (float)1000;
#line 27
      tmp___4 = rand();
#line 27
      vy = (float)(tmp___4 % 500) / (float)1000;
#line 29
      tmp___5 = rand();
#line 29
      degrees = (float)(tmp___5 % 100 + 1000) / (float)1000;
#line 32
      if (sign_x >= 50) {
#line 34
        vx = -vx;
#line 35
        lx = -lx;
#line 36
        degrees = -degrees;
      }
#line 40
      if (sign_y >= 50) {
#line 42
        vy = -vy;
#line 43
        ly = -ly;
      }
#line 47
      if (i < 3) {
#line 49
        (asteroids___0 + i)->alive = 1;
      } else {
#line 53
        (asteroids___0 + i)->alive = 0;
      }
#line 56
      (asteroids___0 + i)->size = (enum sizes)2;
#line 57
      (asteroids___0 + i)->hit_radius = (float)35;
#line 58
      (asteroids___0 + i)->rotation = degrees;
#line 59
      (asteroids___0 + i)->location.x = (float)lx;
#line 60
      (asteroids___0 + i)->location.y = (float)ly;
#line 61
      (asteroids___0 + i)->velocity.x = vx;
#line 62
      (asteroids___0 + i)->velocity.y = vy;
#line 63
      (asteroids___0 + i)->obj_vert[0].x = (float).0;
#line 64
      (asteroids___0 + i)->obj_vert[0].y = (float).4;
#line 65
      (asteroids___0 + i)->obj_vert[1].x = (float).2;
#line 66
      (asteroids___0 + i)->obj_vert[1].y = (float).3;
#line 67
      (asteroids___0 + i)->obj_vert[2].x = (float).2;
#line 68
      (asteroids___0 + i)->obj_vert[2].y = (float).1;
#line 69
      (asteroids___0 + i)->obj_vert[3].x = (float).4;
#line 70
      (asteroids___0 + i)->obj_vert[3].y = (float).0;
#line 71
      (asteroids___0 + i)->obj_vert[4].x = (float).3;
#line 72
      (asteroids___0 + i)->obj_vert[4].y = (float)(-.2);
#line 73
      (asteroids___0 + i)->obj_vert[5].x = (float).1;
#line 74
      (asteroids___0 + i)->obj_vert[5].y = (float)(-.2);
#line 75
      (asteroids___0 + i)->obj_vert[6].x = (float).0;
#line 76
      (asteroids___0 + i)->obj_vert[6].y = (float)(-.3);
#line 77
      (asteroids___0 + i)->obj_vert[7].x = (float)(-.2);
#line 78
      (asteroids___0 + i)->obj_vert[7].y = (float)(-.2);
#line 79
      (asteroids___0 + i)->obj_vert[8].x = (float)(-.4);
#line 80
      (asteroids___0 + i)->obj_vert[8].y = (float)0;
#line 81
      (asteroids___0 + i)->obj_vert[9].x = (float)(-.3);
#line 82
      (asteroids___0 + i)->obj_vert[9].y = (float).3;
#line 84
      j = 0;
#line 84
      while (j < 10) {
#line 87
        multiply_vector(&(asteroids___0 + i)->obj_vert[j], (float)88);
#line 88
        add_vector(&(asteroids___0 + i)->world_vert[j],
                   &(asteroids___0 + i)->obj_vert[j]);
#line 89
        add_vector(&(asteroids___0 + i)->world_vert[j], &translation);
#line 84
        j++;
      }
#line 16
      i++;
    }
#line 92
    return;
  }
}
#line 94 "../asteroids/asteroids.c"
void update_asteroids(struct asteroid *asteroids___0, int size) {
  int i;
  int j;
  struct vector2d translation;

  {
#line 96
    i = 0;
#line 97
    j = 0;
#line 98
    translation.x = (float)320;
#line 98
    translation.y = (float)240;
#line 100
    i = 0;
#line 100
    while (i < size) {
#line 103
      add_vector(&(asteroids___0 + i)->location,
                 &(asteroids___0 + i)->velocity);
#line 107
      j = 0;
#line 107
      while (j < 10) {
#line 109
        (asteroids___0 + i)->world_vert[j] = add_vector_new(
            &(asteroids___0 + i)->obj_vert[j], &(asteroids___0 + i)->location);
#line 110
        add_vector(&(asteroids___0 + i)->world_vert[j], &translation);
#line 111
        rotate_vector(&(asteroids___0 + i)->obj_vert[j],
                      (asteroids___0 + i)->rotation);
#line 107
        j++;
      }
#line 100
      i++;
    }
#line 114
    return;
  }
}
#line 116 "../asteroids/asteroids.c"
void draw_asteroids(uint32_t *pixel_buffer, struct asteroid *asteroids___0,
                    int size) {
  int i;

  {
#line 118
    i = 0;
#line 120
    i = 0;
#line 120
    while (i < size) {
#line 122
      if ((asteroids___0 + i)->alive) {
#line 124
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[0].x,
                  (int)(asteroids___0 + i)->world_vert[0].y,
                  (int)(asteroids___0 + i)->world_vert[1].x,
                  (int)(asteroids___0 + i)->world_vert[1].y, 0xffffffff);
#line 125
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[1].x,
                  (int)(asteroids___0 + i)->world_vert[1].y,
                  (int)(asteroids___0 + i)->world_vert[2].x,
                  (int)(asteroids___0 + i)->world_vert[2].y, 0xffffffff);
#line 126
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[2].x,
                  (int)(asteroids___0 + i)->world_vert[2].y,
                  (int)(asteroids___0 + i)->world_vert[3].x,
                  (int)(asteroids___0 + i)->world_vert[3].y, 0xffffffff);
#line 127
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[3].x,
                  (int)(asteroids___0 + i)->world_vert[3].y,
                  (int)(asteroids___0 + i)->world_vert[4].x,
                  (int)(asteroids___0 + i)->world_vert[4].y, 0xffffffff);
#line 128
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[4].x,
                  (int)(asteroids___0 + i)->world_vert[4].y,
                  (int)(asteroids___0 + i)->world_vert[5].x,
                  (int)(asteroids___0 + i)->world_vert[5].y, 0xffffffff);
#line 129
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[5].x,
                  (int)(asteroids___0 + i)->world_vert[5].y,
                  (int)(asteroids___0 + i)->world_vert[6].x,
                  (int)(asteroids___0 + i)->world_vert[6].y, 0xffffffff);
#line 130
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[6].x,
                  (int)(asteroids___0 + i)->world_vert[6].y,
                  (int)(asteroids___0 + i)->world_vert[7].x,
                  (int)(asteroids___0 + i)->world_vert[7].y, 0xffffffff);
#line 131
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[7].x,
                  (int)(asteroids___0 + i)->world_vert[7].y,
                  (int)(asteroids___0 + i)->world_vert[8].x,
                  (int)(asteroids___0 + i)->world_vert[8].y, 0xffffffff);
#line 132
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[8].x,
                  (int)(asteroids___0 + i)->world_vert[8].y,
                  (int)(asteroids___0 + i)->world_vert[9].x,
                  (int)(asteroids___0 + i)->world_vert[9].y, 0xffffffff);
#line 133
        draw_line(pixel_buffer, (int)(asteroids___0 + i)->world_vert[9].x,
                  (int)(asteroids___0 + i)->world_vert[9].y,
                  (int)(asteroids___0 + i)->world_vert[0].x,
                  (int)(asteroids___0 + i)->world_vert[0].y, 0xffffffff);
      }
#line 120
      i++;
    }
#line 145
    return;
  }
}
#line 147 "../asteroids/asteroids.c"
int shrink_asteroid(struct asteroid *a, int size) {
  int i;

  {
#line 149
    a->obj_vert[0].x = (float).0;
#line 150
    a->obj_vert[0].y = (float).4;
#line 151
    a->obj_vert[1].x = (float).2;
#line 152
    a->obj_vert[1].y = (float).3;
#line 153
    a->obj_vert[2].x = (float).2;
#line 154
    a->obj_vert[2].y = (float).1;
#line 155
    a->obj_vert[3].x = (float).4;
#line 156
    a->obj_vert[3].y = (float).0;
#line 157
    a->obj_vert[4].x = (float).3;
#line 158
    a->obj_vert[4].y = (float)(-.2);
#line 159
    a->obj_vert[5].x = (float).1;
#line 160
    a->obj_vert[5].y = (float)(-.2);
#line 161
    a->obj_vert[6].x = (float).0;
#line 162
    a->obj_vert[6].y = (float)(-.3);
#line 163
    a->obj_vert[7].x = (float)(-.2);
#line 164
    a->obj_vert[7].y = (float)(-.2);
#line 165
    a->obj_vert[8].x = (float)(-.4);
#line 166
    a->obj_vert[8].y = (float)0;
#line 167
    a->obj_vert[9].x = (float)(-.3);
#line 168
    a->obj_vert[9].y = (float).3;
#line 170
    i = 0;
#line 172
    i = 0;
#line 172
    while (i < 10) {
#line 174
      multiply_vector(&a->obj_vert[i], (float)88);
#line 172
      i++;
    }
#line 177
    if (size == 2) {
#line 180
      i = 0;
#line 180
      while (i < 10) {
#line 182
        divide_vector(&a->obj_vert[i], (float)2);
#line 180
        i++;
      }
#line 185
      a->size = (enum sizes)1;
#line 187
      return (0);
    }
#line 190
    if (size == 1) {
#line 193
      i = 0;
#line 193
      while (i < 10) {
#line 195
        divide_vector(&a->obj_vert[i], (float)4);
#line 193
        i++;
      }
#line 198
      a->size = (enum sizes)0;
#line 200
      return (0);
    }
#line 203
    if (size == 0) {
#line 206
      i = 0;
#line 206
      while (i < 10) {
#line 208
        divide_vector(&a->obj_vert[i], (float)8);
#line 206
        i++;
      }
#line 211
      return (0);
    }
#line 214
    return (1);
  }
}
#line 217 "../asteroids/asteroids.c"
void spawn_asteroids(struct asteroid *a, int length, int size,
                     struct vector2d v) {
  int i;
  int count;

  {
#line 219
    i = 0;
#line 220
    count = 0;
#line 222
    i = 0;
#line 222
    while (i < length) {
#line 224
      if ((a + i)->alive == 0) {
#line 226
        if (count == 3) {
#line 228
          break;
        }
#line 231
        (a + i)->location = v;
#line 232
        (a + i)->hit_radius /= (float)2;
#line 233
        (a + i)->alive = 1;
#line 234
        count++;
#line 235
        shrink_asteroid(a + i, size);
      }
#line 222
      i++;
    }
#line 238
    return;
  }
}
#line 240 "../asteroids/asteroids.c"
void bounds_asteroids(struct asteroid *asteroids___0, int size) {
  int i;

  {
#line 242
    i = 0;
#line 244
    i = 0;
#line 244
    while (i < size) {
#line 246
      if ((asteroids___0 + i)->location.x < (float)-320) {
#line 248
        (asteroids___0 + i)->location.x = (float)320;
      }
#line 251
      if ((asteroids___0 + i)->location.x > (float)320) {
#line 253
        (asteroids___0 + i)->location.x = (float)-320;
      }
#line 256
      if ((asteroids___0 + i)->location.y < (float)-240) {
#line 258
        (asteroids___0 + i)->location.y = (float)240;
      }
#line 261
      if ((asteroids___0 + i)->location.y > (float)240) {
#line 263
        (asteroids___0 + i)->location.y = (float)-240;
      }
#line 244
      i++;
    }
#line 266
    return;
  }
}
#line 269 "../asteroids/asteroids.c"
int collision_asteroids(struct asteroid *asteroids___0, int size,
                        struct vector2d *v, float radius) {
  int i;
  float sum;
  float a;
  double tmp;
  float b;
  double tmp___0;
  float distance;
  double tmp___1;

  {
#line 272
    i = 0;
#line 275
    i = 0;
#line 275
    while (i < size) {
#line 278
      if ((asteroids___0 + i)->alive == 1) {
#line 280
        sum = (asteroids___0 + i)->hit_radius + radius;
#line 281
        tmp = pow((double)((asteroids___0 + i)->location.x - v->x), (double)2);
#line 281
        a = (float)tmp;
#line 282
        tmp___0 =
            pow((double)((asteroids___0 + i)->location.y - v->y), (double)2);
#line 282
        b = (float)tmp___0;
#line 283
        tmp___1 = sqrt((double)(a + b));
#line 283
        distance = (float)tmp___1;
#line 285
        if (distance < sum) {
#line 287
          return (i);
        }
      }
#line 275
      i++;
    }
#line 292
    return (-1);
  }
}
#line 1 "cil-SQg1HnxT.o"
#pragma merger("0", "/tmp/cil-FazXwgSU.i", "-sUSE_SDL=2,-sUSE_SDL=2")
#line 119 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdio.h"
extern int printf(char const *, ...);
#line 40 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h"
extern void *malloc(size_t___0);
#line 43
extern void free(void *);
#line 103 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_error.h"
extern char const __attribute__((__visibility__("default"))) *
    SDL_GetError(void);
#line 1756 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_video.h"
extern void __attribute__((__visibility__("default")))
SDL_DestroyWindow(SDL_Window *window);
#line 95 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_keyboard.h"
extern Uint8 const __attribute__((__visibility__("default"))) *
    SDL_GetKeyboardState(int *numkeys);
#line 699 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_events.h"
extern void __attribute__((__visibility__("default"))) SDL_PumpEvents(void);
#line 879
extern int __attribute__((__visibility__("default")))
SDL_PollEvent(SDL_Event *event);
#line 205 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_render.h"
extern int __attribute__((__visibility__("default")))
SDL_CreateWindowAndRenderer(int width, int height, Uint32 window_flags,
                            SDL_Window **window, SDL_Renderer **renderer);
#line 333
extern SDL_Texture __attribute__((__visibility__("default"))) *
    SDL_CreateTexture(SDL_Renderer *renderer, Uint32 format, int access, int w,
                      int h);
#line 597
extern int __attribute__((__visibility__("default")))
SDL_UpdateTexture(SDL_Texture *texture, SDL_Rect const *rect,
                  void const *pixels, int pitch);
#line 1160
extern int __attribute__((__visibility__("default")))
SDL_RenderClear(SDL_Renderer *renderer);
#line 1409
extern int __attribute__((__visibility__("default")))
SDL_RenderCopy(SDL_Renderer *renderer, SDL_Texture *texture,
               SDL_Rect const *srcrect, SDL_Rect const *dstrect);
#line 1748
extern void __attribute__((__visibility__("default")))
SDL_RenderPresent(SDL_Renderer *renderer);
#line 58 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL_timer.h"
extern Uint32 __attribute__((__visibility__("default"))) SDL_GetTicks(void);
#line 144 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/SDL2/SDL.h"
extern int __attribute__((__visibility__("default"))) SDL_Init(Uint32 flags);
#line 223
extern void __attribute__((__visibility__("default"))) SDL_Quit(void);
#line 17 "../asteroids/renderer.h"
void clear_pixels(uint32_t *pixel_buffer, uint32_t colour);
#line 29 "../asteroids/player.h"
void init_player(struct player *p___0);
#line 31
void draw_player(uint32_t *pixel_buffer, struct player *p___0);
#line 33
void shoot_bullet(struct player *p___0);
#line 35
void update_player(struct player *p___0);
#line 37
void bounds_player(struct player *p___0);
#line 39
void apply_force(struct vector2d *velocity, struct vector2d v);
#line 41
void rotate_player(struct player *p___0, float degrees);
#line 43
struct vector2d get_direction(struct player *p___0);
#line 41 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/emscripten/emscripten.h"
extern void emscripten_set_main_loop(void (*func)(void), int fps,
                                     int simulate_infinite_loop);
#line 52
extern void emscripten_cancel_main_loop(void);
#line 18 "../asteroids/main.c"
int init(int width, int height);
#line 20 "../asteroids/main.c"
SDL_Window *window = (SDL_Window *)((void *)0);
#line 21 "../asteroids/main.c"
SDL_Renderer *renderer;
#line 22 "../asteroids/main.c"
SDL_Texture *screen;
#line 23 "../asteroids/main.c"
uint32_t *pixels = (uint32_t *)((void *)0);
#line 24 "../asteroids/main.c"
struct asteroid asteroids[27];
#line 25 "../asteroids/main.c"
struct player p;
#line 26 "../asteroids/main.c"
struct player lives[3];
#line 30 "../asteroids/main.c"
void mainloop(void) {
  int sleep;
  int quit;
  SDL_Event event;
  Uint32 next_game_tick;
  Uint32 __attribute__((__visibility__("default"))) tmp;
  Uint8 const *state;
  Uint8 const __attribute__((__visibility__("default"))) * tmp___0;
  struct vector2d thrust;
  struct vector2d tmp___1;
  int __attribute__((__visibility__("default"))) tmp___2;
  int res;
  int tmp___3;
  int i;
  int i___0;
  struct vector2d translation;
  struct vector2d world;
  struct vector2d tmp___4;
  int index___0;
  int tmp___5;

  {
#line 33
    sleep = 0;
#line 34
    quit = 0;
#line 36
    tmp = SDL_GetTicks();
#line 36
    next_game_tick = (Uint32)tmp;
#line 40
    SDL_PumpEvents();
#line 42
    tmp___0 = SDL_GetKeyboardState((int *)((void *)0));
#line 42
    state = (Uint8 const *)tmp___0;
#line 44
    if (*(state + 41)) {
#line 45
      quit = 1;
    }
#line 48
    if (*(state + 82)) {
#line 49
      tmp___1 = get_direction(&p);
#line 49
      thrust = tmp___1;
#line 50
      multiply_vector(&thrust, (float).06);
#line 51
      apply_force(&p.velocity, thrust);
    }
#line 54
    if (*(state + 80)) {
#line 55
      rotate_player(&p, (float)-4);
    }
#line 58
    if (*(state + 79)) {
#line 59
      rotate_player(&p, (float)4);
    }
#line 62
    while (1) {
#line 62
      tmp___2 = SDL_PollEvent(&event);
#line 62
      if (!tmp___2) {
#line 62
        break;
      }
#line 63
      switch (event.type) {
      case 768U:
#line 65
        switch (event.key.keysym.sym) {
        case 32:
#line 67
          if (p.lives > 0) {
#line 68
            shoot_bullet(&p);
          }
#line 70
          break;
        }
      }
    }
#line 76
    clear_pixels(pixels, (uint32_t)0x00000000);
#line 77
    draw_asteroids(pixels, asteroids, 27);
#line 78
    update_player(&p);
#line 79
    bounds_player(&p);
#line 80
    bounds_asteroids(asteroids, 27);
#line 82
    tmp___3 = collision_asteroids(asteroids, 27, &p.location, p.hit_radius);
#line 82
    res = tmp___3;
#line 84
    if (res != -1) {
#line 85
      (p.lives)--;
#line 86
      p.location.x = (float)0;
#line 87
      p.location.y = (float)0;
#line 88
      p.velocity.x = (float)0;
#line 89
      p.velocity.y = (float)0;
#line 91
      i = 2;
#line 92
      i = 3;
#line 92
      while (i >= 0) {
#line 93
        if (lives[i].lives > 0) {
#line 94
          lives[i].lives = 0;
#line 95
          break;
        }
#line 92
        i--;
      }
    }
#line 99
    draw_player(pixels, &p);
#line 100
    draw_player(pixels, &lives[0]);
#line 101
    draw_player(pixels, &lives[1]);
#line 102
    draw_player(pixels, &lives[2]);
#line 104
    i___0 = 0;
#line 105
    translation.x = (float)-320;
#line 105
    translation.y = (float)-240;
#line 107
    i___0 = 0;
#line 107
    while (i___0 < 3) {
#line 109
      if ((unsigned int)p.bullets[i___0].alive == 0U) {
#line 112
        tmp___4 = add_vector_new(&p.bullets[i___0].location, &translation);
#line 112
        world = tmp___4;
#line 113
        tmp___5 = collision_asteroids(asteroids, 27, &world, (float)1);
#line 113
        index___0 = tmp___5;
#line 116
        if (index___0 != -1) {
#line 117
          asteroids[index___0].alive = 0;
#line 118
          p.bullets[i___0].alive = (enum boolean)1;
#line 120
          if ((unsigned int)asteroids[index___0].size != 0U) {
#line 121
            spawn_asteroids(asteroids, 27, (int)asteroids[index___0].size,
                            asteroids[index___0].location);
          }
        }
      }
#line 107
      i___0++;
    }
#line 127
    update_asteroids(asteroids, 27);
#line 130
    SDL_UpdateTexture(screen, (SDL_Rect const *)((void *)0),
                      (void const *)pixels, (int)(640UL * sizeof(Uint32)));
#line 133
    SDL_RenderClear(renderer);
#line 134
    SDL_RenderCopy(renderer, screen, (SDL_Rect const *)((void *)0),
                   (SDL_Rect const *)((void *)0));
#line 135
    SDL_RenderPresent(renderer);
#line 137
    if (quit == 1) {
#line 138
      emscripten_cancel_main_loop();
#line 141
      free((void *)pixels);
#line 144
      SDL_DestroyWindow(window);
#line 147
      SDL_Quit();
    }
#line 149
    return;
  }
}
#line 151 "../asteroids/main.c"
int main(int argc, char **args) {
  int tmp;
  int i;
  int j;
  int offset;
  struct vector2d translation;
  struct vector2d top_left;

  {
#line 154
    tmp = init(640, 480);
#line 154
    if (tmp == 1) {
#line 156
      return (0);
    }
#line 159
    i = 0;
#line 160
    j = 0;
#line 161
    offset = 0;
#line 162
    translation.x = (float)-320;
#line 162
    translation.y = (float)-240;
#line 165
    i = 0;
#line 165
    while (i < 3) {
#line 167
      init_player(&lives[i]);
#line 168
      lives[i].lives = 1;
#line 171
      j = 0;
#line 171
      while (j < 3) {
#line 173
        divide_vector(&lives[i].obj_vert[j], (float)2);
#line 171
        j++;
      }
#line 177
      top_left.x = (float)(20 + offset);
#line 177
      top_left.y = (float)20;
#line 178
      add_vector(&top_left, &translation);
#line 179
      lives[i].location = top_left;
#line 180
      update_player(&lives[i]);
#line 181
      offset += 20;
#line 165
      i++;
    }
#line 185
    init_player(&p);
#line 186
    init_asteroids(asteroids, 27);
#line 188
    emscripten_set_main_loop(&mainloop, 0, 1);
#line 190
    return (0);
  }
}
#line 193 "../asteroids/main.c"
int init(int width, int height) {
  char const __attribute__((__visibility__("default"))) * tmp;
  int __attribute__((__visibility__("default"))) tmp___0;
  SDL_Texture __attribute__((__visibility__("default"))) * tmp___1;
  void *tmp___2;
  char const __attribute__((__visibility__("default"))) * tmp___3;
  char const __attribute__((__visibility__("default"))) * tmp___4;

  {
#line 196
    tmp___0 = SDL_Init(0x00000020u);
#line 196
    if (tmp___0 < (int __attribute__((__visibility__("default"))))0) {
#line 198
      tmp = SDL_GetError();
#line 198
      printf(
          (char const *__restrict)"SDL could not initialize! SDL_Error: %s\n",
          tmp);
#line 200
      return (1);
    }
#line 204
    SDL_CreateWindowAndRenderer(640, 480, (Uint32)4, &window, &renderer);
#line 207
    tmp___1 = SDL_CreateTexture(renderer, (Uint32)373694468, 1, 640, 480);
#line 207
    screen = (SDL_Texture *)tmp___1;
#line 210
    tmp___2 = malloc(307200UL * sizeof(Uint32));
#line 210
    pixels = (Uint32 *)tmp___2;
#line 213
    if ((unsigned long)window == (unsigned long)((void *)0)) {
#line 215
      tmp___3 = SDL_GetError();
#line 215
      printf((char const
                  *__restrict)"Window could not be created! SDL_Error: %s\n",
             tmp___3);
#line 217
      return (1);
    }
#line 220
    if ((unsigned long)screen == (unsigned long)((void *)0)) {
#line 222
      tmp___4 = SDL_GetError();
#line 222
      printf((char const
                  *__restrict)"Texture could not be created! SDL_Error: %s\n",
             tmp___4);
#line 224
      return (1);
    }
#line 227
    if ((unsigned long)pixels == (unsigned long)((void *)0)) {
#line 229
      printf((char const *__restrict)"Error allocating pixel buffer");
#line 231
      return (1);
    }
#line 234
    return (0);
  }
}
#line 1 "cil-81GmsmvN.o"
#pragma merger("0", "/tmp/cil-9xUWKMuV.i", "-sUSE_SDL=2,-sUSE_SDL=2")
#line 12 "../asteroids/renderer.h"
int draw_pixel(uint32_t *pixel_buffer, int x, int y, uint32_t colour);
#line 27 "../asteroids/vector.h"
void normalise_vector(struct vector2d *v);
#line 29
void limit_vector(struct vector2d *v, float limit);
#line 8 "../asteroids/player.c"
void init_player(struct player *p___0) {
  int i;
  struct vector2d translation;

  {
#line 10
    i = 0;
#line 11
    translation.x = (float)320;
#line 11
    translation.y = (float)240;
#line 13
    p___0->hit_radius = (float)15;
#line 14
    p___0->lives = 3;
#line 15
    p___0->location.x = (float)0;
#line 16
    p___0->location.y = (float)0;
#line 17
    p___0->velocity.x = (float)0;
#line 18
    p___0->velocity.y = (float)0;
#line 19
    p___0->obj_vert[0].x = (float)0;
#line 20
    p___0->obj_vert[0].y = (float)1.5;
#line 21
    p___0->obj_vert[1].x = (float)-1;
#line 22
    p___0->obj_vert[1].y = (float)-1;
#line 23
    p___0->obj_vert[2].x = (float)1;
#line 24
    p___0->obj_vert[2].y = (float)-1;
#line 27
    i = 0;
#line 27
    while (i < 3) {
#line 29
      multiply_vector(&p___0->obj_vert[i], (float)-1);
#line 30
      multiply_vector(&p___0->obj_vert[i], (float)12);
#line 31
      add_vector(&p___0->world_vert[i], &p___0->obj_vert[i]);
#line 32
      add_vector(&p___0->world_vert[i], &translation);
#line 27
      i++;
    }
#line 35
    i = 0;
#line 35
    while (i < 3) {
#line 37
      p___0->bullets[i].alive = (enum boolean)1;
#line 35
      i++;
    }
#line 39
    return;
  }
}
#line 41 "../asteroids/player.c"
void apply_force(struct vector2d *velocity, struct vector2d v) {

  {
#line 43
    add_vector(velocity, &v);
#line 44
    return;
  }
}
#line 46 "../asteroids/player.c"
struct vector2d get_direction(struct player *p___0) {
  struct vector2d direction;

  {
#line 48
    direction = p___0->obj_vert[0];
#line 49
    normalise_vector(&direction);
#line 51
    return (direction);
  }
}
#line 54 "../asteroids/player.c"
void shoot_bullet(struct player *p___0) {
  int i;

  {
#line 56
    i = 0;
#line 58
    i = 0;
#line 58
    while (i < 3) {
#line 60
      if ((unsigned int)p___0->bullets[i].alive == 1U) {
#line 62
        p___0->bullets[i].alive = (enum boolean)0;
#line 63
        p___0->bullets[i].location = p___0->world_vert[0];
#line 64
        p___0->bullets[i].velocity = get_direction(p___0);
#line 65
        multiply_vector(&p___0->bullets[i].velocity, (float)4.1);
#line 66
        break;
      }
#line 58
      i++;
    }
#line 69
    return;
  }
}
#line 71 "../asteroids/player.c"
void draw_player(uint32_t *pixel_buffer, struct player *p___0) {
  int i;

  {
#line 73
    i = 0;
#line 75
    if (p___0->lives > 0) {
#line 77
      draw_line(pixel_buffer, (int)p___0->world_vert[0].x,
                (int)p___0->world_vert[0].y, (int)p___0->world_vert[1].x,
                (int)p___0->world_vert[1].y, 0xffffffff);
#line 78
      draw_line(pixel_buffer, (int)p___0->world_vert[1].x,
                (int)p___0->world_vert[1].y, (int)p___0->world_vert[2].x,
                (int)p___0->world_vert[2].y, 0xffffffff);
#line 79
      draw_line(pixel_buffer, (int)p___0->world_vert[2].x,
                (int)p___0->world_vert[2].y, (int)p___0->world_vert[0].x,
                (int)p___0->world_vert[0].y, 0xffffffff);
    }
#line 91
    i = 0;
#line 91
    while (i < 3) {
#line 93
      if ((unsigned int)p___0->bullets[i].alive == 0U) {
#line 95
        draw_pixel(pixel_buffer, (int)p___0->bullets[i].location.x,
                   (int)p___0->bullets[i].location.y, 0xffffffff);
      }
#line 91
      i++;
    }
#line 107
    return;
  }
}
#line 109 "../asteroids/player.c"
void update_player(struct player *p___0) {
  struct vector2d translation;
  int i;

  {
#line 111
    limit_vector(&p___0->velocity, (float)2);
#line 112
    add_vector(&p___0->location, &p___0->velocity);
#line 114
    translation.x = (float)320;
#line 114
    translation.y = (float)240;
#line 116
    i = 0;
#line 118
    i = 0;
#line 118
    while (i < 3) {
#line 120
      p___0->world_vert[i] =
          add_vector_new(&p___0->obj_vert[i], &p___0->location);
#line 121
      add_vector(&p___0->world_vert[i], &translation);
#line 118
      i++;
    }
#line 124
    i = 0;
#line 124
    while (i < 3) {
#line 126
      add_vector(&p___0->bullets[i].location, &p___0->bullets[i].velocity);
#line 124
      i++;
    }
#line 128
    return;
  }
}
#line 130 "../asteroids/player.c"
void rotate_player(struct player *p___0, float degrees) {
  int i;

  {
#line 132
    i = 0;
#line 134
    i = 0;
#line 134
    while (i < 3) {
#line 136
      rotate_vector(&p___0->obj_vert[i], degrees);
#line 134
      i++;
    }
#line 138
    return;
  }
}
#line 140 "../asteroids/player.c"
void bounds_player(struct player *p___0) {
  int i;

  {
#line 142
    i = 0;
#line 144
    if (p___0->location.x < (float)-320) {
#line 146
      p___0->location.x = (float)320;
    }
#line 149
    if (p___0->location.x > (float)320) {
#line 151
      p___0->location.x = (float)-320;
    }
#line 154
    if (p___0->location.y < (float)-240) {
#line 156
      p___0->location.y = (float)240;
    }
#line 159
    if (p___0->location.y > (float)240) {
#line 161
      p___0->location.y = (float)-240;
    }
#line 166
    i = 0;
#line 166
    while (i < 3) {
#line 168
      if (p___0->bullets[i].location.x < (float)0) {
#line 170
        p___0->bullets[i].alive = (enum boolean)1;
      } else
#line 168
          if (p___0->bullets[i].location.x >= (float)640) {
#line 170
        p___0->bullets[i].alive = (enum boolean)1;
      }
#line 173
      if (p___0->bullets[i].location.y < (float)0) {
#line 175
        p___0->bullets[i].alive = (enum boolean)1;
      } else
#line 173
          if (p___0->bullets[i].location.y >= (float)480) {
#line 175
        p___0->bullets[i].alive = (enum boolean)1;
      }
#line 166
      i++;
    }
#line 178
    return;
  }
}
#line 1 "cil-1ApJ4oEO.o"
#pragma merger("0", "/tmp/cil-XaCxQLcH.i", "-sUSE_SDL=2,-sUSE_SDL=2")
#line 203 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/math.h"
extern double fabs(double);
#line 323
extern double round(double);
#line 6 "../asteroids/renderer.c"
int draw_line(uint32_t *pixel_buffer, int x1, int y1___0, int x2, int y2,
              uint32_t colour) {
  int temp_x;
  int temp_y;
  int dx;
  int dy;
  float slope;
  float ideal_y;
  int y;
  double tmp;
  float error;
  int i;
  int x;
  float ideal_y___0;
  int y___0;
  double tmp___0;
  float error___0;
  int i___0;
  int x___0;
  double tmp___1;
  float slope___0;
  float ideal_x;
  int x___1;
  double tmp___2;
  float error___1;
  int i___1;
  int y___1;
  float ideal_x___0;
  int x___2;
  double tmp___3;
  float error___2;
  int i___2;
  int y___2;
  double tmp___4;
  double tmp___5;

  {
#line 10
    draw_pixel(pixel_buffer, x1, y1___0, colour);
#line 13
    if (x1 > x2) {
#line 15
      temp_x = x1;
#line 16
      temp_y = y1___0;
#line 18
      x1 = x2;
#line 19
      y1___0 = y2;
#line 21
      x2 = temp_x;
#line 22
      y2 = temp_y;
    }
#line 25
    dx = x2 - x1;
#line 26
    dy = y2 - y1___0;
#line 29
    tmp___1 = fabs((double)dy);
#line 29
    if ((double)dx >= tmp___1) {
#line 31
      slope = (float)dy / (float)dx;
#line 34
      if (y1___0 <= y2) {
#line 36
        ideal_y = (float)y1___0 + slope;
#line 37
        tmp = round((double)ideal_y);
#line 37
        y = (int)tmp;
#line 38
        error = ideal_y - (float)y;
#line 40
        i = 0;
#line 43
        i = 1;
#line 43
        while (i <= dx) {
#line 45
          x = x1 + i;
#line 47
          draw_pixel(pixel_buffer, x, y, colour);
#line 49
          error += slope;
#line 51
          if ((double)error >= 0.5) {
#line 53
            y++;
#line 54
            error -= (float)1;
          }
#line 43
          i++;
        }
      }
#line 60
      if (y1___0 > y2) {
#line 62
        ideal_y___0 = (float)y1___0 + slope;
#line 63
        tmp___0 = round((double)ideal_y___0);
#line 63
        y___0 = (int)tmp___0;
#line 64
        error___0 = ideal_y___0 - (float)y___0;
#line 66
        i___0 = 0;
#line 69
        i___0 = 1;
#line 69
        while (i___0 <= dx) {
#line 71
          x___0 = x1 + i___0;
#line 73
          draw_pixel(pixel_buffer, x___0, y___0, colour);
#line 75
          error___0 += slope;
#line 77
          if ((double)error___0 <= -0.5) {
#line 79
            y___0--;
#line 80
            error___0 += (float)1;
          }
#line 69
          i___0++;
        }
      }
    }
#line 89
    tmp___5 = fabs((double)dy);
#line 89
    if (tmp___5 > (double)dx) {
#line 91
      slope___0 = (float)dx / (float)dy;
#line 94
      if (y1___0 < y2) {
#line 96
        ideal_x = (float)x1 + slope___0;
#line 97
        tmp___2 = round((double)ideal_x);
#line 97
        x___1 = (int)tmp___2;
#line 98
        error___1 = ideal_x - (float)x___1;
#line 100
        i___1 = 0;
#line 103
        i___1 = 1;
#line 103
        while (i___1 <= dy) {
#line 105
          y___1 = y1___0 + i___1;
#line 107
          draw_pixel(pixel_buffer, x___1, y___1, colour);
#line 109
          error___1 += slope___0;
#line 111
          if ((double)error___1 >= 0.5) {
#line 113
            x___1++;
#line 114
            error___1 -= (float)1;
          }
#line 103
          i___1++;
        }
      }
#line 120
      if (y1___0 > y2) {
#line 122
        ideal_x___0 = (float)x1 - slope___0;
#line 123
        tmp___3 = round((double)ideal_x___0);
#line 123
        x___2 = (int)tmp___3;
#line 124
        error___2 = ideal_x___0 - (float)x___2;
#line 126
        i___2 = 0;
#line 129
        i___2 = 1;
#line 129
        while (1) {
#line 129
          tmp___4 = fabs((double)dy);
#line 129
          if (!((double)i___2 <= tmp___4)) {
#line 129
            break;
          }
#line 131
          y___2 = y1___0 - i___2;
#line 133
          draw_pixel(pixel_buffer, x___2, y___2, colour);
#line 135
          error___2 += slope___0;
#line 137
          if ((double)error___2 <= -0.5) {
#line 139
            x___2++;
#line 140
            error___2 += (float)1;
          }
#line 129
          i___2++;
        }
      }
    }
#line 146
    return (0);
  }
}
#line 149 "../asteroids/renderer.c"
int draw_pixel(uint32_t *pixel_buffer, int x, int y, uint32_t colour) {
  uint32_t position;

  {
#line 152
    if (x < 0) {
#line 154
      return (1);
    } else
#line 152
        if (y < 0) {
#line 154
      return (1);
    }
#line 158
    if (x >= 640) {
#line 160
      return (1);
    } else
#line 158
        if (y >= 480) {
#line 160
      return (1);
    }
#line 163
    position = (uint32_t)(y * 640 + x);
#line 164
    *(pixel_buffer + position) = colour;
#line 166
    return (0);
  }
}
#line 169 "../asteroids/renderer.c"
void clear_pixels(uint32_t *pixel_buffer, uint32_t colour) {
  int i;
  int buffer_size;

  {
#line 171
    i = 0;
#line 172
    buffer_size = 307200;
#line 174
    i = 0;
#line 174
    while (i < buffer_size) {
#line 176
      *(pixel_buffer + i) = colour;
#line 174
      i++;
    }
#line 178
    return;
  }
}
#line 1 "cil-tDLBtsia.o"
#pragma merger("0", "/tmp/cil-F8sg2gpV.i", "-sUSE_SDL=2,-sUSE_SDL=2")
#line 175 "/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/math.h"
extern double cos(double);
#line 335
extern double sin(double);
#line 21 "../asteroids/vector.h"
void print_vector(struct vector2d *a);
#line 25
float magnitude_vector(struct vector2d *v);
#line 8 "../asteroids/vector.c"
void add_vector(struct vector2d *a, struct vector2d *b) {

  {
#line 10
    a->x += b->x;
#line 11
    a->y += b->y;
#line 12
    return;
  }
}
#line 14 "../asteroids/vector.c"
struct vector2d add_vector_new(struct vector2d *a, struct vector2d *b) {
  struct vector2d new;

  {
#line 16
    new.x = a->x + b->x;
#line 16
    new.y = a->y + b->y;
#line 18
    return (new);
  }
}
#line 21 "../asteroids/vector.c"
void multiply_vector(struct vector2d *v, float n) {

  {
#line 23
    v->x *= n;
#line 24
    v->y *= n;
#line 25
    return;
  }
}
#line 27 "../asteroids/vector.c"
void divide_vector(struct vector2d *v, float n) {

  {
#line 29
    v->x /= n;
#line 30
    v->y /= n;
#line 31
    return;
  }
}
#line 33 "../asteroids/vector.c"
void print_vector(struct vector2d *a) {

  {
#line 35
    printf((char const *__restrict)"x = %f\n y = %f\n", (double)a->x,
           (double)a->y);
#line 36
    return;
  }
}
#line 38 "../asteroids/vector.c"
float magnitude_vector(struct vector2d *v) {
  float c2;
  double tmp;
  double tmp___0;
  double tmp___1;

  {
#line 40
    tmp = pow((double)v->x, (double)2);
#line 40
    tmp___0 = pow((double)v->y, (double)2);
#line 40
    c2 = (float)(tmp + tmp___0);
#line 42
    tmp___1 = sqrt((double)c2);
#line 42
    return ((float)tmp___1);
  }
}
#line 45 "../asteroids/vector.c"
void normalise_vector(struct vector2d *v) {
  float mag;
  float tmp;

  {
#line 47
    tmp = magnitude_vector(v);
#line 47
    mag = tmp;
#line 49
    divide_vector(v, mag);
#line 50
    return;
  }
}
#line 52 "../asteroids/vector.c"
void limit_vector(struct vector2d *v, float limit) {
  float mag;
  float tmp;
  float ratio;

  {
#line 54
    tmp = magnitude_vector(v);
#line 54
    mag = tmp;
#line 56
    if (mag > limit) {
#line 58
      ratio = limit / mag;
#line 59
      v->x *= ratio;
#line 60
      v->y *= ratio;
    }
#line 62
    return;
  }
}
#line 64 "../asteroids/vector.c"
void rotate_vector(struct vector2d *v, float degrees) {
  float angle;
  float sine;
  double tmp;
  float cosine;
  double tmp___0;
  float matrix[2][2];
  float x;
  float y;

  {
#line 67
    angle = (float)(((double)degrees * 3.14159265358979323846) / (double)180);
#line 68
    tmp = sin((double)angle);
#line 68
    sine = (float)tmp;
#line 69
    tmp___0 = cos((double)angle);
#line 69
    cosine = (float)tmp___0;
#line 72
    matrix[0][0] = cosine;
#line 72
    matrix[0][1] = -sine;
#line 72
    matrix[1][0] = sine;
#line 72
    matrix[1][1] = cosine;
#line 74
    x = v->x;
#line 75
    y = v->y;
#line 77
    v->x = matrix[0][0] * x + matrix[0][1] * y;
#line 78
    v->y = matrix[1][0] * x + matrix[1][1] * y;
#line 79
    return;
  }
}
