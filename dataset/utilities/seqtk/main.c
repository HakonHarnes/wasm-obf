#include "/usr/local/bin/tigress/3.3.2/tigress.h"
/* Generated by CIL v. %%VERSION_NUM%% */
/* print_CIL_Input is true */

#include <stdlib.h>

#line 175 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef signed char int8_t;
#line 190 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long int64_t;
#line 210 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int uint32_t;
#line 215 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned long long uint64_t;
#line 139 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned long size_t___0;
#line 241 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long off_t;
#line 398
struct _IO_FILE ;
#line 398 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef struct _IO_FILE FILE;
#line 410 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h"
typedef void *voidp;
#line 1302 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
struct gzFile_s ;
#line 1302 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1834 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
#line 83 "./kseq.h"
struct __kstring_t {
   size_t___0 l ;
   size_t___0 m ;
   char *s ;
};
#line 83 "./kseq.h"
typedef struct __kstring_t kstring_t;
#line 39 "seqtk.c"
struct __kstream_t {
   unsigned char *buf ;
   int begin ;
   int end ;
   int is_eof ;
   gzFile f ;
};
#line 39 "seqtk.c"
typedef struct __kstream_t kstream_t;
#line 39 "seqtk.c"
struct __anonstruct_kseq_t_745567265 {
   kstring_t name ;
   kstring_t comment ;
   kstring_t seq ;
   kstring_t qual ;
   int last_char ;
   int is_fastq ;
   kstream_t *f ;
};
#line 39 "seqtk.c"
typedef struct __anonstruct_kseq_t_745567265 kseq_t;
#line 41 "seqtk.c"
struct __anonstruct_reglist_t_947739297 {
   int n ;
   int m ;
   uint64_t *a ;
};
#line 41 "seqtk.c"
typedef struct __anonstruct_reglist_t_947739297 reglist_t;
#line 122 "./khash.h"
typedef unsigned int khint32_t;
#line 130 "./khash.h"
typedef unsigned long long khint64_t;
#line 137 "./khash.h"
typedef khint32_t khint_t;
#line 138 "./khash.h"
typedef khint_t khiter_t;
#line 532 "./khash.h"
typedef char const   *kh_cstr_t;
#line 47 "seqtk.c"
struct __anonstruct_kh_reg_t_369956422 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   kh_cstr_t *keys ;
   reglist_t *vals ;
};
#line 47 "seqtk.c"
typedef struct __anonstruct_kh_reg_t_369956422 kh_reg_t;
#line 48 "seqtk.c"
struct __anonstruct_kh_64_t_789978953 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   khint64_t *keys ;
   char *vals ;
};
#line 48 "seqtk.c"
typedef struct __anonstruct_kh_64_t_789978953 kh_64_t;
#line 50 "seqtk.c"
typedef kh_reg_t reghash_t;
#line 218 "seqtk.c"
typedef uint64_t krint64_t;
#line 220
struct _krand_t ;
#line 221 "seqtk.c"
typedef struct _krand_t krand_t;
#line 228 "seqtk.c"
struct _krand_t {
   int mti ;
   krint64_t mt[312] ;
};
#line 1572 "seqtk.c"
struct __anonstruct_posstat_t_390825615 {
   int64_t q[94] ;
   int64_t b[5] ;
};
#line 1572 "seqtk.c"
typedef struct __anonstruct_posstat_t_390825615 posstat_t;
#line 72 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern FILE *stdin ;
#line 73
extern FILE *stdout ;
#line 74
extern FILE *stderr ;
#line 89
extern int fflush(FILE * ) ;
#line 100
extern size_t___0 fwrite(void const   * __restrict   , size_t___0  , size_t___0  ,
                         FILE * __restrict   ) ;
#line 107
extern int fputc(int  , FILE * ) ;
#line 109
extern int putchar(int  ) ;
#line 116
extern int fputs(char const   * __restrict   , FILE * __restrict   ) ;
#line 117
extern int puts(char const   * ) ;
#line 119
extern int printf(char const   * __restrict    , ...) ;
#line 120
extern int fprintf(FILE * __restrict   , char const   * __restrict    , ...) ;
#line 152
extern int fileno(FILE * ) ;
#line 11 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h"
extern int isalpha(int  ) ;
#line 14
extern int isdigit(int  ) ;
#line 16
extern int islower(int  ) ;
#line 19
extern int isspace(int  ) ;
#line 20
extern int isupper(int  ) ;
#line 22
extern int tolower(int  ) ;
#line 23
extern int toupper(int  ) ;
#line 23 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern int atoi(char const   * ) ;
#line 24
extern long atol(char const   * ) ;
#line 26
extern double atof(char const   * ) ;
#line 40
extern void *malloc(size_t___0  ) ;
#line 41
extern void *calloc(size_t___0  , size_t___0  ) ;
#line 42
extern void *realloc(void * , size_t___0  ) ;
#line 43
extern void free(void * ) ;
#line 128
extern double drand48(void) ;
#line 130
extern long lrand48(void) ;
#line 134
extern void srand48(long  ) ;
#line 118 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h"
extern int isatty(int  ) ;
#line 137
extern int getopt(int  , char ** , char const   * ) ;
#line 138
extern char *optarg ;
#line 139
extern int optind ;
#line 1342 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1392
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1631
extern int gzclose(gzFile file ) ;
#line 1893
extern gzFile gzopen(char const   * , char const   * ) ;
#line 27 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
#line 29
extern void *memset(void * , int  , size_t___0  ) ;
#line 39
extern int strcmp(char const   * , char const   * ) ;
#line 40
extern int strncmp(char const   * , char const   * , size_t___0  ) ;
#line 54
extern size_t___0 strlen(char const   * ) ;
#line 70
extern char *strdup(char const   * ) ;
#line 19 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h"
extern void __assert_fail(char const   * , char const   * , int  , char const   * )  __attribute__((__noreturn__)) ;
#line 259 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h"
extern double log(double  ) ;
#line 307
extern double pow(double  , double  ) ;
#line 39 "seqtk.c"
__inline static kstream_t *ks_init(gzFile f ) 
{ 
  kstream_t *ks ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 39
  tmp = calloc((size_t___0 )1, sizeof(kstream_t ));
#line 39
  ks = (kstream_t *)tmp;
#line 39
  ks->f = f;
#line 39
  tmp___0 = malloc((size_t___0 )16384);
#line 39
  ks->buf = (unsigned char *)tmp___0;
#line 39
  return (ks);
}
}
#line 39 "seqtk.c"
__inline static void ks_destroy(kstream_t *ks ) 
{ 


  {
#line 39
  if (ks) {
#line 39
    free((void *)ks->buf);
#line 39
    free((void *)ks);
  }
#line 39
  return;
}
}
#line 39 "seqtk.c"
__inline static int ks_getc(kstream_t *ks ) 
{ 
  int tmp ;

  {
#line 39
  if (ks->end < 0) {
#line 39
    return (-3);
  }
#line 39
  if (ks->is_eof) {
#line 39
    if (ks->begin >= ks->end) {
#line 39
      return (-1);
    }
  }
#line 39
  if (ks->begin >= ks->end) {
#line 39
    ks->begin = 0;
#line 39
    ks->end = gzread(ks->f, (voidp )ks->buf, 16384U);
#line 39
    if (ks->end == 0) {
#line 39
      ks->is_eof = 1;
#line 39
      return (-1);
    } else
#line 39
    if (ks->end < 0) {
#line 39
      ks->is_eof = 1;
#line 39
      return (-3);
    }
  }
#line 39
  tmp = ks->begin;
#line 39
  (ks->begin) ++;
#line 39
  return ((int )*(ks->buf + tmp));
}
}
#line 39 "seqtk.c"
static int ks_getuntil2(kstream_t *ks , int delimiter , kstring_t *str , int *dret ,
                        int append ) 
{ 
  int gotany ;
  int i ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 39
  gotany = 0;
#line 39
  if (dret) {
#line 39
    *dret = 0;
  }
#line 39
  if (append) {
#line 39
    str->l = str->l;
  } else {
#line 39
    str->l = (size_t___0 )0;
  }
#line 39
  while (1) {
#line 39
    if (ks->end < 0) {
#line 39
      return (-3);
    }
#line 39
    if (ks->begin >= ks->end) {
#line 39
      if (! ks->is_eof) {
#line 39
        ks->begin = 0;
#line 39
        ks->end = gzread(ks->f, (voidp )ks->buf, 16384U);
#line 39
        if (ks->end == 0) {
#line 39
          ks->is_eof = 1;
#line 39
          break;
        }
#line 39
        if (ks->end == -1) {
#line 39
          ks->is_eof = 1;
#line 39
          return (-3);
        }
      } else {
#line 39
        break;
      }
    }
#line 39
    if (delimiter == 2) {
#line 39
      i = ks->begin;
#line 39
      while (i < ks->end) {
#line 39
        if ((int )*(ks->buf + i) == 10) {
#line 39
          break;
        }
#line 39
        i ++;
      }
    } else
#line 39
    if (delimiter > 2) {
#line 39
      i = ks->begin;
#line 39
      while (i < ks->end) {
#line 39
        if ((int )*(ks->buf + i) == delimiter) {
#line 39
          break;
        }
#line 39
        i ++;
      }
    } else
#line 39
    if (delimiter == 0) {
#line 39
      i = ks->begin;
#line 39
      while (i < ks->end) {
#line 39
        tmp = isspace((int )*(ks->buf + i));
#line 39
        if (tmp) {
#line 39
          break;
        }
#line 39
        i ++;
      }
    } else
#line 39
    if (delimiter == 1) {
#line 39
      i = ks->begin;
#line 39
      while (i < ks->end) {
#line 39
        tmp___0 = isspace((int )*(ks->buf + i));
#line 39
        if (tmp___0) {
#line 39
          if ((int )*(ks->buf + i) != 32) {
#line 39
            break;
          }
        }
#line 39
        i ++;
      }
    } else {
#line 39
      i = 0;
    }
#line 39
    if (str->m - str->l < (size_t___0 )((i - ks->begin) + 1)) {
#line 39
      str->m = (str->l + (size_t___0 )(i - ks->begin)) + 1UL;
#line 39
      (str->m) --;
#line 39
      str->m |= str->m >> 1;
#line 39
      str->m |= str->m >> 2;
#line 39
      str->m |= str->m >> 4;
#line 39
      str->m |= str->m >> 8;
#line 39
      str->m |= str->m >> 16;
#line 39
      (str->m) ++;
#line 39
      tmp___1 = realloc((void *)str->s, str->m);
#line 39
      str->s = (char *)tmp___1;
    }
#line 39
    gotany = 1;
#line 39
    memcpy((void * __restrict  )(str->s + str->l), (void const   * __restrict  )(ks->buf + ks->begin),
           (size_t___0 )(i - ks->begin));
#line 39
    str->l += (size_t___0 )(i - ks->begin);
#line 39
    ks->begin = i + 1;
#line 39
    if (i < ks->end) {
#line 39
      if (dret) {
#line 39
        *dret = (int )*(ks->buf + i);
      }
#line 39
      break;
    }
  }
#line 39
  if (! gotany) {
#line 39
    if (ks->is_eof) {
#line 39
      if (ks->begin >= ks->end) {
#line 39
        return (-1);
      }
    }
  }
#line 39
  if ((unsigned long )str->s == (unsigned long )((char *)0)) {
#line 39
    str->m = (size_t___0 )1;
#line 39
    tmp___2 = calloc((size_t___0 )1, (size_t___0 )1);
#line 39
    str->s = (char *)tmp___2;
  } else
#line 39
  if (delimiter == 2) {
#line 39
    if (str->l > 1UL) {
#line 39
      if ((int )*(str->s + (str->l - 1UL)) == 13) {
#line 39
        (str->l) --;
      }
    }
  }
#line 39
  *(str->s + str->l) = (char )'\000';
#line 39
  return ((int )str->l);
}
}
#line 39 "seqtk.c"
__inline static int ks_getuntil(kstream_t *ks , int delimiter , kstring_t *str , int *dret ) 
{ 
  int tmp ;

  {
#line 39
  tmp = ks_getuntil2(ks, delimiter, str, dret, 0);
#line 39
  return (tmp);
}
}
#line 39 "seqtk.c"
static kseq_t *kseq_init(gzFile fd ) 
{ 
  kseq_t *s ;
  void *tmp ;

  {
#line 39
  tmp = calloc((size_t___0 )1, sizeof(kseq_t ));
#line 39
  s = (kseq_t *)tmp;
#line 39
  s->f = ks_init(fd);
#line 39
  return (s);
}
}
#line 39 "seqtk.c"
static void kseq_destroy(kseq_t *ks ) 
{ 


  {
#line 39
  if (! ks) {
#line 39
    return;
  }
#line 39
  free((void *)ks->name.s);
#line 39
  free((void *)ks->comment.s);
#line 39
  free((void *)ks->seq.s);
#line 39
  free((void *)ks->qual.s);
#line 39
  ks_destroy(ks->f);
#line 39
  free((void *)ks);
#line 39
  return;
}
}
#line 39 "seqtk.c"
static int kseq_read(kseq_t *seq ) 
{ 
  int c ;
  int r ;
  kstream_t *ks ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 39
  ks = seq->f;
#line 39
  if (seq->last_char == 0) {
#line 39
    while (1) {
#line 39
      c = ks_getc(ks);
#line 39
      if (c >= 0) {
#line 39
        if (c != 62) {
#line 39
          if (! (c != 64)) {
#line 39
            break;
          }
        } else {
#line 39
          break;
        }
      } else {
#line 39
        break;
      }
    }
#line 39
    if (c < 0) {
#line 39
      return (c);
    }
#line 39
    seq->last_char = c;
  }
#line 39
  tmp___0 = (size_t___0 )0;
#line 39
  seq->qual.l = tmp___0;
#line 39
  tmp = tmp___0;
#line 39
  seq->seq.l = tmp;
#line 39
  seq->comment.l = tmp;
#line 39
  r = ks_getuntil(ks, 0, & seq->name, & c);
#line 39
  if (r < 0) {
#line 39
    return (r);
  }
#line 39
  if (c != 10) {
#line 39
    ks_getuntil(ks, 2, & seq->comment, (int *)0);
  }
#line 39
  if ((unsigned long )seq->seq.s == (unsigned long )((char *)0)) {
#line 39
    seq->seq.m = (size_t___0 )256;
#line 39
    tmp___1 = malloc(seq->seq.m);
#line 39
    seq->seq.s = (char *)tmp___1;
  }
#line 39
  while (1) {
#line 39
    c = ks_getc(ks);
#line 39
    if (c >= 0) {
#line 39
      if (c != 62) {
#line 39
        if (c != 43) {
#line 39
          if (! (c != 64)) {
#line 39
            break;
          }
        } else {
#line 39
          break;
        }
      } else {
#line 39
        break;
      }
    } else {
#line 39
      break;
    }
#line 39
    if (c == 10) {
#line 39
      continue;
    }
#line 39
    tmp___2 = seq->seq.l;
#line 39
    (seq->seq.l) ++;
#line 39
    *(seq->seq.s + tmp___2) = (char )c;
#line 39
    ks_getuntil2(ks, 2, & seq->seq, (int *)0, 1);
  }
#line 39
  if (c == 62) {
#line 39
    seq->last_char = c;
  } else
#line 39
  if (c == 64) {
#line 39
    seq->last_char = c;
  }
#line 39
  if (seq->seq.l + 1UL >= seq->seq.m) {
#line 39
    seq->seq.m = seq->seq.l + 2UL;
#line 39
    (seq->seq.m) --;
#line 39
    seq->seq.m |= seq->seq.m >> 1;
#line 39
    seq->seq.m |= seq->seq.m >> 2;
#line 39
    seq->seq.m |= seq->seq.m >> 4;
#line 39
    seq->seq.m |= seq->seq.m >> 8;
#line 39
    seq->seq.m |= seq->seq.m >> 16;
#line 39
    (seq->seq.m) ++;
#line 39
    tmp___3 = realloc((void *)seq->seq.s, seq->seq.m);
#line 39
    seq->seq.s = (char *)tmp___3;
  }
#line 39
  *(seq->seq.s + seq->seq.l) = (char)0;
#line 39
  seq->is_fastq = c == 43;
#line 39
  if (! seq->is_fastq) {
#line 39
    return ((int )seq->seq.l);
  }
#line 39
  if (seq->qual.m < seq->seq.m) {
#line 39
    seq->qual.m = seq->seq.m;
#line 39
    tmp___4 = realloc((void *)seq->qual.s, seq->qual.m);
#line 39
    seq->qual.s = (char *)tmp___4;
  }
#line 39
  while (1) {
#line 39
    c = ks_getc(ks);
#line 39
    if (c >= 0) {
#line 39
      if (! (c != 10)) {
#line 39
        break;
      }
    } else {
#line 39
      break;
    }
  }
#line 39
  if (c == -1) {
#line 39
    return (-2);
  }
#line 39
  while (1) {
#line 39
    tmp___5 = ks_getuntil2(ks, 2, & seq->qual, (int *)0, 1);
#line 39
    if (tmp___5 >= 0) {
#line 39
      if (seq->qual.l < seq->seq.l) {
#line 39
        tmp___6 = 1;
      } else {
#line 39
        tmp___6 = 0;
      }
    } else {
#line 39
      tmp___6 = 0;
    }
#line 39
    c = tmp___6;
#line 39
    if (! c) {
#line 39
      break;
    }
  }
#line 39
  if (c == -3) {
#line 39
    return (-3);
  }
#line 39
  seq->last_char = 0;
#line 39
  if (seq->seq.l != seq->qual.l) {
#line 39
    return (-2);
  }
#line 39
  return ((int )seq->seq.l);
}
}
#line 160 "./khash.h"
static double const   __ac_HASH_UPPER  =    (double const   )0.77;
#line 345 "./khash.h"
__inline static khint_t __ac_X31_hash_string(char const   *s ) 
{ 
  khint_t h ;

  {
#line 347
  h = (khint_t )*s;
#line 348
  if (h) {
#line 348
    s ++;
#line 348
    while (*s) {
#line 348
      h = ((h << 5) - h) + (khint_t )*s;
#line 348
      s ++;
    }
  }
#line 349
  return (h);
}
}
#line 47 "seqtk.c"
__inline static kh_reg_t *kh_init_reg(void) 
{ 
  void *tmp ;

  {
#line 47
  tmp = calloc((size_t___0 )1, sizeof(kh_reg_t ));
#line 47
  return ((kh_reg_t *)tmp);
}
}
#line 47 "seqtk.c"
__inline static void kh_destroy_reg(kh_reg_t *h ) 
{ 


  {
#line 47
  if (h) {
#line 47
    free((void *)h->keys);
#line 47
    free((void *)h->flags);
#line 47
    free((void *)h->vals);
#line 47
    free((void *)h);
  }
#line 47
  return;
}
}
#line 47 "seqtk.c"
__inline static khint_t kh_get_reg(kh_reg_t const   *h , kh_cstr_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  int tmp ;
  khint_t tmp___0 ;

  {
#line 47
  if (h->n_buckets) {
#line 47
    mask = (khint_t )(h->n_buckets - 1U);
#line 47
    k = __ac_X31_hash_string(key);
#line 47
    i = k & mask;
#line 47
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
#line 47
    last = i;
#line 47
    while (1) {
#line 47
      if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U)) {
#line 47
        if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 1U)) {
#line 47
          tmp = strcmp(*(h->keys + i), key);
#line 47
          if (tmp == 0) {
#line 47
            break;
          }
        }
      } else {
#line 47
        break;
      }
#line 47
      i = (i + inc) & mask;
#line 47
      if (i == last) {
#line 47
        return ((khint_t )h->n_buckets);
      }
    }
#line 47
    if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 3U) {
#line 47
      tmp___0 = h->n_buckets;
    } else {
#line 47
      tmp___0 = (khint_t )i;
    }
#line 47
    return ((khint_t )tmp___0);
  } else {
#line 47
    return ((khint_t )0);
  }
}
}
#line 47 "seqtk.c"
__inline static void kh_resize_reg(kh_reg_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  kh_cstr_t key ;
  reglist_t val ;
  khint_t new_mask ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  kh_cstr_t tmp___4 ;
  reglist_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 47
  new_flags = (khint32_t *)0;
#line 47
  j = (khint_t )1;
#line 47
  new_n_buckets --;
#line 47
  new_n_buckets |= new_n_buckets >> 1;
#line 47
  new_n_buckets |= new_n_buckets >> 2;
#line 47
  new_n_buckets |= new_n_buckets >> 4;
#line 47
  new_n_buckets |= new_n_buckets >> 8;
#line 47
  new_n_buckets |= new_n_buckets >> 16;
#line 47
  new_n_buckets ++;
#line 47
  if (new_n_buckets < 4U) {
#line 47
    new_n_buckets = (khint_t )4;
  }
#line 47
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
#line 47
    j = (khint_t )0;
  } else {
#line 47
    if (new_n_buckets < 16U) {
#line 47
      tmp = (khint_t )1;
    } else {
#line 47
      tmp = new_n_buckets >> 4;
    }
#line 47
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
#line 47
    new_flags = (khint32_t *)tmp___0;
#line 47
    if (new_n_buckets < 16U) {
#line 47
      tmp___1 = (khint_t )1;
    } else {
#line 47
      tmp___1 = new_n_buckets >> 4;
    }
#line 47
    memset((void *)new_flags, 0xaa, (unsigned long )tmp___1 * sizeof(khint32_t ));
#line 47
    if (h->n_buckets < new_n_buckets) {
#line 47
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
#line 47
      h->keys = (kh_cstr_t *)tmp___2;
#line 47
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(reglist_t ));
#line 47
      h->vals = (reglist_t *)tmp___3;
    }
  }
#line 47
  if (j) {
#line 47
    j = (khint_t )0;
#line 47
    while (j != h->n_buckets) {
#line 47
      if (((*(h->flags + (j >> 4)) >> ((j & 0xfU) << 1)) & 3U) == 0U) {
#line 47
        key = *(h->keys + j);
#line 47
        new_mask = new_n_buckets - 1U;
#line 47
        val = *(h->vals + j);
#line 47
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1ul << ((j & 0xfU) << 1)));
#line 47
        while (1) {
#line 47
          k = __ac_X31_hash_string(key);
#line 47
          i = k & new_mask;
#line 47
          inc = (((k >> 3) ^ (k << 3)) | 1U) & new_mask;
#line 47
          while (! ((*(new_flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U)) {
#line 47
            i = (i + inc) & new_mask;
          }
#line 47
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2ul << ((i & 0xfU) << 1)));
#line 47
          if (i < h->n_buckets) {
#line 47
            if (((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 3U) == 0U) {
#line 47
              tmp___4 = *(h->keys + i);
#line 47
              *(h->keys + i) = key;
#line 47
              key = tmp___4;
#line 47
              tmp___5 = *(h->vals + i);
#line 47
              *(h->vals + i) = val;
#line 47
              val = tmp___5;
#line 47
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1ul << ((i & 0xfU) << 1)));
            } else {
#line 47
              *(h->keys + i) = key;
#line 47
              *(h->vals + i) = val;
#line 47
              break;
            }
          } else {
#line 47
            *(h->keys + i) = key;
#line 47
            *(h->vals + i) = val;
#line 47
            break;
          }
        }
      }
#line 47
      j ++;
    }
#line 47
    if (h->n_buckets > new_n_buckets) {
#line 47
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
#line 47
      h->keys = (kh_cstr_t *)tmp___6;
#line 47
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(reglist_t ));
#line 47
      h->vals = (reglist_t *)tmp___7;
    }
#line 47
    free((void *)h->flags);
#line 47
    h->flags = new_flags;
#line 47
    h->n_buckets = new_n_buckets;
#line 47
    h->n_occupied = h->size;
#line 47
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
  }
#line 47
  return;
}
}
#line 47 "seqtk.c"
__inline static khint_t kh_put_reg(kh_reg_t *h , kh_cstr_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  int tmp ;

  {
#line 47
  if (h->n_occupied >= h->upper_bound) {
#line 47
    if (h->n_buckets > h->size << 1) {
#line 47
      kh_resize_reg(h, h->n_buckets - 1U);
    } else {
#line 47
      kh_resize_reg(h, h->n_buckets + 1U);
    }
  }
#line 47
  mask = h->n_buckets - 1U;
#line 47
  site = h->n_buckets;
#line 47
  x = site;
#line 47
  k = __ac_X31_hash_string(key);
#line 47
  i = k & mask;
#line 47
  if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U) {
#line 47
    x = i;
  } else {
#line 47
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
#line 47
    last = i;
#line 47
    while (1) {
#line 47
      if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U)) {
#line 47
        if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 1U)) {
#line 47
          tmp = strcmp(*(h->keys + i), key);
#line 47
          if (tmp == 0) {
#line 47
            break;
          }
        }
      } else {
#line 47
        break;
      }
#line 47
      if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 1U) {
#line 47
        site = i;
      }
#line 47
      i = (i + inc) & mask;
#line 47
      if (i == last) {
#line 47
        x = site;
#line 47
        break;
      }
    }
#line 47
    if (x == h->n_buckets) {
#line 47
      if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U) {
#line 47
        if (site != h->n_buckets) {
#line 47
          x = site;
        } else {
#line 47
          x = i;
        }
      } else {
#line 47
        x = i;
      }
    }
  }
#line 47
  if ((*(h->flags + (x >> 4)) >> ((x & 0xfU) << 1)) & 2U) {
#line 47
    *(h->keys + x) = key;
#line 47
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3ul << ((x & 0xfU) << 1)));
#line 47
    (h->size) ++;
#line 47
    (h->n_occupied) ++;
#line 47
    *ret = 1;
  } else
#line 47
  if ((*(h->flags + (x >> 4)) >> ((x & 0xfU) << 1)) & 1U) {
#line 47
    *(h->keys + x) = key;
#line 47
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3ul << ((x & 0xfU) << 1)));
#line 47
    (h->size) ++;
#line 47
    *ret = 2;
  } else {
#line 47
    *ret = 0;
  }
#line 47
  return (x);
}
}
#line 48 "seqtk.c"
__inline static kh_64_t *kh_init_64(void) 
{ 
  void *tmp ;

  {
#line 48
  tmp = calloc((size_t___0 )1, sizeof(kh_64_t ));
#line 48
  return ((kh_64_t *)tmp);
}
}
#line 48 "seqtk.c"
__inline static void kh_destroy_64(kh_64_t *h ) 
{ 


  {
#line 48
  if (h) {
#line 48
    free((void *)h->keys);
#line 48
    free((void *)h->flags);
#line 48
    free((void *)h->vals);
#line 48
    free((void *)h);
  }
#line 48
  return;
}
}
#line 48 "seqtk.c"
__inline static khint_t kh_get_64(kh_64_t const   *h , khint64_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t tmp ;

  {
#line 48
  if (h->n_buckets) {
#line 48
    mask = (khint_t )(h->n_buckets - 1U);
#line 48
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
#line 48
    i = k & mask;
#line 48
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
#line 48
    last = i;
#line 48
    while (1) {
#line 48
      if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U)) {
#line 48
        if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 1U)) {
#line 48
          if (! (! (*(h->keys + i) == key))) {
#line 48
            break;
          }
        }
      } else {
#line 48
        break;
      }
#line 48
      i = (i + inc) & mask;
#line 48
      if (i == last) {
#line 48
        return ((khint_t )h->n_buckets);
      }
    }
#line 48
    if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 3U) {
#line 48
      tmp = h->n_buckets;
    } else {
#line 48
      tmp = (khint_t )i;
    }
#line 48
    return ((khint_t )tmp);
  } else {
#line 48
    return ((khint_t )0);
  }
}
}
#line 48 "seqtk.c"
__inline static void kh_resize_64(kh_64_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  void *tmp___2 ;
  khint64_t key ;
  khint_t new_mask ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint64_t tmp___4 ;
  void *tmp___6 ;

  {
#line 48
  new_flags = (khint32_t *)0;
#line 48
  j = (khint_t )1;
#line 48
  new_n_buckets --;
#line 48
  new_n_buckets |= new_n_buckets >> 1;
#line 48
  new_n_buckets |= new_n_buckets >> 2;
#line 48
  new_n_buckets |= new_n_buckets >> 4;
#line 48
  new_n_buckets |= new_n_buckets >> 8;
#line 48
  new_n_buckets |= new_n_buckets >> 16;
#line 48
  new_n_buckets ++;
#line 48
  if (new_n_buckets < 4U) {
#line 48
    new_n_buckets = (khint_t )4;
  }
#line 48
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
#line 48
    j = (khint_t )0;
  } else {
#line 48
    if (new_n_buckets < 16U) {
#line 48
      tmp = (khint_t )1;
    } else {
#line 48
      tmp = new_n_buckets >> 4;
    }
#line 48
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
#line 48
    new_flags = (khint32_t *)tmp___0;
#line 48
    if (new_n_buckets < 16U) {
#line 48
      tmp___1 = (khint_t )1;
    } else {
#line 48
      tmp___1 = new_n_buckets >> 4;
    }
#line 48
    memset((void *)new_flags, 0xaa, (unsigned long )tmp___1 * sizeof(khint32_t ));
#line 48
    if (h->n_buckets < new_n_buckets) {
#line 48
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
#line 48
      h->keys = (khint64_t *)tmp___2;
    }
  }
#line 48
  if (j) {
#line 48
    j = (khint_t )0;
#line 48
    while (j != h->n_buckets) {
#line 48
      if (((*(h->flags + (j >> 4)) >> ((j & 0xfU) << 1)) & 3U) == 0U) {
#line 48
        key = *(h->keys + j);
#line 48
        new_mask = new_n_buckets - 1U;
#line 48
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1ul << ((j & 0xfU) << 1)));
#line 48
        while (1) {
#line 48
          k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
#line 48
          i = k & new_mask;
#line 48
          inc = (((k >> 3) ^ (k << 3)) | 1U) & new_mask;
#line 48
          while (! ((*(new_flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U)) {
#line 48
            i = (i + inc) & new_mask;
          }
#line 48
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2ul << ((i & 0xfU) << 1)));
#line 48
          if (i < h->n_buckets) {
#line 48
            if (((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 3U) == 0U) {
#line 48
              tmp___4 = *(h->keys + i);
#line 48
              *(h->keys + i) = key;
#line 48
              key = tmp___4;
#line 48
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1ul << ((i & 0xfU) << 1)));
            } else {
#line 48
              *(h->keys + i) = key;
#line 48
              break;
            }
          } else {
#line 48
            *(h->keys + i) = key;
#line 48
            break;
          }
        }
      }
#line 48
      j ++;
    }
#line 48
    if (h->n_buckets > new_n_buckets) {
#line 48
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
#line 48
      h->keys = (khint64_t *)tmp___6;
    }
#line 48
    free((void *)h->flags);
#line 48
    h->flags = new_flags;
#line 48
    h->n_buckets = new_n_buckets;
#line 48
    h->n_occupied = h->size;
#line 48
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
  }
#line 48
  return;
}
}
#line 48 "seqtk.c"
__inline static khint_t kh_put_64(kh_64_t *h , khint64_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;

  {
#line 48
  if (h->n_occupied >= h->upper_bound) {
#line 48
    if (h->n_buckets > h->size << 1) {
#line 48
      kh_resize_64(h, h->n_buckets - 1U);
    } else {
#line 48
      kh_resize_64(h, h->n_buckets + 1U);
    }
  }
#line 48
  mask = h->n_buckets - 1U;
#line 48
  site = h->n_buckets;
#line 48
  x = site;
#line 48
  k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
#line 48
  i = k & mask;
#line 48
  if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U) {
#line 48
    x = i;
  } else {
#line 48
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
#line 48
    last = i;
#line 48
    while (1) {
#line 48
      if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U)) {
#line 48
        if (! ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 1U)) {
#line 48
          if (! (! (*(h->keys + i) == key))) {
#line 48
            break;
          }
        }
      } else {
#line 48
        break;
      }
#line 48
      if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 1U) {
#line 48
        site = i;
      }
#line 48
      i = (i + inc) & mask;
#line 48
      if (i == last) {
#line 48
        x = site;
#line 48
        break;
      }
    }
#line 48
    if (x == h->n_buckets) {
#line 48
      if ((*(h->flags + (i >> 4)) >> ((i & 0xfU) << 1)) & 2U) {
#line 48
        if (site != h->n_buckets) {
#line 48
          x = site;
        } else {
#line 48
          x = i;
        }
      } else {
#line 48
        x = i;
      }
    }
  }
#line 48
  if ((*(h->flags + (x >> 4)) >> ((x & 0xfU) << 1)) & 2U) {
#line 48
    *(h->keys + x) = key;
#line 48
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3ul << ((x & 0xfU) << 1)));
#line 48
    (h->size) ++;
#line 48
    (h->n_occupied) ++;
#line 48
    *ret = 1;
  } else
#line 48
  if ((*(h->flags + (x >> 4)) >> ((x & 0xfU) << 1)) & 1U) {
#line 48
    *(h->keys + x) = key;
#line 48
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3ul << ((x & 0xfU) << 1)));
#line 48
    (h->size) ++;
#line 48
    *ret = 2;
  } else {
#line 48
    *ret = 0;
  }
#line 48
  return (x);
}
}
#line 52 "seqtk.c"
reghash_t *stk_reg_read(char const   *fn ) 
{ 
  reghash_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kstream_t *ks ;
  int dret ;
  kstring_t *str ;
  gzFile tmp___1 ;
  int tmp___2 ;
  gzFile tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int beg ;
  int end ;
  reglist_t *p ;
  khint_t k ;
  khint_t tmp___6 ;
  int ret ;
  char *s ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 54
  tmp = kh_init_reg();
#line 54
  h = tmp;
#line 60
  tmp___4 = strcmp(fn, (char const   *)"-");
#line 60
  if (tmp___4) {
#line 60
    tmp___1 = gzopen(fn, (char const   *)"r");
#line 60
    fp = tmp___1;
  } else {
#line 60
    tmp___2 = fileno((FILE *)stdin);
#line 60
    tmp___3 = gzdopen(tmp___2, (char const   *)"r");
#line 60
    fp = tmp___3;
  }
#line 61
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 61
    return ((reghash_t *)0);
  }
#line 62
  ks = ks_init(fp);
#line 63
  tmp___5 = calloc((size_t___0 )1, sizeof(kstring_t ));
#line 63
  str = (kstring_t *)tmp___5;
#line 64
  while (1) {
#line 64
    tmp___14 = ks_getuntil(ks, 0, str, & dret);
#line 64
    if (! (tmp___14 >= 0)) {
#line 64
      break;
    }
#line 65
    beg = -1;
#line 65
    end = -1;
#line 67
    tmp___6 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )str->s);
#line 67
    k = tmp___6;
#line 68
    if (k == h->n_buckets) {
#line 70
      tmp___7 = strdup((char const   *)str->s);
#line 70
      s = tmp___7;
#line 71
      k = kh_put_reg(h, (kh_cstr_t )s, & ret);
#line 72
      memset((void *)(h->vals + k), 0, sizeof(reglist_t ));
    }
#line 74
    p = h->vals + k;
#line 75
    if (dret != 10) {
#line 76
      tmp___10 = ks_getuntil(ks, 0, str, & dret);
#line 76
      if (tmp___10 > 0) {
#line 76
        tmp___11 = isdigit((int )*(str->s + 0));
#line 76
        if (tmp___11) {
#line 77
          beg = atoi((char const   *)str->s);
#line 78
          if (dret != 10) {
#line 79
            tmp___8 = ks_getuntil(ks, 0, str, & dret);
#line 79
            if (tmp___8 > 0) {
#line 79
              tmp___9 = isdigit((int )*(str->s + 0));
#line 79
              if (tmp___9) {
#line 80
                end = atoi((char const   *)str->s);
#line 81
                if (end < 0) {
#line 81
                  end = -1;
                }
              }
            }
          }
        }
      }
    }
#line 87
    if (dret != 10) {
#line 87
      while (1) {
#line 87
        dret = ks_getc(ks);
#line 87
        if (dret > 0) {
#line 87
          if (! (dret != 10)) {
#line 87
            break;
          }
        } else {
#line 87
          break;
        }
      }
    }
#line 88
    if (end < 0) {
#line 88
      if (beg > 0) {
#line 88
        end = beg;
#line 88
        beg --;
      }
    }
#line 89
    if (beg < 0) {
#line 89
      beg = 0;
#line 89
      end = 2147483647;
    }
#line 90
    if (p->n == p->m) {
#line 91
      if (p->m) {
#line 91
        p->m <<= 1;
      } else {
#line 91
        p->m = 4;
      }
#line 92
      tmp___12 = realloc((void *)p->a, (size_t___0 )(p->m * 8));
#line 92
      p->a = (uint64_t *)tmp___12;
    }
#line 94
    tmp___13 = p->n;
#line 94
    (p->n) ++;
#line 94
    *(p->a + tmp___13) = ((uint64_t )beg << 32) | (unsigned long long )end;
  }
#line 96
  ks_destroy(ks);
#line 97
  gzclose(fp);
#line 98
  free((void *)str->s);
#line 98
  free((void *)str);
#line 99
  return (h);
}
}
#line 102 "seqtk.c"
void stk_reg_destroy(reghash_t *h ) 
{ 
  khint_t k ;

  {
#line 105
  if ((unsigned long )h == (unsigned long )((reghash_t *)0)) {
#line 105
    return;
  }
#line 106
  k = (khint_t )0;
#line 106
  while (k < h->n_buckets) {
#line 107
    if (! ((*(h->flags + (k >> 4)) >> ((k & 0xfU) << 1)) & 3U)) {
#line 108
      free((void *)(h->vals + k)->a);
#line 109
      free((void *)((char *)*(h->keys + k)));
    }
#line 106
    k ++;
  }
#line 112
  kh_destroy_reg(h);
#line 113
  return;
}
}
#line 117 "seqtk.c"
unsigned char seq_nt16_table[256]  = 
#line 117
  {      (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)1,      (unsigned char)14,      (unsigned char)2, 
        (unsigned char)13,      (unsigned char)15,      (unsigned char)15,      (unsigned char)4, 
        (unsigned char)11,      (unsigned char)15,      (unsigned char)15,      (unsigned char)12, 
        (unsigned char)15,      (unsigned char)3,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)8,      (unsigned char)15,      (unsigned char)7,      (unsigned char)9, 
        (unsigned char)0,      (unsigned char)10,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)1,      (unsigned char)14,      (unsigned char)2, 
        (unsigned char)13,      (unsigned char)15,      (unsigned char)15,      (unsigned char)4, 
        (unsigned char)11,      (unsigned char)15,      (unsigned char)15,      (unsigned char)12, 
        (unsigned char)15,      (unsigned char)3,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)8,      (unsigned char)15,      (unsigned char)7,      (unsigned char)9, 
        (unsigned char)0,      (unsigned char)10,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15};
#line 136 "seqtk.c"
unsigned char seq_nt6_table[256]  = 
#line 136
  {      (unsigned char)0,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)1,      (unsigned char)5,      (unsigned char)2, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)3, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)1,      (unsigned char)5,      (unsigned char)2, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)3, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5};
#line 156 "seqtk.c"
char *seq_nt16_rev_table  =    "XACMGRSVTWYHKDBN";
#line 157 "seqtk.c"
unsigned char seq_nt16to4_table[16]  = 
#line 157
  {      (unsigned char)4,      (unsigned char)0,      (unsigned char)1,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4};
#line 158 "seqtk.c"
unsigned char seq_nt16comp_table[16]  = 
#line 158
  {      (unsigned char)0,      (unsigned char)8,      (unsigned char)4,      (unsigned char)12, 
        (unsigned char)2,      (unsigned char)10,      (unsigned char)9,      (unsigned char)14, 
        (unsigned char)1,      (unsigned char)6,      (unsigned char)5,      (unsigned char)13, 
        (unsigned char)3,      (unsigned char)11,      (unsigned char)7,      (unsigned char)15};
#line 159 "seqtk.c"
int bitcnt_table[16]  = 
#line 159
  {      4,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4};
#line 160 "seqtk.c"
char comp_tab[128]  = 
#line 160
  {      (char)0,      (char)1,      (char)2,      (char)3, 
        (char)4,      (char)5,      (char)6,      (char)7, 
        (char)8,      (char)9,      (char)10,      (char)11, 
        (char)12,      (char)13,      (char)14,      (char)15, 
        (char)16,      (char)17,      (char)18,      (char)19, 
        (char)20,      (char)21,      (char)22,      (char)23, 
        (char)24,      (char)25,      (char)26,      (char)27, 
        (char)28,      (char)29,      (char)30,      (char)31, 
        (char)32,      (char)33,      (char)34,      (char)35, 
        (char)36,      (char)37,      (char)38,      (char)39, 
        (char)40,      (char)41,      (char)42,      (char)43, 
        (char)44,      (char)45,      (char)46,      (char)47, 
        (char)48,      (char)49,      (char)50,      (char)51, 
        (char)52,      (char)53,      (char)54,      (char)55, 
        (char)56,      (char)57,      (char)58,      (char)59, 
        (char)60,      (char)61,      (char)62,      (char)63, 
        (char)64,      (char )'T',      (char )'V',      (char )'G', 
        (char )'H',      (char )'E',      (char )'F',      (char )'C', 
        (char )'D',      (char )'I',      (char )'J',      (char )'M', 
        (char )'L',      (char )'K',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'Y',      (char )'S', 
        (char )'A',      (char )'A',      (char )'B',      (char )'W', 
        (char )'X',      (char )'R',      (char )'Z',      (char)91, 
        (char)92,      (char)93,      (char)94,      (char)95, 
        (char)64,      (char )'t',      (char )'v',      (char )'g', 
        (char )'h',      (char )'e',      (char )'f',      (char )'c', 
        (char )'d',      (char )'i',      (char )'j',      (char )'m', 
        (char )'l',      (char )'k',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'y',      (char )'s', 
        (char )'a',      (char )'a',      (char )'b',      (char )'w', 
        (char )'x',      (char )'r',      (char )'z',      (char)123, 
        (char)124,      (char)125,      (char)126,      (char)127};
#line 171 "seqtk.c"
static void stk_printstr(kstring_t const   *s , unsigned int line_len ) 
{ 
  int i ;
  int rest ;

  {
#line 173
  if (line_len != 4294967295U) {
#line 173
    if (line_len != 0U) {
#line 174
      rest = (int )s->l;
#line 175
      i = 0;
#line 175
      while ((size_t___0 )i < s->l) {
#line 176
        putchar('\n');
#line 177
        if ((unsigned int )rest > line_len) {
#line 177
          fwrite((void const   * __restrict  )(s->s + i), (size_t___0 )1, (size_t___0 )line_len,
                 (FILE * __restrict  )stdout);
        } else {
#line 178
          fwrite((void const   * __restrict  )(s->s + i), (size_t___0 )1, (size_t___0 )rest,
                 (FILE * __restrict  )stdout);
        }
#line 175
        i = (int )((unsigned int )i + line_len);
#line 175
        rest = (int )((unsigned int )rest - line_len);
      }
#line 180
      putchar('\n');
    } else {
#line 182
      putchar('\n');
#line 183
      puts((char const   *)s->s);
    }
  } else {
#line 182
    putchar('\n');
#line 183
    puts((char const   *)s->s);
  }
#line 185
  return;
}
}
#line 187 "seqtk.c"
__inline static void stk_printseq_renamed(kseq_t const   *s , int line_len , char const   *prefix ,
                                          int64_t n ) 
{ 
  int tmp ;

  {
#line 189
  if (s->qual.l) {
#line 189
    tmp = '@';
  } else {
#line 189
    tmp = '>';
  }
#line 189
  putchar(tmp);
#line 190
  if (n >= 0LL) {
#line 191
    if (prefix) {
#line 191
      fputs((char const   * __restrict  )prefix, (FILE * __restrict  )stdout);
    }
#line 192
    printf((char const   * __restrict  )"%lld", n);
  } else {
#line 193
    fputs((char const   * __restrict  )s->name.s, (FILE * __restrict  )stdout);
  }
#line 194
  if (s->comment.l) {
#line 195
    putchar(' ');
#line 195
    fputs((char const   * __restrict  )s->comment.s, (FILE * __restrict  )stdout);
  }
#line 197
  stk_printstr((kstring_t const   *)(& s->seq), (unsigned int )line_len);
#line 198
  if (s->qual.l) {
#line 199
    putchar('+');
#line 200
    stk_printstr((kstring_t const   *)(& s->qual), (unsigned int )line_len);
  }
#line 202
  return;
}
}
#line 204 "seqtk.c"
__inline static void stk_printseq(kseq_t const   *s , int line_len ) 
{ 


  {
#line 206
  stk_printseq_renamed(s, line_len, (char const   *)0, (int64_t )-1);
#line 207
  return;
}
}
#line 233 "seqtk.c"
static void kr_srand0(krint64_t seed , krand_t *kr ) 
{ 


  {
#line 235
  kr->mt[0] = seed;
#line 236
  kr->mti = 1;
#line 236
  while (kr->mti < 312) {
#line 237
    kr->mt[kr->mti] = 6364136223846793005ULL * (kr->mt[kr->mti - 1] ^ (kr->mt[kr->mti - 1] >> 62)) + (unsigned long long )kr->mti;
#line 236
    (kr->mti) ++;
  }
#line 238
  return;
}
}
#line 240 "seqtk.c"
krand_t *kr_srand(krint64_t seed ) 
{ 
  krand_t *kr ;
  void *tmp ;

  {
#line 243
  tmp = malloc(sizeof(krand_t ));
#line 243
  kr = (krand_t *)tmp;
#line 244
  kr_srand0(seed, kr);
#line 245
  return (kr);
}
}
#line 251
krint64_t kr_rand(krand_t *kr ) ;
#line 251 "seqtk.c"
static krint64_t const   mag01[2]  = {      (krint64_t const   )0,      (krint64_t const   )0xB5026F5AA96619E9ULL};
#line 248 "seqtk.c"
krint64_t kr_rand(krand_t *kr ) 
{ 
  krint64_t x ;
  int i ;
  int tmp ;

  {
#line 252
  if (kr->mti >= 312) {
#line 254
    if (kr->mti == 313) {
#line 254
      kr_srand0(5489ULL, kr);
    }
#line 255
    i = 0;
#line 255
    while (i < 156) {
#line 256
      x = (kr->mt[i] & 0xFFFFFFFF80000000ULL) | (kr->mt[i + 1] & 0x7FFFFFFFULL);
#line 257
      kr->mt[i] = (kr->mt[i + 156] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
#line 255
      i ++;
    }
#line 259
    while (i < 311) {
#line 260
      x = (kr->mt[i] & 0xFFFFFFFF80000000ULL) | (kr->mt[i + 1] & 0x7FFFFFFFULL);
#line 261
      kr->mt[i] = (kr->mt[i + -156] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
#line 259
      i ++;
    }
#line 263
    x = (kr->mt[311] & 0xFFFFFFFF80000000ULL) | (kr->mt[0] & 0x7FFFFFFFULL);
#line 264
    kr->mt[311] = (kr->mt[155] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
#line 265
    kr->mti = 0;
  }
#line 267
  tmp = kr->mti;
#line 267
  (kr->mti) ++;
#line 267
  x = kr->mt[tmp];
#line 268
  x ^= (x >> 29) & 0x5555555555555555ULL;
#line 269
  x ^= (x << 17) & 0x71D67FFFEDA60000ULL;
#line 270
  x ^= (x << 37) & 0xFFF7EEE000000000ULL;
#line 271
  x ^= x >> 43;
#line 272
  return (x);
}
}
#line 279 "seqtk.c"
int stk_trimfq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  double param ;
  double q_int2real[128] ;
  int i ;
  int c ;
  int min_len ;
  int left ;
  int right ;
  int fixed_len ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int beg ;
  int tmp___4 ;
  int end ;
  double s ;
  double max ;
  int q ;
  int is ;
  int imax ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 283
  param = 0.05;
#line 284
  min_len = 30;
#line 284
  left = 0;
#line 284
  right = 0;
#line 284
  fixed_len = -1;
#line 285
  while (1) {
#line 285
    c = getopt(argc, (char **)argv, (char const   *)"l:q:b:e:L:");
#line 285
    if (! (c >= 0)) {
#line 285
      break;
    }
#line 286
    switch (c) {
    case 113: 
#line 287
    param = atof((char const   *)optarg);
#line 287
    break;
    case 108: 
#line 288
    min_len = atoi((char const   *)optarg);
#line 288
    break;
    case 98: 
#line 289
    left = atoi((char const   *)optarg);
#line 289
    break;
    case 101: 
#line 290
    right = atoi((char const   *)optarg);
#line 290
    break;
    case 76: 
#line 291
    fixed_len = atoi((char const   *)optarg);
#line 291
    break;
    }
  }
#line 294
  if (optind == argc) {
#line 295
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 296
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:   seqtk trimfq [options] <in.fq>\n\n");
#line 297
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options: -q FLOAT    error rate threshold (disabled by -b/-e) [%.2f]\n",
            param);
#line 298
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -l INT      maximally trim down to INT bp (disabled by -b/-e) [%d]\n",
            min_len);
#line 299
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -b INT      trim INT bp from left (non-zero to disable -q/-l) [0]\n");
#line 300
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -e INT      trim INT bp from right (non-zero to disable -q/-l) [0]\n");
#line 301
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -L INT      retain at most INT bp from the 5\'-end (non-zero to disable -q/-l) [0]\n");
#line 302
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -Q          force FASTQ output\n");
#line 303
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 304
    return (1);
  }
#line 306
  tmp___3 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 306
  if (tmp___3) {
#line 306
    tmp___0 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 306
    fp = tmp___0;
  } else {
#line 306
    tmp___1 = fileno((FILE *)stdin);
#line 306
    tmp___2 = gzdopen(tmp___1, (char const   *)"r");
#line 306
    fp = tmp___2;
  }
#line 307
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 308
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_trimfq");
#line 309
    return (1);
  }
#line 311
  seq = kseq_init(fp);
#line 312
  i = 0;
#line 312
  while (i < 128) {
#line 313
    q_int2real[i] = pow(10., (double )(- (i - 33)) / 10.);
#line 312
    i ++;
  }
#line 314
  while (1) {
#line 314
    tmp___6 = kseq_read(seq);
#line 314
    if (! (tmp___6 >= 0)) {
#line 314
      break;
    }
#line 317
    if (left) {
#line 317
      goto _L;
    } else
#line 317
    if (right) {
#line 317
      goto _L;
    } else
#line 317
    if (fixed_len > 0) {
      _L: /* CIL Label */ 
#line 318
      beg = left;
#line 318
      end = (int )(seq->seq.l - (size_t___0 )right);
#line 319
      if (beg >= end) {
#line 319
        end = 0;
#line 319
        beg = end;
      }
#line 320
      if (fixed_len > 0) {
#line 320
        if (end - beg > fixed_len) {
#line 320
          end = beg + fixed_len;
        }
      }
    } else
#line 321
    if (seq->qual.l > (size_t___0 )min_len) {
#line 322
      i = 0;
#line 322
      tmp___4 = 0;
#line 322
      beg = tmp___4;
#line 322
      end = (int )seq->qual.l;
#line 322
      max = 0.;
#line 322
      s = max;
#line 322
      while ((size_t___0 )i < seq->qual.l) {
#line 323
        q = (int )*(seq->qual.s + i);
#line 324
        if (q < 36) {
#line 324
          q = 36;
        }
#line 325
        if (q > 127) {
#line 325
          q = 127;
        }
#line 326
        s += param - q_int2real[q];
#line 327
        if (s > max) {
#line 327
          max = s;
#line 327
          beg = tmp___4;
#line 327
          end = i + 1;
        }
#line 328
        if (s < (double )0) {
#line 328
          s = (double )0;
#line 328
          tmp___4 = i + 1;
        }
#line 322
        i ++;
      }
#line 332
      if (max == 0.) {
#line 332
        beg = 0;
#line 332
        end = min_len;
      }
#line 334
      if (end - beg < min_len) {
#line 336
        i = 0;
#line 336
        is = 0;
#line 336
        while (i < min_len) {
#line 337
          is += (int )*(seq->qual.s + i) - 33;
#line 336
          i ++;
        }
#line 338
        imax = is;
#line 338
        beg = 0;
#line 338
        while ((size_t___0 )i < seq->qual.l) {
#line 339
          is += (int )*(seq->qual.s + i) - (int )*(seq->qual.s + (i - min_len));
#line 340
          if (imax < is) {
#line 340
            imax = is;
#line 340
            beg = (i - min_len) + 1;
          }
#line 338
          i ++;
        }
#line 342
        end = beg + min_len;
      }
    } else {
#line 344
      beg = 0;
#line 344
      end = (int )seq->seq.l;
    }
#line 345
    if (seq->is_fastq) {
#line 345
      tmp___5 = '@';
    } else {
#line 345
      tmp___5 = '>';
    }
#line 345
    putchar(tmp___5);
#line 345
    fputs((char const   * __restrict  )seq->name.s, (FILE * __restrict  )stdout);
#line 346
    if (seq->comment.l) {
#line 347
      putchar(' ');
#line 347
      puts((char const   *)seq->comment.s);
    } else {
#line 348
      putchar('\n');
    }
#line 349
    fwrite((void const   * __restrict  )(seq->seq.s + beg), (size_t___0 )1, (size_t___0 )(end - beg),
           (FILE * __restrict  )stdout);
#line 349
    putchar('\n');
#line 350
    if (seq->is_fastq) {
#line 351
      puts((char const   *)"+");
#line 352
      fwrite((void const   * __restrict  )(seq->qual.s + beg), (size_t___0 )1, (size_t___0 )(end - beg),
             (FILE * __restrict  )stdout);
#line 352
      putchar('\n');
    }
  }
#line 355
  kseq_destroy(seq);
#line 356
  gzclose(fp);
#line 357
  return (0);
}
}
#line 361 "seqtk.c"
int stk_comp(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int upper_only ;
  reghash_t *h ;
  reglist_t dummy ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int i ;
  int k ;
  reglist_t *p ;
  khint_t k___0 ;
  khint_t tmp___7 ;
  int beg ;
  int end ;
  int la ;
  int lb ;
  int lc ;
  int na ;
  int nb ;
  int nc ;
  int cnt[11] ;
  int is_CpG ;
  int a ;
  int b ;
  int c___0 ;
  int tmp___8 ;

  {
#line 365
  upper_only = 0;
#line 366
  h = (reghash_t *)0;
#line 369
  while (1) {
#line 369
    c = getopt(argc, (char **)argv, (char const   *)"ur:");
#line 369
    if (! (c >= 0)) {
#line 369
      break;
    }
#line 370
    switch (c) {
    case 117: 
#line 371
    upper_only = 1;
#line 371
    break;
    case 114: 
#line 372
    h = stk_reg_read((char const   *)optarg);
#line 372
    break;
    }
  }
#line 375
  if (argc == optind) {
#line 375
    tmp = fileno((FILE *)stdin);
#line 375
    tmp___0 = isatty(tmp);
#line 375
    if (tmp___0) {
#line 376
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:  seqtk comp [-u] [-r in.bed] <in.fa>\n\n");
#line 377
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Output format: chr, length, #A, #C, #G, #T, #2, #3, #4, #CpG, #tv, #ts, #CpG-ts\n");
#line 378
      return (1);
    }
  }
#line 380
  if (optind < argc) {
#line 380
    tmp___5 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 380
    if (tmp___5) {
#line 380
      tmp___2 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 380
      fp = tmp___2;
    } else {
#line 380
      tmp___3 = fileno((FILE *)stdin);
#line 380
      tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 380
      fp = tmp___4;
    }
  } else {
#line 380
    tmp___3 = fileno((FILE *)stdin);
#line 380
    tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 380
    fp = tmp___4;
  }
#line 381
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 382
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_comp");
#line 383
    return (1);
  }
#line 385
  seq = kseq_init(fp);
#line 386
  dummy.m = 1;
#line 386
  dummy.n = dummy.m;
#line 386
  tmp___6 = calloc((size_t___0 )1, (size_t___0 )8);
#line 386
  dummy.a = (uint64_t *)tmp___6;
#line 387
  while (1) {
#line 387
    l = kseq_read(seq);
#line 387
    if (! (l >= 0)) {
#line 387
      break;
    }
#line 389
    p = (reglist_t *)0;
#line 390
    if (h) {
#line 391
      tmp___7 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
#line 391
      k___0 = tmp___7;
#line 392
      if (k___0 != h->n_buckets) {
#line 392
        p = h->vals + k___0;
      }
    } else {
#line 394
      p = & dummy;
#line 395
      *(dummy.a + 0) = (uint64_t )l;
    }
#line 397
    k = 0;
#line 397
    while (1) {
#line 397
      if (p) {
#line 397
        if (! (k < p->n)) {
#line 397
          break;
        }
      } else {
#line 397
        break;
      }
#line 398
      beg = (int )(*(p->a + k) >> 32);
#line 398
      end = (int )(*(p->a + k) & 4294967295ULL);
#line 400
      if (beg > 0) {
#line 400
        la = (int )*(seq->seq.s + (beg - 1));
#line 400
        lb = (int )seq_nt16_table[la];
#line 400
        lc = bitcnt_table[lb];
      } else {
#line 401
        la = 'a';
#line 401
        lb = -1;
#line 401
        lc = 0;
      }
#line 402
      na = (int )*(seq->seq.s + beg);
#line 402
      nb = (int )seq_nt16_table[na];
#line 402
      nc = bitcnt_table[nb];
#line 403
      memset((void *)(cnt), 0, 11UL * sizeof(int ));
#line 404
      i = beg;
#line 404
      while (i < end) {
#line 405
        is_CpG = 0;
#line 406
        a = na;
#line 406
        b = nb;
#line 406
        c___0 = nc;
#line 407
        na = (int )*(seq->seq.s + (i + 1));
#line 407
        nb = (int )seq_nt16_table[na];
#line 407
        nc = bitcnt_table[nb];
#line 408
        if (b == 2) {
#line 408
          goto _L___0;
        } else
#line 408
        if (b == 10) {
          _L___0: /* CIL Label */ 
#line 409
          if (nb == 4) {
#line 409
            is_CpG = 1;
          } else
#line 409
          if (nb == 5) {
#line 409
            is_CpG = 1;
          }
        } else
#line 410
        if (b == 4) {
#line 410
          goto _L;
        } else
#line 410
        if (b == 5) {
          _L: /* CIL Label */ 
#line 411
          if (lb == 2) {
#line 411
            is_CpG = 1;
          } else
#line 411
          if (lb == 10) {
#line 411
            is_CpG = 1;
          }
        }
#line 413
        if (upper_only == 0) {
#line 413
          goto _L___1;
        } else {
#line 413
          tmp___8 = isupper(a);
#line 413
          if (tmp___8) {
            _L___1: /* CIL Label */ 
#line 414
            if (c___0 > 1) {
#line 414
              (cnt[c___0 + 2]) ++;
            }
#line 415
            if (c___0 == 1) {
#line 415
              (cnt[seq_nt16to4_table[b]]) ++;
            }
#line 416
            if (b == 10) {
#line 416
              (cnt[9]) ++;
            } else
#line 416
            if (b == 5) {
#line 416
              (cnt[9]) ++;
            } else
#line 417
            if (c___0 == 2) {
#line 418
              (cnt[8]) ++;
            }
#line 420
            if (is_CpG) {
#line 421
              (cnt[7]) ++;
#line 422
              if (b == 10) {
#line 422
                (cnt[10]) ++;
              } else
#line 422
              if (b == 5) {
#line 422
                (cnt[10]) ++;
              }
            }
          }
        }
#line 425
        la = a;
#line 425
        lb = b;
#line 425
        lc = c___0;
#line 404
        i ++;
      }
#line 427
      if (h) {
#line 427
        printf((char const   * __restrict  )"%s\t%d\t%d", seq->name.s, beg, end);
      } else {
#line 428
        printf((char const   * __restrict  )"%s\t%d", seq->name.s, l);
      }
#line 429
      i = 0;
#line 429
      while (i < 11) {
#line 429
        printf((char const   * __restrict  )"\t%d", cnt[i]);
#line 429
        i ++;
      }
#line 430
      putchar('\n');
#line 397
      k ++;
    }
#line 432
    fflush((FILE *)stdout);
  }
#line 434
  free((void *)dummy.a);
#line 435
  kseq_destroy(seq);
#line 436
  gzclose(fp);
#line 437
  return (0);
}
}
#line 440 "seqtk.c"
int stk_randbase(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int i ;
  int c ;
  int b ;
  int a ;
  int j ;
  int k ;
  int m ;
  double tmp___4 ;
  int tmp___6 ;

  {
#line 445
  if (argc == 1) {
#line 446
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk randbase <in.fa>\n");
#line 447
    return (1);
  }
#line 449
  tmp___3 = strcmp((char const   *)*(argv + 1), (char const   *)"-");
#line 449
  if (tmp___3 == 0) {
#line 449
    tmp___0 = fileno((FILE *)stdin);
#line 449
    tmp___1 = gzdopen(tmp___0, (char const   *)"r");
#line 449
    fp = tmp___1;
  } else {
#line 449
    tmp___2 = gzopen((char const   *)*(argv + 1), (char const   *)"r");
#line 449
    fp = tmp___2;
  }
#line 450
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 451
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_randbase");
#line 452
    return (1);
  }
#line 454
  seq = kseq_init(fp);
#line 455
  while (1) {
#line 455
    l = kseq_read(seq);
#line 455
    if (! (l >= 0)) {
#line 455
      break;
    }
#line 457
    printf((char const   * __restrict  )">%s", seq->name.s);
#line 458
    i = 0;
#line 458
    while (i < l) {
#line 460
      b = (int )*(seq->seq.s + i);
#line 461
      c = (int )seq_nt16_table[b];
#line 462
      a = bitcnt_table[c];
#line 463
      if (a == 2) {
#line 464
        tmp___4 = drand48();
#line 464
        m = tmp___4 < 0.5;
#line 465
        k = 0;
#line 465
        j = k;
#line 465
        while (j < 4) {
#line 466
          if (((1 << j) & c) == 0) {
#line 466
            goto __Cont;
          }
#line 467
          if (k == m) {
#line 467
            break;
          }
#line 468
          k ++;
          __Cont: /* CIL Label */ 
#line 465
          j ++;
        }
#line 470
        tmp___6 = islower(b);
#line 470
        if (tmp___6) {
#line 470
          *(seq->seq.s + i) = *("acgt" + j);
        } else {
#line 470
          *(seq->seq.s + i) = *("ACGT" + j);
        }
      }
#line 472
      if (i % 60 == 0) {
#line 472
        putchar('\n');
      }
#line 473
      putchar((int )*(seq->seq.s + i));
#line 458
      i ++;
    }
#line 475
    putchar('\n');
  }
#line 477
  kseq_destroy(seq);
#line 478
  gzclose(fp);
#line 479
  return (0);
}
}
#line 482 "seqtk.c"
int stk_hety(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int win_size ;
  int n_start ;
  int win_step ;
  int is_lower_mask ;
  char *buf ;
  uint32_t cnt[3] ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int x ;
  int i ;
  int y ;
  int z ;
  int next ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 486
  win_size = 50000;
#line 486
  n_start = 5;
#line 486
  is_lower_mask = 0;
#line 489
  if (argc == 1) {
#line 490
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 491
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:   seqtk hety [options] <in.fa>\n\n");
#line 492
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options: -w INT   window size [%d]\n",
            win_size);
#line 493
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -t INT   # start positions in a window [%d]\n",
            n_start);
#line 494
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -m       treat lowercases as masked\n");
#line 495
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 496
    return (1);
  }
#line 498
  while (1) {
#line 498
    c = getopt(argc, (char **)argv, (char const   *)"w:t:m");
#line 498
    if (! (c >= 0)) {
#line 498
      break;
    }
#line 499
    switch (c) {
    case 119: 
#line 500
    win_size = atoi((char const   *)optarg);
#line 500
    break;
    case 116: 
#line 501
    n_start = atoi((char const   *)optarg);
#line 501
    break;
    case 109: 
#line 502
    is_lower_mask = 1;
#line 502
    break;
    }
  }
#line 505
  tmp___3 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 505
  if (tmp___3 == 0) {
#line 505
    tmp___0 = fileno((FILE *)stdin);
#line 505
    tmp___1 = gzdopen(tmp___0, (char const   *)"r");
#line 505
    fp = tmp___1;
  } else {
#line 505
    tmp___2 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 505
    fp = tmp___2;
  }
#line 506
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 507
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_hety");
#line 508
    return (1);
  }
#line 510
  seq = kseq_init(fp);
#line 511
  win_step = win_size / n_start;
#line 512
  tmp___4 = calloc((size_t___0 )win_size, (size_t___0 )1);
#line 512
  buf = (char *)tmp___4;
#line 513
  while (1) {
#line 513
    l = kseq_read(seq);
#line 513
    if (! (l >= 0)) {
#line 513
      break;
    }
#line 514
    next = 0;
#line 515
    cnt[2] = (uint32_t )0;
#line 515
    cnt[1] = cnt[2];
#line 515
    cnt[0] = cnt[1];
#line 516
    i = 0;
#line 516
    while (i <= l) {
#line 517
      if (i >= win_size) {
#line 517
        if (i % win_step == 0) {
#line 517
          goto _L;
        } else {
#line 517
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 517
      if (i == l) {
        _L: /* CIL Label */ 
#line 518
        if (i == l) {
#line 518
          if (l >= win_size) {
#line 519
            y = l - win_size;
#line 519
            while (y < next) {
#line 519
              (cnt[(int )*(buf + y % win_size)]) --;
#line 519
              y ++;
            }
          }
        }
#line 521
        if (cnt[1] + cnt[2] > 0U) {
#line 522
          printf((char const   * __restrict  )"%s\t%d\t%d\t%.2lf\t%d\t%d\n", seq->name.s,
                 next, i, ((double )cnt[2] / (double )(cnt[1] + cnt[2])) * (double )win_size,
                 cnt[1] + cnt[2], cnt[2]);
        }
#line 524
        next = i;
      }
#line 526
      if (i < l) {
#line 527
        y = i % win_size;
#line 528
        c = (int )*(seq->seq.s + i);
#line 529
        if (is_lower_mask) {
#line 529
          tmp___5 = islower(c);
#line 529
          if (tmp___5) {
#line 529
            c = 'N';
          }
        }
#line 530
        c = (int )seq_nt16_table[c];
#line 531
        x = bitcnt_table[c];
#line 532
        if (i >= win_size) {
#line 532
          (cnt[(int )*(buf + y)]) --;
        }
#line 533
        if (x > 2) {
#line 533
          z = 0;
        } else {
#line 533
          if (x == 2) {
#line 533
            tmp___6 = 2;
          } else {
#line 533
            tmp___6 = 1;
          }
#line 533
          z = tmp___6;
        }
#line 533
        *(buf + y) = (char )z;
#line 534
        (cnt[z]) ++;
      }
#line 516
      i ++;
    }
  }
#line 538
  free((void *)buf);
#line 539
  kseq_destroy(seq);
#line 540
  gzclose(fp);
#line 541
  return (0);
}
}
#line 546 "seqtk.c"
int stk_subseq(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int i ;
  int j ;
  int c ;
  int is_tab ;
  int line ;
  khint_t k ;
  gzFile tmp___1 ;
  int tmp___2 ;
  gzFile tmp___3 ;
  int tmp___4 ;
  reglist_t *p ;
  int beg ;
  int end ;
  int tmp___5 ;

  {
#line 548
  tmp = kh_init_reg();
#line 548
  h = tmp;
#line 551
  is_tab = 0;
#line 551
  line = 0;
#line 553
  while (1) {
#line 553
    c = getopt(argc, (char **)argv, (char const   *)"tl:");
#line 553
    if (! (c >= 0)) {
#line 553
      break;
    }
#line 554
    switch (c) {
    case 116: 
#line 555
    is_tab = 1;
#line 555
    break;
    case 108: 
#line 556
    line = atoi((char const   *)optarg);
#line 556
    break;
    }
  }
#line 559
  if (optind + 2 > argc) {
#line 560
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 561
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:   seqtk subseq [options] <in.fa> <in.bed>|<name.list>\n\n");
#line 562
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options: -t       TAB delimited output\n");
#line 563
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -l INT   sequence line length [%d]\n\n",
            line);
#line 564
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Note: Use \'samtools faidx\' if only a few regions are intended.\n\n");
#line 565
    return (1);
  }
#line 567
  h = stk_reg_read((char const   *)*(argv + (optind + 1)));
#line 568
  if ((unsigned long )h == (unsigned long )((kh_reg_t *)0)) {
#line 569
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to read the list of regions in file \'%s\'\n",
            "stk_subseq", *(argv + (optind + 1)));
#line 570
    return (1);
  }
#line 573
  tmp___4 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 573
  if (tmp___4) {
#line 573
    tmp___1 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 573
    fp = tmp___1;
  } else {
#line 573
    tmp___2 = fileno((FILE *)stdin);
#line 573
    tmp___3 = gzdopen(tmp___2, (char const   *)"r");
#line 573
    fp = tmp___3;
  }
#line 574
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 575
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream\n",
            "stk_subseq");
#line 576
    return (1);
  }
#line 578
  seq = kseq_init(fp);
#line 579
  while (1) {
#line 579
    l = kseq_read(seq);
#line 579
    if (! (l >= 0)) {
#line 579
      break;
    }
#line 581
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
#line 582
    if (k == h->n_buckets) {
#line 582
      continue;
    }
#line 583
    p = h->vals + k;
#line 584
    i = 0;
#line 584
    while (i < p->n) {
#line 585
      beg = (int )(*(p->a + i) >> 32);
#line 585
      end = (int )*(p->a + i);
#line 586
      if ((size_t___0 )beg >= seq->seq.l) {
#line 587
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[subseq] %s: %d >= %ld\n",
                seq->name.s, beg, seq->seq.l);
#line 588
        goto __Cont;
      }
#line 590
      if ((size_t___0 )end > seq->seq.l) {
#line 590
        end = (int )seq->seq.l;
      }
#line 591
      if (is_tab == 0) {
#line 592
        if (seq->qual.l == seq->seq.l) {
#line 592
          tmp___5 = '@';
        } else {
#line 592
          tmp___5 = '>';
        }
#line 592
        printf((char const   * __restrict  )"%c%s", tmp___5, seq->name.s);
#line 593
        if (beg > 0) {
#line 593
          goto _L;
        } else
#line 593
        if ((int )*(p->a + i) != 2147483647) {
          _L: /* CIL Label */ 
#line 594
          if (end == 2147483647) {
#line 595
            if (beg) {
#line 595
              printf((char const   * __restrict  )":%d", beg + 1);
            }
          } else {
#line 596
            printf((char const   * __restrict  )":%d-%d", beg + 1, end);
          }
        }
#line 598
        if (seq->comment.l) {
#line 598
          printf((char const   * __restrict  )" %s", seq->comment.s);
        }
      } else {
#line 599
        printf((char const   * __restrict  )"%s\t%d\t", seq->name.s, beg + 1);
      }
#line 600
      if ((size_t___0 )end > seq->seq.l) {
#line 600
        end = (int )seq->seq.l;
      }
#line 601
      j = 0;
#line 601
      while (j < end - beg) {
#line 602
        if (is_tab == 0) {
#line 602
          if (j == 0) {
#line 602
            putchar('\n');
          } else
#line 602
          if (line > 0) {
#line 602
            if (j % line == 0) {
#line 602
              putchar('\n');
            }
          }
        }
#line 603
        putchar((int )*(seq->seq.s + (j + beg)));
#line 601
        j ++;
      }
#line 605
      putchar('\n');
#line 606
      if (seq->qual.l != seq->seq.l) {
#line 606
        goto __Cont;
      } else
#line 606
      if (is_tab) {
#line 606
        goto __Cont;
      }
#line 607
      printf((char const   * __restrict  )"+");
#line 608
      j = 0;
#line 608
      while (j < end - beg) {
#line 609
        if (j == 0) {
#line 609
          putchar('\n');
        } else
#line 609
        if (line > 0) {
#line 609
          if (j % line == 0) {
#line 609
            putchar('\n');
          }
        }
#line 610
        putchar((int )*(seq->qual.s + (j + beg)));
#line 608
        j ++;
      }
#line 612
      putchar('\n');
      __Cont: /* CIL Label */ 
#line 584
      i ++;
    }
  }
#line 616
  kseq_destroy(seq);
#line 617
  gzclose(fp);
#line 618
  stk_reg_destroy(h);
#line 619
  return (0);
}
}
#line 623 "seqtk.c"
int stk_mergefa(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  int c ;
  int is_intersect ;
  int is_haploid ;
  int qual ;
  int is_mask ;
  int is_randhet ;
  uint64_t cnt[5] ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c___0[2] ;
  int b[2] ;
  int is_upper ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;

  {
#line 627
  is_intersect = 0;
#line 627
  is_haploid = 0;
#line 627
  qual = 0;
#line 627
  is_mask = 0;
#line 627
  is_randhet = 0;
#line 629
  while (1) {
#line 629
    c = getopt(argc, (char **)argv, (char const   *)"himrq:");
#line 629
    if (! (c >= 0)) {
#line 629
      break;
    }
#line 630
    switch (c) {
    case 105: 
#line 631
    is_intersect = 1;
#line 631
    break;
    case 104: 
#line 632
    is_haploid = 1;
#line 632
    break;
    case 109: 
#line 633
    is_mask = 1;
#line 633
    break;
    case 114: 
#line 634
    is_randhet = 1;
#line 634
    break;
    case 113: 
#line 635
    qual = atoi((char const   *)optarg);
#line 635
    break;
    }
  }
#line 638
  if (is_mask) {
#line 638
    if (is_intersect) {
#line 639
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s] `-i\' and `-h\' cannot be applied at the same time.\n",
              "stk_mergefa");
#line 640
      return (1);
    }
  }
#line 642
  if (optind + 2 > argc) {
#line 643
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nUsage: seqtk mergefa [options] <in1.fa> <in2.fa>\n\n");
#line 644
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options: -q INT   quality threshold [0]\n");
#line 645
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -i       take intersection\n");
#line 646
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -m       convert to lowercase when one of the input base is N\n");
#line 647
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -r       pick a random allele from het\n");
#line 648
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -h       suppress hets in the input\n\n");
#line 649
    return (1);
  }
#line 651
  i = 0;
#line 651
  while (i < 2) {
#line 652
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), (char const   *)"-");
#line 652
    if (tmp___3) {
#line 652
      tmp___0 = gzopen((char const   *)*(argv + (optind + i)), (char const   *)"r");
#line 652
      fp[i] = tmp___0;
    } else {
#line 652
      tmp___1 = fileno((FILE *)stdin);
#line 652
      tmp___2 = gzdopen(tmp___1, (char const   *)"r");
#line 652
      fp[i] = tmp___2;
    }
#line 653
    seq[i] = kseq_init(fp[i]);
#line 651
    i ++;
  }
#line 655
  if ((unsigned long )fp[0] == (unsigned long )((gzFile )0)) {
#line 656
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_mergefa");
#line 657
    return (1);
  } else
#line 655
  if ((unsigned long )fp[1] == (unsigned long )((gzFile )0)) {
#line 656
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_mergefa");
#line 657
    return (1);
  }
#line 659
  cnt[4] = (uint64_t )0;
#line 659
  cnt[3] = cnt[4];
#line 659
  cnt[2] = cnt[3];
#line 659
  cnt[1] = cnt[2];
#line 659
  cnt[0] = cnt[1];
#line 660
  srand48(11L);
#line 661
  while (1) {
#line 661
    tmp___21 = kseq_read(seq[0]);
#line 661
    if (! (tmp___21 >= 0)) {
#line 661
      break;
    }
#line 663
    kseq_read(seq[1]);
#line 664
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
#line 664
    if (tmp___4) {
#line 665
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s] Different sequence names: %s != %s\n",
              "stk_mergefa", (seq[0])->name.s, (seq[1])->name.s);
    }
#line 666
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
#line 667
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s] Unequal sequence length: %ld != %ld\n",
              "stk_mergefa", (seq[0])->seq.l, (seq[1])->seq.l);
    }
#line 668
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
#line 668
      min_l = (int )(seq[0])->seq.l;
    } else {
#line 668
      min_l = (int )(seq[1])->seq.l;
    }
#line 669
    printf((char const   * __restrict  )">%s", (seq[0])->name.s);
#line 670
    l = 0;
#line 670
    while (l < min_l) {
#line 671
      c___0[0] = (int )*((seq[0])->seq.s + l);
#line 671
      c___0[1] = (int )*((seq[1])->seq.s + l);
#line 672
      if ((seq[0])->qual.l) {
#line 672
        if ((int )*((seq[0])->qual.s + l) - 33 < qual) {
#line 672
          c___0[0] = tolower(c___0[0]);
        }
      }
#line 673
      if ((seq[1])->qual.l) {
#line 673
        if ((int )*((seq[1])->qual.s + l) - 33 < qual) {
#line 673
          c___0[1] = tolower(c___0[1]);
        }
      }
#line 674
      if (is_intersect) {
#line 674
        tmp___7 = isupper(c___0[0]);
#line 674
        if (tmp___7) {
#line 674
          is_upper = 1;
        } else {
#line 674
          tmp___8 = isupper(c___0[1]);
#line 674
          if (tmp___8) {
#line 674
            is_upper = 1;
          } else {
#line 674
            is_upper = 0;
          }
        }
      } else
#line 675
      if (is_mask) {
#line 675
        tmp___11 = isupper(c___0[0]);
#line 675
        if (tmp___11) {
#line 675
          is_upper = 1;
        } else {
#line 675
          tmp___12 = isupper(c___0[1]);
#line 675
          if (tmp___12) {
#line 675
            is_upper = 1;
          } else {
#line 675
            is_upper = 0;
          }
        }
      } else {
#line 676
        tmp___15 = isupper(c___0[0]);
#line 676
        if (tmp___15) {
#line 676
          tmp___16 = isupper(c___0[1]);
#line 676
          if (tmp___16) {
#line 676
            is_upper = 1;
          } else {
#line 676
            is_upper = 0;
          }
        } else {
#line 676
          is_upper = 0;
        }
      }
#line 677
      c___0[0] = (int )seq_nt16_table[c___0[0]];
#line 677
      c___0[1] = (int )seq_nt16_table[c___0[1]];
#line 678
      if (c___0[0] == 0) {
#line 678
        c___0[0] = 15;
      }
#line 679
      if (c___0[1] == 0) {
#line 679
        c___0[1] = 15;
      }
#line 680
      b[0] = bitcnt_table[c___0[0]];
#line 681
      b[1] = bitcnt_table[c___0[1]];
#line 682
      if (is_upper) {
#line 683
        if (b[0] == 1) {
#line 683
          if (b[1] == 1) {
#line 684
            if (c___0[0] == c___0[1]) {
#line 684
              (cnt[0]) ++;
            } else {
#line 685
              (cnt[1]) ++;
            }
          } else {
#line 683
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 686
        if (b[0] == 1) {
#line 686
          if (b[1] == 2) {
#line 686
            (cnt[2]) ++;
          } else {
#line 686
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 687
        if (b[0] == 2) {
#line 687
          if (b[1] == 1) {
#line 687
            (cnt[3]) ++;
          } else {
#line 687
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 688
        if (b[0] == 2) {
#line 688
          if (b[1] == 2) {
#line 688
            (cnt[4]) ++;
          }
        }
      }
#line 690
      if (is_haploid) {
#line 690
        if (b[0] > 1) {
#line 690
          is_upper = 0;
        } else
#line 690
        if (b[1] > 1) {
#line 690
          is_upper = 0;
        }
      }
#line 691
      if (is_intersect) {
#line 692
        c___0[0] &= c___0[1];
#line 693
        if (c___0[0] == 0) {
#line 693
          is_upper = 0;
        }
      } else
#line 694
      if (is_mask) {
#line 695
        if (c___0[0] == 15) {
#line 695
          is_upper = 0;
        } else
#line 695
        if (c___0[1] == 15) {
#line 695
          is_upper = 0;
        }
#line 696
        c___0[0] &= c___0[1];
#line 697
        if (c___0[0] == 0) {
#line 697
          is_upper = 0;
        }
      } else
#line 698
      if (is_randhet) {
#line 699
        if (b[0] == 1) {
#line 699
          if (b[1] == 1) {
#line 700
            c___0[0] |= c___0[1];
          } else {
#line 699
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 701
        if (b[0] == 1) {
#line 701
          if (b[1] == 2) {
#line 701
            goto _L___3;
          } else {
#line 701
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 701
        if (b[0] == 2) {
#line 701
          if (b[1] == 1) {
            _L___3: /* CIL Label */ 
#line 701
            if (c___0[0] & c___0[1]) {
#line 702
              tmp___18 = lrand48();
#line 702
              if (tmp___18 & 1L) {
#line 702
                c___0[0] &= c___0[1];
              } else {
#line 702
                c___0[0] |= c___0[1];
              }
            } else {
#line 701
              goto _L___4;
            }
          } else {
#line 701
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 703
        if (b[0] == 2) {
#line 703
          if (b[1] == 2) {
#line 703
            if (c___0[0] == c___0[1]) {
#line 704
              tmp___20 = lrand48();
#line 704
              if (tmp___20 & 1L) {
#line 705
                tmp___19 = lrand48();
#line 705
                if (tmp___19 & 1L) {
#line 706
                  i = 8;
#line 706
                  while (i >= 1) {
#line 707
                    if (c___0[0] & i) {
#line 707
                      c___0[0] &= i;
                    }
#line 706
                    i >>= 1;
                  }
                } else {
#line 709
                  i = 1;
#line 709
                  while (i <= 8) {
#line 710
                    if (c___0[0] & i) {
#line 710
                      c___0[0] &= i;
                    }
#line 709
                    i <<= 1;
                  }
                }
              }
            } else {
#line 713
              is_upper = 0;
            }
          } else {
#line 713
            is_upper = 0;
          }
        } else {
#line 713
          is_upper = 0;
        }
      } else {
#line 714
        c___0[0] |= c___0[1];
      }
#line 715
      c___0[0] = (int )*(seq_nt16_rev_table + c___0[0]);
#line 716
      if (! is_upper) {
#line 716
        c___0[0] = tolower(c___0[0]);
      }
#line 717
      if (l % 60 == 0) {
#line 717
        putchar('\n');
      }
#line 718
      putchar(c___0[0]);
#line 670
      l ++;
    }
#line 720
    putchar('\n');
  }
#line 722
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s] (same,diff,hom-het,het-hom,het-het)=(%ld,%ld,%ld,%ld,%ld)\n",
          "stk_mergefa", (long )cnt[0], (long )cnt[1], (long )cnt[2], (long )cnt[3],
          (long )cnt[4]);
#line 723
  return (0);
}
}
#line 726 "seqtk.c"
int stk_famask(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  int c ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c___0[2] ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 731
  while (1) {
#line 731
    c = getopt(argc, (char **)argv, (char const   *)"");
#line 731
    if (! (c >= 0)) {
#line 731
      break;
    }
  }
#line 732
  if (argc - optind < 2) {
#line 733
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk famask <src.fa> <mask.fa>\n");
#line 734
    return (1);
  }
#line 736
  i = 0;
#line 736
  while (i < 2) {
#line 737
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), (char const   *)"-");
#line 737
    if (tmp___3) {
#line 737
      tmp___0 = gzopen((char const   *)*(argv + (optind + i)), (char const   *)"r");
#line 737
      fp[i] = tmp___0;
    } else {
#line 737
      tmp___1 = fileno((FILE *)stdin);
#line 737
      tmp___2 = gzdopen(tmp___1, (char const   *)"r");
#line 737
      fp[i] = tmp___2;
    }
#line 738
    seq[i] = kseq_init(fp[i]);
#line 736
    i ++;
  }
#line 740
  if ((unsigned long )fp[0] == (unsigned long )((gzFile )0)) {
#line 741
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_famask");
#line 742
    return (1);
  } else
#line 740
  if ((unsigned long )fp[1] == (unsigned long )((gzFile )0)) {
#line 741
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_famask");
#line 742
    return (1);
  }
#line 744
  while (1) {
#line 744
    tmp___5 = kseq_read(seq[0]);
#line 744
    if (! (tmp___5 >= 0)) {
#line 744
      break;
    }
#line 746
    kseq_read(seq[1]);
#line 747
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
#line 747
    if (tmp___4) {
#line 748
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s] Different sequence names: %s != %s\n",
              "stk_famask", (seq[0])->name.s, (seq[1])->name.s);
    }
#line 749
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
#line 750
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s] Unequal sequence length: %ld != %ld\n",
              "stk_famask", (seq[0])->seq.l, (seq[1])->seq.l);
    }
#line 751
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
#line 751
      min_l = (int )(seq[0])->seq.l;
    } else {
#line 751
      min_l = (int )(seq[1])->seq.l;
    }
#line 752
    printf((char const   * __restrict  )">%s", (seq[0])->name.s);
#line 753
    l = 0;
#line 753
    while (l < min_l) {
#line 754
      c___0[0] = (int )*((seq[0])->seq.s + l);
#line 754
      c___0[1] = (int )*((seq[1])->seq.s + l);
#line 755
      if (c___0[1] == 120) {
#line 755
        c___0[0] = tolower(c___0[0]);
      } else
#line 756
      if (c___0[1] != 88) {
#line 756
        c___0[0] = c___0[1];
      }
#line 757
      if (l % 60 == 0) {
#line 757
        putchar('\n');
      }
#line 758
      putchar(c___0[0]);
#line 753
      l ++;
    }
#line 760
    putchar('\n');
  }
#line 762
  return (0);
}
}
#line 765 "seqtk.c"
int stk_mutfa(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  kstream_t *ks ;
  int l ;
  int i ;
  int dret ;
  kstring_t *str ;
  khint_t k ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  char *s ;
  char *tmp___6 ;
  int beg ;
  int ret ;
  reglist_t *p ;
  long tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  gzFile tmp___14 ;
  int tmp___15 ;
  gzFile tmp___16 ;
  int tmp___17 ;
  reglist_t *p___0 ;
  int beg___0 ;

  {
#line 767
  tmp = kh_init_reg();
#line 767
  h = tmp;
#line 774
  if (argc < 3) {
#line 775
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk mutfa <in.fa> <in.snp>\n\n");
#line 776
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Note: <in.snp> contains at least four columns per line which are:\n");
#line 777
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      \'chr  1-based-pos  any  base-changed-to\'.\n");
#line 778
    return (1);
  }
#line 781
  tmp___0 = calloc((size_t___0 )1, sizeof(kstring_t ));
#line 781
  str = (kstring_t *)tmp___0;
#line 782
  tmp___5 = strcmp((char const   *)*(argv + 2), (char const   *)"-");
#line 782
  if (tmp___5) {
#line 782
    tmp___2 = gzopen((char const   *)*(argv + 2), (char const   *)"r");
#line 782
    fp = tmp___2;
  } else {
#line 782
    tmp___3 = fileno((FILE *)stdin);
#line 782
    tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 782
    fp = tmp___4;
  }
#line 783
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 784
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_mutfa");
#line 785
    return (1);
  }
#line 787
  ks = ks_init(fp);
#line 788
  while (1) {
#line 788
    tmp___12 = ks_getuntil(ks, 0, str, & dret);
#line 788
    if (! (tmp___12 >= 0)) {
#line 788
      break;
    }
#line 789
    tmp___6 = strdup((char const   *)str->s);
#line 789
    s = tmp___6;
#line 790
    beg = 0;
#line 792
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )s);
#line 793
    if (k == h->n_buckets) {
#line 794
      k = kh_put_reg(h, (kh_cstr_t )s, & ret);
#line 795
      memset((void *)(h->vals + k), 0, sizeof(reglist_t ));
    }
#line 797
    p = h->vals + k;
#line 798
    tmp___8 = ks_getuntil(ks, 0, str, & dret);
#line 798
    if (tmp___8 > 0) {
#line 798
      tmp___7 = atol((char const   *)str->s);
#line 798
      beg = (int )(tmp___7 - 1L);
    }
#line 799
    ks_getuntil(ks, 0, str, & dret);
#line 800
    ks_getuntil(ks, 0, str, & dret);
#line 802
    if (dret != 10) {
#line 802
      while (1) {
#line 802
        dret = ks_getc(ks);
#line 802
        if (dret > 0) {
#line 802
          if (! (dret != 10)) {
#line 802
            break;
          }
        } else {
#line 802
          break;
        }
      }
    }
#line 803
    tmp___11 = isalpha((int )*(str->s + 0));
#line 803
    if (tmp___11) {
#line 803
      if (str->l == 1UL) {
#line 804
        if (p->n == p->m) {
#line 805
          if (p->m) {
#line 805
            p->m <<= 1;
          } else {
#line 805
            p->m = 4;
          }
#line 806
          tmp___9 = realloc((void *)p->a, (size_t___0 )(p->m * 8));
#line 806
          p->a = (uint64_t *)tmp___9;
        }
#line 808
        tmp___10 = p->n;
#line 808
        (p->n) ++;
#line 808
        *(p->a + tmp___10) = ((uint64_t )beg << 32) | (unsigned long long )*(str->s + 0);
      }
    }
  }
#line 811
  ks_destroy(ks);
#line 812
  gzclose(fp);
#line 813
  free((void *)str->s);
#line 813
  free((void *)str);
#line 815
  tmp___17 = strcmp((char const   *)*(argv + 1), (char const   *)"-");
#line 815
  if (tmp___17) {
#line 815
    tmp___14 = gzopen((char const   *)*(argv + 1), (char const   *)"r");
#line 815
    fp = tmp___14;
  } else {
#line 815
    tmp___15 = fileno((FILE *)stdin);
#line 815
    tmp___16 = gzdopen(tmp___15, (char const   *)"r");
#line 815
    fp = tmp___16;
  }
#line 816
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 817
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_mutfa");
#line 818
    return (1);
  }
#line 820
  seq = kseq_init(fp);
#line 821
  while (1) {
#line 821
    l = kseq_read(seq);
#line 821
    if (! (l >= 0)) {
#line 821
      break;
    }
#line 823
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
#line 824
    if (k != h->n_buckets) {
#line 825
      p___0 = h->vals + k;
#line 826
      i = 0;
#line 826
      while (i < p___0->n) {
#line 827
        beg___0 = (int )(*(p___0->a + i) >> 32);
#line 828
        if ((size_t___0 )beg___0 < seq->seq.l) {
#line 829
          *(seq->seq.s + beg___0) = (char )((int )*(p___0->a + i));
        }
#line 826
        i ++;
      }
    }
#line 832
    printf((char const   * __restrict  )">%s", seq->name.s);
#line 833
    i = 0;
#line 833
    while (i < l) {
#line 834
      if (i % 60 == 0) {
#line 834
        putchar('\n');
      }
#line 835
      putchar((int )*(seq->seq.s + i));
#line 833
      i ++;
    }
#line 837
    putchar('\n');
  }
#line 840
  kseq_destroy(seq);
#line 841
  gzclose(fp);
#line 842
  k = (khint_t )0;
#line 842
  while (k < h->n_buckets) {
#line 843
    if (! ((*(h->flags + (k >> 4)) >> ((k & 0xfU) << 1)) & 3U)) {
#line 844
      free((void *)(h->vals + k)->a);
#line 845
      free((void *)((char *)*(h->keys + k)));
    }
#line 842
    k ++;
  }
#line 848
  kh_destroy_reg(h);
#line 849
  return (0);
}
}
#line 852 "seqtk.c"
int stk_listhet(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int i ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int b ;

  {
#line 857
  if (argc == 1) {
#line 858
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk listhet <in.fa>\n");
#line 859
    return (1);
  }
#line 861
  tmp___3 = strcmp((char const   *)*(argv + 1), (char const   *)"-");
#line 861
  if (tmp___3 == 0) {
#line 861
    tmp___0 = fileno((FILE *)stdin);
#line 861
    tmp___1 = gzdopen(tmp___0, (char const   *)"r");
#line 861
    fp = tmp___1;
  } else {
#line 861
    tmp___2 = gzopen((char const   *)*(argv + 1), (char const   *)"r");
#line 861
    fp = tmp___2;
  }
#line 862
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 863
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_listhet");
#line 864
    return (1);
  }
#line 866
  seq = kseq_init(fp);
#line 867
  while (1) {
#line 867
    l = kseq_read(seq);
#line 867
    if (! (l >= 0)) {
#line 867
      break;
    }
#line 868
    i = 0;
#line 868
    while (i < l) {
#line 869
      b = (int )*(seq->seq.s + i);
#line 870
      if (bitcnt_table[seq_nt16_table[b]] == 2) {
#line 871
        printf((char const   * __restrict  )"%s\t%d\t%c\n", seq->name.s, i + 1, b);
      }
#line 868
      i ++;
    }
  }
#line 874
  kseq_destroy(seq);
#line 875
  gzclose(fp);
#line 876
  return (0);
}
}
#line 880 "seqtk.c"
static int cutN_min_N_tract  =    1000;
#line 881 "seqtk.c"
static int cutN_nonN_penalty  =    10;
#line 883 "seqtk.c"
static int find_next_cut(kseq_t const   *ks , int k , int *begin , int *end ) 
{ 
  int i ;
  int b ;
  int e ;
  int score ;
  int max ;

  {
#line 886
  while ((size_t___0 )k < ks->seq.l) {
#line 887
    if ((int )seq_nt16_table[(int )*(ks->seq.s + k)] == 15) {
#line 889
      score = 0;
#line 889
      max = -1;
#line 889
      e = max;
#line 890
      i = k;
#line 890
      while (1) {
#line 890
        if ((size_t___0 )i < ks->seq.l) {
#line 890
          if (! (score >= 0)) {
#line 890
            break;
          }
        } else {
#line 890
          break;
        }
#line 891
        if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
#line 891
          score ++;
        } else {
#line 892
          score -= cutN_nonN_penalty;
        }
#line 893
        if (score > max) {
#line 893
          max = score;
#line 893
          e = i;
        }
#line 890
        i ++;
      }
#line 895
      score = 0;
#line 895
      max = -1;
#line 895
      b = max;
#line 896
      i = e;
#line 896
      while (1) {
#line 896
        if (i >= 0) {
#line 896
          if (! (score >= 0)) {
#line 896
            break;
          }
        } else {
#line 896
          break;
        }
#line 897
        if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
#line 897
          score ++;
        } else {
#line 898
          score -= cutN_nonN_penalty;
        }
#line 899
        if (score > max) {
#line 899
          max = score;
#line 899
          b = i;
        }
#line 896
        i --;
      }
#line 901
      if ((e + 1) - b >= cutN_min_N_tract) {
#line 902
        *begin = b;
#line 903
        *end = e + 1;
#line 904
        return (*end);
      }
#line 906
      k = e + 1;
    } else {
#line 907
      k ++;
    }
  }
#line 909
  return (-1);
}
}
#line 911 "seqtk.c"
static void print_seq(FILE *fpout , kseq_t const   *ks , int begin , int end ) 
{ 
  int i ;
  int tmp ;

  {
#line 914
  if (begin >= end) {
#line 914
    return;
  }
#line 915
  if (ks->qual.l) {
#line 915
    tmp = '@';
  } else {
#line 915
    tmp = '>';
  }
#line 915
  fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )"%c%s:%d-%d", tmp,
          ks->name.s, begin + 1, end);
#line 916
  i = begin;
#line 916
  while (1) {
#line 916
    if (i < end) {
#line 916
      if (! ((size_t___0 )i < ks->seq.l)) {
#line 916
        break;
      }
    } else {
#line 916
      break;
    }
#line 917
    if ((i - begin) % 60 == 0) {
#line 917
      fputc('\n', fpout);
    }
#line 918
    fputc((int )*(ks->seq.s + i), fpout);
#line 916
    i ++;
  }
#line 920
  fputc('\n', fpout);
#line 921
  if (ks->qual.l == 0UL) {
#line 921
    return;
  }
#line 922
  fputs((char const   * __restrict  )"+\n", (FILE * __restrict  )fpout);
#line 923
  i = begin;
#line 923
  while (1) {
#line 923
    if (i < end) {
#line 923
      if (! ((size_t___0 )i < ks->qual.l)) {
#line 923
        break;
      }
    } else {
#line 923
      break;
    }
#line 924
    if ((i - begin) % 60 == 0) {
#line 924
      fputc('\n', fpout);
    }
#line 925
    fputc((int )*(ks->qual.s + i), fpout);
#line 923
    i ++;
  }
#line 927
  fputc('\n', fpout);
#line 928
  return;
}
}
#line 929 "seqtk.c"
int stk_cutN(int argc , char **argv ) 
{ 
  int c ;
  int l ;
  int gap_only ;
  gzFile fp ;
  kseq_t *ks ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int k ;
  int begin ;
  int end ;
  int tmp___4 ;

  {
#line 931
  gap_only = 0;
#line 934
  while (1) {
#line 934
    c = getopt(argc, (char **)argv, (char const   *)"n:p:g");
#line 934
    if (! (c >= 0)) {
#line 934
      break;
    }
#line 935
    switch (c) {
    case 110: 
#line 936
    cutN_min_N_tract = atoi((char const   *)optarg);
#line 936
    break;
    case 112: 
#line 937
    cutN_nonN_penalty = atoi((char const   *)optarg);
#line 937
    break;
    case 103: 
#line 938
    gap_only = 1;
#line 938
    break;
    default: 
#line 939
    return (1);
    }
  }
#line 942
  if (argc == optind) {
#line 943
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 944
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:   seqtk cutN [options] <in.fa>\n\n");
#line 945
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options: -n INT    min size of N tract [%d]\n",
            cutN_min_N_tract);
#line 946
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -p INT    penalty for a non-N [%d]\n",
            cutN_nonN_penalty);
#line 947
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -g        print gaps only, no sequence\n\n");
#line 948
    return (1);
  }
#line 950
  tmp___3 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 950
  if (tmp___3 == 0) {
#line 950
    tmp___0 = fileno((FILE *)stdin);
#line 950
    tmp___1 = gzdopen(tmp___0, (char const   *)"r");
#line 950
    fp = tmp___1;
  } else {
#line 950
    tmp___2 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 950
    fp = tmp___2;
  }
#line 951
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 952
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_cutN");
#line 953
    return (1);
  }
#line 955
  ks = kseq_init(fp);
#line 956
  while (1) {
#line 956
    l = kseq_read(ks);
#line 956
    if (! (l >= 0)) {
#line 956
      break;
    }
#line 957
    k = 0;
#line 957
    begin = 0;
#line 957
    end = 0;
#line 958
    while (1) {
#line 958
      tmp___4 = find_next_cut((kseq_t const   *)ks, k, & begin, & end);
#line 958
      if (! (tmp___4 >= 0)) {
#line 958
        break;
      }
#line 959
      if (begin != 0) {
#line 960
        if (gap_only) {
#line 960
          printf((char const   * __restrict  )"%s\t%d\t%d\n", ks->name.s, begin, end);
        } else {
#line 961
          print_seq((FILE *)stdout, (kseq_t const   *)ks, k, begin);
        }
      }
#line 963
      k = end;
    }
#line 965
    if (! gap_only) {
#line 965
      print_seq((FILE *)stdout, (kseq_t const   *)ks, k, l);
    }
  }
#line 967
  kseq_destroy(ks);
#line 968
  gzclose(fp);
#line 969
  return (0);
}
}
#line 972 "seqtk.c"
int stk_hrun(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *ks ;
  int min_len ;
  int l ;
  int c ;
  int beg ;
  int i ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 976
  min_len = 7;
#line 976
  l = 0;
#line 976
  c = 0;
#line 976
  beg = 0;
#line 977
  if (argc == optind) {
#line 978
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk hrun <in.fa> [minLen=%d]\n",
            min_len);
#line 979
    return (1);
  }
#line 981
  if (argc == optind + 2) {
#line 981
    min_len = atoi((char const   *)*(argv + (optind + 1)));
  }
#line 982
  tmp___3 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 982
  if (tmp___3 == 0) {
#line 982
    tmp___0 = fileno((FILE *)stdin);
#line 982
    tmp___1 = gzdopen(tmp___0, (char const   *)"r");
#line 982
    fp = tmp___1;
  } else {
#line 982
    tmp___2 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 982
    fp = tmp___2;
  }
#line 983
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 984
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_hrun");
#line 985
    return (1);
  }
#line 987
  ks = kseq_init(fp);
#line 988
  while (1) {
#line 988
    tmp___4 = kseq_read(ks);
#line 988
    if (! (tmp___4 >= 0)) {
#line 988
      break;
    }
#line 989
    c = (int )*(ks->seq.s + 0);
#line 989
    l = 1;
#line 989
    beg = 0;
#line 990
    i = 1;
#line 990
    while ((size_t___0 )i < ks->seq.l) {
#line 991
      if ((int )*(ks->seq.s + i) != c) {
#line 992
        if (l >= min_len) {
#line 992
          printf((char const   * __restrict  )"%s\t%d\t%d\t%c\n", ks->name.s, beg,
                 beg + l, c);
        }
#line 993
        c = (int )*(ks->seq.s + i);
#line 993
        l = 1;
#line 993
        beg = i;
      } else {
#line 994
        l ++;
      }
#line 990
      i ++;
    }
  }
#line 997
  if (l >= min_len) {
#line 997
    printf((char const   * __restrict  )"%s\t%d\t%d\t%c\n", ks->name.s, beg, beg + l,
           c);
  }
#line 998
  kseq_destroy(ks);
#line 999
  gzclose(fp);
#line 1000
  return (0);
}
}
#line 1005 "seqtk.c"
static void cpy_kstr(kstring_t *dst , kstring_t const   *src ) 
{ 
  void *tmp ;

  {
#line 1007
  if (src->l == 0UL) {
#line 1007
    return;
  }
#line 1008
  if (src->l + 1UL > (size_t___0 )dst->m) {
#line 1009
    dst->m = (size_t___0 )(src->l + 1UL);
#line 1010
    (dst->m) --;
#line 1010
    dst->m |= dst->m >> 1;
#line 1010
    dst->m |= dst->m >> 2;
#line 1010
    dst->m |= dst->m >> 4;
#line 1010
    dst->m |= dst->m >> 8;
#line 1010
    dst->m |= dst->m >> 16;
#line 1010
    (dst->m) ++;
#line 1011
    tmp = realloc((void *)dst->s, dst->m);
#line 1011
    dst->s = (char *)tmp;
  }
#line 1013
  dst->l = (size_t___0 )src->l;
#line 1014
  memcpy((void * __restrict  )dst->s, (void const   * __restrict  )src->s, (size_t___0 )(src->l + 1UL));
#line 1015
  return;
}
}
#line 1017 "seqtk.c"
static void cpy_kseq(kseq_t *dst , kseq_t const   *src ) 
{ 


  {
#line 1019
  cpy_kstr(& dst->name, (kstring_t const   *)(& src->name));
#line 1020
  cpy_kstr(& dst->seq, (kstring_t const   *)(& src->seq));
#line 1021
  cpy_kstr(& dst->qual, (kstring_t const   *)(& src->qual));
#line 1022
  cpy_kstr(& dst->comment, (kstring_t const   *)(& src->comment));
#line 1023
  return;
}
}
#line 1025 "seqtk.c"
int stk_sample(int argc , char **argv ) 
{ 
  int c ;
  int twopass ;
  uint64_t i ;
  uint64_t num ;
  uint64_t n_seqs ;
  double frac ;
  gzFile fp ;
  kseq_t *seq ;
  krand_t *kr ;
  long tmp ;
  kseq_t *buf ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  double r ;
  krint64_t tmp___6 ;
  uint64_t y ;
  uint64_t tmp___7 ;
  int tmp___8 ;
  kseq_t *p ;
  uint64_t *buf___0 ;
  kh_64_t *hash ;
  int absent ;
  int tmp___9 ;
  void *tmp___10 ;
  double r___0 ;
  krint64_t tmp___11 ;
  uint64_t y___0 ;
  int tmp___12 ;
  khint_t tmp___13 ;
  int tmp___14 ;

  {
#line 1027
  twopass = 0;
#line 1028
  num = (uint64_t )0;
#line 1028
  n_seqs = (uint64_t )0;
#line 1029
  frac = 0.;
#line 1032
  kr = (krand_t *)0;
#line 1034
  while (1) {
#line 1034
    c = getopt(argc, (char **)argv, (char const   *)"2s:");
#line 1034
    if (! (c >= 0)) {
#line 1034
      break;
    }
#line 1035
    if (c == 115) {
#line 1035
      tmp = atol((char const   *)optarg);
#line 1035
      kr = kr_srand((krint64_t )tmp);
    } else
#line 1036
    if (c == 50) {
#line 1036
      twopass = 1;
    }
  }
#line 1038
  if (optind + 2 > argc) {
#line 1039
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 1040
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:   seqtk sample [-2] [-s seed=11] <in.fa> <frac>|<number>\n\n");
#line 1041
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options: -s INT       RNG seed [11]\n");
#line 1042
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -2           2-pass mode: twice as slow but with much reduced memory\n\n");
#line 1043
    return (1);
  }
#line 1045
  frac = atof((char const   *)*(argv + (optind + 1)));
#line 1046
  if (frac >= 1.0) {
#line 1046
    num = (uint64_t )(frac + .499);
#line 1046
    frac = 0.;
  } else
#line 1047
  if (twopass) {
#line 1048
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[W::%s] when sampling a fraction, option -2 is ignored.",
            "stk_sample");
#line 1049
    twopass = 0;
  }
#line 1051
  if ((unsigned long )kr == (unsigned long )((krand_t *)0)) {
#line 1051
    kr = kr_srand((krint64_t )11);
  }
#line 1053
  if (! twopass) {
#line 1054
    buf = (kseq_t *)0;
#line 1055
    if (num > 0ULL) {
#line 1055
      tmp___0 = calloc((size_t___0 )num, sizeof(kseq_t ));
#line 1055
      buf = (kseq_t *)tmp___0;
    }
#line 1056
    if (num > 0ULL) {
#line 1056
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1057
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] Could not allocate enough memory for %llu sequences. Exiting...\n",
                "stk_sample", num);
#line 1058
        free((void *)kr);
#line 1059
        return (1);
      }
    }
#line 1062
    tmp___5 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 1062
    if (tmp___5) {
#line 1062
      tmp___2 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 1062
      fp = tmp___2;
    } else {
#line 1062
      tmp___3 = fileno((FILE *)stdin);
#line 1062
      tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 1062
      fp = tmp___4;
    }
#line 1063
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1064
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
              "stk_sample");
#line 1065
      return (1);
    }
#line 1067
    seq = kseq_init(fp);
#line 1068
    n_seqs = (uint64_t )0;
#line 1069
    while (1) {
#line 1069
      tmp___8 = kseq_read(seq);
#line 1069
      if (! (tmp___8 >= 0)) {
#line 1069
        break;
      }
#line 1070
      tmp___6 = kr_rand(kr);
#line 1070
      r = (double )(tmp___6 >> 11) * (1.0 / 9007199254740992.0);
#line 1071
      n_seqs ++;
#line 1072
      if (num) {
#line 1073
        if (n_seqs - 1ULL < num) {
#line 1073
          tmp___7 = n_seqs - 1ULL;
        } else {
#line 1073
          tmp___7 = (uint64_t )(r * (double )n_seqs);
        }
#line 1073
        y = tmp___7;
#line 1074
        if (y < num) {
#line 1074
          cpy_kseq(buf + y, (kseq_t const   *)seq);
        }
      } else
#line 1075
      if (r < frac) {
#line 1075
        stk_printseq((kseq_t const   *)seq, -1);
      }
    }
#line 1077
    i = (uint64_t )0;
#line 1077
    while (i < num) {
#line 1078
      p = buf + i;
#line 1079
      if (p->seq.l) {
#line 1079
        stk_printseq((kseq_t const   *)p, -1);
      }
#line 1080
      free((void *)p->seq.s);
#line 1080
      free((void *)p->qual.s);
#line 1080
      free((void *)p->name.s);
#line 1077
      i ++;
    }
#line 1082
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 1082
      free((void *)buf);
    }
  } else {
#line 1088
    tmp___9 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 1088
    if (tmp___9 == 0) {
#line 1089
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] in the 2-pass mode, the input cannot be STDIN.\n",
              "stk_sample");
#line 1090
      free((void *)kr);
#line 1091
      return (1);
    }
#line 1095
    tmp___10 = malloc((size_t___0 )(num * 8ULL));
#line 1095
    buf___0 = (uint64_t *)tmp___10;
#line 1096
    i = (uint64_t )0;
#line 1096
    while (i < num) {
#line 1096
      *(buf___0 + i) = (uint64_t )0xffffffffffffffffu;
#line 1096
      i ++;
    }
#line 1097
    fp = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 1098
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1099
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
              "stk_sample");
#line 1100
      return (1);
    }
#line 1102
    seq = kseq_init(fp);
#line 1103
    n_seqs = (uint64_t )0;
#line 1104
    while (1) {
#line 1104
      tmp___12 = kseq_read(seq);
#line 1104
      if (! (tmp___12 >= 0)) {
#line 1104
        break;
      }
#line 1105
      tmp___11 = kr_rand(kr);
#line 1105
      r___0 = (double )(tmp___11 >> 11) * (1.0 / 9007199254740992.0);
#line 1107
      n_seqs ++;
#line 1108
      if (n_seqs - 1ULL < num) {
#line 1108
        y___0 = n_seqs - 1ULL;
      } else {
#line 1108
        y___0 = (uint64_t )(r___0 * (double )n_seqs);
      }
#line 1109
      if (y___0 < num) {
#line 1109
        *(buf___0 + y___0) = n_seqs;
      }
    }
#line 1111
    kseq_destroy(seq);
#line 1112
    gzclose(fp);
#line 1113
    hash = kh_init_64();
#line 1114
    i = (uint64_t )0;
#line 1114
    while (i < num) {
#line 1114
      kh_put_64(hash, *(buf___0 + i), & absent);
#line 1114
      i ++;
    }
#line 1115
    free((void *)buf___0);
#line 1117
    fp = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 1118
    seq = kseq_init(fp);
#line 1119
    n_seqs = (uint64_t )0;
#line 1120
    while (1) {
#line 1120
      tmp___14 = kseq_read(seq);
#line 1120
      if (! (tmp___14 >= 0)) {
#line 1120
        break;
      }
#line 1121
      n_seqs ++;
#line 1121
      tmp___13 = kh_get_64((kh_64_t const   *)hash, n_seqs);
#line 1121
      if (tmp___13 != hash->n_buckets) {
#line 1122
        stk_printseq((kseq_t const   *)seq, -1);
      }
    }
#line 1123
    kh_destroy_64(hash);
  }
#line 1126
  kseq_destroy(seq);
#line 1127
  gzclose(fp);
#line 1128
  free((void *)kr);
#line 1129
  return (0);
}
}
#line 1134 "seqtk.c"
void stk_mask(kseq_t *seq , kh_reg_t const   *h , int is_complement , int mask_chr ) 
{ 
  unsigned int i ;
  unsigned int j ;
  khiter_t k ;
  int tmp ;
  reglist_t *p ;
  unsigned int beg ;
  unsigned int end ;
  int tmp___0 ;
  int8_t *mask ;
  void *tmp___1 ;
  unsigned int beg___0 ;
  unsigned int end___0 ;
  int tmp___2 ;

  {
#line 1138
  k = kh_get_reg(h, (kh_cstr_t )seq->name.s);
#line 1139
  if (k == (khiter_t )h->n_buckets) {
#line 1140
    if (is_complement) {
#line 1141
      if (mask_chr) {
#line 1142
        j = 0U;
#line 1142
        while ((size_t___0 )j < seq->seq.l) {
#line 1143
          *(seq->seq.s + j) = (char )mask_chr;
#line 1142
          j ++;
        }
      } else {
#line 1145
        j = 0U;
#line 1145
        while ((size_t___0 )j < seq->seq.l) {
#line 1146
          tmp = tolower((int )*(seq->seq.s + j));
#line 1146
          *(seq->seq.s + j) = (char )tmp;
#line 1145
          j ++;
        }
      }
    }
  } else {
#line 1150
    p = h->vals + k;
#line 1151
    if (! is_complement) {
#line 1152
      i = 0U;
#line 1152
      while (i < (unsigned int )p->n) {
#line 1153
        beg = (unsigned int )(*(p->a + i) >> 32);
#line 1153
        end = (unsigned int )*(p->a + i);
#line 1154
        if ((size_t___0 )beg >= seq->seq.l) {
#line 1154
          goto __Cont;
        }
#line 1155
        if ((size_t___0 )end > seq->seq.l) {
#line 1155
          end = (unsigned int )seq->seq.l;
        }
#line 1156
        if (! mask_chr) {
#line 1156
          j = beg;
#line 1156
          while (j < end) {
#line 1156
            tmp___0 = tolower((int )*(seq->seq.s + j));
#line 1156
            *(seq->seq.s + j) = (char )tmp___0;
#line 1156
            j ++;
          }
        } else {
#line 1157
          j = beg;
#line 1157
          while (j < end) {
#line 1157
            *(seq->seq.s + j) = (char )mask_chr;
#line 1157
            j ++;
          }
        }
        __Cont: /* CIL Label */ 
#line 1152
        i ++;
      }
    } else {
#line 1160
      tmp___1 = calloc(seq->seq.l, (size_t___0 )1);
#line 1160
      mask = (int8_t *)tmp___1;
#line 1161
      i = 0U;
#line 1161
      while (i < (unsigned int )p->n) {
#line 1162
        beg___0 = (unsigned int )(*(p->a + i) >> 32);
#line 1162
        end___0 = (unsigned int )*(p->a + i);
#line 1163
        if ((size_t___0 )end___0 >= seq->seq.l) {
#line 1163
          end___0 = (unsigned int )seq->seq.l;
        }
#line 1164
        j = beg___0;
#line 1164
        while (j < end___0) {
#line 1164
          *(mask + j) = (int8_t )1;
#line 1164
          j ++;
        }
#line 1161
        i ++;
      }
#line 1166
      if (mask_chr) {
#line 1167
        j = 0U;
#line 1167
        while ((size_t___0 )j < seq->seq.l) {
#line 1168
          if ((int )*(mask + j) == 0) {
#line 1168
            *(seq->seq.s + j) = (char )mask_chr;
          }
#line 1167
          j ++;
        }
      } else {
#line 1170
        j = 0U;
#line 1170
        while ((size_t___0 )j < seq->seq.l) {
#line 1171
          if ((int )*(mask + j) == 0) {
#line 1171
            tmp___2 = tolower((int )*(seq->seq.s + j));
#line 1171
            *(seq->seq.s + j) = (char )tmp___2;
          }
#line 1170
          j ++;
        }
      }
#line 1173
      free((void *)mask);
    }
  }
#line 1176
  return;
}
}
#line 1178 "seqtk.c"
int stk_seq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int c ;
  int qual_thres ;
  int flag ;
  int qual_shift ;
  int mask_chr ;
  int min_len ;
  int max_q ;
  int fake_qual ;
  unsigned int i ;
  unsigned int line_len ;
  int64_t n_seqs ;
  double frac ;
  kh_reg_t *h ;
  krand_t *kr ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  gzFile tmp___6 ;
  int tmp___7 ;
  krint64_t tmp___8 ;
  int k ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  int c0 ;
  int c1 ;
  int tmp___16 ;

  {
#line 1182
  qual_thres = 0;
#line 1182
  flag = 0;
#line 1182
  qual_shift = 33;
#line 1182
  mask_chr = 0;
#line 1182
  min_len = 0;
#line 1182
  max_q = 255;
#line 1182
  fake_qual = -1;
#line 1183
  line_len = 0U;
#line 1184
  n_seqs = (int64_t )0;
#line 1185
  frac = 1.;
#line 1186
  h = (kh_reg_t *)0;
#line 1187
  kr = (krand_t *)0;
#line 1189
  while (1) {
#line 1189
    c = getopt(argc, (char **)argv, (char const   *)"N12q:l:Q:aACrn:s:f:M:L:cVUX:SF:");
#line 1189
    if (! (c >= 0)) {
#line 1189
      break;
    }
#line 1190
    switch (c) {
    case 65: 
    case 97: 
#line 1192
    flag |= 1;
#line 1192
    break;
    case 67: 
#line 1193
    flag |= 2;
#line 1193
    break;
    case 114: 
#line 1194
    flag |= 4;
#line 1194
    break;
    case 99: 
#line 1195
    flag |= 8;
#line 1195
    break;
    case 49: 
#line 1196
    flag |= 16;
#line 1196
    break;
    case 50: 
#line 1197
    flag |= 32;
#line 1197
    break;
    case 86: 
#line 1198
    flag |= 64;
#line 1198
    break;
    case 78: 
#line 1199
    flag |= 128;
#line 1199
    break;
    case 85: 
#line 1200
    flag |= 256;
#line 1200
    break;
    case 83: 
#line 1201
    flag |= 512;
#line 1201
    break;
    case 77: 
#line 1202
    h = stk_reg_read((char const   *)optarg);
#line 1202
    break;
    case 110: 
#line 1203
    mask_chr = (int )*optarg;
#line 1203
    break;
    case 81: 
#line 1204
    qual_shift = atoi((char const   *)optarg);
#line 1204
    break;
    case 113: 
#line 1205
    qual_thres = atoi((char const   *)optarg);
#line 1205
    break;
    case 88: 
#line 1206
    max_q = atoi((char const   *)optarg);
#line 1206
    break;
    case 108: 
#line 1207
    tmp = atoi((char const   *)optarg);
#line 1207
    line_len = (unsigned int )tmp;
#line 1207
    break;
    case 76: 
#line 1208
    min_len = atoi((char const   *)optarg);
#line 1208
    break;
    case 115: 
#line 1209
    tmp___0 = atol((char const   *)optarg);
#line 1209
    kr = kr_srand((krint64_t )tmp___0);
#line 1209
    break;
    case 102: 
#line 1210
    frac = atof((char const   *)optarg);
#line 1210
    break;
    case 70: 
#line 1211
    fake_qual = (int )*optarg;
#line 1211
    break;
    }
  }
#line 1214
  if ((unsigned long )kr == (unsigned long )((krand_t *)0)) {
#line 1214
    kr = kr_srand((krint64_t )11);
  }
#line 1215
  if (argc == optind) {
#line 1215
    tmp___1 = fileno((FILE *)stdin);
#line 1215
    tmp___2 = isatty(tmp___1);
#line 1215
    if (tmp___2) {
#line 1216
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 1217
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:   seqtk seq [options] <in.fq>|<in.fa>\n\n");
#line 1218
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options: -q INT    mask bases with quality lower than INT [0]\n");
#line 1219
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -X INT    mask bases with quality higher than INT [255]\n");
#line 1220
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -n CHAR   masked bases converted to CHAR; 0 for lowercase [0]\n");
#line 1221
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -l INT    number of residues per line; 0 for 2^32-1 [%d]\n",
              line_len);
#line 1222
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -Q INT    quality shift: ASCII-INT gives base quality [%d]\n",
              qual_shift);
#line 1223
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -s INT    random seed (effective with -f) [11]\n");
#line 1224
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -f FLOAT  sample FLOAT fraction of sequences [1]\n");
#line 1225
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -M FILE   mask regions in BED or name list FILE [null]\n");
#line 1226
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -L INT    drop sequences with length shorter than INT [0]\n");
#line 1227
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -F CHAR   fake FASTQ quality []\n");
#line 1228
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -c        mask complement region (effective with -M)\n");
#line 1229
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -r        reverse complement\n");
#line 1230
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -A        force FASTA output (discard quality)\n");
#line 1231
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -C        drop comments at the header lines\n");
#line 1232
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -N        drop sequences containing ambiguous bases\n");
#line 1233
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -1        output the 2n-1 reads only\n");
#line 1234
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -2        output the 2n reads only\n");
#line 1235
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -V        shift quality by \'(-Q) - 33\'\n");
#line 1236
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -U        convert all bases to uppercases\n");
#line 1237
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         -S        strip of white spaces in sequences\n");
#line 1238
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 1239
      free((void *)kr);
#line 1240
      return (1);
    }
  }
#line 1242
  if (line_len == 0U) {
#line 1242
    line_len = 4294967295U;
  }
#line 1243
  if (optind < argc) {
#line 1243
    tmp___7 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 1243
    if (tmp___7) {
#line 1243
      tmp___4 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 1243
      fp = tmp___4;
    } else {
#line 1243
      tmp___5 = fileno((FILE *)stdin);
#line 1243
      tmp___6 = gzdopen(tmp___5, (char const   *)"r");
#line 1243
      fp = tmp___6;
    }
  } else {
#line 1243
    tmp___5 = fileno((FILE *)stdin);
#line 1243
    tmp___6 = gzdopen(tmp___5, (char const   *)"r");
#line 1243
    fp = tmp___6;
  }
#line 1244
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1245
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_seq");
#line 1246
    return (1);
  }
#line 1248
  seq = kseq_init(fp);
#line 1249
  qual_thres += qual_shift;
#line 1250
  while (1) {
#line 1250
    tmp___16 = kseq_read(seq);
#line 1250
    if (! (tmp___16 >= 0)) {
#line 1250
      break;
    }
#line 1251
    n_seqs ++;
#line 1252
    if (seq->seq.l < (size_t___0 )min_len) {
#line 1252
      continue;
    }
#line 1253
    if (frac < 1.) {
#line 1253
      tmp___8 = kr_rand(kr);
#line 1253
      if ((double )(tmp___8 >> 11) * (1.0 / 9007199254740992.0) >= frac) {
#line 1253
        continue;
      }
    }
#line 1254
    if (flag & 48) {
#line 1255
      if (flag & 16) {
#line 1255
        if ((n_seqs & 1LL) == 0LL) {
#line 1255
          continue;
        }
      }
#line 1256
      if (flag & 32) {
#line 1256
        if ((n_seqs & 1LL) == 1LL) {
#line 1256
          continue;
        }
      }
    }
#line 1258
    if (flag & 512) {
#line 1260
      if (seq->qual.l) {
#line 1261
        k = 0;
#line 1261
        i = (unsigned int )k;
#line 1261
        while ((size_t___0 )i < seq->seq.l) {
#line 1262
          tmp___10 = isspace((int )*(seq->seq.s + i));
#line 1262
          if (! tmp___10) {
#line 1263
            tmp___9 = k;
#line 1263
            k ++;
#line 1263
            *(seq->qual.s + tmp___9) = *(seq->qual.s + i);
          }
#line 1261
          i ++;
        }
#line 1264
        seq->qual.l = (size_t___0 )k;
      }
#line 1266
      k = 0;
#line 1266
      i = (unsigned int )k;
#line 1266
      while ((size_t___0 )i < seq->seq.l) {
#line 1267
        tmp___12 = isspace((int )*(seq->seq.s + i));
#line 1267
        if (! tmp___12) {
#line 1268
          tmp___11 = k;
#line 1268
          k ++;
#line 1268
          *(seq->seq.s + tmp___11) = *(seq->seq.s + i);
        }
#line 1266
        i ++;
      }
#line 1269
      seq->seq.l = (size_t___0 )k;
    }
#line 1271
    if (seq->qual.l) {
#line 1271
      if (qual_thres > qual_shift) {
#line 1272
        if (mask_chr) {
#line 1273
          i = 0U;
#line 1273
          while ((size_t___0 )i < seq->seq.l) {
#line 1274
            if ((int )*(seq->qual.s + i) < qual_thres) {
#line 1275
              *(seq->seq.s + i) = (char )mask_chr;
            } else
#line 1274
            if ((int )*(seq->qual.s + i) > max_q) {
#line 1275
              *(seq->seq.s + i) = (char )mask_chr;
            }
#line 1273
            i ++;
          }
        } else {
#line 1277
          i = 0U;
#line 1277
          while ((size_t___0 )i < seq->seq.l) {
#line 1278
            if ((int )*(seq->qual.s + i) < qual_thres) {
#line 1279
              tmp___13 = tolower((int )*(seq->seq.s + i));
#line 1279
              *(seq->seq.s + i) = (char )tmp___13;
            } else
#line 1278
            if ((int )*(seq->qual.s + i) > max_q) {
#line 1279
              tmp___13 = tolower((int )*(seq->seq.s + i));
#line 1279
              *(seq->seq.s + i) = (char )tmp___13;
            }
#line 1277
            i ++;
          }
        }
      }
    }
#line 1282
    if (flag & 256) {
#line 1283
      i = 0U;
#line 1283
      while ((size_t___0 )i < seq->seq.l) {
#line 1284
        tmp___14 = toupper((int )*(seq->seq.s + i));
#line 1284
        *(seq->seq.s + i) = (char )tmp___14;
#line 1283
        i ++;
      }
    }
#line 1285
    if (flag & 1) {
#line 1285
      seq->qual.l = (size_t___0 )0;
    } else
#line 1286
    if (fake_qual >= 33) {
#line 1286
      if (fake_qual <= 127) {
#line 1287
        if (seq->qual.m < seq->seq.m) {
#line 1288
          seq->qual.m = seq->seq.m;
#line 1289
          tmp___15 = realloc((void *)seq->qual.s, seq->qual.m);
#line 1289
          seq->qual.s = (char *)tmp___15;
        }
#line 1291
        seq->qual.l = seq->seq.l;
#line 1292
        memset((void *)seq->qual.s, fake_qual, seq->qual.l);
#line 1293
        *(seq->qual.s + seq->qual.l) = (char)0;
      }
    }
#line 1295
    if (flag & 2) {
#line 1295
      seq->comment.l = (size_t___0 )0;
    }
#line 1296
    if (h) {
#line 1296
      stk_mask(seq, (kh_reg_t const   *)h, flag & 8, mask_chr);
    }
#line 1297
    if (flag & 4) {
#line 1299
      i = 0U;
#line 1299
      while ((size_t___0 )i < seq->seq.l >> 1) {
#line 1300
        c0 = (int )comp_tab[(int )*(seq->seq.s + i)];
#line 1301
        c1 = (int )comp_tab[(int )*(seq->seq.s + ((seq->seq.l - 1UL) - (size_t___0 )i))];
#line 1302
        *(seq->seq.s + i) = (char )c1;
#line 1303
        *(seq->seq.s + ((seq->seq.l - 1UL) - (size_t___0 )i)) = (char )c0;
#line 1299
        i ++;
      }
#line 1305
      if (seq->seq.l & 1UL) {
#line 1306
        *(seq->seq.s + (seq->seq.l >> 1)) = comp_tab[(int )*(seq->seq.s + (seq->seq.l >> 1))];
      }
#line 1307
      if (seq->qual.l) {
#line 1308
        i = 0U;
#line 1308
        while ((size_t___0 )i < seq->seq.l >> 1) {
#line 1309
          c0 = (int )*(seq->qual.s + i);
#line 1309
          *(seq->qual.s + i) = *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t___0 )i));
#line 1309
          *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t___0 )i)) = (char )c0;
#line 1308
          i ++;
        }
      }
    }
#line 1312
    if (flag & 64) {
#line 1312
      if (seq->qual.l) {
#line 1312
        if (qual_shift != 33) {
#line 1313
          i = 0U;
#line 1313
          while ((size_t___0 )i < seq->qual.l) {
#line 1314
            *(seq->qual.s + i) = (char )((int )*(seq->qual.s + i) - (qual_shift - 33));
#line 1313
            i ++;
          }
        }
      }
    }
#line 1315
    if (flag & 128) {
#line 1316
      i = 0U;
#line 1316
      while ((size_t___0 )i < seq->seq.l) {
#line 1317
        if ((int )seq_nt16to4_table[seq_nt16_table[(int )*(seq->seq.s + i)]] > 3) {
#line 1317
          break;
        }
#line 1316
        i ++;
      }
#line 1318
      if ((size_t___0 )i < seq->seq.l) {
#line 1318
        continue;
      }
    }
#line 1320
    stk_printseq((kseq_t const   *)seq, (int )line_len);
  }
#line 1322
  kseq_destroy(seq);
#line 1323
  gzclose(fp);
#line 1324
  stk_reg_destroy(h);
#line 1325
  free((void *)kr);
#line 1326
  return (0);
}
}
#line 1329 "seqtk.c"
int stk_gc(int argc , char **argv ) 
{ 
  int c ;
  int is_at ;
  int min_l ;
  double frac ;
  double xdropoff ;
  double q ;
  gzFile fp ;
  kseq_t *seq ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int i ;
  int start ;
  int max_i ;
  int n_hits ;
  int start_hits ;
  int max_hits ;
  double sc ;
  double max ;
  int hit ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1331
  is_at = 0;
#line 1331
  min_l = 20;
#line 1332
  frac = (double )0.6f;
#line 1332
  xdropoff = (double )10.0f;
#line 1336
  while (1) {
#line 1336
    c = getopt(argc, (char **)argv, (char const   *)"wx:f:l:");
#line 1336
    if (! (c >= 0)) {
#line 1336
      break;
    }
#line 1337
    if (c == 120) {
#line 1337
      xdropoff = atof((char const   *)optarg);
    } else
#line 1338
    if (c == 119) {
#line 1338
      is_at = 1;
    } else
#line 1339
    if (c == 102) {
#line 1339
      frac = atof((char const   *)optarg);
    } else
#line 1340
    if (c == 108) {
#line 1340
      min_l = atoi((char const   *)optarg);
    }
  }
#line 1342
  if (optind + 1 > argc) {
#line 1343
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk gc [options] <in.fa>\n");
#line 1344
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 1345
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -w         identify high-AT regions\n");
#line 1346
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f FLOAT   min GC fraction (or AT fraction for -w) [%.2f]\n",
            frac);
#line 1347
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -l INT     min region length to output [%d]\n",
            min_l);
#line 1348
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -x FLOAT   X-dropoff [%.1f]\n",
            xdropoff);
#line 1349
    return (1);
  }
#line 1351
  q = ((double )1.0f - frac) / frac;
#line 1353
  tmp___3 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 1353
  if (tmp___3) {
#line 1353
    tmp___0 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 1353
    fp = tmp___0;
  } else {
#line 1353
    tmp___1 = fileno((FILE *)stdin);
#line 1353
    tmp___2 = gzdopen(tmp___1, (char const   *)"r");
#line 1353
    fp = tmp___2;
  }
#line 1354
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1355
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_gc");
#line 1356
    return (1);
  }
#line 1358
  seq = kseq_init(fp);
#line 1359
  while (1) {
#line 1359
    tmp___6 = kseq_read(seq);
#line 1359
    if (! (tmp___6 >= 0)) {
#line 1359
      break;
    }
#line 1360
    start = 0;
#line 1360
    max_i = 0;
#line 1360
    n_hits = 0;
#line 1360
    start_hits = 0;
#line 1360
    max_hits = 0;
#line 1361
    sc = 0.;
#line 1361
    max = 0.;
#line 1362
    i = 0;
#line 1362
    while ((size_t___0 )i < seq->seq.l) {
#line 1364
      c = (int )seq_nt16_table[(int )*(seq->seq.s + i)];
#line 1365
      if (is_at) {
#line 1365
        if (c == 1) {
#line 1365
          tmp___4 = 1;
        } else
#line 1365
        if (c == 8) {
#line 1365
          tmp___4 = 1;
        } else
#line 1365
        if (c == 9) {
#line 1365
          tmp___4 = 1;
        } else {
#line 1365
          tmp___4 = 0;
        }
#line 1365
        hit = tmp___4;
      } else {
#line 1366
        if (c == 2) {
#line 1366
          tmp___5 = 1;
        } else
#line 1366
        if (c == 4) {
#line 1366
          tmp___5 = 1;
        } else
#line 1366
        if (c == 6) {
#line 1366
          tmp___5 = 1;
        } else {
#line 1366
          tmp___5 = 0;
        }
#line 1366
        hit = tmp___5;
      }
#line 1367
      n_hits += hit;
#line 1368
      if (hit) {
#line 1369
        if (sc == (double )0) {
#line 1369
          start = i;
#line 1369
          start_hits = n_hits;
        }
#line 1370
        sc += q;
#line 1371
        if (sc > max) {
#line 1371
          max = sc;
#line 1371
          max_i = i;
#line 1371
          max_hits = n_hits;
        }
      } else
#line 1372
      if (sc > (double )0) {
#line 1373
        sc += (double )(- 1.0f);
#line 1374
        if (sc < (double )0) {
#line 1374
          goto _L;
        } else
#line 1374
        if (max - sc > xdropoff) {
          _L: /* CIL Label */ 
#line 1375
          if ((max_i + 1) - start >= min_l) {
#line 1376
            printf((char const   * __restrict  )"%s\t%d\t%d\t%d\n", seq->name.s, start,
                   max_i + 1, (max_hits - start_hits) + 1);
          }
#line 1377
          max = (double )0;
#line 1377
          sc = max;
#line 1378
          i = max_i;
        }
      }
#line 1362
      i ++;
    }
#line 1382
    if (max > 0.) {
#line 1382
      if ((max_i + 1) - start >= min_l) {
#line 1383
        printf((char const   * __restrict  )"%s\t%d\t%d\t%d\n", seq->name.s, start,
               max_i + 1, (max_hits - start_hits) + 1);
      }
    }
  }
#line 1385
  kseq_destroy(seq);
#line 1386
  gzclose(fp);
#line 1387
  return (0);
}
}
#line 1390 "seqtk.c"
int stk_mergepe(int argc , char **argv ) 
{ 
  gzFile fp1 ;
  gzFile fp2 ;
  kseq_t *seq[2] ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___5 ;
  int tmp___6 ;
  gzFile tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1395
  if (argc < 3) {
#line 1396
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk mergepe <in1.fq> <in2.fq>\n");
#line 1397
    return (1);
  }
#line 1399
  tmp___3 = strcmp((char const   *)*(argv + 1), (char const   *)"-");
#line 1399
  if (tmp___3) {
#line 1399
    tmp___0 = gzopen((char const   *)*(argv + 1), (char const   *)"r");
#line 1399
    fp1 = tmp___0;
  } else {
#line 1399
    tmp___1 = fileno((FILE *)stdin);
#line 1399
    tmp___2 = gzdopen(tmp___1, (char const   *)"r");
#line 1399
    fp1 = tmp___2;
  }
#line 1400
  tmp___8 = strcmp((char const   *)*(argv + 2), (char const   *)"-");
#line 1400
  if (tmp___8) {
#line 1400
    tmp___5 = gzopen((char const   *)*(argv + 2), (char const   *)"r");
#line 1400
    fp2 = tmp___5;
  } else {
#line 1400
    tmp___6 = fileno((FILE *)stdin);
#line 1400
    tmp___7 = gzdopen(tmp___6, (char const   *)"r");
#line 1400
    fp2 = tmp___7;
  }
#line 1401
  if ((unsigned long )fp1 == (unsigned long )((gzFile )0)) {
#line 1402
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_mergepe");
#line 1403
    return (1);
  } else
#line 1401
  if ((unsigned long )fp2 == (unsigned long )((gzFile )0)) {
#line 1402
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_mergepe");
#line 1403
    return (1);
  }
#line 1405
  seq[0] = kseq_init(fp1);
#line 1406
  seq[1] = kseq_init(fp2);
#line 1407
  while (1) {
#line 1407
    tmp___10 = kseq_read(seq[0]);
#line 1407
    if (! (tmp___10 >= 0)) {
#line 1407
      break;
    }
#line 1408
    tmp___9 = kseq_read(seq[1]);
#line 1408
    if (tmp___9 < 0) {
#line 1409
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[W::%s] the 2nd file has fewer records.\n",
              "stk_mergepe");
#line 1410
      break;
    }
#line 1412
    stk_printseq((kseq_t const   *)seq[0], 0);
#line 1413
    stk_printseq((kseq_t const   *)seq[1], 0);
  }
#line 1415
  tmp___11 = kseq_read(seq[1]);
#line 1415
  if (tmp___11 >= 0) {
#line 1416
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[W::%s] the 1st file has fewer records.\n",
            "stk_mergepe");
  }
#line 1417
  kseq_destroy(seq[0]);
#line 1417
  gzclose(fp1);
#line 1418
  kseq_destroy(seq[1]);
#line 1418
  gzclose(fp2);
#line 1419
  return (0);
}
}
#line 1422 "seqtk.c"
int stk_dropse(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  kseq_t last ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  kstring_t *p ;
  kstring_t *q ;
  int is_diff ;
  int l ;
  size_t___0 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1427
  if (argc == 1) {
#line 1427
    tmp = fileno((FILE *)stdin);
#line 1427
    tmp___0 = isatty(tmp);
#line 1427
    if (tmp___0) {
#line 1428
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk dropse <in.fq>\n");
#line 1429
      return (1);
    }
  }
#line 1431
  if (argc > 1) {
#line 1431
    tmp___5 = strcmp((char const   *)*(argv + 1), (char const   *)"-");
#line 1431
    if (tmp___5) {
#line 1431
      tmp___2 = gzopen((char const   *)*(argv + 1), (char const   *)"r");
#line 1431
      fp = tmp___2;
    } else {
#line 1431
      tmp___3 = fileno((FILE *)stdin);
#line 1431
      tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 1431
      fp = tmp___4;
    }
  } else {
#line 1431
    tmp___3 = fileno((FILE *)stdin);
#line 1431
    tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 1431
    fp = tmp___4;
  }
#line 1432
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1433
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_dropse");
#line 1434
    return (1);
  }
#line 1436
  seq = kseq_init(fp);
#line 1438
  memset((void *)(& last), 0, sizeof(kseq_t ));
#line 1439
  while (1) {
#line 1439
    tmp___11 = kseq_read(seq);
#line 1439
    if (! (tmp___11 >= 0)) {
#line 1439
      break;
    }
#line 1440
    if (last.name.l) {
#line 1441
      p = & last.name;
#line 1441
      q = & seq->name;
#line 1443
      if (p->l == q->l) {
#line 1444
        if (p->l > 2UL) {
#line 1444
          if ((int )*(p->s + (p->l - 2UL)) == 47) {
#line 1444
            if ((int )*(q->s + (q->l - 2UL)) == 47) {
#line 1444
              tmp___9 = isdigit((int )*(p->s + (p->l - 1UL)));
#line 1444
              if (tmp___9) {
#line 1444
                tmp___10 = isdigit((int )*(q->s + (q->l - 1UL)));
#line 1444
                if (tmp___10) {
#line 1444
                  tmp___8 = p->l - 2UL;
                } else {
#line 1444
                  tmp___8 = p->l;
                }
              } else {
#line 1444
                tmp___8 = p->l;
              }
            } else {
#line 1444
              tmp___8 = p->l;
            }
          } else {
#line 1444
            tmp___8 = p->l;
          }
        } else {
#line 1444
          tmp___8 = p->l;
        }
#line 1444
        l = (int )tmp___8;
#line 1445
        is_diff = strncmp((char const   *)p->s, (char const   *)q->s, (size_t___0 )l);
      } else {
#line 1446
        is_diff = 1;
      }
#line 1447
      if (! is_diff) {
#line 1448
        stk_printseq((kseq_t const   *)(& last), 0);
#line 1449
        stk_printseq((kseq_t const   *)seq, 0);
#line 1450
        last.name.l = (size_t___0 )0;
      } else {
#line 1451
        cpy_kseq(& last, (kseq_t const   *)seq);
      }
    } else {
#line 1452
      cpy_kseq(& last, (kseq_t const   *)seq);
    }
  }
#line 1455
  kseq_destroy(seq);
#line 1456
  gzclose(fp);
#line 1458
  return (0);
}
}
#line 1461 "seqtk.c"
int stk_rename(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  kseq_t last ;
  char *prefix ;
  uint64_t n ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  kstring_t *p ;
  kstring_t *q ;
  int is_diff ;
  int l ;
  size_t___0 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1465
  prefix = (char *)0;
#line 1466
  n = (uint64_t )1;
#line 1468
  if (argc == 1) {
#line 1468
    tmp = fileno((FILE *)stdin);
#line 1468
    tmp___0 = isatty(tmp);
#line 1468
    if (tmp___0) {
#line 1469
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk rename <in.fq> [prefix]\n");
#line 1470
      return (1);
    }
  }
#line 1472
  if (argc > 1) {
#line 1472
    tmp___5 = strcmp((char const   *)*(argv + 1), (char const   *)"-");
#line 1472
    if (tmp___5) {
#line 1472
      tmp___2 = gzopen((char const   *)*(argv + 1), (char const   *)"r");
#line 1472
      fp = tmp___2;
    } else {
#line 1472
      tmp___3 = fileno((FILE *)stdin);
#line 1472
      tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 1472
      fp = tmp___4;
    }
  } else {
#line 1472
    tmp___3 = fileno((FILE *)stdin);
#line 1472
    tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 1472
    fp = tmp___4;
  }
#line 1473
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1474
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_rename");
#line 1475
    return (1);
  }
#line 1477
  seq = kseq_init(fp);
#line 1478
  if (argc > 2) {
#line 1478
    prefix = *(argv + 2);
  }
#line 1480
  memset((void *)(& last), 0, sizeof(kseq_t ));
#line 1481
  while (1) {
#line 1481
    tmp___11 = kseq_read(seq);
#line 1481
    if (! (tmp___11 >= 0)) {
#line 1481
      break;
    }
#line 1482
    if (last.name.l) {
#line 1483
      p = & last.name;
#line 1483
      q = & seq->name;
#line 1485
      if (p->l == q->l) {
#line 1486
        if (p->l > 2UL) {
#line 1486
          if ((int )*(p->s + (p->l - 2UL)) == 47) {
#line 1486
            if ((int )*(q->s + (q->l - 2UL)) == 47) {
#line 1486
              tmp___9 = isdigit((int )*(p->s + (p->l - 1UL)));
#line 1486
              if (tmp___9) {
#line 1486
                tmp___10 = isdigit((int )*(q->s + (q->l - 1UL)));
#line 1486
                if (tmp___10) {
#line 1486
                  tmp___8 = p->l - 2UL;
                } else {
#line 1486
                  tmp___8 = p->l;
                }
              } else {
#line 1486
                tmp___8 = p->l;
              }
            } else {
#line 1486
              tmp___8 = p->l;
            }
          } else {
#line 1486
            tmp___8 = p->l;
          }
        } else {
#line 1486
          tmp___8 = p->l;
        }
#line 1486
        l = (int )tmp___8;
#line 1487
        is_diff = strncmp((char const   *)p->s, (char const   *)q->s, (size_t___0 )l);
      } else {
#line 1488
        is_diff = 1;
      }
#line 1489
      if (! is_diff) {
#line 1490
        stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix,
                             (int64_t )n);
#line 1491
        stk_printseq_renamed((kseq_t const   *)seq, 0, (char const   *)prefix, (int64_t )n);
#line 1492
        last.name.l = (size_t___0 )0;
#line 1493
        n ++;
      } else {
#line 1495
        stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix,
                             (int64_t )n);
#line 1496
        n ++;
#line 1497
        cpy_kseq(& last, (kseq_t const   *)seq);
      }
    } else {
#line 1499
      cpy_kseq(& last, (kseq_t const   *)seq);
    }
  }
#line 1501
  if (last.name.l) {
#line 1501
    stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix, (int64_t )n);
  }
#line 1503
  kseq_destroy(seq);
#line 1504
  gzclose(fp);
#line 1506
  return (0);
}
}
#line 1509 "seqtk.c"
int stk_kfreq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *ks ;
  int kmer ;
  int i ;
  int l ;
  int mask ;
  char *nei ;
  size_t___0 tmp ;
  int c ;
  int tmp___0 ;
  void *tmp___1 ;
  int j ;
  int x ;
  int tmp___3 ;
  gzFile tmp___4 ;
  gzFile tmp___5 ;
  int tmp___6 ;
  int k ;
  int x___0[2] ;
  int cnt[2] ;
  int cnt_nei[2] ;
  int which ;
  int c___0 ;
  int tmp___7 ;

  {
#line 1516
  if (argc < 2) {
#line 1517
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk kfreq <kmer> <in.fa>\n");
#line 1518
    return (1);
  }
#line 1522
  tmp = strlen((char const   *)*(argv + 1));
#line 1522
  l = (int )tmp;
#line 1523
  kmer = 0;
#line 1523
  i = kmer;
#line 1523
  while (i < l) {
#line 1524
    c = (int )seq_nt6_table[(int )*(*(argv + 1) + i)];
#line 1525
    if (c >= 1) {
#line 1525
      if (c <= 4) {
#line 1525
        tmp___0 = 1;
      } else {
#line 1525
        __assert_fail((char const   *)"c >= 1 && c <= 4", (char const   *)"seqtk.c",
                      1525, (char const   *)"stk_kfreq");
#line 1525
        tmp___0 = 0;
      }
    } else {
#line 1525
      __assert_fail((char const   *)"c >= 1 && c <= 4", (char const   *)"seqtk.c",
                    1525, (char const   *)"stk_kfreq");
#line 1525
      tmp___0 = 0;
    }
#line 1526
    kmer = (kmer << 2) | (c - 1);
#line 1523
    i ++;
  }
#line 1528
  mask = (1 << 2 * l) - 1;
#line 1531
  tmp___1 = calloc((size_t___0 )1, (size_t___0 )(1 << 2 * l));
#line 1531
  nei = (char *)tmp___1;
#line 1532
  i = 0;
#line 1532
  while (i < l) {
#line 1534
    x = kmer & ~ (3 << 2 * i);
#line 1535
    j = 0;
#line 1535
    while (j < 4) {
#line 1536
      *(nei + (x | (j << 2 * i))) = (char)1;
#line 1535
      j ++;
    }
#line 1532
    i ++;
  }
#line 1539
  if (argc == 2) {
#line 1539
    tmp___3 = fileno((FILE *)stdin);
#line 1539
    tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 1539
    fp = tmp___4;
  } else {
#line 1539
    tmp___6 = strcmp((char const   *)*(argv + 2), (char const   *)"-");
#line 1539
    if (tmp___6 == 0) {
#line 1539
      tmp___3 = fileno((FILE *)stdin);
#line 1539
      tmp___4 = gzdopen(tmp___3, (char const   *)"r");
#line 1539
      fp = tmp___4;
    } else {
#line 1539
      tmp___5 = gzopen((char const   *)*(argv + 2), (char const   *)"r");
#line 1539
      fp = tmp___5;
    }
  }
#line 1540
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1541
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_kfreq");
#line 1542
    return (1);
  }
#line 1544
  ks = kseq_init(fp);
#line 1545
  while (1) {
#line 1545
    tmp___7 = kseq_read(ks);
#line 1545
    if (! (tmp___7 >= 0)) {
#line 1545
      break;
    }
#line 1547
    cnt_nei[1] = 0;
#line 1547
    cnt_nei[0] = cnt_nei[1];
#line 1547
    cnt[1] = cnt_nei[0];
#line 1547
    cnt[0] = cnt[1];
#line 1547
    k = cnt[0];
#line 1547
    x___0[1] = k;
#line 1547
    x___0[0] = x___0[1];
#line 1548
    i = 0;
#line 1548
    while ((size_t___0 )i < ks->seq.l) {
#line 1549
      c___0 = (int )seq_nt6_table[(int )*(ks->seq.s + i)];
#line 1550
      if (c___0 >= 1) {
#line 1550
        if (c___0 <= 4) {
#line 1551
          x___0[0] = ((x___0[0] << 2) | (c___0 - 1)) & mask;
#line 1552
          x___0[1] = (x___0[1] >> 2) | ((4 - c___0) << 2 * (l - 1));
#line 1553
          if (k < l) {
#line 1553
            k ++;
          }
#line 1554
          if (k == l) {
#line 1555
            if (x___0[0] == kmer) {
#line 1555
              (cnt[0]) ++;
            } else
#line 1556
            if (x___0[1] == kmer) {
#line 1556
              (cnt[1]) ++;
            }
#line 1557
            if (*(nei + x___0[0])) {
#line 1557
              (cnt_nei[0]) ++;
            } else
#line 1558
            if (*(nei + x___0[1])) {
#line 1558
              (cnt_nei[1]) ++;
            }
          }
        } else {
#line 1560
          k = 0;
        }
      } else {
#line 1560
        k = 0;
      }
#line 1548
      i ++;
    }
#line 1562
    if (cnt_nei[0] > cnt_nei[1]) {
#line 1562
      which = 0;
    } else {
#line 1562
      which = 1;
    }
#line 1563
    printf((char const   * __restrict  )"%s\t%ld\t%c\t%d\t%d\n", ks->name.s, ks->seq.l,
           (int )*("+-" + which), cnt_nei[which], cnt[which]);
  }
#line 1565
  kseq_destroy(ks);
#line 1566
  gzclose(fp);
#line 1567
  return (0);
}
}
#line 1576 "seqtk.c"
static void fqc_aux(posstat_t *p , int pos , int64_t *allq , double *perr , int qthres ) 
{ 
  int k ;
  int64_t sum ;
  int64_t qsum ;
  int64_t sum_low ;
  double psum ;
  double tmp ;

  {
#line 1579
  sum = (int64_t )0;
#line 1579
  qsum = (int64_t )0;
#line 1579
  sum_low = (int64_t )0;
#line 1580
  psum = (double )0;
#line 1581
  if (pos <= 0) {
#line 1581
    printf((char const   * __restrict  )"ALL");
  } else {
#line 1582
    printf((char const   * __restrict  )"%d", pos);
  }
#line 1583
  k = 0;
#line 1583
  while (k <= 4) {
#line 1583
    sum += p->b[k];
#line 1583
    k ++;
  }
#line 1584
  printf((char const   * __restrict  )"\t%lld", sum);
#line 1585
  k = 0;
#line 1585
  while (k <= 4) {
#line 1586
    printf((char const   * __restrict  )"\t%.1f", (100. * (double )p->b[k]) / (double )sum);
#line 1585
    k ++;
  }
#line 1587
  k = 0;
#line 1587
  while (k <= 93) {
#line 1588
    qsum += p->q[k] * (int64_t )k;
#line 1588
    psum += (double )p->q[k] * *(perr + k);
#line 1589
    if (k < qthres) {
#line 1589
      sum_low += p->q[k];
    }
#line 1587
    k ++;
  }
#line 1591
  tmp = log((psum + 1e-6) / ((double )sum + 1e-6));
#line 1591
  printf((char const   * __restrict  )"\t%.1f\t%.1f", (double )qsum / (double )sum,
         - 4.343 * tmp);
#line 1592
  if (qthres <= 0) {
#line 1593
    k = 0;
#line 1593
    while (k <= 93) {
#line 1594
      if (*(allq + k) > 0LL) {
#line 1594
        printf((char const   * __restrict  )"\t%.2f", (100. * (double )p->q[k]) / (double )sum);
      }
#line 1593
      k ++;
    }
  } else {
#line 1595
    printf((char const   * __restrict  )"\t%.1f\t%.1f", (100. * (double )sum_low) / (double )sum,
           (100. * (double )(sum - sum_low)) / (double )sum);
  }
#line 1596
  putchar('\n');
#line 1597
  return;
}
}
#line 1599 "seqtk.c"
int stk_fqchk(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int i ;
  int c ;
  int k ;
  int max_len ;
  int min_len ;
  int max_alloc ;
  int offset ;
  int n_diffQ ;
  int qthres ;
  int64_t tot_len ;
  int64_t n ;
  double perr[94] ;
  posstat_t all ;
  posstat_t *pos ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int old_max ;
  void *tmp___4 ;
  int q ;
  int b ;
  int tmp___5 ;

  {
#line 1603
  max_len = 0;
#line 1603
  min_len = 0x7fffffff;
#line 1603
  max_alloc = 0;
#line 1603
  offset = 33;
#line 1603
  n_diffQ = 0;
#line 1603
  qthres = 20;
#line 1604
  tot_len = (int64_t )0;
#line 1604
  n = (int64_t )0;
#line 1606
  pos = (posstat_t *)0;
#line 1608
  while (1) {
#line 1608
    c = getopt(argc, (char **)argv, (char const   *)"q:");
#line 1608
    if (! (c >= 0)) {
#line 1608
      break;
    }
#line 1609
    if (c == 113) {
#line 1609
      qthres = atoi((char const   *)optarg);
    }
  }
#line 1611
  if (optind == argc) {
#line 1612
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: seqtk fqchk [-q %d] <in.fq>\n",
            qthres);
#line 1613
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Note: use -q0 to get the distribution of all quality values\n");
#line 1614
    return (1);
  }
#line 1616
  tmp___3 = strcmp((char const   *)*(argv + optind), (char const   *)"-");
#line 1616
  if (tmp___3 == 0) {
#line 1616
    tmp___0 = fileno((FILE *)stdin);
#line 1616
    tmp___1 = gzdopen(tmp___0, (char const   *)"r");
#line 1616
    fp = tmp___1;
  } else {
#line 1616
    tmp___2 = gzopen((char const   *)*(argv + optind), (char const   *)"r");
#line 1616
    fp = tmp___2;
  }
#line 1617
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
#line 1618
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[E::%s] failed to open the input file/stream.\n",
            "stk_fqchk");
#line 1619
    return (1);
  }
#line 1621
  seq = kseq_init(fp);
#line 1622
  k = 0;
#line 1622
  while (k <= 93) {
#line 1623
    perr[k] = pow(10., - .1 * (double )k);
#line 1622
    k ++;
  }
#line 1624
  perr[3] = .5;
#line 1624
  perr[2] = perr[3];
#line 1624
  perr[1] = perr[2];
#line 1624
  perr[0] = perr[1];
#line 1625
  while (1) {
#line 1625
    tmp___5 = kseq_read(seq);
#line 1625
    if (! (tmp___5 >= 0)) {
#line 1625
      break;
    }
#line 1626
    if (seq->qual.l == 0UL) {
#line 1626
      continue;
    }
#line 1627
    n ++;
#line 1628
    tot_len = (int64_t )((unsigned long long )tot_len + (unsigned long long )seq->seq.l);
#line 1629
    if ((size_t___0 )min_len < seq->seq.l) {
#line 1629
      min_len = min_len;
    } else {
#line 1629
      min_len = (int )seq->seq.l;
    }
#line 1630
    if ((size_t___0 )max_len > seq->seq.l) {
#line 1630
      max_len = max_len;
    } else {
#line 1630
      max_len = (int )seq->seq.l;
    }
#line 1631
    if (max_len > max_alloc) {
#line 1632
      old_max = max_alloc;
#line 1633
      max_alloc = max_len;
#line 1634
      max_alloc --;
#line 1634
      max_alloc |= max_alloc >> 1;
#line 1634
      max_alloc |= max_alloc >> 2;
#line 1634
      max_alloc |= max_alloc >> 4;
#line 1634
      max_alloc |= max_alloc >> 8;
#line 1634
      max_alloc |= max_alloc >> 16;
#line 1634
      max_alloc ++;
#line 1635
      tmp___4 = realloc((void *)pos, (unsigned long )max_alloc * sizeof(posstat_t ));
#line 1635
      pos = (posstat_t *)tmp___4;
#line 1636
      memset((void *)(pos + old_max), 0, (unsigned long )(max_alloc - old_max) * sizeof(posstat_t ));
    }
#line 1638
    i = 0;
#line 1638
    while ((size_t___0 )i < seq->qual.l) {
#line 1639
      q = (int )*(seq->qual.s + i) - offset;
#line 1640
      b = (int )seq_nt6_table[(int )*(seq->seq.s + i)];
#line 1641
      if (b) {
#line 1641
        b --;
      } else {
#line 1641
        b = 4;
      }
#line 1642
      if (q < 93) {
#line 1642
        q = q;
      } else {
#line 1642
        q = 93;
      }
#line 1643
      ((pos + i)->q[q]) ++;
#line 1644
      ((pos + i)->b[b]) ++;
#line 1638
      i ++;
    }
  }
#line 1647
  kseq_destroy(seq);
#line 1648
  gzclose(fp);
#line 1650
  memset((void *)(& all), 0, sizeof(posstat_t ));
#line 1651
  i = 0;
#line 1651
  while (i < max_len) {
#line 1652
    k = 0;
#line 1652
    while (k <= 93) {
#line 1653
      all.q[k] += (pos + i)->q[k];
#line 1652
      k ++;
    }
#line 1654
    k = 0;
#line 1654
    while (k <= 4) {
#line 1655
      all.b[k] += (pos + i)->b[k];
#line 1654
      k ++;
    }
#line 1651
    i ++;
  }
#line 1657
  n_diffQ = 0;
#line 1657
  k = n_diffQ;
#line 1657
  while (k <= 93) {
#line 1658
    if (all.q[k]) {
#line 1658
      n_diffQ ++;
    }
#line 1657
    k ++;
  }
#line 1659
  printf((char const   * __restrict  )"min_len: %d; max_len: %d; avg_len: %.2f; %d distinct quality values\n",
         min_len, max_len, (double )tot_len / (double )n, n_diffQ);
#line 1660
  printf((char const   * __restrict  )"POS\t#bases\t%%A\t%%C\t%%G\t%%T\t%%N\tavgQ\terrQ");
#line 1661
  if (qthres <= 0) {
#line 1662
    k = 0;
#line 1662
    while (k <= 93) {
#line 1663
      if (all.q[k] > 0LL) {
#line 1663
        printf((char const   * __restrict  )"\t%%Q%d", k);
      }
#line 1662
      k ++;
    }
  } else {
#line 1664
    printf((char const   * __restrict  )"\t%%low\t%%high");
  }
#line 1665
  putchar('\n');
#line 1666
  fqc_aux(& all, 0, (int64_t *)(all.q), (double *)(perr), qthres);
#line 1667
  i = 0;
#line 1667
  while (i < max_len) {
#line 1668
    fqc_aux(pos + i, i + 1, (int64_t *)(all.q), (double *)(perr), qthres);
#line 1667
    i ++;
  }
#line 1669
  free((void *)pos);
#line 1670
  return (0);
}
}
#line 1674 "seqtk.c"
static int usage(void) 
{ 


  {
#line 1676
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 1677
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage:   seqtk <command> <arguments>\n");
#line 1678
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Version: 1.3-r106\n\n");
#line 1679
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Command: seq       common transformation of FASTA/Q\n");
#line 1680
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         comp      get the nucleotide composition of FASTA/Q\n");
#line 1681
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         sample    subsample sequences\n");
#line 1682
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         subseq    extract subsequences from FASTA/Q\n");
#line 1683
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         fqchk     fastq QC (base/quality summary)\n");
#line 1684
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         mergepe   interleave two PE FASTA/Q files\n");
#line 1685
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         trimfq    trim FASTQ using the Phred algorithm\n\n");
#line 1686
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         hety      regional heterozygosity\n");
#line 1687
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         gc        identify high- or low-GC regions\n");
#line 1688
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         mutfa     point mutate FASTA at specified positions\n");
#line 1689
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         mergefa   merge two FASTA/Q files\n");
#line 1690
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         famask    apply a X-coded FASTA to a source FASTA\n");
#line 1691
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         dropse    drop unpaired from interleaved PE FASTA/Q\n");
#line 1692
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         rename    rename sequence names\n");
#line 1693
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         randbase  choose a random base from hets\n");
#line 1694
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         cutN      cut sequence at long N\n");
#line 1695
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"         listhet   extract the position of each het\n");
#line 1696
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 1697
  return (1);
}
}
#line 1700 "seqtk.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 1702
  optind = 1;
#line 1703
  if (argc == 1) {
#line 1703
    tmp = usage();
#line 1703
    return (tmp);
  }
#line 1704
  tmp___37 = strcmp((char const   *)*(argv + 1), (char const   *)"comp");
#line 1704
  if (tmp___37 == 0) {
#line 1704
    tmp___0 = stk_comp(argc - 1, argv + 1);
#line 1704
    return (tmp___0);
  } else {
#line 1705
    tmp___36 = strcmp((char const   *)*(argv + 1), (char const   *)"fqchk");
#line 1705
    if (tmp___36 == 0) {
#line 1705
      tmp___1 = stk_fqchk(argc - 1, argv + 1);
#line 1705
      return (tmp___1);
    } else {
#line 1706
      tmp___35 = strcmp((char const   *)*(argv + 1), (char const   *)"hety");
#line 1706
      if (tmp___35 == 0) {
#line 1706
        tmp___2 = stk_hety(argc - 1, argv + 1);
#line 1706
        return (tmp___2);
      } else {
#line 1707
        tmp___34 = strcmp((char const   *)*(argv + 1), (char const   *)"gc");
#line 1707
        if (tmp___34 == 0) {
#line 1707
          tmp___3 = stk_gc(argc - 1, argv + 1);
#line 1707
          return (tmp___3);
        } else {
#line 1708
          tmp___33 = strcmp((char const   *)*(argv + 1), (char const   *)"subseq");
#line 1708
          if (tmp___33 == 0) {
#line 1708
            tmp___4 = stk_subseq(argc - 1, argv + 1);
#line 1708
            return (tmp___4);
          } else {
#line 1709
            tmp___32 = strcmp((char const   *)*(argv + 1), (char const   *)"mutfa");
#line 1709
            if (tmp___32 == 0) {
#line 1709
              tmp___5 = stk_mutfa(argc - 1, argv + 1);
#line 1709
              return (tmp___5);
            } else {
#line 1710
              tmp___31 = strcmp((char const   *)*(argv + 1), (char const   *)"mergefa");
#line 1710
              if (tmp___31 == 0) {
#line 1710
                tmp___6 = stk_mergefa(argc - 1, argv + 1);
#line 1710
                return (tmp___6);
              } else {
#line 1711
                tmp___30 = strcmp((char const   *)*(argv + 1), (char const   *)"mergepe");
#line 1711
                if (tmp___30 == 0) {
#line 1711
                  tmp___7 = stk_mergepe(argc - 1, argv + 1);
#line 1711
                  return (tmp___7);
                } else {
#line 1712
                  tmp___29 = strcmp((char const   *)*(argv + 1), (char const   *)"dropse");
#line 1712
                  if (tmp___29 == 0) {
#line 1712
                    tmp___8 = stk_dropse(argc - 1, argv + 1);
#line 1712
                    return (tmp___8);
                  } else {
#line 1713
                    tmp___28 = strcmp((char const   *)*(argv + 1), (char const   *)"randbase");
#line 1713
                    if (tmp___28 == 0) {
#line 1713
                      tmp___9 = stk_randbase(argc - 1, argv + 1);
#line 1713
                      return (tmp___9);
                    } else {
#line 1714
                      tmp___27 = strcmp((char const   *)*(argv + 1), (char const   *)"cutN");
#line 1714
                      if (tmp___27 == 0) {
#line 1714
                        tmp___10 = stk_cutN(argc - 1, argv + 1);
#line 1714
                        return (tmp___10);
                      } else {
#line 1715
                        tmp___26 = strcmp((char const   *)*(argv + 1), (char const   *)"listhet");
#line 1715
                        if (tmp___26 == 0) {
#line 1715
                          tmp___11 = stk_listhet(argc - 1, argv + 1);
#line 1715
                          return (tmp___11);
                        } else {
#line 1716
                          tmp___25 = strcmp((char const   *)*(argv + 1), (char const   *)"famask");
#line 1716
                          if (tmp___25 == 0) {
#line 1716
                            tmp___12 = stk_famask(argc - 1, argv + 1);
#line 1716
                            return (tmp___12);
                          } else {
#line 1717
                            tmp___24 = strcmp((char const   *)*(argv + 1), (char const   *)"trimfq");
#line 1717
                            if (tmp___24 == 0) {
#line 1717
                              tmp___13 = stk_trimfq(argc - 1, argv + 1);
#line 1717
                              return (tmp___13);
                            } else {
#line 1718
                              tmp___23 = strcmp((char const   *)*(argv + 1), (char const   *)"hrun");
#line 1718
                              if (tmp___23 == 0) {
#line 1718
                                tmp___14 = stk_hrun(argc - 1, argv + 1);
#line 1718
                                return (tmp___14);
                              } else {
#line 1719
                                tmp___22 = strcmp((char const   *)*(argv + 1), (char const   *)"sample");
#line 1719
                                if (tmp___22 == 0) {
#line 1719
                                  tmp___15 = stk_sample(argc - 1, argv + 1);
#line 1719
                                  return (tmp___15);
                                } else {
#line 1720
                                  tmp___21 = strcmp((char const   *)*(argv + 1), (char const   *)"seq");
#line 1720
                                  if (tmp___21 == 0) {
#line 1720
                                    tmp___16 = stk_seq(argc - 1, argv + 1);
#line 1720
                                    return (tmp___16);
                                  } else {
#line 1721
                                    tmp___20 = strcmp((char const   *)*(argv + 1),
                                                      (char const   *)"kfreq");
#line 1721
                                    if (tmp___20 == 0) {
#line 1721
                                      tmp___17 = stk_kfreq(argc - 1, argv + 1);
#line 1721
                                      return (tmp___17);
                                    } else {
#line 1722
                                      tmp___19 = strcmp((char const   *)*(argv + 1),
                                                        (char const   *)"rename");
#line 1722
                                      if (tmp___19 == 0) {
#line 1722
                                        tmp___18 = stk_rename(argc - 1, argv + 1);
#line 1722
                                        return (tmp___18);
                                      } else {
#line 1724
                                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[main] unrecognized command \'%s\'. Abort!\n",
                                                *(argv + 1));
#line 1725
                                        return (1);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
