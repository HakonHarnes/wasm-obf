
/* Generated by Tigress v3.2 (https://tigress.wtf), 07:50:46-2023/04/23 */


/*
BEGIN-UNIVERSE
{
  "Not added to universe": [
    "__sync_and_and_fetch", "__sync_fetch_and_or", "__atomic_or_fetch",
    "__atomic_nand_fetch_8", "__atomic_fetch_and", "__atomic_xor_fetch_16",
    "__atomic_fetch_nand_16", "__atomic_sub_fetch_1", "__atomic_fetch_or",
    "__sync_synchronize", "__sync_or_and_fetch", "__atomic_nand_fetch_4",
    "__atomic_sub_fetch_4", "__atomic_compare_exchange_n",
    "__sync_add_and_fetch", "__atomic_signal_fence", "__atomic_fetch_nand_1",
    "__atomic_and_fetch_16", "__sync_fetch_and_nand", "__atomic_xor_fetch_8",
    "__atomic_xor_fetch_2", "__atomic_thread_fence", "__atomic_store_16",
    "__atomic_fetch_and_8", "__atomic_and_fetch_2", "__atomic_test_and_set",
    "__atomic_fetch_add_8", "__atomic_fetch_nand", "__atomic_exchange_16",
    "__atomic_clear", "__atomic_store", "__atomic_add_fetch_2",
    "__atomic_fetch_xor_1", "__atomic_and_fetch",
    "__atomic_compare_exchange_4", "__sync_sub_and_fetch",
    "__sync_nand_and_fetch", "__atomic_load_16", "__atomic_always_lock_free",
    "__atomic_nand_fetch_16", "__sync_xor_and_fetch", "__atomic_fetch_xor_8",
    "__atomic_exchange_8", "__atomic_exchange_1", "__sync_fetch_and_and",
    "__atomic_feraiseexcept", "__atomic_and_fetch_4", "__atomic_or_fetch_8",
    "__atomic_or_fetch_4", "__atomic_or_fetch_1", "__atomic_fetch_and_2",
    "__sync_lock_release", "__atomic_fetch_nand_8", "__atomic_fetch_add",
    "__atomic_nand_fetch_1", "__atomic_fetch_nand_2", "__atomic_load_n",
    "__atomic_compare_exchange_16", "__atomic_exchange_n",
    "__atomic_fetch_or_1", "__atomic_fetch_or_8", "__atomic_fetch_add_1",
    "__atomic_fetch_sub_1", "__atomic_fetch_or_4", "__atomic_load_2",
    "__atomic_store_2", "__atomic_exchange_4", "__sync_fetch_and_xor",
    "__atomic_fetch_sub_4", "__atomic_fetch_and_4",
    "__atomic_compare_exchange", "__atomic_load_1",
    "__atomic_compare_exchange_1", "__atomic_fetch_xor_2", "__atomic_load",
    "__atomic_or_fetch_16", "__atomic_add_fetch_16",
    "__sync_val_compare_and_swap", "__atomic_store_4",
    "__atomic_fetch_and_1", "__atomic_fetch_nand_4", "__atomic_fetch_add_16",
    "__atomic_compare_exchange_2", "__atomic_exchange",
    "__atomic_sub_fetch_8", "__atomic_fetch_sub_16", "__atomic_exchange_2",
    "__atomic_sub_fetch_2", "__atomic_fetch_xor_16", "__atomic_fetch_or_16",
    "__atomic_load_4", "__atomic_store_n", "__atomic_fetch_add_4",
    "__atomic_nand_fetch_2", "__sync_lock_test_and_set",
    "__atomic_sub_fetch", "__atomic_fetch_and_16",
    "__atomic_compare_exchange_8", "__atomic_nand_fetch", "__atomic_load_8",
    "__atomic_xor_fetch_4", "__atomic_fetch_sub_2", "__atomic_add_fetch",
    "__atomic_store_8", "__atomic_xor_fetch", "__sync_fetch_and_add",
    "__atomic_or_fetch_2", "__atomic_add_fetch_1", "__atomic_fetch_xor",
    "__atomic_add_fetch_8", "__atomic_fetch_xor_4", "__atomic_fetch_sub_8",
    "__sync_bool_compare_and_swap", "__atomic_and_fetch_1",
    "__atomic_store_1", "__atomic_xor_fetch_1", "__atomic_fetch_or_2",
    "__atomic_sub_fetch_16", "__sync_fetch_and_sub", "__atomic_fetch_add_2",
    "__atomic_is_lock_free", "__atomic_and_fetch_8", "__atomic_fetch_sub",
    "__atomic_add_fetch_4", "kr_rand"
  ],
  "Transformations": [
    { "TransformationNumber": 3, "TransformationKind": "AntiAliasAnalysis",
    "TransformationUpdates": {
      "Modified Function Implementations": [
        "stk_reg_read", "stk_reg_destroy", "stk_mask", "kseq_read",
        "kseq_init", "kseq_destroy", "ks_init", "ks_getuntil2",
        "ks_getuntil", "ks_getc", "ks_destroy", "kr_srand", "kr_rand",
        "kh_resize_reg", "kh_resize_64", "kh_put_reg", "kh_init_reg",
        "kh_init_64", "kh_get_reg", "kh_destroy_reg", "kh_destroy_64",
        "fqc_aux", "cpy_kstr", "cpy_kseq"
      ],
      "New Global Variables": { "_3__functionPtrArray": "INIT" }
    } }, { "TransformationNumber": 2, "TransformationKind": "InitEntropy",
    "TransformationUpdates": {
      "New Global Variables": {
        "_2_alwaysZero": "INIT",
        "_2_entropy": "INIT"
      }
    } }, { "TransformationNumber": 1, "TransformationKind": "InitOpaque",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ],
      "New Global Variables": {
        "_1_main_1_opaque_ptr_2": "INIT",
        "_1_main_1_opaque_list_2": "INIT",
        "_1_main_1_opaque_ptr_1": "INIT",
        "_1_main_1_opaque_list_1": "INIT"
      },
      "New Types": [
        "_1_main_1_opaque_StructureType", "_1_main_1_opaque_NodeStruct"
      ]
    } }, { "TransformationNumber": 0, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ],
      "New Global Variables": {
        "_global_envp": "FUN: '_global_envp_i$nit'",
        "_global_argv": "FUN: '_global_argv_i$nit'",
        "_global_argc": "FUN: '_global_argc_i$nit'"
      }
    } }, { "TransformationNumber": -1, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "New Functions": [
        "main", "usage", "stk_fqchk", "fqc_aux", "stk_kfreq", "stk_rename",
        "stk_dropse", "stk_mergepe", "stk_gc", "stk_seq", "stk_mask",
        "stk_sample", "cpy_kseq", "cpy_kstr", "stk_hrun", "stk_cutN",
        "print_seq", "find_next_cut", "stk_listhet", "stk_mutfa",
        "stk_famask", "stk_mergefa", "stk_subseq", "stk_hety",
        "stk_randbase", "stk_comp", "stk_trimfq", "kr_rand", "kr_srand",
        "kr_srand0", "stk_printseq", "stk_printseq_renamed", "stk_printstr",
        "stk_reg_destroy", "stk_reg_read", "kh_put_64", "kh_resize_64",
        "kh_get_64", "kh_destroy_64", "kh_init_64", "kh_put_reg",
        "kh_resize_reg", "kh_get_reg", "kh_destroy_reg", "kh_init_reg",
        "__ac_X31_hash_string", "kseq_read", "kseq_destroy", "kseq_init",
        "ks_getuntil", "ks_getuntil2", "ks_getc", "ks_destroy", "ks_init"
      ],
      "New Global Variables": {
        "cutN_nonN_penalty": "FUN: 'cutN_nonN_penalty_i$nit'",
        "cutN_min_N_tract": "FUN: 'cutN_min_N_tract_i$nit'",
        "mag01": "FUN: 'mag01_i$nit'",
        "comp_tab": "FUN: 'comp_tab_i$nit'",
        "bitcnt_table": "FUN: 'bitcnt_table_i$nit'",
        "seq_nt16comp_table": "FUN: 'seq_nt16comp_table_i$nit'",
        "seq_nt16to4_table": "FUN: 'seq_nt16to4_table_i$nit'",
        "seq_nt16_rev_table": "FUN: 'seq_nt16_rev_table_i$nit'",
        "seq_nt6_table": "FUN: 'seq_nt6_table_i$nit'",
        "seq_nt16_table": "FUN: 'seq_nt16_table_i$nit'",
        "__ac_HASH_UPPER": "FUN: '__ac_HASH_UPPER_i$nit'"
      },
      "New Externs": [
        "__builtin_va_copy", "__builtin_frob_return_address",
        "__builtin_popcountll", "__builtin_atanf", "__builtin_ia32_addps",
        "__builtin_strcspn", "__builtin_asinf", "__builtin_ia32_maxps",
        "__builtin_ia32_unpckhps", "__builtin_acos",
        "__builtin___sprintf_chk", "__builtin_cosh", "__builtin_tanhf",
        "__builtin_mempcpy", "__builtin_sqrtl", "__builtin_parity",
        "__builtin_coshl", "__builtin_cosl", "__builtin_cosf",
        "__builtin_acosl", "__builtin___mempcpy_chk", "__builtin_clz",
        "__builtin_log10", "__builtin___strcat_chk", "__builtin_modff",
        "__builtin_sin", "__builtin_frexp", "__builtin_acosf",
        "__builtin_sinhl", "__builtin___stpcpy_chk", "__builtin_fabs",
        "__builtin_va_start", "__builtin_bswap16", "__builtin_ctz",
        "__builtin_strpbrk", "__builtin_strcpy", "__builtin_sqrt",
        "__builtin_next_arg", "__builtin_log10f", "__builtin_fabsl",
        "__builtin_floorl", "__builtin_floorf", "__builtin_memcpy",
        "__builtin_ia32_subps", "__builtin_parityll", "__builtin_va_end",
        "__builtin_bzero", "__builtin_strncmp", "__builtin___vsprintf_chk",
        "__builtin_sqrtf", "__builtin_nans", "__builtin_exp",
        "__builtin_strcmp", "__builtin_ldexpf", "__builtin_powif",
        "__builtin_log10l", "__builtin___memmove_chk",
        "__builtin_return_address", "__builtin_fabsf",
        "__builtin_object_size", "__builtin_alloca",
        "__builtin_va_arg_pack_len", "__builtin_tanl", "__builtin_modfl",
        "__builtin_stpcpy", "__builtin_sinl", "__builtin_asin",
        "__builtin_sinhf", "__builtin_ctzl", "__builtin_tanhl",
        "__builtin_bswap64", "__builtin_ia32_mulps", "__builtin_tan",
        "__builtin_strncpy", "__builtin_inff", "__builtin___memset_chk",
        "__builtin_huge_val", "__builtin_clzl", "__builtin_frexpf",
        "__builtin_fmodl", "__builtin_atan", "__builtin___fprintf_chk",
        "__builtin_ceilf", "__builtin_return", "__builtin_asinl",
        "__builtin_ffsll", "__builtin_va_arg_pack",
        "__builtin___strncpy_chk", "__builtin_powi", "__builtin_strchr",
        "__builtin___strncat_chk", "__builtin_huge_vall", "__builtin_ffsl",
        "__builtin___vprintf_chk", "__builtin_ia32_unpcklps",
        "__builtin_strncat", "__builtin_ctzll", "__builtin_stdarg_start",
        "__builtin_frexpl", "__builtin_tanf", "__builtin_logl",
        "__builtin_va_arg", "__builtin_expect", "__builtin___printf_chk",
        "__builtin___vfprintf_chk", "__builtin_prefetch", "__builtin_nansl",
        "__builtin_fmod", "__builtin_tanh", "__builtin_unreachable",
        "__builtin_ldexpl", "__builtin_apply", "__builtin_sinf",
        "__builtin_ceil", "__builtin_powil", "__builtin_expl",
        "__builtin_constant_p", "__builtin_log", "__builtin_expf",
        "__builtin_types_compatible_p", "__builtin_atan2l",
        "__builtin_apply_args", "__builtin_logf", "__builtin_strlen",
        "__builtin_ffs", "__builtin_inf", "__builtin___memcpy_chk",
        "__builtin_trap", "__builtin_parityl", "__builtin_strspn",
        "__builtin_varargs_start", "__builtin_nan",
        "__builtin___snprintf_chk", "__builtin_atanl", "__builtin_clzll",
        "__builtin_huge_valf", "__builtin_coshf", "__builtin_nansf",
        "__builtin___vsnprintf_chk", "__builtin_nanf", "__builtin_atan2",
        "__builtin_popcountl", "__builtin_ceill", "__builtin___strcpy_chk",
        "__builtin_floor", "__builtin_cos", "__builtin_memset",
        "__builtin_nanl", "__builtin_atan2f", "__builtin_popcount",
        "__builtin_sinh", "__builtin_bcopy", "__builtin_extract_return_addr",
        "__builtin_bswap32", "__builtin_ldexp", "__builtin_infl",
        "__builtin_fmodf", "__builtin_frame_address", "getloadavg", "atoi",
        "atol", "atoll", "atof", "strtof", "strtod", "strtold", "strtol",
        "strtoul", "strtoll", "strtoull", "rand", "srand", "malloc",
        "calloc", "realloc", "free", "aligned_alloc", "abort", "atexit",
        "exit", "_Exit", "at_quick_exit", "quick_exit", "getenv", "system",
        "bsearch", "qsort", "abs", "labs", "llabs", "div", "ldiv", "lldiv",
        "mblen", "mbtowc", "wctomb", "mbstowcs", "wcstombs",
        "__ctype_get_mb_cur_max", "posix_memalign", "setenv", "unsetenv",
        "mkstemp", "mkostemp", "mkdtemp", "getsubopt", "rand_r", "realpath",
        "random", "srandom", "initstate", "setstate", "putenv",
        "posix_openpt", "grantpt", "unlockpt", "ptsname", "l64a", "a64l",
        "setkey", "drand48", "erand48", "lrand48", "nrand48", "mrand48",
        "jrand48", "srand48", "seed48", "lcong48", "alloca", "mktemp",
        "mkstemps", "mkostemps", "valloc", "memalign", "clearenv",
        "reallocarray", "qsort_r", "stdin", "stdout", "stderr", "fflush",
        "fwrite", "fputc", "putchar", "fputs", "puts", "printf", "fprintf",
        "fileno", "isalpha", "isdigit", "islower", "isspace", "isupper",
        "tolower", "toupper", "isatty", "getopt", "optarg", "optind",
        "gzdopen", "gzread", "gzclose", "gzopen", "memcpy", "memset",
        "strcmp", "strncmp", "strlen", "strdup", "__assert_fail", "log",
        "pow"
      ],
      "New Types": [
        "posstat_t", "__anonstruct_posstat_t_390825615", "_krand_t",
        "krand_t", "_krand_t", "krint64_t", "reghash_t", "kh_64_t",
        "__anonstruct_kh_64_t_789978953", "kh_reg_t",
        "__anonstruct_kh_reg_t_369956422", "kh_cstr_t", "khiter_t",
        "khint_t", "khint64_t", "khint32_t", "reglist_t",
        "__anonstruct_reglist_t_947739297", "kseq_t",
        "__anonstruct_kseq_t_745567265", "kstream_t", "__kstream_t",
        "kstring_t", "__kstring_t", "gzFile_s", "gzFile", "gzFile_s",
        "voidp", "FILE", "_IO_FILE", "off_t", "size_t___0", "uint64_t",
        "uint32_t", "int64_t", "int8_t", "lldiv_t",
        "__anonstruct_lldiv_t_989260392", "ldiv_t",
        "__anonstruct_ldiv_t_721778306", "div_t",
        "__anonstruct_div_t_109580352", "size_t", "wchar_t"
      ]
    } }
  ]
}
END-UNIVERSE
*/


/* BEGIN STRUCT-DECL gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */
struct gzFile_s ;
/* END STRUCT-DECL gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */

/* BEGIN STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
struct _IO_FILE ;
/* END STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN STRUCT-DECL _krand_t LOC=seqtk.c:220 */
struct _krand_t ;
/* END STRUCT-DECL _krand_t LOC=seqtk.c:220 */

/* BEGIN STRUCT-DECL __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */
struct __anonstruct_kh_reg_t_369956422 ;
/* END STRUCT-DECL __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */

/* BEGIN STRUCT-DECL __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */
struct __anonstruct_posstat_t_390825615 ;
/* END STRUCT-DECL __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */

/* BEGIN STRUCT-DECL __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */
struct __anonstruct_reglist_t_947739297 ;
/* END STRUCT-DECL __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */

/* BEGIN STRUCT-DECL __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
struct __anonstruct_ldiv_t_721778306 ;
/* END STRUCT-DECL __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN STRUCT-DECL _1_main_1_opaque_NodeStruct LOC=UNKNOWN */
struct _1_main_1_opaque_NodeStruct ;
/* END STRUCT-DECL _1_main_1_opaque_NodeStruct LOC=UNKNOWN */

/* BEGIN STRUCT-DECL __kstring_t LOC=./kseq.h:83 */
struct __kstring_t ;
/* END STRUCT-DECL __kstring_t LOC=./kseq.h:83 */

/* BEGIN STRUCT-DECL __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
struct __anonstruct_div_t_109580352 ;
/* END STRUCT-DECL __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN STRUCT-DECL __kstream_t LOC=seqtk.c:39 */
struct __kstream_t ;
/* END STRUCT-DECL __kstream_t LOC=seqtk.c:39 */

/* BEGIN STRUCT-DECL __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */
struct __anonstruct_kh_64_t_789978953 ;
/* END STRUCT-DECL __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */

/* BEGIN STRUCT-DECL __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */
struct __anonstruct_kseq_t_745567265 ;
/* END STRUCT-DECL __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */

/* BEGIN STRUCT-DECL __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
struct __anonstruct_lldiv_t_989260392 ;
/* END STRUCT-DECL __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN FUNCTION-DECL __builtin_strchr LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* END FUNCTION-DECL __builtin_strchr LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ctz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ctz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */
extern int isdigit(int  ) ;
/* END FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */

/* BEGIN FUNCTION-DECL stk_trimfq LOC=UNKNOWN */
int stk_trimfq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_trimfq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:132 */
extern long mrand48(void) ;
/* END FUNCTION-DECL-EXTERN mrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:132 */

/* BEGIN FUNCTION-DECL __builtin_acosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_acosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */

/* BEGIN TYPEDEF size_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t;
/* END TYPEDEF size_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN FUNCTION-DECL-EXTERN qsort_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:151 */
extern void qsort_r(void * , size_t  , size_t  , int (*)(void const   * , void const   * ,
                                                         void * ) , void * ) ;
/* END FUNCTION-DECL-EXTERN qsort_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:151 */

/* BEGIN FUNCTION-DECL __builtin_acosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_acosf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* END FUNCTION-DECL __builtin_sinh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lcong48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:136 */
extern void lcong48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN lcong48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:136 */

/* BEGIN STRUCT _1_main_1_opaque_NodeStruct LOC=UNKNOWN */
struct _1_main_1_opaque_NodeStruct {
   struct _1_main_1_opaque_NodeStruct *prev ;
   int data ;
   struct _1_main_1_opaque_NodeStruct *next ;
};
/* END STRUCT _1_main_1_opaque_NodeStruct LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _1_main_1_opaque_list_2 LOC=UNKNOWN */
struct _1_main_1_opaque_NodeStruct *_1_main_1_opaque_list_2  =    (struct _1_main_1_opaque_NodeStruct *)0;
/* END VARIABLE-DEF _1_main_1_opaque_list_2 LOC=UNKNOWN */

/* BEGIN TYPEDEF kh_reg_t LOC=seqtk.c:47 */
typedef struct __anonstruct_kh_reg_t_369956422 kh_reg_t;
/* END TYPEDEF kh_reg_t LOC=seqtk.c:47 */

/* BEGIN TYPEDEF kseq_t LOC=seqtk.c:39 */
typedef struct __anonstruct_kseq_t_745567265 kseq_t;
/* END TYPEDEF kseq_t LOC=seqtk.c:39 */

/* BEGIN FUNCTION-DECL stk_mask LOC=UNKNOWN */
void stk_mask(kseq_t *seq , kh_reg_t const   *h , int is_complement , int mask_chr ) ;
/* END FUNCTION-DECL stk_mask LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_argc LOC=UNKNOWN */
int _global_argc  ;
/* END VARIABLE-DEF _global_argc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* END FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_trap LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* END FUNCTION-DECL __builtin_trap LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* END FUNCTION-DECL __builtin_cosh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* END FUNCTION-DECL __builtin_log10f LOC=BUILTIN */

/* BEGIN TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
typedef struct _IO_FILE FILE;
/* END TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */
extern int fputs(char const   * __restrict   , FILE * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */

/* BEGIN FUNCTION-DECL stk_sample LOC=UNKNOWN */
int stk_sample(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_sample LOC=UNKNOWN */

/* BEGIN TYPEDEF reglist_t LOC=seqtk.c:41 */
typedef struct __anonstruct_reglist_t_947739297 reglist_t;
/* END TYPEDEF reglist_t LOC=seqtk.c:41 */

/* BEGIN TYPEDEF kh_cstr_t LOC=./khash.h:532 */
typedef char const   *kh_cstr_t;
/* END TYPEDEF kh_cstr_t LOC=./khash.h:532 */

/* BEGIN TYPEDEF khint32_t LOC=./khash.h:122 */
typedef unsigned int khint32_t;
/* END TYPEDEF khint32_t LOC=./khash.h:122 */

/* BEGIN TYPEDEF khint_t LOC=./khash.h:137 */
typedef khint32_t khint_t;
/* END TYPEDEF khint_t LOC=./khash.h:137 */

/* BEGIN STRUCT __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */
struct __anonstruct_kh_reg_t_369956422 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   kh_cstr_t *keys ;
   reglist_t *vals ;
};
/* END STRUCT __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */

/* BEGIN TYPEDEF reghash_t LOC=seqtk.c:50 */
typedef kh_reg_t reghash_t;
/* END TYPEDEF reghash_t LOC=seqtk.c:50 */

/* BEGIN FUNCTION-DECL stk_reg_destroy LOC=UNKNOWN */
void stk_reg_destroy(reghash_t *h ) ;
/* END FUNCTION-DECL stk_reg_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mkstemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:104 */
extern int mkstemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mkstemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:104 */

/* BEGIN FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN __ctype_get_mb_cur_max LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:81 */
extern size_t __ctype_get_mb_cur_max(void) ;
/* END FUNCTION-DECL-EXTERN __ctype_get_mb_cur_max LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:81 */

/* BEGIN STRUCT __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
struct __anonstruct_div_t_109580352 {
   int quot ;
   int rem ;
};
/* END STRUCT __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN FUNCTION-DECL-EXTERN a64l LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:126 */
extern long a64l(char const   * ) ;
/* END FUNCTION-DECL-EXTERN a64l LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:126 */

/* BEGIN FUNCTION-DECL __builtin_acos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* END FUNCTION-DECL __builtin_acos LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_listhet LOC=UNKNOWN */
int stk_listhet(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_listhet LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mkostemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:143 */
extern int mkostemps(char * , int  , int  ) ;
/* END FUNCTION-DECL-EXTERN mkostemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:143 */

/* BEGIN VARIABLE-DEF _1_main_1_opaque_list_1 LOC=UNKNOWN */
struct _1_main_1_opaque_NodeStruct *_1_main_1_opaque_list_1  =    (struct _1_main_1_opaque_NodeStruct *)0;
/* END VARIABLE-DEF _1_main_1_opaque_list_1 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN abort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:46 */
extern void abort(void) ;
/* END FUNCTION-DECL-EXTERN abort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:46 */

/* BEGIN FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */
extern int fprintf(FILE * __restrict   , char const   * __restrict    , ...) ;
/* END FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */

/* BEGIN FUNCTION-DECL-EXTERN getloadavg LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h:8 */
extern int getloadavg(double *loadavg , int nelem ) ;
/* END FUNCTION-DECL-EXTERN getloadavg LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h:8 */

/* BEGIN FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_mergepe LOC=UNKNOWN */
int stk_mergepe(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_mergepe LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_parity LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_parity LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN at_quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:50 */
extern int at_quick_exit(void (*)(void) ) ;
/* END FUNCTION-DECL-EXTERN at_quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:50 */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN setenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:102 */
extern int setenv(char const   * , char const   * , int  ) ;
/* END FUNCTION-DECL-EXTERN setenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:102 */

/* BEGIN FUNCTION-DECL __builtin_cosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_cosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtod LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:29 */
extern double strtod(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtod LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:29 */

/* BEGIN FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */

/* BEGIN TYPEDEF khint64_t LOC=./khash.h:130 */
typedef unsigned long long khint64_t;
/* END TYPEDEF khint64_t LOC=./khash.h:130 */

/* BEGIN STRUCT __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */
struct __anonstruct_kh_64_t_789978953 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   khint64_t *keys ;
   char *vals ;
};
/* END STRUCT __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */

/* BEGIN FUNCTION-DECL-EXTERN fileno LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:152 */
extern int fileno(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fileno LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:152 */

/* BEGIN FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN __assert_fail LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h:19 */
extern  __attribute__((__noreturn__)) void __assert_fail(char const   * , char const   * ,
                                                         int  , char const   * ) ;
/* END FUNCTION-DECL-EXTERN __assert_fail LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h:19 */

/* BEGIN TYPEDEF uint64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:215 */
typedef unsigned long long uint64_t;
/* END TYPEDEF uint64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:215 */

/* BEGIN FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */

/* BEGIN TYPEDEF gzFile LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */
typedef struct gzFile_s *gzFile;
/* END TYPEDEF gzFile LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */

/* BEGIN TYPEDEF voidp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h:410 */
typedef void *voidp;
/* END TYPEDEF voidp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h:410 */

/* BEGIN FUNCTION-DECL-EXTERN gzread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1392 */
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
/* END FUNCTION-DECL-EXTERN gzread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1392 */

/* BEGIN FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */

/* BEGIN TYPEDEF int64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:190 */
typedef long long int64_t;
/* END TYPEDEF int64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:190 */

/* BEGIN TYPEDEF posstat_t LOC=seqtk.c:1572 */
typedef struct __anonstruct_posstat_t_390825615 posstat_t;
/* END TYPEDEF posstat_t LOC=seqtk.c:1572 */

/* BEGIN FUNCTION-DECL fqc_aux LOC=UNKNOWN */
static void fqc_aux(posstat_t *p , int pos , int64_t *allq , double *perr , int qthres ) ;
/* END FUNCTION-DECL fqc_aux LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_inff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* END FUNCTION-DECL __builtin_inff LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN unsetenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:103 */
extern int unsetenv(char const   * ) ;
/* END FUNCTION-DECL-EXTERN unsetenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:103 */

/* BEGIN FUNCTION-DECL __builtin_asin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* END FUNCTION-DECL __builtin_asin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN ptsname LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:124 */
extern char *ptsname(int  ) ;
/* END FUNCTION-DECL-EXTERN ptsname LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:124 */

/* BEGIN FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */
extern int isatty(int  ) ;
/* END FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */

/* BEGIN FUNCTION-DECL __builtin_object_size LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* END FUNCTION-DECL __builtin_object_size LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN rand_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:108 */
extern int rand_r(unsigned int * ) ;
/* END FUNCTION-DECL-EXTERN rand_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:108 */

/* BEGIN FUNCTION-DECL kseq_read LOC=UNKNOWN */
static int kseq_read(kseq_t *seq ) ;
/* END FUNCTION-DECL kseq_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN gzdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1342 */
extern gzFile gzdopen(int fd , char const   *mode ) ;
/* END FUNCTION-DECL-EXTERN gzdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1342 */

/* BEGIN FUNCTION-DECL __builtin_asinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_asinf LOC=BUILTIN */

/* BEGIN TYPEDEF wchar_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:38 */
typedef int wchar_t;
/* END TYPEDEF wchar_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:38 */

/* BEGIN FUNCTION-DECL-EXTERN wcstombs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:76 */
extern size_t wcstombs(char * __restrict   , wchar_t const   * __restrict   , size_t  ) ;
/* END FUNCTION-DECL-EXTERN wcstombs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:76 */

/* BEGIN FUNCTION-DECL-EXTERN atol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:24 */
extern long atol(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:24 */

/* BEGIN FUNCTION-DECL-EXTERN getopt LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:137 */
extern int getopt(int  , char ** , char const   * ) ;
/* END FUNCTION-DECL-EXTERN getopt LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:137 */

/* BEGIN FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */
extern int tolower(int  ) ;
/* END FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */

/* BEGIN FUNCTION-DECL-EXTERN mbstowcs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:75 */
extern size_t mbstowcs(wchar_t * __restrict   , char const   * __restrict   , size_t  ) ;
/* END FUNCTION-DECL-EXTERN mbstowcs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:75 */

/* BEGIN FUNCTION-DECL __builtin_coshl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_coshl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN malloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:40 */
extern void *malloc(unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN malloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:40 */

/* BEGIN FUNCTION-DECL stk_rename LOC=UNKNOWN */
int stk_rename(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_rename LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* END FUNCTION-DECL __builtin_tan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mkstemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:142 */
extern int mkstemps(char * , int  ) ;
/* END FUNCTION-DECL-EXTERN mkstemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:142 */

/* BEGIN FUNCTION-DECL-EXTERN atoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:25 */
extern long long atoll(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:25 */

/* BEGIN TYPEDEF kstream_t LOC=seqtk.c:39 */
typedef struct __kstream_t kstream_t;
/* END TYPEDEF kstream_t LOC=seqtk.c:39 */

/* BEGIN TYPEDEF kstring_t LOC=./kseq.h:83 */
typedef struct __kstring_t kstring_t;
/* END TYPEDEF kstring_t LOC=./kseq.h:83 */

/* BEGIN FUNCTION-DECL ks_getuntil LOC=UNKNOWN */
__inline static int ks_getuntil(kstream_t *ks , int delimiter , kstring_t *str , int *dret ) ;
/* END FUNCTION-DECL ks_getuntil LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_printseq_renamed LOC=UNKNOWN */
__inline static void stk_printseq_renamed(kseq_t const   *s , int line_len , char const   *prefix ,
                                          int64_t n ) ;
/* END FUNCTION-DECL stk_printseq_renamed LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN realpath LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:115 */
extern char *realpath(char const   * __restrict   , char * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN realpath LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:115 */

/* BEGIN TYPEDEF ldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
typedef struct __anonstruct_ldiv_t_721778306 ldiv_t;
/* END TYPEDEF ldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN FUNCTION-DECL-EXTERN l64a LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:125 */
extern char *l64a(long  ) ;
/* END FUNCTION-DECL-EXTERN l64a LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:125 */

/* BEGIN FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_seq LOC=UNKNOWN */
int stk_seq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_seq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* END FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */
struct __anonstruct_posstat_t_390825615 {
   int64_t q[94] ;
   int64_t b[5] ;
};
/* END STRUCT __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */

/* BEGIN FUNCTION-DECL kh_get_reg LOC=UNKNOWN */
__inline static khint_t kh_get_reg(kh_reg_t const   *h , kh_cstr_t key ) ;
/* END FUNCTION-DECL kh_get_reg LOC=UNKNOWN */

/* BEGIN TYPEDEF lldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
typedef struct __anonstruct_lldiv_t_989260392 lldiv_t;
/* END TYPEDEF lldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* END FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* END FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN getenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:53 */
extern char *getenv(char const   * ) ;
/* END FUNCTION-DECL-EXTERN getenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:53 */

/* BEGIN VARIABLE-DECL-EXTERN optind LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:139 */
extern int optind ;
/* END VARIABLE-DECL-EXTERN optind LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:139 */

/* BEGIN TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t___0;
/* END TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */
extern size_t___0 strlen(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */

/* BEGIN FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */
extern int isspace(int  ) ;
/* END FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */

/* BEGIN FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */
extern int strncmp(char const   * , char const   * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */

/* BEGIN TYPEDEF kh_64_t LOC=seqtk.c:48 */
typedef struct __anonstruct_kh_64_t_789978953 kh_64_t;
/* END TYPEDEF kh_64_t LOC=seqtk.c:48 */

/* BEGIN FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL ks_getuntil2 LOC=UNKNOWN */
static int ks_getuntil2(kstream_t *ks , int delimiter , kstring_t *str , int *dret ,
                        int append ) ;
/* END FUNCTION-DECL ks_getuntil2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN realloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:42 */
extern void *realloc(void * , unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN realloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:42 */

/* BEGIN FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* END FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN clearenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:147 */
extern int clearenv(void) ;
/* END FUNCTION-DECL-EXTERN clearenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:147 */

/* BEGIN FUNCTION-DECL __builtin_coshf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* END FUNCTION-DECL __builtin_coshf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL print_seq LOC=UNKNOWN */
static void print_seq(FILE *fpout , kseq_t const   *ks , int begin , int end ) ;
/* END FUNCTION-DECL print_seq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN grantpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:122 */
extern int grantpt(int  ) ;
/* END FUNCTION-DECL-EXTERN grantpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:122 */

/* BEGIN FUNCTION-DECL __builtin_floor LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* END FUNCTION-DECL __builtin_floor LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_modfl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* END FUNCTION-DECL __builtin_modfl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_infl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* END FUNCTION-DECL __builtin_infl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN erand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:129 */
extern double erand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN erand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:129 */

/* BEGIN VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */
extern FILE *stdout ;
/* END VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */

/* BEGIN FUNCTION-DECL stk_comp LOC=UNKNOWN */
int stk_comp(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_comp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN pow LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:307 */
extern double pow(double  , double  ) ;
/* END FUNCTION-DECL-EXTERN pow LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:307 */

/* BEGIN FUNCTION-DECL-EXTERN exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:48 */
extern void exit(int  ) ;
/* END FUNCTION-DECL-EXTERN exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:48 */

/* BEGIN FUNCTION-DECL kh_init_reg LOC=UNKNOWN */
__inline static kh_reg_t *kh_init_reg(void) ;
/* END FUNCTION-DECL kh_init_reg LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF seq_nt16comp_table LOC=UNKNOWN */
unsigned char seq_nt16comp_table[16]  ;
/* END VARIABLE-DEF seq_nt16comp_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_expf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* END FUNCTION-DECL __builtin_expf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN jrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:133 */
extern long jrand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN jrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:133 */

/* BEGIN FUNCTION-DECL __builtin_ffs LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ffs LOC=BUILTIN */

/* BEGIN STRUCT __kstream_t LOC=seqtk.c:39 */
struct __kstream_t {
   unsigned char *buf ;
   int begin ;
   int end ;
   int is_eof ;
   gzFile f ;
};
/* END STRUCT __kstream_t LOC=seqtk.c:39 */

/* BEGIN FUNCTION-DECL __builtin_nanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN abs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:60 */
extern int abs(int  ) ;
/* END FUNCTION-DECL-EXTERN abs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:60 */

/* BEGIN FUNCTION-DECL-EXTERN log LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:259 */
extern double log(double  ) ;
/* END FUNCTION-DECL-EXTERN log LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:259 */

/* BEGIN FUNCTION-DECL-EXTERN mbtowc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:73 */
extern int mbtowc(wchar_t * __restrict   , char const   * __restrict   , size_t  ) ;
/* END FUNCTION-DECL-EXTERN mbtowc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:73 */

/* BEGIN FUNCTION-DECL-EXTERN islower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:16 */
extern int islower(int  ) ;
/* END FUNCTION-DECL-EXTERN islower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:16 */

/* BEGIN FUNCTION-DECL __builtin_sin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* END FUNCTION-DECL __builtin_sin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN labs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:61 */
extern long labs(long  ) ;
/* END FUNCTION-DECL-EXTERN labs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:61 */

/* BEGIN FUNCTION-DECL-EXTERN srand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:38 */
extern void srand(unsigned int  ) ;
/* END FUNCTION-DECL-EXTERN srand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:38 */

/* BEGIN FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _1_main_1_opaque_ptr_2 LOC=UNKNOWN */
struct _1_main_1_opaque_NodeStruct *_1_main_1_opaque_ptr_2  =    (struct _1_main_1_opaque_NodeStruct *)0;
/* END VARIABLE-DEF _1_main_1_opaque_ptr_2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atexit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:47 */
extern int atexit(void (*)(void) ) ;
/* END FUNCTION-DECL-EXTERN atexit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:47 */

/* BEGIN VARIABLE-DEF seq_nt16_rev_table LOC=UNKNOWN */
char *seq_nt16_rev_table  ;
/* END VARIABLE-DEF seq_nt16_rev_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN system LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:55 */
extern int system(char const   * ) ;
/* END FUNCTION-DECL-EXTERN system LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:55 */

/* BEGIN FUNCTION-DECL kh_get_64 LOC=UNKNOWN */
__inline static khint_t kh_get_64(kh_64_t const   *h , khint64_t key ) ;
/* END FUNCTION-DECL kh_get_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN toupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:23 */
extern int toupper(int  ) ;
/* END FUNCTION-DECL-EXTERN toupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:23 */

/* BEGIN FUNCTION-DECL-EXTERN mkostemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:105 */
extern int mkostemp(char * , int  ) ;
/* END FUNCTION-DECL-EXTERN mkostemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:105 */

/* BEGIN FUNCTION-DECL-EXTERN strtof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:28 */
extern float strtof(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:28 */

/* BEGIN FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN qsort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:58 */
extern void qsort(void * , size_t  , size_t  , int (*)(void const   * , void const   * ) ) ;
/* END FUNCTION-DECL-EXTERN qsort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:58 */

/* BEGIN FUNCTION-DECL-EXTERN fwrite LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:100 */
extern size_t___0 fwrite(void const   * __restrict   , size_t___0  , size_t___0  ,
                         FILE * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN fwrite LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:100 */

/* BEGIN FUNCTION-DECL __builtin_strncat LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncat LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_floorf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* END FUNCTION-DECL __builtin_floorf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_hrun LOC=UNKNOWN */
int stk_hrun(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_hrun LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_kfreq LOC=UNKNOWN */
int stk_kfreq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_kfreq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN gzopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1893 */
extern gzFile gzopen(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN gzopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1893 */

/* BEGIN FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mkdtemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:106 */
extern char *mkdtemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mkdtemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:106 */

/* BEGIN FUNCTION-DECL-EXTERN strtol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:32 */
extern long strtol(char const   * __restrict   , char ** __restrict   , int  ) ;
/* END FUNCTION-DECL-EXTERN strtol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:32 */

/* BEGIN FUNCTION-DECL __builtin_fabs LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* END FUNCTION-DECL __builtin_fabs LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_init_64 LOC=UNKNOWN */
__inline static kh_64_t *kh_init_64(void) ;
/* END FUNCTION-DECL kh_init_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanf LOC=BUILTIN */

/* BEGIN TYPEDEF _1_main_1_opaque_StructureType LOC=UNKNOWN */
typedef struct _1_main_1_opaque_NodeStruct *_1_main_1_opaque_StructureType;
/* END TYPEDEF _1_main_1_opaque_StructureType LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF seq_nt6_table LOC=UNKNOWN */
unsigned char seq_nt6_table[256]  ;
/* END VARIABLE-DEF seq_nt6_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN atof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:26 */
extern double atof(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:26 */

/* BEGIN FUNCTION-DECL __builtin_tanh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* END FUNCTION-DECL __builtin_tanh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN setkey LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:127 */
extern void setkey(char const   * ) ;
/* END FUNCTION-DECL-EXTERN setkey LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:127 */

/* BEGIN STRUCT __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
struct __anonstruct_ldiv_t_721778306 {
   long quot ;
   long rem ;
};
/* END STRUCT __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN FUNCTION-DECL-EXTERN strtoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:34 */
extern long long strtoll(char const   * __restrict   , char ** __restrict   , int  ) ;
/* END FUNCTION-DECL-EXTERN strtoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:34 */

/* BEGIN TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */
typedef long long off_t;
/* END TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */

/* BEGIN FUNCTION-DECL __builtin_powil LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_mergefa LOC=UNKNOWN */
int stk_mergefa(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_mergefa LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_famask LOC=UNKNOWN */
int stk_famask(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_famask LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* END FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _global_argv LOC=UNKNOWN */
char **_global_argv  ;
/* END VARIABLE-DEF _global_argv LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_atanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN posix_memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:101 */
extern int posix_memalign(void ** , size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN posix_memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:101 */

/* BEGIN FUNCTION-DECL kseq_destroy LOC=UNKNOWN */
static void kseq_destroy(kseq_t *ks ) ;
/* END FUNCTION-DECL kseq_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN random LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:116 */
extern long random(void) ;
/* END FUNCTION-DECL-EXTERN random LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:116 */

/* BEGIN FUNCTION-DECL __builtin_nansf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansf LOC=BUILTIN */

/* BEGIN TYPEDEF krint64_t LOC=seqtk.c:218 */
typedef uint64_t krint64_t;
/* END TYPEDEF krint64_t LOC=seqtk.c:218 */

/* BEGIN STRUCT _krand_t LOC=seqtk.c:228 */
struct _krand_t {
   int mti ;
   krint64_t mt[312] ;
};
/* END STRUCT _krand_t LOC=seqtk.c:228 */

/* BEGIN FUNCTION-DECL cpy_kstr LOC=UNKNOWN */
static void cpy_kstr(kstring_t *dst , kstring_t const   *src ) ;
/* END FUNCTION-DECL cpy_kstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_dropse LOC=UNKNOWN */
int stk_dropse(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_dropse LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL ks_destroy LOC=UNKNOWN */
__inline static void ks_destroy(kstream_t *ks ) ;
/* END FUNCTION-DECL ks_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN putchar LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:109 */
extern int putchar(int  ) ;
/* END FUNCTION-DECL-EXTERN putchar LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:109 */

/* BEGIN FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN putenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:120 */
extern int putenv(char * ) ;
/* END FUNCTION-DECL-EXTERN putenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:120 */

/* BEGIN FUNCTION-DECL __builtin_nansl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_printstr LOC=UNKNOWN */
static void stk_printstr(kstring_t const   *s , unsigned int line_len ) ;
/* END FUNCTION-DECL stk_printstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* END FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_parityl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_parityl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN reallocarray LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:150 */
extern void *reallocarray(void * , size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN reallocarray LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:150 */

/* BEGIN TYPEDEF krand_t LOC=seqtk.c:221 */
typedef struct _krand_t krand_t;
/* END TYPEDEF krand_t LOC=seqtk.c:221 */

/* BEGIN FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* END FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN getsubopt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:107 */
extern int getsubopt(char ** , char * const  * , char ** ) ;
/* END FUNCTION-DECL-EXTERN getsubopt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:107 */

/* BEGIN FUNCTION-DECL __builtin_ceil LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* END FUNCTION-DECL __builtin_ceil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strlen LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strlen LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN seed48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:135 */
extern unsigned short *seed48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN seed48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:135 */

/* BEGIN FUNCTION-DECL-EXTERN puts LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:117 */
extern int puts(char const   * ) ;
/* END FUNCTION-DECL-EXTERN puts LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:117 */

/* BEGIN FUNCTION-DECL-EXTERN fflush LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:89 */
extern int fflush(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fflush LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:89 */

/* BEGIN FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */

/* BEGIN FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* END FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_asinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_asinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */

/* BEGIN STRUCT gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1834 */
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
/* END STRUCT gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1834 */

/* BEGIN FUNCTION-DECL __builtin_atanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_atanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strdup LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:70 */
extern char *strdup(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strdup LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:70 */

/* BEGIN FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN setstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:119 */
extern char *setstate(char * ) ;
/* END FUNCTION-DECL-EXTERN setstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:119 */

/* BEGIN FUNCTION-DECL-EXTERN memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:145 */
extern void *memalign(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:145 */

/* BEGIN VARIABLE-DEF __ac_HASH_UPPER LOC=UNKNOWN */
static double __ac_HASH_UPPER  ;
/* END VARIABLE-DEF __ac_HASH_UPPER LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL cpy_kseq LOC=UNKNOWN */
static void cpy_kseq(kseq_t *dst , kseq_t const   *src ) ;
/* END FUNCTION-DECL cpy_kseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_parityll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_parityll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fmod LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* END FUNCTION-DECL __builtin_fmod LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtold LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:30 */
extern long double strtold(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtold LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:30 */

/* BEGIN FUNCTION-DECL kr_rand LOC=UNKNOWN */
krint64_t kr_rand(krand_t *kr ) ;
/* END FUNCTION-DECL kr_rand LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN gzclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1631 */
extern int gzclose(gzFile file ) ;
/* END FUNCTION-DECL-EXTERN gzclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1631 */

/* BEGIN TYPEDEF div_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
typedef struct __anonstruct_div_t_109580352 div_t;
/* END TYPEDEF div_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN FUNCTION-DECL-EXTERN div LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:68 */
extern div_t div(int  , int  ) ;
/* END FUNCTION-DECL-EXTERN div LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:68 */

/* BEGIN FUNCTION-DECL-EXTERN bsearch LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:57 */
extern void *bsearch(void const   * , void const   * , size_t  , size_t  , int (*)(void const   * ,
                                                                                   void const   * ) ) ;
/* END FUNCTION-DECL-EXTERN bsearch LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:57 */

/* BEGIN FUNCTION-DECL kseq_init LOC=UNKNOWN */
static kseq_t *kseq_init(gzFile fd ) ;
/* END FUNCTION-DECL kseq_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN llabs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:62 */
extern long long llabs(long long  ) ;
/* END FUNCTION-DECL-EXTERN llabs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:62 */

/* BEGIN FUNCTION-DECL __builtin_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* END FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __ac_X31_hash_string LOC=UNKNOWN */
__inline static khint_t __ac_X31_hash_string(char const   *s ) ;
/* END FUNCTION-DECL __ac_X31_hash_string LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtoull LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:35 */
extern unsigned long long strtoull(char const   * __restrict   , char ** __restrict   ,
                                   int  ) ;
/* END FUNCTION-DECL-EXTERN strtoull LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:35 */

/* BEGIN STRUCT __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
struct __anonstruct_lldiv_t_989260392 {
   long long quot ;
   long long rem ;
};
/* END STRUCT __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN FUNCTION-DECL kh_resize_64 LOC=UNKNOWN */
__inline static void kh_resize_64(kh_64_t *h , khint_t new_n_buckets ) ;
/* END FUNCTION-DECL kh_resize_64 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF mag01 LOC=UNKNOWN */
static krint64_t mag01[2]  ;
/* END VARIABLE-DEF mag01 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_mutfa LOC=UNKNOWN */
int stk_mutfa(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_mutfa LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floorl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_floorl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _2_entropy LOC=UNKNOWN */
unsigned long _2_entropy  =    4141707142UL;
/* END VARIABLE-DEF _2_entropy LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN optarg LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:138 */
extern char *optarg ;
/* END VARIABLE-DECL-EXTERN optarg LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:138 */

/* BEGIN FUNCTION-DECL __builtin_expl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_expl LOC=BUILTIN */

/* BEGIN VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */
extern FILE *stderr ;
/* END VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */

/* BEGIN FUNCTION-DECL __builtin_log10l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* END FUNCTION-DECL __builtin_log10l LOC=BUILTIN */

/* BEGIN VARIABLE-DEF seq_nt16_table LOC=UNKNOWN */
unsigned char seq_nt16_table[256]  ;
/* END VARIABLE-DEF seq_nt16_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN lldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:70 */
extern lldiv_t lldiv(long long  , long long  ) ;
/* END FUNCTION-DECL-EXTERN lldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:70 */

/* BEGIN FUNCTION-DECL __builtin_popcount LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_popcount LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* END FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */
extern int strcmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */

/* BEGIN STRUCT __kstring_t LOC=./kseq.h:83 */
struct __kstring_t {
   size_t___0 l ;
   size_t___0 m ;
   char *s ;
};
/* END STRUCT __kstring_t LOC=./kseq.h:83 */

/* BEGIN STRUCT __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */
struct __anonstruct_kseq_t_745567265 {
   kstring_t name ;
   kstring_t comment ;
   kstring_t seq ;
   kstring_t qual ;
   int last_char ;
   int is_fastq ;
   kstream_t *f ;
};
/* END STRUCT __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */

/* BEGIN FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */

/* BEGIN TYPEDEF int8_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:175 */
typedef signed char int8_t;
/* END TYPEDEF int8_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:175 */

/* BEGIN FUNCTION-DECL kh_put_reg LOC=UNKNOWN */
__inline static khint_t kh_put_reg(kh_reg_t *h , kh_cstr_t key , int *ret ) ;
/* END FUNCTION-DECL kh_put_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_clz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_clz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bzero LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bzero LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nans LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nans LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memset LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* END FUNCTION-DECL __builtin_memset LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_printseq LOC=UNKNOWN */
__inline static void stk_printseq(kseq_t const   *s , int line_len ) ;
/* END FUNCTION-DECL stk_printseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_subseq LOC=UNKNOWN */
int stk_subseq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_subseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mblen LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:72 */
extern int mblen(char const   * , size_t  ) ;
/* END FUNCTION-DECL-EXTERN mblen LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:72 */

/* BEGIN FUNCTION-DECL-EXTERN isalpha LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:11 */
extern int isalpha(int  ) ;
/* END FUNCTION-DECL-EXTERN isalpha LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:11 */

/* BEGIN VARIABLE-DEF seq_nt16to4_table LOC=UNKNOWN */
unsigned char seq_nt16to4_table[16]  ;
/* END VARIABLE-DEF seq_nt16to4_table LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _2_alwaysZero LOC=UNKNOWN */
unsigned long _2_alwaysZero  =    0;
/* END VARIABLE-DEF _2_alwaysZero LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN posix_openpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:121 */
extern int posix_openpt(int  ) ;
/* END FUNCTION-DECL-EXTERN posix_openpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:121 */

/* BEGIN FUNCTION-DECL __builtin_clzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_clzl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ceill LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* END FUNCTION-DECL __builtin_ceill LOC=BUILTIN */

/* BEGIN TYPEDEF uint32_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:210 */
typedef unsigned int uint32_t;
/* END TYPEDEF uint32_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:210 */

/* BEGIN FUNCTION-DECL __builtin_atan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* END FUNCTION-DECL __builtin_atan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL ks_getc LOC=UNKNOWN */
__inline static int ks_getc(kstream_t *ks ) ;
/* END FUNCTION-DECL ks_getc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_hety LOC=UNKNOWN */
int stk_hety(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_hety LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN aligned_alloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:44 */
extern void *aligned_alloc(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN aligned_alloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:44 */

/* BEGIN FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_return LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* END FUNCTION-DECL __builtin_return LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF bitcnt_table LOC=UNKNOWN */
int bitcnt_table[16]  ;
/* END VARIABLE-DEF bitcnt_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN ldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:69 */
extern ldiv_t ldiv(long  , long  ) ;
/* END FUNCTION-DECL-EXTERN ldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:69 */

/* BEGIN FUNCTION-DECL __builtin_powif LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powif LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN calloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:41 */
extern void *calloc(unsigned long  , unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN calloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:41 */

/* BEGIN VARIABLE-DEF cutN_min_N_tract LOC=UNKNOWN */
static int cutN_min_N_tract  ;
/* END VARIABLE-DEF cutN_min_N_tract LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */
extern int printf(char const   * __restrict    , ...) ;
/* END FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */

/* BEGIN FUNCTION-DECL-EXTERN isupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:20 */
extern int isupper(int  ) ;
/* END FUNCTION-DECL-EXTERN isupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:20 */

/* BEGIN VARIABLE-DEF _global_envp LOC=UNKNOWN */
char **_global_envp  ;
/* END VARIABLE-DEF _global_envp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:130 */
extern long lrand48(void) ;
/* END FUNCTION-DECL-EXTERN lrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:130 */

/* BEGIN FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* END FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN valloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:144 */
extern void *valloc(size_t  ) ;
/* END FUNCTION-DECL-EXTERN valloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:144 */

/* BEGIN FUNCTION-DECL stk_gc LOC=UNKNOWN */
int stk_gc(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_gc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */
/* compiler builtin: 
   long long __builtin_bswap64(long long  ) ;  */
/* END FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_clzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_clzll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_resize_reg LOC=UNKNOWN */
__inline static void kh_resize_reg(kh_reg_t *h , khint_t new_n_buckets ) ;
/* END FUNCTION-DECL kh_resize_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_logl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_logl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_end LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_end LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtoul LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:33 */
extern unsigned long strtoul(char const   * __restrict   , char ** __restrict   ,
                             int  ) ;
/* END FUNCTION-DECL-EXTERN strtoul LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:33 */

/* BEGIN FUNCTION-DECL __builtin_cos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* END FUNCTION-DECL __builtin_cos LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* END FUNCTION-DECL __builtin_log LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN alloca LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h:11 */
extern void *alloca(size_t  ) ;
/* END FUNCTION-DECL-EXTERN alloca LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h:11 */

/* BEGIN FUNCTION-DECL-EXTERN free LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:43 */
extern void free(void * ) ;
/* END FUNCTION-DECL-EXTERN free LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:43 */

/* BEGIN FUNCTION-DECL main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) ;
/* END FUNCTION-DECL main LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_exp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* END FUNCTION-DECL __builtin_exp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mktemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:141 */
extern char *mktemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mktemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:141 */

/* BEGIN FUNCTION-DECL-EXTERN wctomb LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:74 */
extern int wctomb(char * , wchar_t  ) ;
/* END FUNCTION-DECL-EXTERN wctomb LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:74 */

/* BEGIN FUNCTION-DECL-EXTERN nrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:131 */
extern long nrand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN nrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:131 */

/* BEGIN FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kr_srand0 LOC=UNKNOWN */
static void kr_srand0(krint64_t seed , krand_t *kr ) ;
/* END FUNCTION-DECL kr_srand0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL kr_srand LOC=UNKNOWN */
krand_t *kr_srand(krint64_t seed ) ;
/* END FUNCTION-DECL kr_srand LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */
extern FILE *stdin ;
/* END VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */

/* BEGIN FUNCTION-DECL-EXTERN initstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:118 */
extern char *initstate(unsigned int  , char * , size_t  ) ;
/* END FUNCTION-DECL-EXTERN initstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:118 */

/* BEGIN FUNCTION-DECL-EXTERN unlockpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:123 */
extern int unlockpt(int  ) ;
/* END FUNCTION-DECL-EXTERN unlockpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:123 */

/* BEGIN FUNCTION-DECL-EXTERN atoi LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:23 */
extern int atoi(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atoi LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:23 */

/* BEGIN FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */
extern void *memset(void * , int  , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */

/* BEGIN VARIABLE-DEF _3__functionPtrArray LOC=UNKNOWN */
void *_3__functionPtrArray[]  = 
  {      & cpy_kstr,      & cpy_kstr - 791,      & cpy_kstr,      & cpy_kstr, 
        & cpy_kstr + 459,      & cpy_kstr,      & realloc,      & realloc - 835, 
        & memcpy,      & memcpy + 900,      & printf,      & printf + 598, 
        & printf,      & printf,      & printf,      & log, 
        & log - 738,      & printf,      & printf + 27,      & printf, 
        & printf,      & putchar,      & free,      & free, 
        & free - 514,      & free,      & free + 694,      & free, 
        & free,      & free + 281,      & free,      & free - 963, 
        & free,      & free + 503,      & free,      & free + 478, 
        & strcmp,      & calloc,      & calloc + 106,      & calloc, 
        & calloc - 821,      & strcmp,      & malloc,      & malloc - 229, 
        & memset,      & memset + 499,      & realloc,      & realloc - 802, 
        & realloc,      & free,      & malloc,      & memset, 
        & memset - 304,      & realloc,      & realloc,      & realloc + 445, 
        & realloc,      & realloc,      & realloc + 300,      & free, 
        & free - 399,      & kr_srand0,      & malloc,      & malloc - 418, 
        & kr_srand0,      & free,      & free,      & free - 402, 
        & gzread,      & ks_getuntil2,      & gzread,      & isspace, 
        & isspace + 331,      & isspace,      & realloc,      & memcpy, 
        & calloc,      & calloc,      & calloc - 483,      & malloc, 
        & malloc - 571,      & free,      & free + 611,      & free, 
        & free + 348,      & free,      & free - 606,      & free, 
        & free - 110,      & free,      & free + 472,      & calloc, 
        & calloc + 183,      & malloc,      & malloc + 102,      & ks_getuntil2, 
        & realloc,      & realloc,      & realloc - 398,      & ks_getuntil2, 
        & tolower,      & tolower,      & calloc,      & calloc + 523, 
        & tolower,      & free,      & free,      & free - 521, 
        & free,      & free - 579,      & strcmp,      & gzopen, 
        & gzopen + 527,      & fileno,      & gzdopen,      & calloc, 
        & strdup,      & memset,      & isdigit,      & isdigit + 800, 
        & atoi,      & atoi - 974,      & isdigit,      & isdigit - 423, 
        & atoi,      & atoi - 470,      & realloc,      & realloc + 366, 
        & gzclose,      & gzclose - 880,      & free,      & free + 398, 
        & free,      & free - 277};
/* END VARIABLE-DEF _3__functionPtrArray LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */
struct __anonstruct_reglist_t_947739297 {
   int n ;
   int m ;
   uint64_t *a ;
};
/* END STRUCT __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */

/* BEGIN TYPEDEF khiter_t LOC=./khash.h:138 */
typedef khint_t khiter_t;
/* END TYPEDEF khiter_t LOC=./khash.h:138 */

/* BEGIN FUNCTION-DECL stk_fqchk LOC=UNKNOWN */
int stk_fqchk(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_fqchk LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* END FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */

/* BEGIN FUNCTION-DECL find_next_cut LOC=UNKNOWN */
static int find_next_cut(kseq_t const   *ks , int k , int *begin , int *end ) ;
/* END FUNCTION-DECL find_next_cut LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_cosf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_randbase LOC=UNKNOWN */
int stk_randbase(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_randbase LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* END FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:51 */
extern void quick_exit(int  ) ;
/* END FUNCTION-DECL-EXTERN quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:51 */

/* BEGIN FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF cutN_nonN_penalty LOC=UNKNOWN */
static int cutN_nonN_penalty  ;
/* END VARIABLE-DEF cutN_nonN_penalty LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_apply LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_apply LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN _Exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:49 */
extern void _Exit(int  ) ;
/* END FUNCTION-DECL-EXTERN _Exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:49 */

/* BEGIN FUNCTION-DECL-EXTERN srandom LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:117 */
extern void srandom(unsigned int  ) ;
/* END FUNCTION-DECL-EXTERN srandom LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:117 */

/* BEGIN FUNCTION-DECL stk_reg_read LOC=UNKNOWN */
reghash_t *stk_reg_read(char const   *fn ) ;
/* END FUNCTION-DECL stk_reg_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN srand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:134 */
extern void srand48(long  ) ;
/* END FUNCTION-DECL-EXTERN srand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:134 */

/* BEGIN FUNCTION-DECL kh_destroy_64 LOC=UNKNOWN */
__inline static void kh_destroy_64(kh_64_t *h ) ;
/* END FUNCTION-DECL kh_destroy_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL usage LOC=UNKNOWN */
static int usage(void) ;
/* END FUNCTION-DECL usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL ks_init LOC=UNKNOWN */
__inline static kstream_t *ks_init(gzFile f ) ;
/* END FUNCTION-DECL ks_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_powi LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powi LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_destroy_reg LOC=UNKNOWN */
__inline static void kh_destroy_reg(kh_reg_t *h ) ;
/* END FUNCTION-DECL kh_destroy_reg LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _1_main_1_opaque_ptr_1 LOC=UNKNOWN */
struct _1_main_1_opaque_NodeStruct *_1_main_1_opaque_ptr_1  =    (struct _1_main_1_opaque_NodeStruct *)0;
/* END VARIABLE-DEF _1_main_1_opaque_ptr_1 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_logf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* END FUNCTION-DECL __builtin_logf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_expect LOC=BUILTIN */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* END FUNCTION-DECL __builtin_expect LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN rand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:37 */
extern int rand(void) ;
/* END FUNCTION-DECL-EXTERN rand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:37 */

/* BEGIN FUNCTION-DECL stk_cutN LOC=UNKNOWN */
int stk_cutN(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_cutN LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN drand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:128 */
extern double drand48(void) ;
/* END FUNCTION-DECL-EXTERN drand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:128 */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_alloca LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_alloca LOC=BUILTIN */

/* BEGIN VARIABLE-DEF comp_tab LOC=UNKNOWN */
char comp_tab[128]  ;
/* END VARIABLE-DEF comp_tab LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_inf LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* END FUNCTION-DECL __builtin_inf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* END FUNCTION-DECL __builtin_log10 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_put_64 LOC=UNKNOWN */
__inline static khint_t kh_put_64(kh_64_t *h , khint64_t key , int *ret ) ;
/* END FUNCTION-DECL kh_put_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_modff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* END FUNCTION-DECL __builtin_modff LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */
extern int fputc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */

/* BEGIN FUNCTION-DEF stk_sample LOC=UNKNOWN */
int stk_sample(int argc , char **argv ) 
{ 
  int c ;
  int twopass ;
  uint64_t i ;
  uint64_t num ;
  uint64_t n_seqs ;
  double frac ;
  gzFile fp ;
  kseq_t *seq ;
  krand_t *kr ;
  long tmp ;
  kseq_t *buf ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  double r ;
  krint64_t tmp___6 ;
  uint64_t y ;
  uint64_t tmp___7 ;
  int tmp___8 ;
  kseq_t *p ;
  uint64_t *buf___0 ;
  kh_64_t *hash ;
  int absent ;
  int tmp___9 ;
  void *tmp___10 ;
  double r___0 ;
  krint64_t tmp___11 ;
  uint64_t y___0 ;
  int tmp___12 ;
  khint_t tmp___13 ;
  int tmp___14 ;

  {
  twopass = 0;
  num = (uint64_t )0;
  n_seqs = (uint64_t )0;
  frac = 0.;
  kr = (krand_t *)0;
  while (1) {
    c = getopt(argc, argv, "2s:");
    if (! (c >= 0)) {
      break;
    }
    if (c == 115) {
      tmp = atol((char const   *)optarg);
      kr = kr_srand((krint64_t )tmp);
    } else
    if (c == 50) {
      twopass = 1;
    }
  }
  if (optind + 2 > argc) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk sample [-2] [-s seed=11] <in.fa> <frac>|<number>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -s INT       RNG seed [11]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -2           2-pass mode: twice as slow but with much reduced memory\n\n");
    return (1);
  }
  frac = atof((char const   *)*(argv + (optind + 1)));
  if (frac >= 1.0) {
    num = (uint64_t )(frac + .499);
    frac = 0.;
  } else
  if (twopass) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[W::%s] when sampling a fraction, option -2 is ignored.",
            "stk_sample");
    twopass = 0;
  }
  if ((unsigned long )kr == (unsigned long )((krand_t *)0)) {
    kr = kr_srand((krint64_t )11);
  }
  if (! twopass) {
    buf = (kseq_t *)0;
    if (num > 0ULL) {
      tmp___0 = calloc((size_t___0 )num, sizeof(kseq_t ));
      buf = (kseq_t *)tmp___0;
    }
    if (num > 0ULL) {
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] Could not allocate enough memory for %llu sequences. Exiting...\n",
                "stk_sample", num);
        free((void *)kr);
        return (1);
      }
    }
    tmp___5 = strcmp((char const   *)*(argv + optind), "-");
    if (tmp___5) {
      tmp___2 = gzopen((char const   *)*(argv + optind), "r");
      fp = tmp___2;
    } else {
      tmp___3 = fileno(stdin);
      tmp___4 = gzdopen(tmp___3, "r");
      fp = tmp___4;
    }
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
              "stk_sample");
      return (1);
    }
    seq = kseq_init(fp);
    n_seqs = (uint64_t )0;
    while (1) {
      tmp___8 = kseq_read(seq);
      if (! (tmp___8 >= 0)) {
        break;
      }
      tmp___6 = kr_rand(kr);
      r = (double )(tmp___6 >> 11) * (1.0 / 9007199254740992.0);
      n_seqs ++;
      if (num) {
        if (n_seqs - 1ULL < num) {
          tmp___7 = n_seqs - 1ULL;
        } else {
          tmp___7 = (uint64_t )(r * (double )n_seqs);
        }
        y = tmp___7;
        if (y < num) {
          cpy_kseq(buf + y, (kseq_t const   *)seq);
        }
      } else
      if (r < frac) {
        stk_printseq((kseq_t const   *)seq, -1);
      }
    }
    i = (uint64_t )0;
    while (i < num) {
      p = buf + i;
      if (p->seq.l) {
        stk_printseq((kseq_t const   *)p, -1);
      }
      free((void *)p->seq.s);
      free((void *)p->qual.s);
      free((void *)p->name.s);
      i ++;
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      free((void *)buf);
    }
  } else {
    tmp___9 = strcmp((char const   *)*(argv + optind), "-");
    if (tmp___9 == 0) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] in the 2-pass mode, the input cannot be STDIN.\n",
              "stk_sample");
      free((void *)kr);
      return (1);
    }
    tmp___10 = malloc((size_t___0 )(num * 8ULL));
    buf___0 = (uint64_t *)tmp___10;
    i = (uint64_t )0;
    while (i < num) {
      *(buf___0 + i) = 0xffffffffffffffffULL;
      i ++;
    }
    fp = gzopen((char const   *)*(argv + optind), "r");
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
              "stk_sample");
      return (1);
    }
    seq = kseq_init(fp);
    n_seqs = (uint64_t )0;
    while (1) {
      tmp___12 = kseq_read(seq);
      if (! (tmp___12 >= 0)) {
        break;
      }
      tmp___11 = kr_rand(kr);
      r___0 = (double )(tmp___11 >> 11) * (1.0 / 9007199254740992.0);
      n_seqs ++;
      if (n_seqs - 1ULL < num) {
        y___0 = n_seqs - 1ULL;
      } else {
        y___0 = (uint64_t )(r___0 * (double )n_seqs);
      }
      if (y___0 < num) {
        *(buf___0 + y___0) = n_seqs;
      }
    }
    kseq_destroy(seq);
    gzclose(fp);
    hash = kh_init_64();
    i = (uint64_t )0;
    while (i < num) {
      kh_put_64(hash, *(buf___0 + i), & absent);
      i ++;
    }
    free((void *)buf___0);
    fp = gzopen((char const   *)*(argv + optind), "r");
    seq = kseq_init(fp);
    n_seqs = (uint64_t )0;
    while (1) {
      tmp___14 = kseq_read(seq);
      if (! (tmp___14 >= 0)) {
        break;
      }
      n_seqs ++;
      tmp___13 = kh_get_64((kh_64_t const   *)hash, n_seqs);
      if (tmp___13 != hash->n_buckets) {
        stk_printseq((kseq_t const   *)seq, -1);
      }
    }
    kh_destroy_64(hash);
  }
  kseq_destroy(seq);
  gzclose(fp);
  free((void *)kr);
  return (0);
}
}
/* END FUNCTION-DEF stk_sample LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_trimfq LOC=UNKNOWN */
int stk_trimfq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  double param ;
  double q_int2real[128] ;
  int i ;
  int c ;
  int min_len ;
  int left ;
  int right ;
  int fixed_len ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int beg ;
  int tmp___4 ;
  int end ;
  double s ;
  double max ;
  int q ;
  int is ;
  int imax ;
  int tmp___5 ;
  int tmp___6 ;

  {
  param = 0.05;
  min_len = 30;
  left = 0;
  right = 0;
  fixed_len = -1;
  while (1) {
    c = getopt(argc, argv, "l:q:b:e:L:");
    if (! (c >= 0)) {
      break;
    }
    switch (c) {
    case 113: 
    param = atof((char const   *)optarg);
    break;
    case 108: 
    min_len = atoi((char const   *)optarg);
    break;
    case 98: 
    left = atoi((char const   *)optarg);
    break;
    case 101: 
    right = atoi((char const   *)optarg);
    break;
    case 76: 
    fixed_len = atoi((char const   *)optarg);
    break;
    }
  }
  if (optind == argc) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk trimfq [options] <in.fq>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q FLOAT    error rate threshold (disabled by -b/-e) [%.2f]\n",
            param);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT      maximally trim down to INT bp (disabled by -b/-e) [%d]\n",
            min_len);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -b INT      trim INT bp from left (non-zero to disable -q/-l) [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -e INT      trim INT bp from right (non-zero to disable -q/-l) [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -L INT      retain at most INT bp from the 5\'-end (non-zero to disable -q/-l) [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -Q          force FASTQ output\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    return (1);
  }
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  if (tmp___3) {
    tmp___0 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___0;
  } else {
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_trimfq");
    return (1);
  }
  seq = kseq_init(fp);
  i = 0;
  while (i < 128) {
    q_int2real[i] = pow(10., (double )(- (i - 33)) / 10.);
    i ++;
  }
  while (1) {
    tmp___6 = kseq_read(seq);
    if (! (tmp___6 >= 0)) {
      break;
    }
    if (left) {
      goto _L;
    } else
    if (right) {
      goto _L;
    } else
    if (fixed_len > 0) {
      _L: 
      beg = left;
      end = (int )(seq->seq.l - (size_t___0 )right);
      if (beg >= end) {
        end = 0;
        beg = end;
      }
      if (fixed_len > 0) {
        if (end - beg > fixed_len) {
          end = beg + fixed_len;
        }
      }
    } else
    if (seq->qual.l > (size_t___0 )min_len) {
      i = 0;
      tmp___4 = 0;
      beg = tmp___4;
      end = (int )seq->qual.l;
      max = 0.;
      s = max;
      while ((size_t___0 )i < seq->qual.l) {
        q = (int )*(seq->qual.s + i);
        if (q < 36) {
          q = 36;
        }
        if (q > 127) {
          q = 127;
        }
        s += param - q_int2real[q];
        if (s > max) {
          max = s;
          beg = tmp___4;
          end = i + 1;
        }
        if (s < (double )0) {
          s = (double )0;
          tmp___4 = i + 1;
        }
        i ++;
      }
      if (max == 0.) {
        beg = 0;
        end = min_len;
      }
      if (end - beg < min_len) {
        i = 0;
        is = 0;
        while (i < min_len) {
          is += (int )*(seq->qual.s + i) - 33;
          i ++;
        }
        imax = is;
        beg = 0;
        while ((size_t___0 )i < seq->qual.l) {
          is += (int )*(seq->qual.s + i) - (int )*(seq->qual.s + (i - min_len));
          if (imax < is) {
            imax = is;
            beg = (i - min_len) + 1;
          }
          i ++;
        }
        end = beg + min_len;
      }
    } else {
      beg = 0;
      end = (int )seq->seq.l;
    }
    if (seq->is_fastq) {
      tmp___5 = '@';
    } else {
      tmp___5 = '>';
    }
    putchar(tmp___5);
    fputs((char const   */* __restrict  */)seq->name.s, (FILE */* __restrict  */)stdout);
    if (seq->comment.l) {
      putchar(' ');
      puts((char const   *)seq->comment.s);
    } else {
      putchar('\n');
    }
    fwrite((void const   */* __restrict  */)(seq->seq.s + beg), (size_t___0 )1, (size_t___0 )(end - beg),
           (FILE */* __restrict  */)stdout);
    putchar('\n');
    if (seq->is_fastq) {
      puts("+");
      fwrite((void const   */* __restrict  */)(seq->qual.s + beg), (size_t___0 )1,
             (size_t___0 )(end - beg), (FILE */* __restrict  */)stdout);
      putchar('\n');
    }
  }
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_trimfq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_comp LOC=UNKNOWN */
int stk_comp(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int upper_only ;
  reghash_t *h ;
  reglist_t dummy ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int i ;
  int k ;
  reglist_t *p ;
  khint_t k___0 ;
  khint_t tmp___7 ;
  int beg ;
  int end ;
  int la ;
  int lb ;
  int lc ;
  int na ;
  int nb ;
  int nc ;
  int cnt[11] ;
  int is_CpG ;
  int a ;
  int b ;
  int c___0 ;
  int tmp___8 ;

  {
  upper_only = 0;
  h = (reghash_t *)0;
  while (1) {
    c = getopt(argc, argv, "ur:");
    if (! (c >= 0)) {
      break;
    }
    switch (c) {
    case 117: 
    upper_only = 1;
    break;
    case 114: 
    h = stk_reg_read((char const   *)optarg);
    break;
    }
  }
  if (argc == optind) {
    tmp = fileno(stdin);
    tmp___0 = isatty(tmp);
    if (tmp___0) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:  seqtk comp [-u] [-r in.bed] <in.fa>\n\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output format: chr, length, #A, #C, #G, #T, #2, #3, #4, #CpG, #tv, #ts, #CpG-ts\n");
      return (1);
    }
  }
  if (optind < argc) {
    tmp___5 = strcmp((char const   *)*(argv + optind), "-");
    if (tmp___5) {
      tmp___2 = gzopen((char const   *)*(argv + optind), "r");
      fp = tmp___2;
    } else {
      tmp___3 = fileno(stdin);
      tmp___4 = gzdopen(tmp___3, "r");
      fp = tmp___4;
    }
  } else {
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_comp");
    return (1);
  }
  seq = kseq_init(fp);
  dummy.m = 1;
  dummy.n = dummy.m;
  tmp___6 = calloc((size_t___0 )1, (size_t___0 )8);
  dummy.a = (uint64_t *)tmp___6;
  while (1) {
    l = kseq_read(seq);
    if (! (l >= 0)) {
      break;
    }
    p = (reglist_t *)0;
    if (h) {
      tmp___7 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
      k___0 = tmp___7;
      if (k___0 != h->n_buckets) {
        p = h->vals + k___0;
      }
    } else {
      p = & dummy;
      *(dummy.a + 0) = (uint64_t )l;
    }
    k = 0;
    while (1) {
      if (p) {
        if (! (k < p->n)) {
          break;
        }
      } else {
        break;
      }
      beg = (int )(*(p->a + k) >> 32);
      end = (int )(*(p->a + k) & 4294967295ULL);
      if (beg > 0) {
        la = (int )*(seq->seq.s + (beg - 1));
        lb = (int )seq_nt16_table[la];
        lc = bitcnt_table[lb];
      } else {
        la = 'a';
        lb = -1;
        lc = 0;
      }
      na = (int )*(seq->seq.s + beg);
      nb = (int )seq_nt16_table[na];
      nc = bitcnt_table[nb];
      memset((void *)(cnt), 0, 11UL * sizeof(int ));
      i = beg;
      while (i < end) {
        is_CpG = 0;
        a = na;
        b = nb;
        c___0 = nc;
        na = (int )*(seq->seq.s + (i + 1));
        nb = (int )seq_nt16_table[na];
        nc = bitcnt_table[nb];
        if (b == 2) {
          goto _L___0;
        } else
        if (b == 10) {
          _L___0: 
          if (nb == 4) {
            is_CpG = 1;
          } else
          if (nb == 5) {
            is_CpG = 1;
          }
        } else
        if (b == 4) {
          goto _L;
        } else
        if (b == 5) {
          _L: 
          if (lb == 2) {
            is_CpG = 1;
          } else
          if (lb == 10) {
            is_CpG = 1;
          }
        }
        if (upper_only == 0) {
          goto _L___1;
        } else {
          tmp___8 = isupper(a);
          if (tmp___8) {
            _L___1: 
            if (c___0 > 1) {
              (cnt[c___0 + 2]) ++;
            }
            if (c___0 == 1) {
              (cnt[seq_nt16to4_table[b]]) ++;
            }
            if (b == 10) {
              (cnt[9]) ++;
            } else
            if (b == 5) {
              (cnt[9]) ++;
            } else
            if (c___0 == 2) {
              (cnt[8]) ++;
            }
            if (is_CpG) {
              (cnt[7]) ++;
              if (b == 10) {
                (cnt[10]) ++;
              } else
              if (b == 5) {
                (cnt[10]) ++;
              }
            }
          }
        }
        la = a;
        lb = b;
        lc = c___0;
        i ++;
      }
      if (h) {
        printf((char const   */* __restrict  */)"%s\t%d\t%d", seq->name.s, beg, end);
      } else {
        printf((char const   */* __restrict  */)"%s\t%d", seq->name.s, l);
      }
      i = 0;
      while (i < 11) {
        printf((char const   */* __restrict  */)"\t%d", cnt[i]);
        i ++;
      }
      putchar('\n');
      k ++;
    }
    fflush(stdout);
  }
  free((void *)dummy.a);
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_comp LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_reg_destroy LOC=UNKNOWN */
void stk_reg_destroy(reghash_t *h ) 
{ 
  khint_t k ;

  {
  if ((unsigned long )h == (unsigned long )((reghash_t *)0)) {
    return;
  }
  k = (khint_t )0;
  while (k < h->n_buckets) {
    if (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      ((void (*)(void * ))_3__functionPtrArray[106 - ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((void *)(h->vals + k)->a);
      _3__functionPtrArray[26 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[101];
      ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 108 - 7 : 108])((void *)((char *)*(h->keys + k)));
    }
    k ++;
  }
  kh_destroy_reg(h);
  return;
}
}
/* END FUNCTION-DEF stk_reg_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_get_reg LOC=UNKNOWN */
__inline static khint_t kh_get_reg(kh_reg_t const   *h , kh_cstr_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  int tmp ;
  khint_t tmp___0 ;

  {
  if (h->n_buckets) {
    mask = (khint_t )(h->n_buckets - 1U);
    k = __ac_X31_hash_string(key);
    i = k & mask;
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          tmp = ((int (*)(char const   * , char const   * ))_3__functionPtrArray[36 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])(*(h->keys + i),
                                                                                                                                             key);
          if (tmp == 0) {
            break;
          }
        }
      } else {
        break;
      }
      i = (i + inc) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp___0 = (khint_t )h->n_buckets;
    } else {
      tmp___0 = i;
    }
    return (tmp___0);
  } else {
    return ((khint_t )0);
  }
}
}
/* END FUNCTION-DEF kh_get_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_destroy_reg LOC=UNKNOWN */
__inline static void kh_destroy_reg(kh_reg_t *h ) 
{ 


  {
  if (h) {
    ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 28 : 2])((void *)h->keys);
    _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 11 >> 2 : 11] = _3__functionPtrArray[8];
    ((void (*)(void * ))_3__functionPtrArray[30 + ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((void *)h->flags);
    ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 32 + 8 : 32])((void *)h->vals);
    _3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 16 : 5] = _3__functionPtrArray[29];
    ((void (*)(void * ))_3__functionPtrArray[34 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((void *)h);
  }
  return;
}
}
/* END FUNCTION-DEF kh_destroy_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF print_seq LOC=UNKNOWN */
static void print_seq(FILE *fpout , kseq_t const   *ks , int begin , int end ) 
{ 
  int i ;
  int tmp ;

  {
  if (begin >= end) {
    return;
  }
  if (ks->qual.l) {
    tmp = '@';
  } else {
    tmp = '>';
  }
  fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%c%s:%d-%d",
          tmp, ks->name.s, begin + 1, end);
  i = begin;
  while (1) {
    if (i < end) {
      if (! ((size_t___0 )i < (size_t___0 )ks->seq.l)) {
        break;
      }
    } else {
      break;
    }
    if ((i - begin) % 60 == 0) {
      fputc('\n', fpout);
    }
    fputc((int )*(ks->seq.s + i), fpout);
    i ++;
  }
  fputc('\n', fpout);
  if (ks->qual.l == 0UL) {
    return;
  }
  fputs((char const   */* __restrict  */)"+\n", (FILE */* __restrict  */)fpout);
  i = begin;
  while (1) {
    if (i < end) {
      if (! ((size_t___0 )i < (size_t___0 )ks->qual.l)) {
        break;
      }
    } else {
      break;
    }
    if ((i - begin) % 60 == 0) {
      fputc('\n', fpout);
    }
    fputc((int )*(ks->qual.s + i), fpout);
    i ++;
  }
  fputc('\n', fpout);
  return;
}
}
/* END FUNCTION-DEF print_seq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_hrun LOC=UNKNOWN */
int stk_hrun(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *ks ;
  int min_len ;
  int l ;
  int c ;
  int beg ;
  int i ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  min_len = 7;
  l = 0;
  c = 0;
  beg = 0;
  if (argc == optind) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk hrun <in.fa> [minLen=%d]\n",
            min_len);
    return (1);
  }
  if (argc == optind + 2) {
    min_len = atoi((char const   *)*(argv + (optind + 1)));
  }
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  if (tmp___3 == 0) {
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
  } else {
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_hrun");
    return (1);
  }
  ks = kseq_init(fp);
  while (1) {
    tmp___4 = kseq_read(ks);
    if (! (tmp___4 >= 0)) {
      break;
    }
    c = (int )*(ks->seq.s + 0);
    l = 1;
    beg = 0;
    i = 1;
    while ((size_t___0 )i < ks->seq.l) {
      if ((int )*(ks->seq.s + i) != c) {
        if (l >= min_len) {
          printf((char const   */* __restrict  */)"%s\t%d\t%d\t%c\n", ks->name.s,
                 beg, beg + l, c);
        }
        c = (int )*(ks->seq.s + i);
        l = 1;
        beg = i;
      } else {
        l ++;
      }
      i ++;
    }
  }
  if (l >= min_len) {
    printf((char const   */* __restrict  */)"%s\t%d\t%d\t%c\n", ks->name.s, beg, beg + l,
           c);
  }
  kseq_destroy(ks);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_hrun LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_getuntil LOC=UNKNOWN */
__inline static int ks_getuntil(kstream_t *ks , int delimiter , kstring_t *str , int *dret ) 
{ 
  int tmp ;

  {
  tmp = ((int (*)(kstream_t *ks , int delimiter , kstring_t *str , int *dret , int append ))_3__functionPtrArray[69 + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])(ks,
                                                                                                                                                                           delimiter,
                                                                                                                                                                           str,
                                                                                                                                                                           dret,
                                                                                                                                                                           0);
  _3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 9 : delimiter] = _3__functionPtrArray[25];
  return (tmp);
}
}
/* END FUNCTION-DEF ks_getuntil LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_init LOC=UNKNOWN */
__inline static kstream_t *ks_init(gzFile f ) 
{ 
  kstream_t *ks ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ((void *(*)(unsigned long  , unsigned long  ))_3__functionPtrArray[77 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((size_t___0 )1,
                                                                                                                                                                                            sizeof(kstream_t ));
  ks = (kstream_t *)tmp;
  ks->f = f;
  tmp___0 = ((void *(*)(unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 1 : 79])((size_t___0 )16384);
  ks->buf = (unsigned char *)tmp___0;
  return (ks);
}
}
/* END FUNCTION-DEF ks_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kseq_init LOC=UNKNOWN */
static kseq_t *kseq_init(gzFile fd ) 
{ 
  kseq_t *s ;
  void *tmp ;

  {
  tmp = ((void *(*)(unsigned long  , unsigned long  ))_3__functionPtrArray[91 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((size_t___0 )1,
                                                                                                                                                                                            sizeof(kseq_t ));
  _3__functionPtrArray[(_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[63];
  s = (kseq_t *)tmp;
  s->f = ks_init(fd);
  return (s);
}
}
/* END FUNCTION-DEF kseq_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_put_reg LOC=UNKNOWN */
__inline static khint_t kh_put_reg(kh_reg_t *h , kh_cstr_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  int tmp ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      kh_resize_reg(h, h->n_buckets - 1U);
    } else {
      kh_resize_reg(h, h->n_buckets + 1U);
    }
  }
  mask = h->n_buckets - 1U;
  site = h->n_buckets;
  x = site;
  k = __ac_X31_hash_string(key);
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          tmp = ((int (*)(char const   * , char const   * ))_3__functionPtrArray[41 - ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])(*(h->keys + i),
                                                                                                                                             key);
          if (tmp == 0) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      i = (i + inc) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
/* END FUNCTION-DEF kh_put_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_printstr LOC=UNKNOWN */
static void stk_printstr(kstring_t const   *s , unsigned int line_len ) 
{ 
  int i ;
  int rest ;

  {
  if (line_len != 4294967295U) {
    if (line_len != 0U) {
      rest = (int )s->l;
      i = 0;
      while ((size_t___0 )i < (size_t___0 )s->l) {
        putchar('\n');
        if ((unsigned int )rest > line_len) {
          fwrite((void const   */* __restrict  */)(s->s + i), (size_t___0 )1, (size_t___0 )line_len,
                 (FILE */* __restrict  */)stdout);
        } else {
          fwrite((void const   */* __restrict  */)(s->s + i), (size_t___0 )1, (size_t___0 )rest,
                 (FILE */* __restrict  */)stdout);
        }
        i = (int )((unsigned int )i + line_len);
        rest = (int )((unsigned int )rest - line_len);
      }
      putchar('\n');
    } else {
      putchar('\n');
      puts((char const   *)s->s);
    }
  } else {
    putchar('\n');
    puts((char const   *)s->s);
  }
  return;
}
}
/* END FUNCTION-DEF stk_printstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_randbase LOC=UNKNOWN */
int stk_randbase(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int i ;
  int c ;
  int b ;
  int a ;
  int j ;
  int k ;
  int m ;
  double tmp___4 ;
  int tmp___6 ;

  {
  if (argc == 1) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk randbase <in.fa>\n");
    return (1);
  }
  tmp___3 = strcmp((char const   *)*(argv + 1), "-");
  if (tmp___3 == 0) {
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
  } else {
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_randbase");
    return (1);
  }
  seq = kseq_init(fp);
  while (1) {
    l = kseq_read(seq);
    if (! (l >= 0)) {
      break;
    }
    printf((char const   */* __restrict  */)">%s", seq->name.s);
    i = 0;
    while (i < l) {
      b = (int )*(seq->seq.s + i);
      c = (int )seq_nt16_table[b];
      a = bitcnt_table[c];
      if (a == 2) {
        tmp___4 = drand48();
        m = tmp___4 < 0.5;
        k = 0;
        j = k;
        while (j < 4) {
          if (((1 << j) & c) == 0) {
            goto __Cont;
          }
          if (k == m) {
            break;
          }
          k ++;
          __Cont: 
          j ++;
        }
        tmp___6 = islower(b);
        if (tmp___6) {
          *(seq->seq.s + i) = (char )*("acgt" + j);
        } else {
          *(seq->seq.s + i) = (char )*("ACGT" + j);
        }
      }
      if (i % 60 == 0) {
        putchar('\n');
      }
      putchar((int )*(seq->seq.s + i));
      i ++;
    }
    putchar('\n');
  }
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_randbase LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cpy_kstr LOC=UNKNOWN */
static void cpy_kstr(kstring_t *dst , kstring_t const   *src ) 
{ 
  void *tmp ;

  {
  if (src->l == 0UL) {
    return;
  }
  if (src->l + 1UL > (size_t___0 const   )dst->m) {
    dst->m = (size_t___0 )(src->l + 1UL);
    (dst->m) --;
    dst->m |= dst->m >> 1;
    dst->m |= dst->m >> 2;
    dst->m |= dst->m >> 4;
    dst->m |= dst->m >> 8;
    dst->m |= dst->m >> 16;
    (dst->m) ++;
    tmp = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[6 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((void *)dst->s,
                                                                                                                                                                                     dst->m);
    _3__functionPtrArray[4 - ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))] = (void *)1213517;
    dst->s = (char *)tmp;
  }
  dst->l = (size_t___0 )src->l;
  ((void *(*)(void * __restrict   , void const   * __restrict   , size_t___0  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 8 : 5])((void */* __restrict  */)dst->s,
                                                                                                                                                                (void const   */* __restrict  */)src->s,
                                                                                                                                                                (size_t___0 )(src->l + 1UL));
  _3__functionPtrArray[! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = & src;
  return;
}
}
/* END FUNCTION-DEF cpy_kstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_mergefa LOC=UNKNOWN */
int stk_mergefa(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  int c ;
  int is_intersect ;
  int is_haploid ;
  int qual ;
  int is_mask ;
  int is_randhet ;
  uint64_t cnt[5] ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c___0[2] ;
  int b[2] ;
  int is_upper ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;

  {
  is_intersect = 0;
  is_haploid = 0;
  qual = 0;
  is_mask = 0;
  is_randhet = 0;
  while (1) {
    c = getopt(argc, argv, "himrq:");
    if (! (c >= 0)) {
      break;
    }
    switch (c) {
    case 105: 
    is_intersect = 1;
    break;
    case 104: 
    is_haploid = 1;
    break;
    case 109: 
    is_mask = 1;
    break;
    case 114: 
    is_randhet = 1;
    break;
    case 113: 
    qual = atoi((char const   *)optarg);
    break;
    }
  }
  if (is_mask) {
    if (is_intersect) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] `-i\' and `-h\' cannot be applied at the same time.\n",
              "stk_mergefa");
      return (1);
    }
  }
  if (optind + 2 > argc) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage: seqtk mergefa [options] <in1.fa> <in2.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q INT   quality threshold [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -i       take intersection\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m       convert to lowercase when one of the input base is N\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -r       pick a random allele from het\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -h       suppress hets in the input\n\n");
    return (1);
  }
  i = 0;
  while (i < 2) {
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), "-");
    if (tmp___3) {
      tmp___0 = gzopen((char const   *)*(argv + (optind + i)), "r");
      fp[i] = tmp___0;
    } else {
      tmp___1 = fileno(stdin);
      tmp___2 = gzdopen(tmp___1, "r");
      fp[i] = tmp___2;
    }
    seq[i] = kseq_init(fp[i]);
    i ++;
  }
  if ((unsigned long )fp[0] == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergefa");
    return (1);
  } else
  if ((unsigned long )fp[1] == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergefa");
    return (1);
  }
  cnt[4] = (uint64_t )0;
  cnt[3] = cnt[4];
  cnt[2] = cnt[3];
  cnt[1] = cnt[2];
  cnt[0] = cnt[1];
  srand48(11L);
  while (1) {
    tmp___21 = kseq_read(seq[0]);
    if (! (tmp___21 >= 0)) {
      break;
    }
    kseq_read(seq[1]);
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
    if (tmp___4) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Different sequence names: %s != %s\n",
              "stk_mergefa", (seq[0])->name.s, (seq[1])->name.s);
    }
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Unequal sequence length: %ld != %ld\n",
              "stk_mergefa", (seq[0])->seq.l, (seq[1])->seq.l);
    }
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
      min_l = (int )(seq[0])->seq.l;
    } else {
      min_l = (int )(seq[1])->seq.l;
    }
    printf((char const   */* __restrict  */)">%s", (seq[0])->name.s);
    l = 0;
    while (l < min_l) {
      c___0[0] = (int )*((seq[0])->seq.s + l);
      c___0[1] = (int )*((seq[1])->seq.s + l);
      if ((seq[0])->qual.l) {
        if ((int )*((seq[0])->qual.s + l) - 33 < qual) {
          c___0[0] = tolower(c___0[0]);
        }
      }
      if ((seq[1])->qual.l) {
        if ((int )*((seq[1])->qual.s + l) - 33 < qual) {
          c___0[1] = tolower(c___0[1]);
        }
      }
      if (is_intersect) {
        tmp___7 = isupper(c___0[0]);
        if (tmp___7) {
          is_upper = 1;
        } else {
          tmp___8 = isupper(c___0[1]);
          if (tmp___8) {
            is_upper = 1;
          } else {
            is_upper = 0;
          }
        }
      } else
      if (is_mask) {
        tmp___11 = isupper(c___0[0]);
        if (tmp___11) {
          is_upper = 1;
        } else {
          tmp___12 = isupper(c___0[1]);
          if (tmp___12) {
            is_upper = 1;
          } else {
            is_upper = 0;
          }
        }
      } else {
        tmp___15 = isupper(c___0[0]);
        if (tmp___15) {
          tmp___16 = isupper(c___0[1]);
          if (tmp___16) {
            is_upper = 1;
          } else {
            is_upper = 0;
          }
        } else {
          is_upper = 0;
        }
      }
      c___0[0] = (int )seq_nt16_table[c___0[0]];
      c___0[1] = (int )seq_nt16_table[c___0[1]];
      if (c___0[0] == 0) {
        c___0[0] = 15;
      }
      if (c___0[1] == 0) {
        c___0[1] = 15;
      }
      b[0] = bitcnt_table[c___0[0]];
      b[1] = bitcnt_table[c___0[1]];
      if (is_upper) {
        if (b[0] == 1) {
          if (b[1] == 1) {
            if (c___0[0] == c___0[1]) {
              (cnt[0]) ++;
            } else {
              (cnt[1]) ++;
            }
          } else {
            goto _L___1;
          }
        } else
        _L___1: 
        if (b[0] == 1) {
          if (b[1] == 2) {
            (cnt[2]) ++;
          } else {
            goto _L___0;
          }
        } else
        _L___0: 
        if (b[0] == 2) {
          if (b[1] == 1) {
            (cnt[3]) ++;
          } else {
            goto _L;
          }
        } else
        _L: 
        if (b[0] == 2) {
          if (b[1] == 2) {
            (cnt[4]) ++;
          }
        }
      }
      if (is_haploid) {
        if (b[0] > 1) {
          is_upper = 0;
        } else
        if (b[1] > 1) {
          is_upper = 0;
        }
      }
      if (is_intersect) {
        c___0[0] &= c___0[1];
        if (c___0[0] == 0) {
          is_upper = 0;
        }
      } else
      if (is_mask) {
        if (c___0[0] == 15) {
          is_upper = 0;
        } else
        if (c___0[1] == 15) {
          is_upper = 0;
        }
        c___0[0] &= c___0[1];
        if (c___0[0] == 0) {
          is_upper = 0;
        }
      } else
      if (is_randhet) {
        if (b[0] == 1) {
          if (b[1] == 1) {
            c___0[0] |= c___0[1];
          } else {
            goto _L___6;
          }
        } else
        _L___6: 
        if (b[0] == 1) {
          if (b[1] == 2) {
            goto _L___3;
          } else {
            goto _L___5;
          }
        } else
        _L___5: 
        if (b[0] == 2) {
          if (b[1] == 1) {
            _L___3: 
            if (c___0[0] & c___0[1]) {
              tmp___18 = lrand48();
              if (tmp___18 & 1L) {
                c___0[0] &= c___0[1];
              } else {
                c___0[0] |= c___0[1];
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else
        _L___4: 
        if (b[0] == 2) {
          if (b[1] == 2) {
            if (c___0[0] == c___0[1]) {
              tmp___20 = lrand48();
              if (tmp___20 & 1L) {
                tmp___19 = lrand48();
                if (tmp___19 & 1L) {
                  i = 8;
                  while (i >= 1) {
                    if (c___0[0] & i) {
                      c___0[0] &= i;
                    }
                    i >>= 1;
                  }
                } else {
                  i = 1;
                  while (i <= 8) {
                    if (c___0[0] & i) {
                      c___0[0] &= i;
                    }
                    i <<= 1;
                  }
                }
              }
            } else {
              is_upper = 0;
            }
          } else {
            is_upper = 0;
          }
        } else {
          is_upper = 0;
        }
      } else {
        c___0[0] |= c___0[1];
      }
      c___0[0] = (int )*(seq_nt16_rev_table + c___0[0]);
      if (! is_upper) {
        c___0[0] = tolower(c___0[0]);
      }
      if (l % 60 == 0) {
        putchar('\n');
      }
      putchar(c___0[0]);
      l ++;
    }
    putchar('\n');
  }
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] (same,diff,hom-het,het-hom,het-het)=(%ld,%ld,%ld,%ld,%ld)\n",
          "stk_mergefa", (long )cnt[0], (long )cnt[1], (long )cnt[2], (long )cnt[3],
          (long )cnt[4]);
  return (0);
}
}
/* END FUNCTION-DEF stk_mergefa LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_hety LOC=UNKNOWN */
int stk_hety(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int win_size ;
  int n_start ;
  int win_step ;
  int is_lower_mask ;
  char *buf ;
  uint32_t cnt[3] ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int x ;
  int i ;
  int y ;
  int z ;
  int next ;
  int tmp___5 ;
  int tmp___6 ;

  {
  win_size = 50000;
  n_start = 5;
  is_lower_mask = 0;
  if (argc == 1) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk hety [options] <in.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -w INT   window size [%d]\n",
            win_size);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -t INT   # start positions in a window [%d]\n",
            n_start);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m       treat lowercases as masked\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    return (1);
  }
  while (1) {
    c = getopt(argc, argv, "w:t:m");
    if (! (c >= 0)) {
      break;
    }
    switch (c) {
    case 119: 
    win_size = atoi((char const   *)optarg);
    break;
    case 116: 
    n_start = atoi((char const   *)optarg);
    break;
    case 109: 
    is_lower_mask = 1;
    break;
    }
  }
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  if (tmp___3 == 0) {
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
  } else {
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_hety");
    return (1);
  }
  seq = kseq_init(fp);
  win_step = win_size / n_start;
  tmp___4 = calloc((size_t___0 )win_size, (size_t___0 )1);
  buf = (char *)tmp___4;
  while (1) {
    l = kseq_read(seq);
    if (! (l >= 0)) {
      break;
    }
    next = 0;
    cnt[2] = (uint32_t )0;
    cnt[1] = cnt[2];
    cnt[0] = cnt[1];
    i = 0;
    while (i <= l) {
      if (i >= win_size) {
        if (i % win_step == 0) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else
      _L___0: 
      if (i == l) {
        _L: 
        if (i == l) {
          if (l >= win_size) {
            y = l - win_size;
            while (y < next) {
              (cnt[(int )*(buf + y % win_size)]) --;
              y ++;
            }
          }
        }
        if (cnt[1] + cnt[2] > 0U) {
          printf((char const   */* __restrict  */)"%s\t%d\t%d\t%.2lf\t%d\t%d\n", seq->name.s,
                 next, i, ((double )cnt[2] / (double )(cnt[1] + cnt[2])) * (double )win_size,
                 cnt[1] + cnt[2], cnt[2]);
        }
        next = i;
      }
      if (i < l) {
        y = i % win_size;
        c = (int )*(seq->seq.s + i);
        if (is_lower_mask) {
          tmp___5 = islower(c);
          if (tmp___5) {
            c = 'N';
          }
        }
        c = (int )seq_nt16_table[c];
        x = bitcnt_table[c];
        if (i >= win_size) {
          (cnt[(int )*(buf + y)]) --;
        }
        if (x > 2) {
          z = 0;
        } else {
          if (x == 2) {
            tmp___6 = 2;
          } else {
            tmp___6 = 1;
          }
          z = tmp___6;
        }
        *(buf + y) = (char )z;
        (cnt[z]) ++;
      }
      i ++;
    }
  }
  free((void *)buf);
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_hety LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kseq_destroy LOC=UNKNOWN */
static void kseq_destroy(kseq_t *ks ) 
{ 


  {
  if (! ks) {
    return;
  }
  ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 81 : 4])((void *)ks->name.s);
  _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 29 * 5 : 29] = _3__functionPtrArray[1];
  ((void (*)(void * ))_3__functionPtrArray[83 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((void *)ks->comment.s);
  _3__functionPtrArray[80 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[21];
  ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 85 : 6])((void *)ks->seq.s);
  _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 5 : 63] = _3__functionPtrArray[76];
  ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 1 : 87])((void *)ks->qual.s);
  ks_destroy(ks->f);
  ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 89 : 89 - 5])((void *)ks);
  _3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 16 : 6] = _3__functionPtrArray[84];
  return;
}
}
/* END FUNCTION-DEF kseq_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_printseq_renamed LOC=UNKNOWN */
__inline static void stk_printseq_renamed(kseq_t const   *s , int line_len , char const   *prefix ,
                                          int64_t n ) 
{ 
  int tmp ;

  {
  if (s->qual.l) {
    tmp = '@';
  } else {
    tmp = '>';
  }
  putchar(tmp);
  if (n >= 0LL) {
    if (prefix) {
      fputs((char const   */* __restrict  */)prefix, (FILE */* __restrict  */)stdout);
    }
    printf((char const   */* __restrict  */)"%lld", n);
  } else {
    fputs((char const   */* __restrict  */)s->name.s, (FILE */* __restrict  */)stdout);
  }
  if (s->comment.l) {
    putchar(' ');
    fputs((char const   */* __restrict  */)s->comment.s, (FILE */* __restrict  */)stdout);
  }
  stk_printstr(& s->seq, (unsigned int )line_len);
  if (s->qual.l) {
    putchar('+');
    stk_printstr(& s->qual, (unsigned int )line_len);
  }
  return;
}
}
/* END FUNCTION-DEF stk_printseq_renamed LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_resize_reg LOC=UNKNOWN */
__inline static void kh_resize_reg(kh_reg_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  kh_cstr_t key ;
  reglist_t val ;
  khint_t new_mask ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  kh_cstr_t tmp___4 ;
  reglist_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = ((void *(*)(unsigned long  ))_3__functionPtrArray[50 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((unsigned long )tmp * sizeof(khint32_t ));
    _3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 24 : 5] = _3__functionPtrArray[39];
    new_flags = (khint32_t *)tmp___0;
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    ((void *(*)(void * , int  , size_t___0  ))_3__functionPtrArray[51 - ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((void *)new_flags,
                                                                                                                                                                                    170,
                                                                                                                                                                                    (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 4 : 53])((void *)h->keys,
                                                                                                                                       (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
      h->keys = (kh_cstr_t *)tmp___2;
      tmp___3 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[54 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((void *)h->vals,
                                                                                                                                                                                            (unsigned long )new_n_buckets * sizeof(reglist_t ));
      _3__functionPtrArray[(_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[31];
      h->vals = (reglist_t *)tmp___3;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          k = __ac_X31_hash_string(key);
          i = k & new_mask;
          inc = (((k >> 3) ^ (k << 3)) | 1U) & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            i = (i + inc) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[56 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((void *)h->keys,
                                                                                                                                     (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
      h->keys = (kh_cstr_t *)tmp___6;
      tmp___7 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 57 : 4])((void *)h->vals,
                                                                                                                                       (unsigned long )new_n_buckets * sizeof(reglist_t ));
      _3__functionPtrArray[(_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[37];
      h->vals = (reglist_t *)tmp___7;
    }
    ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 59 | 10 : 59])((void *)h->flags);
    _3__functionPtrArray[47 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[37];
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
  }
  return;
}
}
/* END FUNCTION-DEF kh_resize_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_getuntil2 LOC=UNKNOWN */
static int ks_getuntil2(kstream_t *ks , int delimiter , kstring_t *str , int *dret ,
                        int append ) 
{ 
  int gotany ;
  int i ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  gotany = 0;
  if (dret) {
    *dret = 0;
  }
  if (append) {
    str->l = str->l;
  } else {
    str->l = (size_t___0 )0;
  }
  while (1) {
    if (ks->end < 0) {
      return (-3);
    }
    if (ks->begin >= ks->end) {
      if (! ks->is_eof) {
        ks->begin = 0;
        ks->end = ((int (*)(gzFile file , voidp buf , unsigned int len ))_3__functionPtrArray[70 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])(ks->f,
                                                                                                                                                          (voidp )ks->buf,
                                                                                                                                                          16384U);
        _3__functionPtrArray[29 - ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[62];
        if (ks->end == 0) {
          ks->is_eof = 1;
          break;
        }
        if (ks->end == -1) {
          ks->is_eof = 1;
          return (-3);
        }
      } else {
        break;
      }
    }
    if (delimiter == 2) {
      i = ks->begin;
      while (i < ks->end) {
        if ((int )*(ks->buf + i) == 10) {
          break;
        }
        i ++;
      }
    } else
    if (delimiter > 2) {
      i = ks->begin;
      while (i < ks->end) {
        if ((int )*(ks->buf + i) == delimiter) {
          break;
        }
        i ++;
      }
    } else
    if (delimiter == 0) {
      i = ks->begin;
      while (i < ks->end) {
        tmp = ((int (*)(int  ))_3__functionPtrArray[71 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((int )*(ks->buf + i));
        _3__functionPtrArray[(_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[61];
        if (tmp) {
          break;
        }
        i ++;
      }
    } else
    if (delimiter == 1) {
      i = ks->begin;
      while (i < ks->end) {
        tmp___0 = ((int (*)(int  ))_3__functionPtrArray[73 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((int )*(ks->buf + i));
        if (tmp___0) {
          if ((int )*(ks->buf + i) != 32) {
            break;
          }
        }
        i ++;
      }
    } else {
      i = 0;
    }
    if (str->m - str->l < (size_t___0 )((i - ks->begin) + 1)) {
      str->m = (str->l + (size_t___0 )(i - ks->begin)) + 1UL;
      (str->m) --;
      str->m |= str->m >> 1;
      str->m |= str->m >> 2;
      str->m |= str->m >> 4;
      str->m |= str->m >> 8;
      str->m |= str->m >> 16;
      (str->m) ++;
      tmp___1 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[74 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((void *)str->s,
                                                                                                                                                                                            str->m);
      _3__functionPtrArray[26 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[38];
      str->s = (char *)tmp___1;
    }
    gotany = 1;
    ((void *(*)(void * __restrict   , void const   * __restrict   , size_t___0  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 75 - 9 : 75])((void */* __restrict  */)(str->s + str->l),
                                                                                                                                                                        (void const   */* __restrict  */)(ks->buf + ks->begin),
                                                                                                                                                                        (size_t___0 )(i - ks->begin));
    str->l += (size_t___0 )(i - ks->begin);
    ks->begin = i + 1;
    if (i < ks->end) {
      if (dret) {
        *dret = (int )*(ks->buf + i);
      }
      break;
    }
  }
  if (! gotany) {
    if (ks->is_eof) {
      if (ks->begin >= ks->end) {
        return (-1);
      }
    }
  }
  if ((unsigned long )str->s == (unsigned long )((char *)0)) {
    str->m = (size_t___0 )1;
    tmp___2 = ((void *(*)(unsigned long  , unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 76 * 5 : 76])((size_t___0 )1,
                                                                                                                                                  (size_t___0 )1);
    str->s = (char *)tmp___2;
  } else
  if (delimiter == 2) {
    if (str->l > 1UL) {
      if ((int )*(str->s + (str->l - 1UL)) == 13) {
        (str->l) --;
      }
    }
  }
  *(str->s + str->l) = (char )'\000';
  return ((int )str->l);
}
}
/* END FUNCTION-DEF ks_getuntil2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_kfreq LOC=UNKNOWN */
int stk_kfreq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *ks ;
  int kmer ;
  int i ;
  int l ;
  int mask ;
  char *nei ;
  size_t___0 tmp ;
  int c ;
  int tmp___0 ;
  void *tmp___1 ;
  int j ;
  int x ;
  int tmp___3 ;
  gzFile tmp___4 ;
  gzFile tmp___5 ;
  int tmp___6 ;
  int k ;
  int x___0[2] ;
  int cnt[2] ;
  int cnt_nei[2] ;
  int which ;
  int c___0 ;
  int tmp___7 ;

  {
  if (argc < 2) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk kfreq <kmer> <in.fa>\n");
    return (1);
  }
  tmp = strlen((char const   *)*(argv + 1));
  l = (int )tmp;
  kmer = 0;
  i = kmer;
  while (i < l) {
    c = (int )seq_nt6_table[(int )*(*(argv + 1) + i)];
    if (c >= 1) {
      if (c <= 4) {
        tmp___0 = 1;
      } else {
        __assert_fail("c >= 1 && c <= 4", "seqtk.c", 1525, "stk_kfreq");
        tmp___0 = 0;
      }
    } else {
      __assert_fail("c >= 1 && c <= 4", "seqtk.c", 1525, "stk_kfreq");
      tmp___0 = 0;
    }
    kmer = (kmer << 2) | (c - 1);
    i ++;
  }
  mask = (1 << 2 * l) - 1;
  tmp___1 = calloc((size_t___0 )1, (size_t___0 )(1 << 2 * l));
  nei = (char *)tmp___1;
  i = 0;
  while (i < l) {
    x = kmer & ~ (3 << 2 * i);
    j = 0;
    while (j < 4) {
      *(nei + (x | (j << 2 * i))) = (char)1;
      j ++;
    }
    i ++;
  }
  if (argc == 2) {
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
  } else {
    tmp___6 = strcmp((char const   *)*(argv + 2), "-");
    if (tmp___6 == 0) {
      tmp___3 = fileno(stdin);
      tmp___4 = gzdopen(tmp___3, "r");
      fp = tmp___4;
    } else {
      tmp___5 = gzopen((char const   *)*(argv + 2), "r");
      fp = tmp___5;
    }
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_kfreq");
    return (1);
  }
  ks = kseq_init(fp);
  while (1) {
    tmp___7 = kseq_read(ks);
    if (! (tmp___7 >= 0)) {
      break;
    }
    cnt_nei[1] = 0;
    cnt_nei[0] = cnt_nei[1];
    cnt[1] = cnt_nei[0];
    cnt[0] = cnt[1];
    k = cnt[0];
    x___0[1] = k;
    x___0[0] = x___0[1];
    i = 0;
    while ((size_t___0 )i < ks->seq.l) {
      c___0 = (int )seq_nt6_table[(int )*(ks->seq.s + i)];
      if (c___0 >= 1) {
        if (c___0 <= 4) {
          x___0[0] = ((x___0[0] << 2) | (c___0 - 1)) & mask;
          x___0[1] = (x___0[1] >> 2) | ((4 - c___0) << 2 * (l - 1));
          if (k < l) {
            k ++;
          }
          if (k == l) {
            if (x___0[0] == kmer) {
              (cnt[0]) ++;
            } else
            if (x___0[1] == kmer) {
              (cnt[1]) ++;
            }
            if (*(nei + x___0[0])) {
              (cnt_nei[0]) ++;
            } else
            if (*(nei + x___0[1])) {
              (cnt_nei[1]) ++;
            }
          }
        } else {
          k = 0;
        }
      } else {
        k = 0;
      }
      i ++;
    }
    if (cnt_nei[0] > cnt_nei[1]) {
      which = 0;
    } else {
      which = 1;
    }
    printf((char const   */* __restrict  */)"%s\t%ld\t%c\t%d\t%d\n", ks->name.s, ks->seq.l,
           (int )*("+-" + which), cnt_nei[which], cnt[which]);
  }
  kseq_destroy(ks);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_kfreq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF find_next_cut LOC=UNKNOWN */
static int find_next_cut(kseq_t const   *ks , int k , int *begin , int *end ) 
{ 
  int i ;
  int b ;
  int e ;
  int score ;
  int max ;

  {
  while ((size_t___0 )k < (size_t___0 )ks->seq.l) {
    if ((int )seq_nt16_table[(int )*(ks->seq.s + k)] == 15) {
      score = 0;
      max = -1;
      e = max;
      i = k;
      while (1) {
        if ((size_t___0 )i < (size_t___0 )ks->seq.l) {
          if (! (score >= 0)) {
            break;
          }
        } else {
          break;
        }
        if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
          score ++;
        } else {
          score -= cutN_nonN_penalty;
        }
        if (score > max) {
          max = score;
          e = i;
        }
        i ++;
      }
      score = 0;
      max = -1;
      b = max;
      i = e;
      while (1) {
        if (i >= 0) {
          if (! (score >= 0)) {
            break;
          }
        } else {
          break;
        }
        if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
          score ++;
        } else {
          score -= cutN_nonN_penalty;
        }
        if (score > max) {
          max = score;
          b = i;
        }
        i --;
      }
      if ((e + 1) - b >= cutN_min_N_tract) {
        *begin = b;
        *end = e + 1;
        return (*end);
      }
      k = e + 1;
    } else {
      k ++;
    }
  }
  return (-1);
}
}
/* END FUNCTION-DEF find_next_cut LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_gc LOC=UNKNOWN */
int stk_gc(int argc , char **argv ) 
{ 
  int c ;
  int is_at ;
  int min_l ;
  double frac ;
  double xdropoff ;
  double q ;
  gzFile fp ;
  kseq_t *seq ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int i ;
  int start ;
  int max_i ;
  int n_hits ;
  int start_hits ;
  int max_hits ;
  double sc ;
  double max ;
  int hit ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  is_at = 0;
  min_l = 20;
  frac = (double )0.6f;
  xdropoff = (double )10.0f;
  while (1) {
    c = getopt(argc, argv, "wx:f:l:");
    if (! (c >= 0)) {
      break;
    }
    if (c == 120) {
      xdropoff = atof((char const   *)optarg);
    } else
    if (c == 119) {
      is_at = 1;
    } else
    if (c == 102) {
      frac = atof((char const   *)optarg);
    } else
    if (c == 108) {
      min_l = atoi((char const   *)optarg);
    }
  }
  if (optind + 1 > argc) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk gc [options] <in.fa>\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -w         identify high-AT regions\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f FLOAT   min GC fraction (or AT fraction for -w) [%.2f]\n",
            frac);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l INT     min region length to output [%d]\n",
            min_l);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -x FLOAT   X-dropoff [%.1f]\n",
            xdropoff);
    return (1);
  }
  q = ((double )1.0f - frac) / frac;
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  if (tmp___3) {
    tmp___0 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___0;
  } else {
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_gc");
    return (1);
  }
  seq = kseq_init(fp);
  while (1) {
    tmp___6 = kseq_read(seq);
    if (! (tmp___6 >= 0)) {
      break;
    }
    start = 0;
    max_i = 0;
    n_hits = 0;
    start_hits = 0;
    max_hits = 0;
    sc = 0.;
    max = 0.;
    i = 0;
    while ((size_t___0 )i < seq->seq.l) {
      c = (int )seq_nt16_table[(int )*(seq->seq.s + i)];
      if (is_at) {
        if (c == 1) {
          tmp___4 = 1;
        } else
        if (c == 8) {
          tmp___4 = 1;
        } else
        if (c == 9) {
          tmp___4 = 1;
        } else {
          tmp___4 = 0;
        }
        hit = tmp___4;
      } else {
        if (c == 2) {
          tmp___5 = 1;
        } else
        if (c == 4) {
          tmp___5 = 1;
        } else
        if (c == 6) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
        hit = tmp___5;
      }
      n_hits += hit;
      if (hit) {
        if (sc == (double )0) {
          start = i;
          start_hits = n_hits;
        }
        sc += q;
        if (sc > max) {
          max = sc;
          max_i = i;
          max_hits = n_hits;
        }
      } else
      if (sc > (double )0) {
        sc += (double )(- 1.0f);
        if (sc < (double )0) {
          goto _L;
        } else
        if (max - sc > xdropoff) {
          _L: 
          if ((max_i + 1) - start >= min_l) {
            printf((char const   */* __restrict  */)"%s\t%d\t%d\t%d\n", seq->name.s,
                   start, max_i + 1, (max_hits - start_hits) + 1);
          }
          max = (double )0;
          sc = max;
          i = max_i;
        }
      }
      i ++;
    }
    if (max > 0.) {
      if ((max_i + 1) - start >= min_l) {
        printf((char const   */* __restrict  */)"%s\t%d\t%d\t%d\n", seq->name.s, start,
               max_i + 1, (max_hits - start_hits) + 1);
      }
    }
  }
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_gc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_rename LOC=UNKNOWN */
int stk_rename(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  kseq_t last ;
  char *prefix ;
  uint64_t n ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  kstring_t *p ;
  kstring_t *q ;
  int is_diff ;
  int l ;
  size_t___0 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  prefix = (char *)0;
  n = (uint64_t )1;
  if (argc == 1) {
    tmp = fileno(stdin);
    tmp___0 = isatty(tmp);
    if (tmp___0) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk rename <in.fq> [prefix]\n");
      return (1);
    }
  }
  if (argc > 1) {
    tmp___5 = strcmp((char const   *)*(argv + 1), "-");
    if (tmp___5) {
      tmp___2 = gzopen((char const   *)*(argv + 1), "r");
      fp = tmp___2;
    } else {
      tmp___3 = fileno(stdin);
      tmp___4 = gzdopen(tmp___3, "r");
      fp = tmp___4;
    }
  } else {
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_rename");
    return (1);
  }
  seq = kseq_init(fp);
  if (argc > 2) {
    prefix = *(argv + 2);
  }
  memset((void *)(& last), 0, sizeof(kseq_t ));
  while (1) {
    tmp___11 = kseq_read(seq);
    if (! (tmp___11 >= 0)) {
      break;
    }
    if (last.name.l) {
      p = & last.name;
      q = & seq->name;
      if (p->l == q->l) {
        if (p->l > 2UL) {
          if ((int )*(p->s + (p->l - 2UL)) == 47) {
            if ((int )*(q->s + (q->l - 2UL)) == 47) {
              tmp___9 = isdigit((int )*(p->s + (p->l - 1UL)));
              if (tmp___9) {
                tmp___10 = isdigit((int )*(q->s + (q->l - 1UL)));
                if (tmp___10) {
                  tmp___8 = p->l - 2UL;
                } else {
                  tmp___8 = p->l;
                }
              } else {
                tmp___8 = p->l;
              }
            } else {
              tmp___8 = p->l;
            }
          } else {
            tmp___8 = p->l;
          }
        } else {
          tmp___8 = p->l;
        }
        l = (int )tmp___8;
        is_diff = strncmp((char const   *)p->s, (char const   *)q->s, (size_t___0 )l);
      } else {
        is_diff = 1;
      }
      if (! is_diff) {
        stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix,
                             (int64_t )n);
        stk_printseq_renamed((kseq_t const   *)seq, 0, (char const   *)prefix, (int64_t )n);
        last.name.l = (size_t___0 )0;
        n ++;
      } else {
        stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix,
                             (int64_t )n);
        n ++;
        cpy_kseq(& last, (kseq_t const   *)seq);
      }
    } else {
      cpy_kseq(& last, (kseq_t const   *)seq);
    }
  }
  if (last.name.l) {
    stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix, (int64_t )n);
  }
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_rename LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cpy_kseq LOC=UNKNOWN */
static void cpy_kseq(kseq_t *dst , kseq_t const   *src ) 
{ 


  {
  ((void (*)(kstring_t *dst , kstring_t const   *src ))_3__functionPtrArray[(_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])(& dst->name,
                                                                                                                                                                                      & src->name);
  _3__functionPtrArray[! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = & dst;
  ((void (*)(kstring_t *dst , kstring_t const   *src ))_3__functionPtrArray[(_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])(& dst->seq,
                                                                                                                                                                                                                                             & src->seq);
  ((void (*)(kstring_t *dst , kstring_t const   *src ))_3__functionPtrArray[(((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)) + 1) + 1])(& dst->qual,
                                                                                                                                                                                                  & src->qual);
  _3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 4 : 2] = _3__functionPtrArray[3];
  ((void (*)(kstring_t *dst , kstring_t const   *src ))_3__functionPtrArray[5 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])(& dst->comment,
                                                                                                                                     & src->comment);
  _3__functionPtrArray[! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[5];
  return;
}
}
/* END FUNCTION-DEF cpy_kseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_reg_read LOC=UNKNOWN */
reghash_t *stk_reg_read(char const   *fn ) 
{ 
  reghash_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kstream_t *ks ;
  int dret ;
  kstring_t *str ;
  gzFile tmp___1 ;
  int tmp___2 ;
  gzFile tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int beg ;
  int end ;
  reglist_t *p ;
  khint_t k ;
  khint_t tmp___6 ;
  int ret ;
  char *s ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  tmp = kh_init_reg();
  h = tmp;
  tmp___4 = ((int (*)(char const   * , char const   * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 8 : 110])(fn,
                                                                                                                                          "-");
  _3__functionPtrArray[38 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[61];
  if (tmp___4) {
    tmp___1 = ((gzFile (*)(char const   * , char const   * ))_3__functionPtrArray[111 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])(fn,
                                                                                                                                             "r");
    _3__functionPtrArray[58 - ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[3];
    fp = tmp___1;
  } else {
    tmp___2 = ((int (*)(FILE * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 113 + 8 : 113])(stdin);
    _3__functionPtrArray[84 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[10];
    tmp___3 = ((gzFile (*)(int fd , char const   *mode ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 114 : 10])(tmp___2,
                                                                                                                                            "r");
    _3__functionPtrArray[94 - ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[82];
    fp = tmp___3;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    return ((reghash_t *)0);
  }
  ks = ks_init(fp);
  tmp___5 = ((void *(*)(unsigned long  , unsigned long  ))_3__functionPtrArray[115 - ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((size_t___0 )1,
                                                                                                                                            sizeof(kstring_t ));
  str = (kstring_t *)tmp___5;
  while (1) {
    tmp___14 = ks_getuntil(ks, 0, str, & dret);
    if (! (tmp___14 >= 0)) {
      break;
    }
    beg = -1;
    end = -1;
    tmp___6 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )str->s);
    k = tmp___6;
    if (k == h->n_buckets) {
      tmp___7 = ((char *(*)(char const   * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 1 : 116])((char const   *)str->s);
      s = tmp___7;
      k = kh_put_reg(h, (kh_cstr_t )s, & ret);
      ((void *(*)(void * , int  , size_t___0  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 117 : 8])((void *)(h->vals + k),
                                                                                                                                  0,
                                                                                                                                  sizeof(reglist_t ));
    }
    p = h->vals + k;
    if (dret != 10) {
      tmp___10 = ks_getuntil(ks, 0, str, & dret);
      if (tmp___10 > 0) {
        tmp___11 = ((int (*)(int  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 118 : 118 + 10])((int )*(str->s + 0));
        _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? tmp___9 : 24] = & k;
        if (tmp___11) {
          beg = ((int (*)(char const   * ))_3__functionPtrArray[120 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((char const   *)str->s);
          _3__functionPtrArray[78 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[65];
          if (dret != 10) {
            tmp___8 = ks_getuntil(ks, 0, str, & dret);
            if (tmp___8 > 0) {
              tmp___9 = ((int (*)(int  ))_3__functionPtrArray[122 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((int )*(str->s + 0));
              if (tmp___9) {
                end = ((int (*)(char const   * ))_3__functionPtrArray[124 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((char const   *)str->s);
                if (end < 0) {
                  end = -1;
                }
              }
            }
          }
        }
      }
    }
    if (dret != 10) {
      while (1) {
        dret = ks_getc(ks);
        if (dret > 0) {
          if (! (dret != 10)) {
            break;
          }
        } else {
          break;
        }
      }
    }
    if (end < 0) {
      if (beg > 0) {
        end = beg;
        beg --;
      }
    }
    if (beg < 0) {
      beg = 0;
      end = 2147483647;
    }
    if (p->n == p->m) {
      if (p->m) {
        p->m <<= 1;
      } else {
        p->m = 4;
      }
      tmp___12 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[126 + ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((void *)p->a,
                                                                                                                                         (size_t___0 )(p->m * 8));
      _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 2 : 9] = _3__functionPtrArray[85];
      p->a = (uint64_t *)tmp___12;
    }
    tmp___13 = p->n;
    (p->n) ++;
    *(p->a + tmp___13) = ((uint64_t )beg << 32) | (unsigned long long )end;
  }
  ks_destroy(ks);
  ((int (*)(gzFile file ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 128 : 128 | tmp___4])(fp);
  _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 47 - 3 : 47] = _3__functionPtrArray[28];
  ((void (*)(void * ))_3__functionPtrArray[130 - ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((void *)str->s);
  _3__functionPtrArray[129 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[39];
  ((void (*)(void * ))_3__functionPtrArray[132 + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((void *)str);
  return (h);
}
}
/* END FUNCTION-DEF stk_reg_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF usage LOC=UNKNOWN */
static int usage(void) 
{ 


  {
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk <command> <arguments>\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version: 1.3-r106\n\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Command: seq       common transformation of FASTA/Q\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         comp      get the nucleotide composition of FASTA/Q\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         sample    subsample sequences\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         subseq    extract subsequences from FASTA/Q\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         fqchk     fastq QC (base/quality summary)\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mergepe   interleave two PE FASTA/Q files\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         trimfq    trim FASTQ using the Phred algorithm\n\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         hety      regional heterozygosity\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         gc        identify high- or low-GC regions\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mutfa     point mutate FASTA at specified positions\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mergefa   merge two FASTA/Q files\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         famask    apply a X-coded FASTA to a source FASTA\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         dropse    drop unpaired from interleaved PE FASTA/Q\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         rename    rename sequence names\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         randbase  choose a random base from hets\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         cutN      cut sequence at long N\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         listhet   extract the position of each het\n");
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  return (1);
}
}
/* END FUNCTION-DEF usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_dropse LOC=UNKNOWN */
int stk_dropse(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  kseq_t last ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  kstring_t *p ;
  kstring_t *q ;
  int is_diff ;
  int l ;
  size_t___0 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  if (argc == 1) {
    tmp = fileno(stdin);
    tmp___0 = isatty(tmp);
    if (tmp___0) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk dropse <in.fq>\n");
      return (1);
    }
  }
  if (argc > 1) {
    tmp___5 = strcmp((char const   *)*(argv + 1), "-");
    if (tmp___5) {
      tmp___2 = gzopen((char const   *)*(argv + 1), "r");
      fp = tmp___2;
    } else {
      tmp___3 = fileno(stdin);
      tmp___4 = gzdopen(tmp___3, "r");
      fp = tmp___4;
    }
  } else {
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_dropse");
    return (1);
  }
  seq = kseq_init(fp);
  memset((void *)(& last), 0, sizeof(kseq_t ));
  while (1) {
    tmp___11 = kseq_read(seq);
    if (! (tmp___11 >= 0)) {
      break;
    }
    if (last.name.l) {
      p = & last.name;
      q = & seq->name;
      if (p->l == q->l) {
        if (p->l > 2UL) {
          if ((int )*(p->s + (p->l - 2UL)) == 47) {
            if ((int )*(q->s + (q->l - 2UL)) == 47) {
              tmp___9 = isdigit((int )*(p->s + (p->l - 1UL)));
              if (tmp___9) {
                tmp___10 = isdigit((int )*(q->s + (q->l - 1UL)));
                if (tmp___10) {
                  tmp___8 = p->l - 2UL;
                } else {
                  tmp___8 = p->l;
                }
              } else {
                tmp___8 = p->l;
              }
            } else {
              tmp___8 = p->l;
            }
          } else {
            tmp___8 = p->l;
          }
        } else {
          tmp___8 = p->l;
        }
        l = (int )tmp___8;
        is_diff = strncmp((char const   *)p->s, (char const   *)q->s, (size_t___0 )l);
      } else {
        is_diff = 1;
      }
      if (! is_diff) {
        stk_printseq((kseq_t const   *)(& last), 0);
        stk_printseq((kseq_t const   *)seq, 0);
        last.name.l = (size_t___0 )0;
      } else {
        cpy_kseq(& last, (kseq_t const   *)seq);
      }
    } else {
      cpy_kseq(& last, (kseq_t const   *)seq);
    }
  }
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_dropse LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_resize_64 LOC=UNKNOWN */
__inline static void kh_resize_64(kh_64_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  void *tmp___2 ;
  khint64_t key ;
  khint_t new_mask ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint64_t tmp___4 ;
  void *tmp___6 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = ((void *(*)(unsigned long  ))_3__functionPtrArray[42 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((unsigned long )tmp * sizeof(khint32_t ));
    _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 5 : 40] = _3__functionPtrArray[1];
    new_flags = (khint32_t *)tmp___0;
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    ((void *(*)(void * , int  , size_t___0  ))_3__functionPtrArray[44 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((void *)new_flags,
                                                                                                                             170,
                                                                                                                             (unsigned long )tmp___1 * sizeof(khint32_t ));
    _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 29 << 3 : 29] = & tmp___4;
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 4 : 46])((void *)h->keys,
                                                                                                                                       (unsigned long )new_n_buckets * sizeof(khint64_t ));
      h->keys = (khint64_t *)tmp___2;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
          i = k & new_mask;
          inc = (((k >> 3) ^ (k << 3)) | 1U) & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            i = (i + inc) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              break;
            }
          } else {
            *(h->keys + i) = key;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[48 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((void *)h->keys,
                                                                                                                                                                                            (unsigned long )new_n_buckets * sizeof(khint64_t ));
      h->keys = (khint64_t *)tmp___6;
    }
    ((void (*)(void * ))_3__functionPtrArray[49 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
  }
  return;
}
}
/* END FUNCTION-DEF kh_resize_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_listhet LOC=UNKNOWN */
int stk_listhet(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int i ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int b ;

  {
  if (argc == 1) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk listhet <in.fa>\n");
    return (1);
  }
  tmp___3 = strcmp((char const   *)*(argv + 1), "-");
  if (tmp___3 == 0) {
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
  } else {
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_listhet");
    return (1);
  }
  seq = kseq_init(fp);
  while (1) {
    l = kseq_read(seq);
    if (! (l >= 0)) {
      break;
    }
    i = 0;
    while (i < l) {
      b = (int )*(seq->seq.s + i);
      if (bitcnt_table[seq_nt16_table[b]] == 2) {
        printf((char const   */* __restrict  */)"%s\t%d\t%c\n", seq->name.s, i + 1,
               b);
      }
      i ++;
    }
  }
  kseq_destroy(seq);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_listhet LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_seq LOC=UNKNOWN */
int stk_seq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int c ;
  int qual_thres ;
  int flag ;
  int qual_shift ;
  int mask_chr ;
  int min_len ;
  int max_q ;
  int fake_qual ;
  unsigned int i ;
  unsigned int line_len ;
  int64_t n_seqs ;
  double frac ;
  kh_reg_t *h ;
  krand_t *kr ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  gzFile tmp___6 ;
  int tmp___7 ;
  krint64_t tmp___8 ;
  int k ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  int c0 ;
  int c1 ;
  int tmp___16 ;

  {
  qual_thres = 0;
  flag = 0;
  qual_shift = 33;
  mask_chr = 0;
  min_len = 0;
  max_q = 255;
  fake_qual = -1;
  line_len = 0U;
  n_seqs = (int64_t )0;
  frac = 1.;
  h = (kh_reg_t *)0;
  kr = (krand_t *)0;
  while (1) {
    c = getopt(argc, argv, "N12q:l:Q:aACrn:s:f:M:L:cVUX:SF:");
    if (! (c >= 0)) {
      break;
    }
    switch (c) {
    case 97: 
    case 65: 
    flag |= 1;
    break;
    case 67: 
    flag |= 2;
    break;
    case 114: 
    flag |= 4;
    break;
    case 99: 
    flag |= 8;
    break;
    case 49: 
    flag |= 16;
    break;
    case 50: 
    flag |= 32;
    break;
    case 86: 
    flag |= 64;
    break;
    case 78: 
    flag |= 128;
    break;
    case 85: 
    flag |= 256;
    break;
    case 83: 
    flag |= 512;
    break;
    case 77: 
    h = stk_reg_read((char const   *)optarg);
    break;
    case 110: 
    mask_chr = (int )*optarg;
    break;
    case 81: 
    qual_shift = atoi((char const   *)optarg);
    break;
    case 113: 
    qual_thres = atoi((char const   *)optarg);
    break;
    case 88: 
    max_q = atoi((char const   *)optarg);
    break;
    case 108: 
    tmp = atoi((char const   *)optarg);
    line_len = (unsigned int )tmp;
    break;
    case 76: 
    min_len = atoi((char const   *)optarg);
    break;
    case 115: 
    tmp___0 = atol((char const   *)optarg);
    kr = kr_srand((krint64_t )tmp___0);
    break;
    case 102: 
    frac = atof((char const   *)optarg);
    break;
    case 70: 
    fake_qual = (int )*optarg;
    break;
    }
  }
  if ((unsigned long )kr == (unsigned long )((krand_t *)0)) {
    kr = kr_srand((krint64_t )11);
  }
  if (argc == optind) {
    tmp___1 = fileno(stdin);
    tmp___2 = isatty(tmp___1);
    if (tmp___2) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk seq [options] <in.fq>|<in.fa>\n\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q INT    mask bases with quality lower than INT [0]\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -X INT    mask bases with quality higher than INT [255]\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -n CHAR   masked bases converted to CHAR; 0 for lowercase [0]\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT    number of residues per line; 0 for 2^32-1 [%d]\n",
              line_len);
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -Q INT    quality shift: ASCII-INT gives base quality [%d]\n",
              qual_shift);
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -s INT    random seed (effective with -f) [11]\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -f FLOAT  sample FLOAT fraction of sequences [1]\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -M FILE   mask regions in BED or name list FILE [null]\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -L INT    drop sequences with length shorter than INT [0]\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -F CHAR   fake FASTQ quality []\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -c        mask complement region (effective with -M)\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -r        reverse complement\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -A        force FASTA output (discard quality)\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -C        drop comments at the header lines\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -N        drop sequences containing ambiguous bases\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -1        output the 2n-1 reads only\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -2        output the 2n reads only\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -V        shift quality by \'(-Q) - 33\'\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -U        convert all bases to uppercases\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -S        strip of white spaces in sequences\n");
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      free((void *)kr);
      return (1);
    }
  }
  if (line_len == 0U) {
    line_len = 4294967295U;
  }
  if (optind < argc) {
    tmp___7 = strcmp((char const   *)*(argv + optind), "-");
    if (tmp___7) {
      tmp___4 = gzopen((char const   *)*(argv + optind), "r");
      fp = tmp___4;
    } else {
      tmp___5 = fileno(stdin);
      tmp___6 = gzdopen(tmp___5, "r");
      fp = tmp___6;
    }
  } else {
    tmp___5 = fileno(stdin);
    tmp___6 = gzdopen(tmp___5, "r");
    fp = tmp___6;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_seq");
    return (1);
  }
  seq = kseq_init(fp);
  qual_thres += qual_shift;
  while (1) {
    tmp___16 = kseq_read(seq);
    if (! (tmp___16 >= 0)) {
      break;
    }
    n_seqs ++;
    if (seq->seq.l < (size_t___0 )min_len) {
      continue;
    }
    if (frac < 1.) {
      tmp___8 = kr_rand(kr);
      if ((double )(tmp___8 >> 11) * (1.0 / 9007199254740992.0) >= frac) {
        continue;
      }
    }
    if (flag & 48) {
      if (flag & 16) {
        if ((n_seqs & 1LL) == 0LL) {
          continue;
        }
      }
      if (flag & 32) {
        if ((n_seqs & 1LL) == 1LL) {
          continue;
        }
      }
    }
    if (flag & 512) {
      if (seq->qual.l) {
        k = 0;
        i = (unsigned int )k;
        while ((size_t___0 )i < seq->seq.l) {
          tmp___10 = isspace((int )*(seq->seq.s + i));
          if (! tmp___10) {
            tmp___9 = k;
            k ++;
            *(seq->qual.s + tmp___9) = *(seq->qual.s + i);
          }
          i ++;
        }
        seq->qual.l = (size_t___0 )k;
      }
      k = 0;
      i = (unsigned int )k;
      while ((size_t___0 )i < seq->seq.l) {
        tmp___12 = isspace((int )*(seq->seq.s + i));
        if (! tmp___12) {
          tmp___11 = k;
          k ++;
          *(seq->seq.s + tmp___11) = *(seq->seq.s + i);
        }
        i ++;
      }
      seq->seq.l = (size_t___0 )k;
    }
    if (seq->qual.l) {
      if (qual_thres > qual_shift) {
        if (mask_chr) {
          i = 0U;
          while ((size_t___0 )i < seq->seq.l) {
            if ((int )*(seq->qual.s + i) < qual_thres) {
              *(seq->seq.s + i) = (char )mask_chr;
            } else
            if ((int )*(seq->qual.s + i) > max_q) {
              *(seq->seq.s + i) = (char )mask_chr;
            }
            i ++;
          }
        } else {
          i = 0U;
          while ((size_t___0 )i < seq->seq.l) {
            if ((int )*(seq->qual.s + i) < qual_thres) {
              tmp___13 = tolower((int )*(seq->seq.s + i));
              *(seq->seq.s + i) = (char )tmp___13;
            } else
            if ((int )*(seq->qual.s + i) > max_q) {
              tmp___13 = tolower((int )*(seq->seq.s + i));
              *(seq->seq.s + i) = (char )tmp___13;
            }
            i ++;
          }
        }
      }
    }
    if (flag & 256) {
      i = 0U;
      while ((size_t___0 )i < seq->seq.l) {
        tmp___14 = toupper((int )*(seq->seq.s + i));
        *(seq->seq.s + i) = (char )tmp___14;
        i ++;
      }
    }
    if (flag & 1) {
      seq->qual.l = (size_t___0 )0;
    } else
    if (fake_qual >= 33) {
      if (fake_qual <= 127) {
        if (seq->qual.m < seq->seq.m) {
          seq->qual.m = seq->seq.m;
          tmp___15 = realloc((void *)seq->qual.s, seq->qual.m);
          seq->qual.s = (char *)tmp___15;
        }
        seq->qual.l = seq->seq.l;
        memset((void *)seq->qual.s, fake_qual, seq->qual.l);
        *(seq->qual.s + seq->qual.l) = (char)0;
      }
    }
    if (flag & 2) {
      seq->comment.l = (size_t___0 )0;
    }
    if (h) {
      stk_mask(seq, (kh_reg_t const   *)h, flag & 8, mask_chr);
    }
    if (flag & 4) {
      i = 0U;
      while ((size_t___0 )i < seq->seq.l >> 1) {
        c0 = (int )comp_tab[(int )*(seq->seq.s + i)];
        c1 = (int )comp_tab[(int )*(seq->seq.s + ((seq->seq.l - 1UL) - (size_t___0 )i))];
        *(seq->seq.s + i) = (char )c1;
        *(seq->seq.s + ((seq->seq.l - 1UL) - (size_t___0 )i)) = (char )c0;
        i ++;
      }
      if (seq->seq.l & 1UL) {
        *(seq->seq.s + (seq->seq.l >> 1)) = comp_tab[(int )*(seq->seq.s + (seq->seq.l >> 1))];
      }
      if (seq->qual.l) {
        i = 0U;
        while ((size_t___0 )i < seq->seq.l >> 1) {
          c0 = (int )*(seq->qual.s + i);
          *(seq->qual.s + i) = *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t___0 )i));
          *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t___0 )i)) = (char )c0;
          i ++;
        }
      }
    }
    if (flag & 64) {
      if (seq->qual.l) {
        if (qual_shift != 33) {
          i = 0U;
          while ((size_t___0 )i < seq->qual.l) {
            *(seq->qual.s + i) = (char )((int )*(seq->qual.s + i) - (qual_shift - 33));
            i ++;
          }
        }
      }
    }
    if (flag & 128) {
      i = 0U;
      while ((size_t___0 )i < seq->seq.l) {
        if ((int )seq_nt16to4_table[seq_nt16_table[(int )*(seq->seq.s + i)]] > 3) {
          break;
        }
        i ++;
      }
      if ((size_t___0 )i < seq->seq.l) {
        continue;
      }
    }
    stk_printseq((kseq_t const   *)seq, (int )line_len);
  }
  kseq_destroy(seq);
  gzclose(fp);
  stk_reg_destroy(h);
  free((void *)kr);
  return (0);
}
}
/* END FUNCTION-DEF stk_seq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_init_reg LOC=UNKNOWN */
__inline static kh_reg_t *kh_init_reg(void) 
{ 
  void *tmp ;

  {
  tmp = ((void *(*)(unsigned long  , unsigned long  ))_3__functionPtrArray[39 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((size_t___0 )1,
                                                                                                                                                                                            sizeof(kh_reg_t ));
  return ((kh_reg_t *)tmp);
}
}
/* END FUNCTION-DEF kh_init_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_destroy LOC=UNKNOWN */
__inline static void ks_destroy(kstream_t *ks ) 
{ 


  {
  if (ks) {
    ((void (*)(void * ))_3__functionPtrArray[65 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((void *)ks->buf);
    ((void (*)(void * ))_3__functionPtrArray[66 - ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((void *)ks);
    _3__functionPtrArray[40 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[4];
  }
  return;
}
}
/* END FUNCTION-DEF ks_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_fqchk LOC=UNKNOWN */
int stk_fqchk(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int i ;
  int c ;
  int k ;
  int max_len ;
  int min_len ;
  int max_alloc ;
  int offset ;
  int n_diffQ ;
  int qthres ;
  int64_t tot_len ;
  int64_t n ;
  double perr[94] ;
  posstat_t all ;
  posstat_t *pos ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int old_max ;
  void *tmp___4 ;
  int q ;
  int b ;
  int tmp___5 ;

  {
  max_len = 0;
  min_len = 2147483647;
  max_alloc = 0;
  offset = 33;
  n_diffQ = 0;
  qthres = 20;
  tot_len = (int64_t )0;
  n = (int64_t )0;
  pos = (posstat_t *)0;
  while (1) {
    c = getopt(argc, argv, "q:");
    if (! (c >= 0)) {
      break;
    }
    if (c == 113) {
      qthres = atoi((char const   *)optarg);
    }
  }
  if (optind == argc) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk fqchk [-q %d] <in.fq>\n",
            qthres);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: use -q0 to get the distribution of all quality values\n");
    return (1);
  }
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  if (tmp___3 == 0) {
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
  } else {
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_fqchk");
    return (1);
  }
  seq = kseq_init(fp);
  k = 0;
  while (k <= 93) {
    perr[k] = pow(10., - .1 * (double )k);
    k ++;
  }
  perr[3] = .5;
  perr[2] = perr[3];
  perr[1] = perr[2];
  perr[0] = perr[1];
  while (1) {
    tmp___5 = kseq_read(seq);
    if (! (tmp___5 >= 0)) {
      break;
    }
    if (seq->qual.l == 0UL) {
      continue;
    }
    n ++;
    tot_len = (int64_t )((unsigned long long )tot_len + (unsigned long long )seq->seq.l);
    if ((size_t___0 )min_len < seq->seq.l) {
      min_len = min_len;
    } else {
      min_len = (int )seq->seq.l;
    }
    if ((size_t___0 )max_len > seq->seq.l) {
      max_len = max_len;
    } else {
      max_len = (int )seq->seq.l;
    }
    if (max_len > max_alloc) {
      old_max = max_alloc;
      max_alloc = max_len;
      max_alloc --;
      max_alloc |= max_alloc >> 1;
      max_alloc |= max_alloc >> 2;
      max_alloc |= max_alloc >> 4;
      max_alloc |= max_alloc >> 8;
      max_alloc |= max_alloc >> 16;
      max_alloc ++;
      tmp___4 = realloc((void *)pos, (unsigned long )max_alloc * sizeof(posstat_t ));
      pos = (posstat_t *)tmp___4;
      memset((void *)(pos + old_max), 0, (unsigned long )(max_alloc - old_max) * sizeof(posstat_t ));
    }
    i = 0;
    while ((size_t___0 )i < seq->qual.l) {
      q = (int )*(seq->qual.s + i) - offset;
      b = (int )seq_nt6_table[(int )*(seq->seq.s + i)];
      if (b) {
        b --;
      } else {
        b = 4;
      }
      if (q < 93) {
        q = q;
      } else {
        q = 93;
      }
      ((pos + i)->q[q]) ++;
      ((pos + i)->b[b]) ++;
      i ++;
    }
  }
  kseq_destroy(seq);
  gzclose(fp);
  memset((void *)(& all), 0, sizeof(posstat_t ));
  i = 0;
  while (i < max_len) {
    k = 0;
    while (k <= 93) {
      all.q[k] += (pos + i)->q[k];
      k ++;
    }
    k = 0;
    while (k <= 4) {
      all.b[k] += (pos + i)->b[k];
      k ++;
    }
    i ++;
  }
  n_diffQ = 0;
  k = n_diffQ;
  while (k <= 93) {
    if (all.q[k]) {
      n_diffQ ++;
    }
    k ++;
  }
  printf((char const   */* __restrict  */)"min_len: %d; max_len: %d; avg_len: %.2f; %d distinct quality values\n",
         min_len, max_len, (double )tot_len / (double )n, n_diffQ);
  printf((char const   */* __restrict  */)"POS\t#bases\t%%A\t%%C\t%%G\t%%T\t%%N\tavgQ\terrQ");
  if (qthres <= 0) {
    k = 0;
    while (k <= 93) {
      if (all.q[k] > 0LL) {
        printf((char const   */* __restrict  */)"\t%%Q%d", k);
      }
      k ++;
    }
  } else {
    printf((char const   */* __restrict  */)"\t%%low\t%%high");
  }
  putchar('\n');
  fqc_aux(& all, 0, all.q, perr, qthres);
  i = 0;
  while (i < max_len) {
    fqc_aux(pos + i, i + 1, all.q, perr, qthres);
    i ++;
  }
  free((void *)pos);
  return (0);
}
}
/* END FUNCTION-DEF stk_fqchk LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_get_64 LOC=UNKNOWN */
__inline static khint_t kh_get_64(kh_64_t const   *h , khint64_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t tmp ;

  {
  if (h->n_buckets) {
    mask = (khint_t )(h->n_buckets - 1U);
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & mask;
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      i = (i + inc) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp = (khint_t )h->n_buckets;
    } else {
      tmp = i;
    }
    return (tmp);
  } else {
    return ((khint_t )0);
  }
}
}
/* END FUNCTION-DEF kh_get_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kr_srand LOC=UNKNOWN */
krand_t *kr_srand(krint64_t seed ) 
{ 
  krand_t *kr ;
  void *tmp ;

  {
  tmp = ((void *(*)(unsigned long  ))_3__functionPtrArray[62 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])(sizeof(krand_t ));
  _3__functionPtrArray[16 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[20];
  kr = (krand_t *)tmp;
  ((void (*)(krint64_t seed , krand_t *kr ))_3__functionPtrArray[64 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])(seed,
                                                                                                                           kr);
  return (kr);
}
}
/* END FUNCTION-DEF kr_srand LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_put_64 LOC=UNKNOWN */
__inline static khint_t kh_put_64(kh_64_t *h , khint64_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      kh_resize_64(h, h->n_buckets - 1U);
    } else {
      kh_resize_64(h, h->n_buckets + 1U);
    }
  }
  mask = h->n_buckets - 1U;
  site = h->n_buckets;
  x = site;
  k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      i = (i + inc) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
/* END FUNCTION-DEF kh_put_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kr_rand LOC=UNKNOWN */
krint64_t kr_rand(krand_t *kr ) 
{ 
  krint64_t x ;
  int i ;
  int tmp ;

  {
  if (kr->mti >= 312) {
    if (kr->mti == 313) {
      ((void (*)(krint64_t seed , krand_t *kr ))_3__functionPtrArray[61 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])(5489ULL,
                                                                                                                                                                                      kr);
      _3__functionPtrArray[38 + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[10];
    }
    i = 0;
    while (i < 156) {
      x = (kr->mt[i] & 0xffffffff80000000ULL) | (kr->mt[i + 1] & 2147483647ULL);
      kr->mt[i] = (kr->mt[i + 156] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
      i ++;
    }
    while (i < 311) {
      x = (kr->mt[i] & 0xffffffff80000000ULL) | (kr->mt[i + 1] & 2147483647ULL);
      kr->mt[i] = (kr->mt[i + -156] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
      i ++;
    }
    x = (kr->mt[311] & 0xffffffff80000000ULL) | (kr->mt[0] & 2147483647ULL);
    kr->mt[311] = (kr->mt[155] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
    kr->mti = 0;
  }
  tmp = kr->mti;
  (kr->mti) ++;
  x = kr->mt[tmp];
  x ^= (x >> 29) & 6148914691236517205ULL;
  x ^= (x << 17) & 8202884508482404352ULL;
  x ^= (x << 37) & 0xfff7eee000000000ULL;
  x ^= x >> 43;
  return (x);
}
}
/* END FUNCTION-DEF kr_rand LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_init_64 LOC=UNKNOWN */
__inline static kh_64_t *kh_init_64(void) 
{ 
  void *tmp ;

  {
  tmp = ((void *(*)(unsigned long  , unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 37 : 5])((size_t___0 )1,
                                                                                                                                       sizeof(kh_64_t ));
  return ((kh_64_t *)tmp);
}
}
/* END FUNCTION-DEF kh_init_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_mask LOC=UNKNOWN */
void stk_mask(kseq_t *seq , kh_reg_t const   *h , int is_complement , int mask_chr ) 
{ 
  unsigned int i ;
  unsigned int j ;
  khiter_t k ;
  int tmp ;
  reglist_t *p ;
  unsigned int beg ;
  unsigned int end ;
  int tmp___0 ;
  int8_t *mask ;
  void *tmp___1 ;
  unsigned int beg___0 ;
  unsigned int end___0 ;
  int tmp___2 ;

  {
  k = kh_get_reg(h, (kh_cstr_t )seq->name.s);
  if (k == (khiter_t )h->n_buckets) {
    if (is_complement) {
      if (mask_chr) {
        j = 0U;
        while ((size_t___0 )j < seq->seq.l) {
          *(seq->seq.s + j) = (char )mask_chr;
          j ++;
        }
      } else {
        j = 0U;
        while ((size_t___0 )j < seq->seq.l) {
          tmp = ((int (*)(int  ))_3__functionPtrArray[100 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((int )*(seq->seq.s + j));
          *(seq->seq.s + j) = (char )tmp;
          j ++;
        }
      }
    }
  } else {
    p = (reglist_t *)(h->vals + k);
    if (! is_complement) {
      i = 0U;
      while (i < (unsigned int )p->n) {
        beg = (unsigned int )(*(p->a + i) >> 32);
        end = (unsigned int )*(p->a + i);
        if ((size_t___0 )beg >= seq->seq.l) {
          goto __Cont;
        }
        if ((size_t___0 )end > seq->seq.l) {
          end = (unsigned int )seq->seq.l;
        }
        if (! mask_chr) {
          j = beg;
          while (j < end) {
            tmp___0 = ((int (*)(int  ))_3__functionPtrArray[101 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((int )*(seq->seq.s + j));
            *(seq->seq.s + j) = (char )tmp___0;
            j ++;
          }
        } else {
          j = beg;
          while (j < end) {
            *(seq->seq.s + j) = (char )mask_chr;
            j ++;
          }
        }
        __Cont: 
        i ++;
      }
    } else {
      tmp___1 = ((void *(*)(unsigned long  , unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 102 << is_complement : 102])(seq->seq.l,
                                                                                                                                                                   (size_t___0 )1);
      _3__functionPtrArray[43 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[82];
      mask = (int8_t *)tmp___1;
      i = 0U;
      while (i < (unsigned int )p->n) {
        beg___0 = (unsigned int )(*(p->a + i) >> 32);
        end___0 = (unsigned int )*(p->a + i);
        if ((size_t___0 )end___0 >= seq->seq.l) {
          end___0 = (unsigned int )seq->seq.l;
        }
        j = beg___0;
        while (j < end___0) {
          *(mask + j) = (int8_t )1;
          j ++;
        }
        i ++;
      }
      if (mask_chr) {
        j = 0U;
        while ((size_t___0 )j < seq->seq.l) {
          if ((int )*(mask + j) == 0) {
            *(seq->seq.s + j) = (char )mask_chr;
          }
          j ++;
        }
      } else {
        j = 0U;
        while ((size_t___0 )j < seq->seq.l) {
          if ((int )*(mask + j) == 0) {
            tmp___2 = ((int (*)(int  ))_3__functionPtrArray[104 - ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((int )*(seq->seq.s + j));
            _3__functionPtrArray[55 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[99];
            *(seq->seq.s + j) = (char )tmp___2;
          }
          j ++;
        }
      }
      ((void (*)(void * ))_3__functionPtrArray[105 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((void *)mask);
    }
  }
  return;
}
}
/* END FUNCTION-DEF stk_mask LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kr_srand0 LOC=UNKNOWN */
static void kr_srand0(krint64_t seed , krand_t *kr ) 
{ 


  {
  kr->mt[0] = seed;
  kr->mti = 1;
  while (kr->mti < 312) {
    kr->mt[kr->mti] = 6364136223846793005ULL * (kr->mt[kr->mti - 1] ^ (kr->mt[kr->mti - 1] >> 62)) + (unsigned long long )kr->mti;
    (kr->mti) ++;
  }
  return;
}
}
/* END FUNCTION-DEF kr_srand0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_subseq LOC=UNKNOWN */
int stk_subseq(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int i ;
  int j ;
  int c ;
  int is_tab ;
  int line ;
  khint_t k ;
  gzFile tmp___1 ;
  int tmp___2 ;
  gzFile tmp___3 ;
  int tmp___4 ;
  reglist_t *p ;
  int beg ;
  int end ;
  int tmp___5 ;

  {
  tmp = kh_init_reg();
  h = tmp;
  is_tab = 0;
  line = 0;
  while (1) {
    c = getopt(argc, argv, "tl:");
    if (! (c >= 0)) {
      break;
    }
    switch (c) {
    case 116: 
    is_tab = 1;
    break;
    case 108: 
    line = atoi((char const   *)optarg);
    break;
    }
  }
  if (optind + 2 > argc) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk subseq [options] <in.fa> <in.bed>|<name.list>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -t       TAB delimited output\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT   sequence line length [%d]\n\n",
            line);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Use \'samtools faidx\' if only a few regions are intended.\n\n");
    return (1);
  }
  h = stk_reg_read((char const   *)*(argv + (optind + 1)));
  if ((unsigned long )h == (unsigned long )((kh_reg_t *)0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to read the list of regions in file \'%s\'\n",
            "stk_subseq", *(argv + (optind + 1)));
    return (1);
  }
  tmp___4 = strcmp((char const   *)*(argv + optind), "-");
  if (tmp___4) {
    tmp___1 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___1;
  } else {
    tmp___2 = fileno(stdin);
    tmp___3 = gzdopen(tmp___2, "r");
    fp = tmp___3;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream\n",
            "stk_subseq");
    return (1);
  }
  seq = kseq_init(fp);
  while (1) {
    l = kseq_read(seq);
    if (! (l >= 0)) {
      break;
    }
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
    if (k == h->n_buckets) {
      continue;
    }
    p = h->vals + k;
    i = 0;
    while (i < p->n) {
      beg = (int )(*(p->a + i) >> 32);
      end = (int )*(p->a + i);
      if ((size_t___0 )beg >= seq->seq.l) {
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[subseq] %s: %d >= %ld\n",
                seq->name.s, beg, seq->seq.l);
        goto __Cont;
      }
      if ((size_t___0 )end > seq->seq.l) {
        end = (int )seq->seq.l;
      }
      if (is_tab == 0) {
        if (seq->qual.l == seq->seq.l) {
          tmp___5 = '@';
        } else {
          tmp___5 = '>';
        }
        printf((char const   */* __restrict  */)"%c%s", tmp___5, seq->name.s);
        if (beg > 0) {
          goto _L;
        } else
        if ((int )*(p->a + i) != 2147483647) {
          _L: 
          if (end == 2147483647) {
            if (beg) {
              printf((char const   */* __restrict  */)":%d", beg + 1);
            }
          } else {
            printf((char const   */* __restrict  */)":%d-%d", beg + 1, end);
          }
        }
        if (seq->comment.l) {
          printf((char const   */* __restrict  */)" %s", seq->comment.s);
        }
      } else {
        printf((char const   */* __restrict  */)"%s\t%d\t", seq->name.s, beg + 1);
      }
      if ((size_t___0 )end > seq->seq.l) {
        end = (int )seq->seq.l;
      }
      j = 0;
      while (j < end - beg) {
        if (is_tab == 0) {
          if (j == 0) {
            putchar('\n');
          } else
          if (line > 0) {
            if (j % line == 0) {
              putchar('\n');
            }
          }
        }
        putchar((int )*(seq->seq.s + (j + beg)));
        j ++;
      }
      putchar('\n');
      if (seq->qual.l != seq->seq.l) {
        goto __Cont;
      } else
      if (is_tab) {
        goto __Cont;
      }
      printf((char const   */* __restrict  */)"+");
      j = 0;
      while (j < end - beg) {
        if (j == 0) {
          putchar('\n');
        } else
        if (line > 0) {
          if (j % line == 0) {
            putchar('\n');
          }
        }
        putchar((int )*(seq->qual.s + (j + beg)));
        j ++;
      }
      putchar('\n');
      __Cont: 
      i ++;
    }
  }
  kseq_destroy(seq);
  gzclose(fp);
  stk_reg_destroy(h);
  return (0);
}
}
/* END FUNCTION-DEF stk_subseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_famask LOC=UNKNOWN */
int stk_famask(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  int c ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c___0[2] ;
  int tmp___4 ;
  int tmp___5 ;

  {
  while (1) {
    c = getopt(argc, argv, "");
    if (! (c >= 0)) {
      break;
    }
  }
  if (argc - optind < 2) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk famask <src.fa> <mask.fa>\n");
    return (1);
  }
  i = 0;
  while (i < 2) {
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), "-");
    if (tmp___3) {
      tmp___0 = gzopen((char const   *)*(argv + (optind + i)), "r");
      fp[i] = tmp___0;
    } else {
      tmp___1 = fileno(stdin);
      tmp___2 = gzdopen(tmp___1, "r");
      fp[i] = tmp___2;
    }
    seq[i] = kseq_init(fp[i]);
    i ++;
  }
  if ((unsigned long )fp[0] == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_famask");
    return (1);
  } else
  if ((unsigned long )fp[1] == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_famask");
    return (1);
  }
  while (1) {
    tmp___5 = kseq_read(seq[0]);
    if (! (tmp___5 >= 0)) {
      break;
    }
    kseq_read(seq[1]);
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
    if (tmp___4) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Different sequence names: %s != %s\n",
              "stk_famask", (seq[0])->name.s, (seq[1])->name.s);
    }
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Unequal sequence length: %ld != %ld\n",
              "stk_famask", (seq[0])->seq.l, (seq[1])->seq.l);
    }
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
      min_l = (int )(seq[0])->seq.l;
    } else {
      min_l = (int )(seq[1])->seq.l;
    }
    printf((char const   */* __restrict  */)">%s", (seq[0])->name.s);
    l = 0;
    while (l < min_l) {
      c___0[0] = (int )*((seq[0])->seq.s + l);
      c___0[1] = (int )*((seq[1])->seq.s + l);
      if (c___0[1] == 120) {
        c___0[0] = tolower(c___0[0]);
      } else
      if (c___0[1] != 88) {
        c___0[0] = c___0[1];
      }
      if (l % 60 == 0) {
        putchar('\n');
      }
      putchar(c___0[0]);
      l ++;
    }
    putchar('\n');
  }
  return (0);
}
}
/* END FUNCTION-DEF stk_famask LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_getc LOC=UNKNOWN */
__inline static int ks_getc(kstream_t *ks ) 
{ 
  int tmp ;

  {
  if (ks->end < 0) {
    return (-3);
  }
  if (ks->is_eof) {
    if (ks->begin >= ks->end) {
      return (-1);
    }
  }
  if (ks->begin >= ks->end) {
    ks->begin = 0;
    ks->end = ((int (*)(gzFile file , voidp buf , unsigned int len ))_3__functionPtrArray[68 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])(ks->f,
                                                                                                                                                      (voidp )ks->buf,
                                                                                                                                                      16384U);
    if (ks->end == 0) {
      ks->is_eof = 1;
      return (-1);
    } else
    if (ks->end < 0) {
      ks->is_eof = 1;
      return (-3);
    }
  }
  tmp = ks->begin;
  (ks->begin) ++;
  return ((int )*(ks->buf + tmp));
}
}
/* END FUNCTION-DEF ks_getc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_printseq LOC=UNKNOWN */
__inline static void stk_printseq(kseq_t const   *s , int line_len ) 
{ 


  {
  stk_printseq_renamed(s, line_len, (char const   *)0, (int64_t )-1);
  return;
}
}
/* END FUNCTION-DEF stk_printseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kseq_read LOC=UNKNOWN */
static int kseq_read(kseq_t *seq ) 
{ 
  int c ;
  int r ;
  kstream_t *ks ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  ks = seq->f;
  if (seq->last_char == 0) {
    while (1) {
      c = ks_getc(ks);
      if (c >= 0) {
        if (c != 62) {
          if (! (c != 64)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    }
    if (c < 0) {
      return (c);
    }
    seq->last_char = c;
  }
  tmp___0 = (size_t___0 )0;
  seq->qual.l = tmp___0;
  tmp = tmp___0;
  seq->seq.l = tmp;
  seq->comment.l = tmp;
  r = ks_getuntil(ks, 0, & seq->name, & c);
  if (r < 0) {
    return (r);
  }
  if (c != 10) {
    ks_getuntil(ks, 2, & seq->comment, (int *)0);
  }
  if ((unsigned long )seq->seq.s == (unsigned long )((char *)0)) {
    seq->seq.m = (size_t___0 )256;
    tmp___1 = ((void *(*)(unsigned long  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 5 : 93])(seq->seq.m);
    seq->seq.s = (char *)tmp___1;
  }
  while (1) {
    c = ks_getc(ks);
    if (c >= 0) {
      if (c != 62) {
        if (c != 43) {
          if (! (c != 64)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (c == 10) {
      continue;
    }
    tmp___2 = seq->seq.l;
    (seq->seq.l) ++;
    *(seq->seq.s + tmp___2) = (char )c;
    ((int (*)(kstream_t *ks , int delimiter , kstring_t *str , int *dret , int append ))_3__functionPtrArray[95 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])(ks,
                                                                                                                                                                                                                              2,
                                                                                                                                                                                                                              & seq->seq,
                                                                                                                                                                                                                              (int *)0,
                                                                                                                                                                                                                              1);
  }
  if (c == 62) {
    seq->last_char = c;
  } else
  if (c == 64) {
    seq->last_char = c;
  }
  if (seq->seq.l + 1UL >= seq->seq.m) {
    seq->seq.m = seq->seq.l + 2UL;
    (seq->seq.m) --;
    seq->seq.m |= seq->seq.m >> 1;
    seq->seq.m |= seq->seq.m >> 2;
    seq->seq.m |= seq->seq.m >> 4;
    seq->seq.m |= seq->seq.m >> 8;
    seq->seq.m |= seq->seq.m >> 16;
    (seq->seq.m) ++;
    tmp___3 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[96 + ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((void *)seq->seq.s,
                                                                                                                                                                                          seq->seq.m);
    _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 8 : 4] = _3__functionPtrArray[83];
    seq->seq.s = (char *)tmp___3;
  }
  *(seq->seq.s + seq->seq.l) = (char)0;
  seq->is_fastq = c == 43;
  if (! seq->is_fastq) {
    return ((int )seq->seq.l);
  }
  if (seq->qual.m < seq->seq.m) {
    seq->qual.m = seq->seq.m;
    tmp___4 = ((void *(*)(void * , unsigned long  ))_3__functionPtrArray[97 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((void *)seq->qual.s,
                                                                                                                                                                                          seq->qual.m);
    _3__functionPtrArray[72 + ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[81];
    seq->qual.s = (char *)tmp___4;
  }
  while (1) {
    c = ks_getc(ks);
    if (c >= 0) {
      if (! (c != 10)) {
        break;
      }
    } else {
      break;
    }
  }
  if (c == -1) {
    return (-2);
  }
  while (1) {
    tmp___5 = ((int (*)(kstream_t *ks , int delimiter , kstring_t *str , int *dret ,
                        int append ))_3__functionPtrArray[99 - ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])(ks,
                                                                                                                      2,
                                                                                                                      & seq->qual,
                                                                                                                      (int *)0,
                                                                                                                      1);
    _3__functionPtrArray[47 + ! (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[78];
    if (tmp___5 >= 0) {
      if (seq->qual.l < seq->seq.l) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    } else {
      tmp___6 = 0;
    }
    c = tmp___6;
    if (! c) {
      break;
    }
  }
  if (c == -3) {
    return (-3);
  }
  seq->last_char = 0;
  if (seq->seq.l != seq->qual.l) {
    return (-2);
  }
  return ((int )seq->seq.l);
}
}
/* END FUNCTION-DEF kseq_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_mutfa LOC=UNKNOWN */
int stk_mutfa(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  kstream_t *ks ;
  int l ;
  int i ;
  int dret ;
  kstring_t *str ;
  khint_t k ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  char *s ;
  char *tmp___6 ;
  int beg ;
  int ret ;
  reglist_t *p ;
  long tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  gzFile tmp___14 ;
  int tmp___15 ;
  gzFile tmp___16 ;
  int tmp___17 ;
  reglist_t *p___0 ;
  int beg___0 ;

  {
  tmp = kh_init_reg();
  h = tmp;
  if (argc < 3) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk mutfa <in.fa> <in.snp>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: <in.snp> contains at least four columns per line which are:\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      \'chr  1-based-pos  any  base-changed-to\'.\n");
    return (1);
  }
  tmp___0 = calloc((size_t___0 )1, sizeof(kstring_t ));
  str = (kstring_t *)tmp___0;
  tmp___5 = strcmp((char const   *)*(argv + 2), "-");
  if (tmp___5) {
    tmp___2 = gzopen((char const   *)*(argv + 2), "r");
    fp = tmp___2;
  } else {
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mutfa");
    return (1);
  }
  ks = ks_init(fp);
  while (1) {
    tmp___12 = ks_getuntil(ks, 0, str, & dret);
    if (! (tmp___12 >= 0)) {
      break;
    }
    tmp___6 = strdup((char const   *)str->s);
    s = tmp___6;
    beg = 0;
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )s);
    if (k == h->n_buckets) {
      k = kh_put_reg(h, (kh_cstr_t )s, & ret);
      memset((void *)(h->vals + k), 0, sizeof(reglist_t ));
    }
    p = h->vals + k;
    tmp___8 = ks_getuntil(ks, 0, str, & dret);
    if (tmp___8 > 0) {
      tmp___7 = atol((char const   *)str->s);
      beg = (int )(tmp___7 - 1L);
    }
    ks_getuntil(ks, 0, str, & dret);
    ks_getuntil(ks, 0, str, & dret);
    if (dret != 10) {
      while (1) {
        dret = ks_getc(ks);
        if (dret > 0) {
          if (! (dret != 10)) {
            break;
          }
        } else {
          break;
        }
      }
    }
    tmp___11 = isalpha((int )*(str->s + 0));
    if (tmp___11) {
      if (str->l == 1UL) {
        if (p->n == p->m) {
          if (p->m) {
            p->m <<= 1;
          } else {
            p->m = 4;
          }
          tmp___9 = realloc((void *)p->a, (size_t___0 )(p->m * 8));
          p->a = (uint64_t *)tmp___9;
        }
        tmp___10 = p->n;
        (p->n) ++;
        *(p->a + tmp___10) = ((uint64_t )beg << 32) | (unsigned long long )*(str->s + 0);
      }
    }
  }
  ks_destroy(ks);
  gzclose(fp);
  free((void *)str->s);
  free((void *)str);
  tmp___17 = strcmp((char const   *)*(argv + 1), "-");
  if (tmp___17) {
    tmp___14 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___14;
  } else {
    tmp___15 = fileno(stdin);
    tmp___16 = gzdopen(tmp___15, "r");
    fp = tmp___16;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mutfa");
    return (1);
  }
  seq = kseq_init(fp);
  while (1) {
    l = kseq_read(seq);
    if (! (l >= 0)) {
      break;
    }
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
    if (k != h->n_buckets) {
      p___0 = h->vals + k;
      i = 0;
      while (i < p___0->n) {
        beg___0 = (int )(*(p___0->a + i) >> 32);
        if ((size_t___0 )beg___0 < seq->seq.l) {
          *(seq->seq.s + beg___0) = (char )((int )*(p___0->a + i));
        }
        i ++;
      }
    }
    printf((char const   */* __restrict  */)">%s", seq->name.s);
    i = 0;
    while (i < l) {
      if (i % 60 == 0) {
        putchar('\n');
      }
      putchar((int )*(seq->seq.s + i));
      i ++;
    }
    putchar('\n');
  }
  kseq_destroy(seq);
  gzclose(fp);
  k = (khint_t )0;
  while (k < h->n_buckets) {
    if (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      free((void *)(h->vals + k)->a);
      free((void *)((char *)*(h->keys + k)));
    }
    k ++;
  }
  kh_destroy_reg(h);
  return (0);
}
}
/* END FUNCTION-DEF stk_mutfa LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_destroy_64 LOC=UNKNOWN */
__inline static void kh_destroy_64(kh_64_t *h ) 
{ 


  {
  if (h) {
    ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 22 : 0])((void *)h->keys);
    ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 23 ^ 4 : 23])((void *)h->flags);
    ((void (*)(void * ))_3__functionPtrArray[25 * ! (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((void *)h->vals);
    ((void (*)(void * ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 27 : 27 | 2])((void *)h);
  }
  return;
}
}
/* END FUNCTION-DEF kh_destroy_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF __ac_X31_hash_string LOC=UNKNOWN */
__inline static khint_t __ac_X31_hash_string(char const   *s ) 
{ 
  khint_t h ;

  {
  h = (khint_t )*s;
  if (h) {
    s ++;
    while (*s) {
      h = ((h << 5) - h) + (khint_t )*s;
      s ++;
    }
  }
  return (h);
}
}
/* END FUNCTION-DEF __ac_X31_hash_string LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int _BARRIER_0 ;
  struct _1_main_1_opaque_NodeStruct *p44 ;
  int r45 ;
  struct _1_main_1_opaque_NodeStruct *p46 ;
  int r47 ;
  struct _1_main_1_opaque_NodeStruct *p48 ;
  int _1_main__BEGIN_1 ;
  int _1_main__END_1 ;
  int _1_main__BARRIER_2 ;

  {
  {
  {
  {
  {
  cutN_nonN_penalty = 10;
  goto cutN_nonN_penalty_i$nit_INLINE_cutN_nonN_penalty_i$nit;
  }
  cutN_nonN_penalty_i$nit_INLINE_cutN_nonN_penalty_i$nit: /* CIL Label */ ;
  }
  {
  {
  cutN_min_N_tract = 1000;
  goto cutN_min_N_tract_i$nit_INLINE_cutN_min_N_tract_i$nit;
  }
  cutN_min_N_tract_i$nit_INLINE_cutN_min_N_tract_i$nit: /* CIL Label */ ;
  }
  {
  {
  mag01[0] = (krint64_t const   )0;
  mag01[1] = (krint64_t const   )0xb5026f5aa96619e9ULL;
  goto mag01_i$nit_INLINE_mag01_i$nit;
  }
  mag01_i$nit_INLINE_mag01_i$nit: /* CIL Label */ ;
  }
  {
  {
  comp_tab[0] = (char)0;
  comp_tab[1] = (char)1;
  comp_tab[2] = (char)2;
  comp_tab[3] = (char)3;
  comp_tab[4] = (char)4;
  comp_tab[5] = (char)5;
  comp_tab[6] = (char)6;
  comp_tab[7] = (char)7;
  comp_tab[8] = (char)8;
  comp_tab[9] = (char)9;
  comp_tab[10] = (char)10;
  comp_tab[11] = (char)11;
  comp_tab[12] = (char)12;
  comp_tab[13] = (char)13;
  comp_tab[14] = (char)14;
  comp_tab[15] = (char)15;
  comp_tab[16] = (char)16;
  comp_tab[17] = (char)17;
  comp_tab[18] = (char)18;
  comp_tab[19] = (char)19;
  comp_tab[20] = (char)20;
  comp_tab[21] = (char)21;
  comp_tab[22] = (char)22;
  comp_tab[23] = (char)23;
  comp_tab[24] = (char)24;
  comp_tab[25] = (char)25;
  comp_tab[26] = (char)26;
  comp_tab[27] = (char)27;
  comp_tab[28] = (char)28;
  comp_tab[29] = (char)29;
  comp_tab[30] = (char)30;
  comp_tab[31] = (char)31;
  comp_tab[32] = (char)32;
  comp_tab[33] = (char)33;
  comp_tab[34] = (char)34;
  comp_tab[35] = (char)35;
  comp_tab[36] = (char)36;
  comp_tab[37] = (char)37;
  comp_tab[38] = (char)38;
  comp_tab[39] = (char)39;
  comp_tab[40] = (char)40;
  comp_tab[41] = (char)41;
  comp_tab[42] = (char)42;
  comp_tab[43] = (char)43;
  comp_tab[44] = (char)44;
  comp_tab[45] = (char)45;
  comp_tab[46] = (char)46;
  comp_tab[47] = (char)47;
  comp_tab[48] = (char)48;
  comp_tab[49] = (char)49;
  comp_tab[50] = (char)50;
  comp_tab[51] = (char)51;
  comp_tab[52] = (char)52;
  comp_tab[53] = (char)53;
  comp_tab[54] = (char)54;
  comp_tab[55] = (char)55;
  comp_tab[56] = (char)56;
  comp_tab[57] = (char)57;
  comp_tab[58] = (char)58;
  comp_tab[59] = (char)59;
  comp_tab[60] = (char)60;
  comp_tab[61] = (char)61;
  comp_tab[62] = (char)62;
  comp_tab[63] = (char)63;
  comp_tab[64] = (char)64;
  comp_tab[65] = (char )'T';
  comp_tab[66] = (char )'V';
  comp_tab[67] = (char )'G';
  comp_tab[68] = (char )'H';
  comp_tab[69] = (char )'E';
  comp_tab[70] = (char )'F';
  comp_tab[71] = (char )'C';
  comp_tab[72] = (char )'D';
  comp_tab[73] = (char )'I';
  comp_tab[74] = (char )'J';
  comp_tab[75] = (char )'M';
  comp_tab[76] = (char )'L';
  comp_tab[77] = (char )'K';
  comp_tab[78] = (char )'N';
  comp_tab[79] = (char )'O';
  comp_tab[80] = (char )'P';
  comp_tab[81] = (char )'Q';
  comp_tab[82] = (char )'Y';
  comp_tab[83] = (char )'S';
  comp_tab[84] = (char )'A';
  comp_tab[85] = (char )'A';
  comp_tab[86] = (char )'B';
  comp_tab[87] = (char )'W';
  comp_tab[88] = (char )'X';
  comp_tab[89] = (char )'R';
  comp_tab[90] = (char )'Z';
  comp_tab[91] = (char)91;
  comp_tab[92] = (char)92;
  comp_tab[93] = (char)93;
  comp_tab[94] = (char)94;
  comp_tab[95] = (char)95;
  comp_tab[96] = (char)64;
  comp_tab[97] = (char )'t';
  comp_tab[98] = (char )'v';
  comp_tab[99] = (char )'g';
  comp_tab[100] = (char )'h';
  comp_tab[101] = (char )'e';
  comp_tab[102] = (char )'f';
  comp_tab[103] = (char )'c';
  comp_tab[104] = (char )'d';
  comp_tab[105] = (char )'i';
  comp_tab[106] = (char )'j';
  comp_tab[107] = (char )'m';
  comp_tab[108] = (char )'l';
  comp_tab[109] = (char )'k';
  comp_tab[110] = (char )'n';
  comp_tab[111] = (char )'o';
  comp_tab[112] = (char )'p';
  comp_tab[113] = (char )'q';
  comp_tab[114] = (char )'y';
  comp_tab[115] = (char )'s';
  comp_tab[116] = (char )'a';
  comp_tab[117] = (char )'a';
  comp_tab[118] = (char )'b';
  comp_tab[119] = (char )'w';
  comp_tab[120] = (char )'x';
  comp_tab[121] = (char )'r';
  comp_tab[122] = (char )'z';
  comp_tab[123] = (char)123;
  comp_tab[124] = (char)124;
  comp_tab[125] = (char)125;
  comp_tab[126] = (char)126;
  comp_tab[127] = (char)127;
  goto comp_tab_i$nit_INLINE_comp_tab_i$nit;
  }
  comp_tab_i$nit_INLINE_comp_tab_i$nit: /* CIL Label */ ;
  }
  {
  {
  bitcnt_table[0] = 4;
  bitcnt_table[1] = 1;
  bitcnt_table[2] = 1;
  bitcnt_table[3] = 2;
  bitcnt_table[4] = 1;
  bitcnt_table[5] = 2;
  bitcnt_table[6] = 2;
  bitcnt_table[7] = 3;
  bitcnt_table[8] = 1;
  bitcnt_table[9] = 2;
  bitcnt_table[10] = 2;
  bitcnt_table[11] = 3;
  bitcnt_table[12] = 2;
  bitcnt_table[13] = 3;
  bitcnt_table[14] = 3;
  bitcnt_table[15] = 4;
  goto bitcnt_table_i$nit_INLINE_bitcnt_table_i$nit;
  }
  bitcnt_table_i$nit_INLINE_bitcnt_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16comp_table[0] = (unsigned char)0;
  seq_nt16comp_table[1] = (unsigned char)8;
  seq_nt16comp_table[2] = (unsigned char)4;
  seq_nt16comp_table[3] = (unsigned char)12;
  seq_nt16comp_table[4] = (unsigned char)2;
  seq_nt16comp_table[5] = (unsigned char)10;
  seq_nt16comp_table[6] = (unsigned char)9;
  seq_nt16comp_table[7] = (unsigned char)14;
  seq_nt16comp_table[8] = (unsigned char)1;
  seq_nt16comp_table[9] = (unsigned char)6;
  seq_nt16comp_table[10] = (unsigned char)5;
  seq_nt16comp_table[11] = (unsigned char)13;
  seq_nt16comp_table[12] = (unsigned char)3;
  seq_nt16comp_table[13] = (unsigned char)11;
  seq_nt16comp_table[14] = (unsigned char)7;
  seq_nt16comp_table[15] = (unsigned char)15;
  goto seq_nt16comp_table_i$nit_INLINE_seq_nt16comp_table_i$nit;
  }
  seq_nt16comp_table_i$nit_INLINE_seq_nt16comp_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16to4_table[0] = (unsigned char)4;
  seq_nt16to4_table[1] = (unsigned char)0;
  seq_nt16to4_table[2] = (unsigned char)1;
  seq_nt16to4_table[3] = (unsigned char)4;
  seq_nt16to4_table[4] = (unsigned char)2;
  seq_nt16to4_table[5] = (unsigned char)4;
  seq_nt16to4_table[6] = (unsigned char)4;
  seq_nt16to4_table[7] = (unsigned char)4;
  seq_nt16to4_table[8] = (unsigned char)3;
  seq_nt16to4_table[9] = (unsigned char)4;
  seq_nt16to4_table[10] = (unsigned char)4;
  seq_nt16to4_table[11] = (unsigned char)4;
  seq_nt16to4_table[12] = (unsigned char)4;
  seq_nt16to4_table[13] = (unsigned char)4;
  seq_nt16to4_table[14] = (unsigned char)4;
  seq_nt16to4_table[15] = (unsigned char)4;
  goto seq_nt16to4_table_i$nit_INLINE_seq_nt16to4_table_i$nit;
  }
  seq_nt16to4_table_i$nit_INLINE_seq_nt16to4_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16_rev_table = (char *)"XACMGRSVTWYHKDBN";
  goto seq_nt16_rev_table_i$nit_INLINE_seq_nt16_rev_table_i$nit;
  }
  seq_nt16_rev_table_i$nit_INLINE_seq_nt16_rev_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt6_table[0] = (unsigned char)0;
  seq_nt6_table[1] = (unsigned char)5;
  seq_nt6_table[2] = (unsigned char)5;
  seq_nt6_table[3] = (unsigned char)5;
  seq_nt6_table[4] = (unsigned char)5;
  seq_nt6_table[5] = (unsigned char)5;
  seq_nt6_table[6] = (unsigned char)5;
  seq_nt6_table[7] = (unsigned char)5;
  seq_nt6_table[8] = (unsigned char)5;
  seq_nt6_table[9] = (unsigned char)5;
  seq_nt6_table[10] = (unsigned char)5;
  seq_nt6_table[11] = (unsigned char)5;
  seq_nt6_table[12] = (unsigned char)5;
  seq_nt6_table[13] = (unsigned char)5;
  seq_nt6_table[14] = (unsigned char)5;
  seq_nt6_table[15] = (unsigned char)5;
  seq_nt6_table[16] = (unsigned char)5;
  seq_nt6_table[17] = (unsigned char)5;
  seq_nt6_table[18] = (unsigned char)5;
  seq_nt6_table[19] = (unsigned char)5;
  seq_nt6_table[20] = (unsigned char)5;
  seq_nt6_table[21] = (unsigned char)5;
  seq_nt6_table[22] = (unsigned char)5;
  seq_nt6_table[23] = (unsigned char)5;
  seq_nt6_table[24] = (unsigned char)5;
  seq_nt6_table[25] = (unsigned char)5;
  seq_nt6_table[26] = (unsigned char)5;
  seq_nt6_table[27] = (unsigned char)5;
  seq_nt6_table[28] = (unsigned char)5;
  seq_nt6_table[29] = (unsigned char)5;
  seq_nt6_table[30] = (unsigned char)5;
  seq_nt6_table[31] = (unsigned char)5;
  seq_nt6_table[32] = (unsigned char)5;
  seq_nt6_table[33] = (unsigned char)5;
  seq_nt6_table[34] = (unsigned char)5;
  seq_nt6_table[35] = (unsigned char)5;
  seq_nt6_table[36] = (unsigned char)5;
  seq_nt6_table[37] = (unsigned char)5;
  seq_nt6_table[38] = (unsigned char)5;
  seq_nt6_table[39] = (unsigned char)5;
  seq_nt6_table[40] = (unsigned char)5;
  seq_nt6_table[41] = (unsigned char)5;
  seq_nt6_table[42] = (unsigned char)5;
  seq_nt6_table[43] = (unsigned char)5;
  seq_nt6_table[44] = (unsigned char)5;
  seq_nt6_table[45] = (unsigned char)5;
  seq_nt6_table[46] = (unsigned char)5;
  seq_nt6_table[47] = (unsigned char)5;
  seq_nt6_table[48] = (unsigned char)5;
  seq_nt6_table[49] = (unsigned char)5;
  seq_nt6_table[50] = (unsigned char)5;
  seq_nt6_table[51] = (unsigned char)5;
  seq_nt6_table[52] = (unsigned char)5;
  seq_nt6_table[53] = (unsigned char)5;
  seq_nt6_table[54] = (unsigned char)5;
  seq_nt6_table[55] = (unsigned char)5;
  seq_nt6_table[56] = (unsigned char)5;
  seq_nt6_table[57] = (unsigned char)5;
  seq_nt6_table[58] = (unsigned char)5;
  seq_nt6_table[59] = (unsigned char)5;
  seq_nt6_table[60] = (unsigned char)5;
  seq_nt6_table[61] = (unsigned char)5;
  seq_nt6_table[62] = (unsigned char)5;
  seq_nt6_table[63] = (unsigned char)5;
  seq_nt6_table[64] = (unsigned char)5;
  seq_nt6_table[65] = (unsigned char)1;
  seq_nt6_table[66] = (unsigned char)5;
  seq_nt6_table[67] = (unsigned char)2;
  seq_nt6_table[68] = (unsigned char)5;
  seq_nt6_table[69] = (unsigned char)5;
  seq_nt6_table[70] = (unsigned char)5;
  seq_nt6_table[71] = (unsigned char)3;
  seq_nt6_table[72] = (unsigned char)5;
  seq_nt6_table[73] = (unsigned char)5;
  seq_nt6_table[74] = (unsigned char)5;
  seq_nt6_table[75] = (unsigned char)5;
  seq_nt6_table[76] = (unsigned char)5;
  seq_nt6_table[77] = (unsigned char)5;
  seq_nt6_table[78] = (unsigned char)5;
  seq_nt6_table[79] = (unsigned char)5;
  seq_nt6_table[80] = (unsigned char)5;
  seq_nt6_table[81] = (unsigned char)5;
  seq_nt6_table[82] = (unsigned char)5;
  seq_nt6_table[83] = (unsigned char)5;
  seq_nt6_table[84] = (unsigned char)4;
  seq_nt6_table[85] = (unsigned char)5;
  seq_nt6_table[86] = (unsigned char)5;
  seq_nt6_table[87] = (unsigned char)5;
  seq_nt6_table[88] = (unsigned char)5;
  seq_nt6_table[89] = (unsigned char)5;
  seq_nt6_table[90] = (unsigned char)5;
  seq_nt6_table[91] = (unsigned char)5;
  seq_nt6_table[92] = (unsigned char)5;
  seq_nt6_table[93] = (unsigned char)5;
  seq_nt6_table[94] = (unsigned char)5;
  seq_nt6_table[95] = (unsigned char)5;
  seq_nt6_table[96] = (unsigned char)5;
  seq_nt6_table[97] = (unsigned char)1;
  seq_nt6_table[98] = (unsigned char)5;
  seq_nt6_table[99] = (unsigned char)2;
  seq_nt6_table[100] = (unsigned char)5;
  seq_nt6_table[101] = (unsigned char)5;
  seq_nt6_table[102] = (unsigned char)5;
  seq_nt6_table[103] = (unsigned char)3;
  seq_nt6_table[104] = (unsigned char)5;
  seq_nt6_table[105] = (unsigned char)5;
  seq_nt6_table[106] = (unsigned char)5;
  seq_nt6_table[107] = (unsigned char)5;
  seq_nt6_table[108] = (unsigned char)5;
  seq_nt6_table[109] = (unsigned char)5;
  seq_nt6_table[110] = (unsigned char)5;
  seq_nt6_table[111] = (unsigned char)5;
  seq_nt6_table[112] = (unsigned char)5;
  seq_nt6_table[113] = (unsigned char)5;
  seq_nt6_table[114] = (unsigned char)5;
  seq_nt6_table[115] = (unsigned char)5;
  seq_nt6_table[116] = (unsigned char)4;
  seq_nt6_table[117] = (unsigned char)5;
  seq_nt6_table[118] = (unsigned char)5;
  seq_nt6_table[119] = (unsigned char)5;
  seq_nt6_table[120] = (unsigned char)5;
  seq_nt6_table[121] = (unsigned char)5;
  seq_nt6_table[122] = (unsigned char)5;
  seq_nt6_table[123] = (unsigned char)5;
  seq_nt6_table[124] = (unsigned char)5;
  seq_nt6_table[125] = (unsigned char)5;
  seq_nt6_table[126] = (unsigned char)5;
  seq_nt6_table[127] = (unsigned char)5;
  seq_nt6_table[128] = (unsigned char)5;
  seq_nt6_table[129] = (unsigned char)5;
  seq_nt6_table[130] = (unsigned char)5;
  seq_nt6_table[131] = (unsigned char)5;
  seq_nt6_table[132] = (unsigned char)5;
  seq_nt6_table[133] = (unsigned char)5;
  seq_nt6_table[134] = (unsigned char)5;
  seq_nt6_table[135] = (unsigned char)5;
  seq_nt6_table[136] = (unsigned char)5;
  seq_nt6_table[137] = (unsigned char)5;
  seq_nt6_table[138] = (unsigned char)5;
  seq_nt6_table[139] = (unsigned char)5;
  seq_nt6_table[140] = (unsigned char)5;
  seq_nt6_table[141] = (unsigned char)5;
  seq_nt6_table[142] = (unsigned char)5;
  seq_nt6_table[143] = (unsigned char)5;
  seq_nt6_table[144] = (unsigned char)5;
  seq_nt6_table[145] = (unsigned char)5;
  seq_nt6_table[146] = (unsigned char)5;
  seq_nt6_table[147] = (unsigned char)5;
  seq_nt6_table[148] = (unsigned char)5;
  seq_nt6_table[149] = (unsigned char)5;
  seq_nt6_table[150] = (unsigned char)5;
  seq_nt6_table[151] = (unsigned char)5;
  seq_nt6_table[152] = (unsigned char)5;
  seq_nt6_table[153] = (unsigned char)5;
  seq_nt6_table[154] = (unsigned char)5;
  seq_nt6_table[155] = (unsigned char)5;
  seq_nt6_table[156] = (unsigned char)5;
  seq_nt6_table[157] = (unsigned char)5;
  seq_nt6_table[158] = (unsigned char)5;
  seq_nt6_table[159] = (unsigned char)5;
  seq_nt6_table[160] = (unsigned char)5;
  seq_nt6_table[161] = (unsigned char)5;
  seq_nt6_table[162] = (unsigned char)5;
  seq_nt6_table[163] = (unsigned char)5;
  seq_nt6_table[164] = (unsigned char)5;
  seq_nt6_table[165] = (unsigned char)5;
  seq_nt6_table[166] = (unsigned char)5;
  seq_nt6_table[167] = (unsigned char)5;
  seq_nt6_table[168] = (unsigned char)5;
  seq_nt6_table[169] = (unsigned char)5;
  seq_nt6_table[170] = (unsigned char)5;
  seq_nt6_table[171] = (unsigned char)5;
  seq_nt6_table[172] = (unsigned char)5;
  seq_nt6_table[173] = (unsigned char)5;
  seq_nt6_table[174] = (unsigned char)5;
  seq_nt6_table[175] = (unsigned char)5;
  seq_nt6_table[176] = (unsigned char)5;
  seq_nt6_table[177] = (unsigned char)5;
  seq_nt6_table[178] = (unsigned char)5;
  seq_nt6_table[179] = (unsigned char)5;
  seq_nt6_table[180] = (unsigned char)5;
  seq_nt6_table[181] = (unsigned char)5;
  seq_nt6_table[182] = (unsigned char)5;
  seq_nt6_table[183] = (unsigned char)5;
  seq_nt6_table[184] = (unsigned char)5;
  seq_nt6_table[185] = (unsigned char)5;
  seq_nt6_table[186] = (unsigned char)5;
  seq_nt6_table[187] = (unsigned char)5;
  seq_nt6_table[188] = (unsigned char)5;
  seq_nt6_table[189] = (unsigned char)5;
  seq_nt6_table[190] = (unsigned char)5;
  seq_nt6_table[191] = (unsigned char)5;
  seq_nt6_table[192] = (unsigned char)5;
  seq_nt6_table[193] = (unsigned char)5;
  seq_nt6_table[194] = (unsigned char)5;
  seq_nt6_table[195] = (unsigned char)5;
  seq_nt6_table[196] = (unsigned char)5;
  seq_nt6_table[197] = (unsigned char)5;
  seq_nt6_table[198] = (unsigned char)5;
  seq_nt6_table[199] = (unsigned char)5;
  seq_nt6_table[200] = (unsigned char)5;
  seq_nt6_table[201] = (unsigned char)5;
  seq_nt6_table[202] = (unsigned char)5;
  seq_nt6_table[203] = (unsigned char)5;
  seq_nt6_table[204] = (unsigned char)5;
  seq_nt6_table[205] = (unsigned char)5;
  seq_nt6_table[206] = (unsigned char)5;
  seq_nt6_table[207] = (unsigned char)5;
  seq_nt6_table[208] = (unsigned char)5;
  seq_nt6_table[209] = (unsigned char)5;
  seq_nt6_table[210] = (unsigned char)5;
  seq_nt6_table[211] = (unsigned char)5;
  seq_nt6_table[212] = (unsigned char)5;
  seq_nt6_table[213] = (unsigned char)5;
  seq_nt6_table[214] = (unsigned char)5;
  seq_nt6_table[215] = (unsigned char)5;
  seq_nt6_table[216] = (unsigned char)5;
  seq_nt6_table[217] = (unsigned char)5;
  seq_nt6_table[218] = (unsigned char)5;
  seq_nt6_table[219] = (unsigned char)5;
  seq_nt6_table[220] = (unsigned char)5;
  seq_nt6_table[221] = (unsigned char)5;
  seq_nt6_table[222] = (unsigned char)5;
  seq_nt6_table[223] = (unsigned char)5;
  seq_nt6_table[224] = (unsigned char)5;
  seq_nt6_table[225] = (unsigned char)5;
  seq_nt6_table[226] = (unsigned char)5;
  seq_nt6_table[227] = (unsigned char)5;
  seq_nt6_table[228] = (unsigned char)5;
  seq_nt6_table[229] = (unsigned char)5;
  seq_nt6_table[230] = (unsigned char)5;
  seq_nt6_table[231] = (unsigned char)5;
  seq_nt6_table[232] = (unsigned char)5;
  seq_nt6_table[233] = (unsigned char)5;
  seq_nt6_table[234] = (unsigned char)5;
  seq_nt6_table[235] = (unsigned char)5;
  seq_nt6_table[236] = (unsigned char)5;
  seq_nt6_table[237] = (unsigned char)5;
  seq_nt6_table[238] = (unsigned char)5;
  seq_nt6_table[239] = (unsigned char)5;
  seq_nt6_table[240] = (unsigned char)5;
  seq_nt6_table[241] = (unsigned char)5;
  seq_nt6_table[242] = (unsigned char)5;
  seq_nt6_table[243] = (unsigned char)5;
  seq_nt6_table[244] = (unsigned char)5;
  seq_nt6_table[245] = (unsigned char)5;
  seq_nt6_table[246] = (unsigned char)5;
  seq_nt6_table[247] = (unsigned char)5;
  seq_nt6_table[248] = (unsigned char)5;
  seq_nt6_table[249] = (unsigned char)5;
  seq_nt6_table[250] = (unsigned char)5;
  seq_nt6_table[251] = (unsigned char)5;
  seq_nt6_table[252] = (unsigned char)5;
  seq_nt6_table[253] = (unsigned char)5;
  seq_nt6_table[254] = (unsigned char)5;
  seq_nt6_table[255] = (unsigned char)5;
  goto seq_nt6_table_i$nit_INLINE_seq_nt6_table_i$nit;
  }
  seq_nt6_table_i$nit_INLINE_seq_nt6_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16_table[0] = (unsigned char)15;
  seq_nt16_table[1] = (unsigned char)15;
  seq_nt16_table[2] = (unsigned char)15;
  seq_nt16_table[3] = (unsigned char)15;
  seq_nt16_table[4] = (unsigned char)15;
  seq_nt16_table[5] = (unsigned char)15;
  seq_nt16_table[6] = (unsigned char)15;
  seq_nt16_table[7] = (unsigned char)15;
  seq_nt16_table[8] = (unsigned char)15;
  seq_nt16_table[9] = (unsigned char)15;
  seq_nt16_table[10] = (unsigned char)15;
  seq_nt16_table[11] = (unsigned char)15;
  seq_nt16_table[12] = (unsigned char)15;
  seq_nt16_table[13] = (unsigned char)15;
  seq_nt16_table[14] = (unsigned char)15;
  seq_nt16_table[15] = (unsigned char)15;
  seq_nt16_table[16] = (unsigned char)15;
  seq_nt16_table[17] = (unsigned char)15;
  seq_nt16_table[18] = (unsigned char)15;
  seq_nt16_table[19] = (unsigned char)15;
  seq_nt16_table[20] = (unsigned char)15;
  seq_nt16_table[21] = (unsigned char)15;
  seq_nt16_table[22] = (unsigned char)15;
  seq_nt16_table[23] = (unsigned char)15;
  seq_nt16_table[24] = (unsigned char)15;
  seq_nt16_table[25] = (unsigned char)15;
  seq_nt16_table[26] = (unsigned char)15;
  seq_nt16_table[27] = (unsigned char)15;
  seq_nt16_table[28] = (unsigned char)15;
  seq_nt16_table[29] = (unsigned char)15;
  seq_nt16_table[30] = (unsigned char)15;
  seq_nt16_table[31] = (unsigned char)15;
  seq_nt16_table[32] = (unsigned char)15;
  seq_nt16_table[33] = (unsigned char)15;
  seq_nt16_table[34] = (unsigned char)15;
  seq_nt16_table[35] = (unsigned char)15;
  seq_nt16_table[36] = (unsigned char)15;
  seq_nt16_table[37] = (unsigned char)15;
  seq_nt16_table[38] = (unsigned char)15;
  seq_nt16_table[39] = (unsigned char)15;
  seq_nt16_table[40] = (unsigned char)15;
  seq_nt16_table[41] = (unsigned char)15;
  seq_nt16_table[42] = (unsigned char)15;
  seq_nt16_table[43] = (unsigned char)15;
  seq_nt16_table[44] = (unsigned char)15;
  seq_nt16_table[45] = (unsigned char)15;
  seq_nt16_table[46] = (unsigned char)15;
  seq_nt16_table[47] = (unsigned char)15;
  seq_nt16_table[48] = (unsigned char)15;
  seq_nt16_table[49] = (unsigned char)15;
  seq_nt16_table[50] = (unsigned char)15;
  seq_nt16_table[51] = (unsigned char)15;
  seq_nt16_table[52] = (unsigned char)15;
  seq_nt16_table[53] = (unsigned char)15;
  seq_nt16_table[54] = (unsigned char)15;
  seq_nt16_table[55] = (unsigned char)15;
  seq_nt16_table[56] = (unsigned char)15;
  seq_nt16_table[57] = (unsigned char)15;
  seq_nt16_table[58] = (unsigned char)15;
  seq_nt16_table[59] = (unsigned char)15;
  seq_nt16_table[60] = (unsigned char)15;
  seq_nt16_table[61] = (unsigned char)15;
  seq_nt16_table[62] = (unsigned char)15;
  seq_nt16_table[63] = (unsigned char)15;
  seq_nt16_table[64] = (unsigned char)15;
  seq_nt16_table[65] = (unsigned char)1;
  seq_nt16_table[66] = (unsigned char)14;
  seq_nt16_table[67] = (unsigned char)2;
  seq_nt16_table[68] = (unsigned char)13;
  seq_nt16_table[69] = (unsigned char)15;
  seq_nt16_table[70] = (unsigned char)15;
  seq_nt16_table[71] = (unsigned char)4;
  seq_nt16_table[72] = (unsigned char)11;
  seq_nt16_table[73] = (unsigned char)15;
  seq_nt16_table[74] = (unsigned char)15;
  seq_nt16_table[75] = (unsigned char)12;
  seq_nt16_table[76] = (unsigned char)15;
  seq_nt16_table[77] = (unsigned char)3;
  seq_nt16_table[78] = (unsigned char)15;
  seq_nt16_table[79] = (unsigned char)15;
  seq_nt16_table[80] = (unsigned char)15;
  seq_nt16_table[81] = (unsigned char)15;
  seq_nt16_table[82] = (unsigned char)5;
  seq_nt16_table[83] = (unsigned char)6;
  seq_nt16_table[84] = (unsigned char)8;
  seq_nt16_table[85] = (unsigned char)15;
  seq_nt16_table[86] = (unsigned char)7;
  seq_nt16_table[87] = (unsigned char)9;
  seq_nt16_table[88] = (unsigned char)0;
  seq_nt16_table[89] = (unsigned char)10;
  seq_nt16_table[90] = (unsigned char)15;
  seq_nt16_table[91] = (unsigned char)15;
  seq_nt16_table[92] = (unsigned char)15;
  seq_nt16_table[93] = (unsigned char)15;
  seq_nt16_table[94] = (unsigned char)15;
  seq_nt16_table[95] = (unsigned char)15;
  seq_nt16_table[96] = (unsigned char)15;
  seq_nt16_table[97] = (unsigned char)1;
  seq_nt16_table[98] = (unsigned char)14;
  seq_nt16_table[99] = (unsigned char)2;
  seq_nt16_table[100] = (unsigned char)13;
  seq_nt16_table[101] = (unsigned char)15;
  seq_nt16_table[102] = (unsigned char)15;
  seq_nt16_table[103] = (unsigned char)4;
  seq_nt16_table[104] = (unsigned char)11;
  seq_nt16_table[105] = (unsigned char)15;
  seq_nt16_table[106] = (unsigned char)15;
  seq_nt16_table[107] = (unsigned char)12;
  seq_nt16_table[108] = (unsigned char)15;
  seq_nt16_table[109] = (unsigned char)3;
  seq_nt16_table[110] = (unsigned char)15;
  seq_nt16_table[111] = (unsigned char)15;
  seq_nt16_table[112] = (unsigned char)15;
  seq_nt16_table[113] = (unsigned char)15;
  seq_nt16_table[114] = (unsigned char)5;
  seq_nt16_table[115] = (unsigned char)6;
  seq_nt16_table[116] = (unsigned char)8;
  seq_nt16_table[117] = (unsigned char)15;
  seq_nt16_table[118] = (unsigned char)7;
  seq_nt16_table[119] = (unsigned char)9;
  seq_nt16_table[120] = (unsigned char)0;
  seq_nt16_table[121] = (unsigned char)10;
  seq_nt16_table[122] = (unsigned char)15;
  seq_nt16_table[123] = (unsigned char)15;
  seq_nt16_table[124] = (unsigned char)15;
  seq_nt16_table[125] = (unsigned char)15;
  seq_nt16_table[126] = (unsigned char)15;
  seq_nt16_table[127] = (unsigned char)15;
  seq_nt16_table[128] = (unsigned char)15;
  seq_nt16_table[129] = (unsigned char)15;
  seq_nt16_table[130] = (unsigned char)15;
  seq_nt16_table[131] = (unsigned char)15;
  seq_nt16_table[132] = (unsigned char)15;
  seq_nt16_table[133] = (unsigned char)15;
  seq_nt16_table[134] = (unsigned char)15;
  seq_nt16_table[135] = (unsigned char)15;
  seq_nt16_table[136] = (unsigned char)15;
  seq_nt16_table[137] = (unsigned char)15;
  seq_nt16_table[138] = (unsigned char)15;
  seq_nt16_table[139] = (unsigned char)15;
  seq_nt16_table[140] = (unsigned char)15;
  seq_nt16_table[141] = (unsigned char)15;
  seq_nt16_table[142] = (unsigned char)15;
  seq_nt16_table[143] = (unsigned char)15;
  seq_nt16_table[144] = (unsigned char)15;
  seq_nt16_table[145] = (unsigned char)15;
  seq_nt16_table[146] = (unsigned char)15;
  seq_nt16_table[147] = (unsigned char)15;
  seq_nt16_table[148] = (unsigned char)15;
  seq_nt16_table[149] = (unsigned char)15;
  seq_nt16_table[150] = (unsigned char)15;
  seq_nt16_table[151] = (unsigned char)15;
  seq_nt16_table[152] = (unsigned char)15;
  seq_nt16_table[153] = (unsigned char)15;
  seq_nt16_table[154] = (unsigned char)15;
  seq_nt16_table[155] = (unsigned char)15;
  seq_nt16_table[156] = (unsigned char)15;
  seq_nt16_table[157] = (unsigned char)15;
  seq_nt16_table[158] = (unsigned char)15;
  seq_nt16_table[159] = (unsigned char)15;
  seq_nt16_table[160] = (unsigned char)15;
  seq_nt16_table[161] = (unsigned char)15;
  seq_nt16_table[162] = (unsigned char)15;
  seq_nt16_table[163] = (unsigned char)15;
  seq_nt16_table[164] = (unsigned char)15;
  seq_nt16_table[165] = (unsigned char)15;
  seq_nt16_table[166] = (unsigned char)15;
  seq_nt16_table[167] = (unsigned char)15;
  seq_nt16_table[168] = (unsigned char)15;
  seq_nt16_table[169] = (unsigned char)15;
  seq_nt16_table[170] = (unsigned char)15;
  seq_nt16_table[171] = (unsigned char)15;
  seq_nt16_table[172] = (unsigned char)15;
  seq_nt16_table[173] = (unsigned char)15;
  seq_nt16_table[174] = (unsigned char)15;
  seq_nt16_table[175] = (unsigned char)15;
  seq_nt16_table[176] = (unsigned char)15;
  seq_nt16_table[177] = (unsigned char)15;
  seq_nt16_table[178] = (unsigned char)15;
  seq_nt16_table[179] = (unsigned char)15;
  seq_nt16_table[180] = (unsigned char)15;
  seq_nt16_table[181] = (unsigned char)15;
  seq_nt16_table[182] = (unsigned char)15;
  seq_nt16_table[183] = (unsigned char)15;
  seq_nt16_table[184] = (unsigned char)15;
  seq_nt16_table[185] = (unsigned char)15;
  seq_nt16_table[186] = (unsigned char)15;
  seq_nt16_table[187] = (unsigned char)15;
  seq_nt16_table[188] = (unsigned char)15;
  seq_nt16_table[189] = (unsigned char)15;
  seq_nt16_table[190] = (unsigned char)15;
  seq_nt16_table[191] = (unsigned char)15;
  seq_nt16_table[192] = (unsigned char)15;
  seq_nt16_table[193] = (unsigned char)15;
  seq_nt16_table[194] = (unsigned char)15;
  seq_nt16_table[195] = (unsigned char)15;
  seq_nt16_table[196] = (unsigned char)15;
  seq_nt16_table[197] = (unsigned char)15;
  seq_nt16_table[198] = (unsigned char)15;
  seq_nt16_table[199] = (unsigned char)15;
  seq_nt16_table[200] = (unsigned char)15;
  seq_nt16_table[201] = (unsigned char)15;
  seq_nt16_table[202] = (unsigned char)15;
  seq_nt16_table[203] = (unsigned char)15;
  seq_nt16_table[204] = (unsigned char)15;
  seq_nt16_table[205] = (unsigned char)15;
  seq_nt16_table[206] = (unsigned char)15;
  seq_nt16_table[207] = (unsigned char)15;
  seq_nt16_table[208] = (unsigned char)15;
  seq_nt16_table[209] = (unsigned char)15;
  seq_nt16_table[210] = (unsigned char)15;
  seq_nt16_table[211] = (unsigned char)15;
  seq_nt16_table[212] = (unsigned char)15;
  seq_nt16_table[213] = (unsigned char)15;
  seq_nt16_table[214] = (unsigned char)15;
  seq_nt16_table[215] = (unsigned char)15;
  seq_nt16_table[216] = (unsigned char)15;
  seq_nt16_table[217] = (unsigned char)15;
  seq_nt16_table[218] = (unsigned char)15;
  seq_nt16_table[219] = (unsigned char)15;
  seq_nt16_table[220] = (unsigned char)15;
  seq_nt16_table[221] = (unsigned char)15;
  seq_nt16_table[222] = (unsigned char)15;
  seq_nt16_table[223] = (unsigned char)15;
  seq_nt16_table[224] = (unsigned char)15;
  seq_nt16_table[225] = (unsigned char)15;
  seq_nt16_table[226] = (unsigned char)15;
  seq_nt16_table[227] = (unsigned char)15;
  seq_nt16_table[228] = (unsigned char)15;
  seq_nt16_table[229] = (unsigned char)15;
  seq_nt16_table[230] = (unsigned char)15;
  seq_nt16_table[231] = (unsigned char)15;
  seq_nt16_table[232] = (unsigned char)15;
  seq_nt16_table[233] = (unsigned char)15;
  seq_nt16_table[234] = (unsigned char)15;
  seq_nt16_table[235] = (unsigned char)15;
  seq_nt16_table[236] = (unsigned char)15;
  seq_nt16_table[237] = (unsigned char)15;
  seq_nt16_table[238] = (unsigned char)15;
  seq_nt16_table[239] = (unsigned char)15;
  seq_nt16_table[240] = (unsigned char)15;
  seq_nt16_table[241] = (unsigned char)15;
  seq_nt16_table[242] = (unsigned char)15;
  seq_nt16_table[243] = (unsigned char)15;
  seq_nt16_table[244] = (unsigned char)15;
  seq_nt16_table[245] = (unsigned char)15;
  seq_nt16_table[246] = (unsigned char)15;
  seq_nt16_table[247] = (unsigned char)15;
  seq_nt16_table[248] = (unsigned char)15;
  seq_nt16_table[249] = (unsigned char)15;
  seq_nt16_table[250] = (unsigned char)15;
  seq_nt16_table[251] = (unsigned char)15;
  seq_nt16_table[252] = (unsigned char)15;
  seq_nt16_table[253] = (unsigned char)15;
  seq_nt16_table[254] = (unsigned char)15;
  seq_nt16_table[255] = (unsigned char)15;
  goto seq_nt16_table_i$nit_INLINE_seq_nt16_table_i$nit;
  }
  seq_nt16_table_i$nit_INLINE_seq_nt16_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  __ac_HASH_UPPER = (double const   )0.77;
  goto __ac_HASH_UPPER_i$nit_INLINE___ac_HASH_UPPER_i$nit;
  }
  __ac_HASH_UPPER_i$nit_INLINE___ac_HASH_UPPER_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_envp_i$nit_INLINE__global_envp_i$nit;
  }
  _global_envp_i$nit_INLINE__global_envp_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argv_i$nit_INLINE__global_argv_i$nit;
  }
  _global_argv_i$nit_INLINE__global_argv_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argc_i$nit_INLINE__global_argc_i$nit;
  }
  _global_argc_i$nit_INLINE__global_argc_i$nit: /* CIL Label */ ;
  }
  goto megaInit_INLINE_megaInit;
  }
  megaInit_INLINE_megaInit: /* CIL Label */ ;
  }
  _global_argc = argc;
  _global_argv = argv;
  _global_envp = _formal_envp;
  _BARRIER_0 = 1;
  _1_main__BEGIN_1 = 1;
  p44 = (struct _1_main_1_opaque_NodeStruct *)malloc(sizeof(struct _1_main_1_opaque_NodeStruct ));
  p44->next = p44;
  p44->prev = p44;
  _1_main_1_opaque_list_1 = p44;
  r47 = rand();
  p48 = (struct _1_main_1_opaque_NodeStruct *)malloc(sizeof(struct _1_main_1_opaque_NodeStruct ));
  p48->data = 0 * r47;
  p48->next = _1_main_1_opaque_list_1->next;
  p48->prev = _1_main_1_opaque_list_1;
  (_1_main_1_opaque_list_1->next)->prev = p48;
  _1_main_1_opaque_list_1->next = p48;
  r45 = rand();
  p46 = (struct _1_main_1_opaque_NodeStruct *)malloc(sizeof(struct _1_main_1_opaque_NodeStruct ));
  p46->data = 1 * r45;
  p46->next = _1_main_1_opaque_list_1->next;
  p46->prev = _1_main_1_opaque_list_1;
  (_1_main_1_opaque_list_1->next)->prev = p46;
  _1_main_1_opaque_list_1->next = p46;
  _1_main_1_opaque_ptr_1 = _1_main_1_opaque_list_1->next;
  _1_main_1_opaque_ptr_2 = _1_main_1_opaque_ptr_1;
  _1_main__END_1 = 1;
  _1_main__BARRIER_2 = 1;
  optind = 1;
  if (argc == 1) {
    tmp = usage();
    return (tmp);
  }
  tmp___37 = strcmp((char const   *)*(argv + 1), "comp");
  if (tmp___37 == 0) {
    tmp___0 = stk_comp(argc - 1, argv + 1);
    return (tmp___0);
  } else {
    tmp___36 = strcmp((char const   *)*(argv + 1), "fqchk");
    if (tmp___36 == 0) {
      tmp___1 = stk_fqchk(argc - 1, argv + 1);
      return (tmp___1);
    } else {
      tmp___35 = strcmp((char const   *)*(argv + 1), "hety");
      if (tmp___35 == 0) {
        tmp___2 = stk_hety(argc - 1, argv + 1);
        return (tmp___2);
      } else {
        tmp___34 = strcmp((char const   *)*(argv + 1), "gc");
        if (tmp___34 == 0) {
          tmp___3 = stk_gc(argc - 1, argv + 1);
          return (tmp___3);
        } else {
          tmp___33 = strcmp((char const   *)*(argv + 1), "subseq");
          if (tmp___33 == 0) {
            tmp___4 = stk_subseq(argc - 1, argv + 1);
            return (tmp___4);
          } else {
            tmp___32 = strcmp((char const   *)*(argv + 1), "mutfa");
            if (tmp___32 == 0) {
              tmp___5 = stk_mutfa(argc - 1, argv + 1);
              return (tmp___5);
            } else {
              tmp___31 = strcmp((char const   *)*(argv + 1), "mergefa");
              if (tmp___31 == 0) {
                tmp___6 = stk_mergefa(argc - 1, argv + 1);
                return (tmp___6);
              } else {
                tmp___30 = strcmp((char const   *)*(argv + 1), "mergepe");
                if (tmp___30 == 0) {
                  tmp___7 = stk_mergepe(argc - 1, argv + 1);
                  return (tmp___7);
                } else {
                  tmp___29 = strcmp((char const   *)*(argv + 1), "dropse");
                  if (tmp___29 == 0) {
                    tmp___8 = stk_dropse(argc - 1, argv + 1);
                    return (tmp___8);
                  } else {
                    tmp___28 = strcmp((char const   *)*(argv + 1), "randbase");
                    if (tmp___28 == 0) {
                      tmp___9 = stk_randbase(argc - 1, argv + 1);
                      return (tmp___9);
                    } else {
                      tmp___27 = strcmp((char const   *)*(argv + 1), "cutN");
                      if (tmp___27 == 0) {
                        tmp___10 = stk_cutN(argc - 1, argv + 1);
                        return (tmp___10);
                      } else {
                        tmp___26 = strcmp((char const   *)*(argv + 1), "listhet");
                        if (tmp___26 == 0) {
                          tmp___11 = stk_listhet(argc - 1, argv + 1);
                          return (tmp___11);
                        } else {
                          tmp___25 = strcmp((char const   *)*(argv + 1), "famask");
                          if (tmp___25 == 0) {
                            tmp___12 = stk_famask(argc - 1, argv + 1);
                            return (tmp___12);
                          } else {
                            tmp___24 = strcmp((char const   *)*(argv + 1), "trimfq");
                            if (tmp___24 == 0) {
                              tmp___13 = stk_trimfq(argc - 1, argv + 1);
                              return (tmp___13);
                            } else {
                              tmp___23 = strcmp((char const   *)*(argv + 1), "hrun");
                              if (tmp___23 == 0) {
                                tmp___14 = stk_hrun(argc - 1, argv + 1);
                                return (tmp___14);
                              } else {
                                tmp___22 = strcmp((char const   *)*(argv + 1), "sample");
                                if (tmp___22 == 0) {
                                  tmp___15 = stk_sample(argc - 1, argv + 1);
                                  return (tmp___15);
                                } else {
                                  tmp___21 = strcmp((char const   *)*(argv + 1), "seq");
                                  if (tmp___21 == 0) {
                                    tmp___16 = stk_seq(argc - 1, argv + 1);
                                    return (tmp___16);
                                  } else {
                                    tmp___20 = strcmp((char const   *)*(argv + 1),
                                                      "kfreq");
                                    if (tmp___20 == 0) {
                                      tmp___17 = stk_kfreq(argc - 1, argv + 1);
                                      return (tmp___17);
                                    } else {
                                      tmp___19 = strcmp((char const   *)*(argv + 1),
                                                        "rename");
                                      if (tmp___19 == 0) {
                                        tmp___18 = stk_rename(argc - 1, argv + 1);
                                        return (tmp___18);
                                      } else {
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[main] unrecognized command \'%s\'. Abort!\n",
                                                *(argv + 1));
                                        return (1);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
/* END FUNCTION-DEF main LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_mergepe LOC=UNKNOWN */
int stk_mergepe(int argc , char **argv ) 
{ 
  gzFile fp1 ;
  gzFile fp2 ;
  kseq_t *seq[2] ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___5 ;
  int tmp___6 ;
  gzFile tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  if (argc < 3) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk mergepe <in1.fq> <in2.fq>\n");
    return (1);
  }
  tmp___3 = strcmp((char const   *)*(argv + 1), "-");
  if (tmp___3) {
    tmp___0 = gzopen((char const   *)*(argv + 1), "r");
    fp1 = tmp___0;
  } else {
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp1 = tmp___2;
  }
  tmp___8 = strcmp((char const   *)*(argv + 2), "-");
  if (tmp___8) {
    tmp___5 = gzopen((char const   *)*(argv + 2), "r");
    fp2 = tmp___5;
  } else {
    tmp___6 = fileno(stdin);
    tmp___7 = gzdopen(tmp___6, "r");
    fp2 = tmp___7;
  }
  if ((unsigned long )fp1 == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergepe");
    return (1);
  } else
  if ((unsigned long )fp2 == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergepe");
    return (1);
  }
  seq[0] = kseq_init(fp1);
  seq[1] = kseq_init(fp2);
  while (1) {
    tmp___10 = kseq_read(seq[0]);
    if (! (tmp___10 >= 0)) {
      break;
    }
    tmp___9 = kseq_read(seq[1]);
    if (tmp___9 < 0) {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[W::%s] the 2nd file has fewer records.\n",
              "stk_mergepe");
      break;
    }
    stk_printseq((kseq_t const   *)seq[0], 0);
    stk_printseq((kseq_t const   *)seq[1], 0);
  }
  tmp___11 = kseq_read(seq[1]);
  if (tmp___11 >= 0) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[W::%s] the 1st file has fewer records.\n",
            "stk_mergepe");
  }
  kseq_destroy(seq[0]);
  gzclose(fp1);
  kseq_destroy(seq[1]);
  gzclose(fp2);
  return (0);
}
}
/* END FUNCTION-DEF stk_mergepe LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fqc_aux LOC=UNKNOWN */
static void fqc_aux(posstat_t *p , int pos , int64_t *allq , double *perr , int qthres ) 
{ 
  int k ;
  int64_t sum ;
  int64_t qsum ;
  int64_t sum_low ;
  double psum ;
  double tmp ;

  {
  sum = (int64_t )0;
  qsum = (int64_t )0;
  sum_low = (int64_t )0;
  psum = (double )0;
  if (pos <= 0) {
    ((int (*)(char const   * __restrict    , ...))_3__functionPtrArray[10 * ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((char const   */* __restrict  */)"ALL");
  } else {
    ((int (*)(char const   * __restrict    , ...))_3__functionPtrArray[12 + ((_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2) - (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((char const   */* __restrict  */)"%d",
                                                                                                                                                                                        pos);
  }
  k = 0;
  while (k <= 4) {
    sum += p->b[k];
    k ++;
  }
  ((int (*)(char const   * __restrict    , ...))_3__functionPtrArray[13 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))])((char const   */* __restrict  */)"\t%lld",
                                                                                                                                                                                      sum);
  k = 0;
  while (k <= 4) {
    ((int (*)(char const   * __restrict    , ...))_3__functionPtrArray[14 + ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2))])((char const   */* __restrict  */)"\t%.1f",
                                                                                                                                                                                        (100. * (double )p->b[k]) / (double )sum);
    _3__functionPtrArray[7 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)] = & sum;
    k ++;
  }
  k = 0;
  while (k <= 93) {
    qsum += p->q[k] * (int64_t )k;
    psum += (double )p->q[k] * *(perr + k);
    if (k < qthres) {
      sum_low += p->q[k];
    }
    k ++;
  }
  tmp = ((double (*)(double  ))_3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 15 : 10])((psum + 1e-6) / ((double )sum + 1e-6));
  ((int (*)(char const   * __restrict    , ...))_3__functionPtrArray[17 + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((char const   */* __restrict  */)"\t%.1f\t%.1f",
                                                                                                                               (double )qsum / (double )sum,
                                                                                                                               - 4.343 * tmp);
  _3__functionPtrArray[_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2 ? 11 << qthres : 11] = & sum;
  if (qthres <= 0) {
    k = 0;
    while (k <= 93) {
      if (*(allq + k) > 0LL) {
        ((int (*)(char const   * __restrict    , ...))_3__functionPtrArray[19 + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])((char const   */* __restrict  */)"\t%.2f",
                                                                                                                                     (100. * (double )p->q[k]) / (double )sum);
        _3__functionPtrArray[11 + (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)] = _3__functionPtrArray[16];
      }
      k ++;
    }
  } else {
    ((int (*)(char const   * __restrict    , ...))_3__functionPtrArray[20 * (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2)])((char const   */* __restrict  */)"\t%.1f\t%.1f",
                                                                                                                                 (100. * (double )sum_low) / (double )sum,
                                                                                                                                 (100. * (double )(sum - sum_low)) / (double )sum);
    _3__functionPtrArray[_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2 ? 7 : qthres] = _3__functionPtrArray[14];
  }
  ((int (*)(int  ))_3__functionPtrArray[21 - (_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2)])('\n');
  _3__functionPtrArray[18 * ((_1_main_1_opaque_ptr_1 != _1_main_1_opaque_ptr_2) + (_1_main_1_opaque_ptr_1 == _1_main_1_opaque_ptr_2))] = _3__functionPtrArray[17];
  return;
}
}
/* END FUNCTION-DEF fqc_aux LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_cutN LOC=UNKNOWN */
int stk_cutN(int argc , char **argv ) 
{ 
  int c ;
  int l ;
  int gap_only ;
  gzFile fp ;
  kseq_t *ks ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int k ;
  int begin ;
  int end ;
  int tmp___4 ;

  {
  gap_only = 0;
  while (1) {
    c = getopt(argc, argv, "n:p:g");
    if (! (c >= 0)) {
      break;
    }
    switch (c) {
    case 110: 
    cutN_min_N_tract = atoi((char const   *)optarg);
    break;
    case 112: 
    cutN_nonN_penalty = atoi((char const   *)optarg);
    break;
    case 103: 
    gap_only = 1;
    break;
    default: 
    return (1);
    }
  }
  if (argc == optind) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk cutN [options] <in.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -n INT    min size of N tract [%d]\n",
            cutN_min_N_tract);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -p INT    penalty for a non-N [%d]\n",
            cutN_nonN_penalty);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -g        print gaps only, no sequence\n\n");
    return (1);
  }
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  if (tmp___3 == 0) {
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
  } else {
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_cutN");
    return (1);
  }
  ks = kseq_init(fp);
  while (1) {
    l = kseq_read(ks);
    if (! (l >= 0)) {
      break;
    }
    k = 0;
    begin = 0;
    end = 0;
    while (1) {
      tmp___4 = find_next_cut((kseq_t const   *)ks, k, & begin, & end);
      if (! (tmp___4 >= 0)) {
        break;
      }
      if (begin != 0) {
        if (gap_only) {
          printf((char const   */* __restrict  */)"%s\t%d\t%d\n", ks->name.s, begin,
                 end);
        } else {
          print_seq(stdout, (kseq_t const   *)ks, k, begin);
        }
      }
      k = end;
    }
    if (! gap_only) {
      print_seq(stdout, (kseq_t const   *)ks, k, l);
    }
  }
  kseq_destroy(ks);
  gzclose(fp);
  return (0);
}
}
/* END FUNCTION-DEF stk_cutN LOC=UNKNOWN */
