
/* Generated by Tigress v3.2 (https://tigress.wtf), 06:21:49-2023/04/21 */


/*
BEGIN-UNIVERSE
{
  "Not added to universe": [
    "__sync_and_and_fetch", "__sync_fetch_and_or", "__atomic_or_fetch",
    "__atomic_nand_fetch_8", "__atomic_fetch_and", "__atomic_xor_fetch_16",
    "__atomic_fetch_nand_16", "__atomic_sub_fetch_1", "__atomic_fetch_or",
    "__sync_synchronize", "__sync_or_and_fetch", "__atomic_nand_fetch_4",
    "__atomic_sub_fetch_4", "__atomic_compare_exchange_n",
    "__sync_add_and_fetch", "__atomic_signal_fence", "__atomic_fetch_nand_1",
    "__atomic_and_fetch_16", "__sync_fetch_and_nand", "__atomic_xor_fetch_8",
    "__atomic_xor_fetch_2", "__atomic_thread_fence", "__atomic_store_16",
    "__atomic_fetch_and_8", "__atomic_and_fetch_2", "__atomic_test_and_set",
    "__atomic_fetch_add_8", "__atomic_fetch_nand", "__atomic_exchange_16",
    "__atomic_clear", "__atomic_store", "__atomic_add_fetch_2",
    "__atomic_fetch_xor_1", "__atomic_and_fetch",
    "__atomic_compare_exchange_4", "__sync_sub_and_fetch",
    "__sync_nand_and_fetch", "__atomic_load_16", "__atomic_always_lock_free",
    "__atomic_nand_fetch_16", "__sync_xor_and_fetch", "__atomic_fetch_xor_8",
    "__atomic_exchange_8", "__atomic_exchange_1", "__sync_fetch_and_and",
    "__atomic_feraiseexcept", "__atomic_and_fetch_4", "__atomic_or_fetch_8",
    "__atomic_or_fetch_4", "__atomic_or_fetch_1", "__atomic_fetch_and_2",
    "__sync_lock_release", "__atomic_fetch_nand_8", "__atomic_fetch_add",
    "__atomic_nand_fetch_1", "__atomic_fetch_nand_2", "__atomic_load_n",
    "__atomic_compare_exchange_16", "__atomic_exchange_n",
    "__atomic_fetch_or_1", "__atomic_fetch_or_8", "__atomic_fetch_add_1",
    "__atomic_fetch_sub_1", "__atomic_fetch_or_4", "__atomic_load_2",
    "__atomic_store_2", "__atomic_exchange_4", "__sync_fetch_and_xor",
    "__atomic_fetch_sub_4", "__atomic_fetch_and_4",
    "__atomic_compare_exchange", "__atomic_load_1",
    "__atomic_compare_exchange_1", "__atomic_fetch_xor_2", "__atomic_load",
    "__atomic_or_fetch_16", "__atomic_add_fetch_16",
    "__sync_val_compare_and_swap", "__atomic_store_4",
    "__atomic_fetch_and_1", "__atomic_fetch_nand_4", "__atomic_fetch_add_16",
    "__atomic_compare_exchange_2", "__atomic_exchange",
    "__atomic_sub_fetch_8", "__atomic_fetch_sub_16", "__atomic_exchange_2",
    "__atomic_sub_fetch_2", "__atomic_fetch_xor_16", "__atomic_fetch_or_16",
    "__atomic_load_4", "__atomic_store_n", "__atomic_fetch_add_4",
    "__atomic_nand_fetch_2", "__sync_lock_test_and_set",
    "__atomic_sub_fetch", "__atomic_fetch_and_16",
    "__atomic_compare_exchange_8", "__atomic_nand_fetch", "__atomic_load_8",
    "__atomic_xor_fetch_4", "__atomic_fetch_sub_2", "__atomic_add_fetch",
    "__atomic_store_8", "__atomic_xor_fetch", "__sync_fetch_and_add",
    "__atomic_or_fetch_2", "__atomic_add_fetch_1", "__atomic_fetch_xor",
    "__atomic_add_fetch_8", "__atomic_fetch_xor_4", "__atomic_fetch_sub_8",
    "__sync_bool_compare_and_swap", "__atomic_and_fetch_1",
    "__atomic_store_1", "__atomic_xor_fetch_1", "__atomic_fetch_or_2",
    "__atomic_sub_fetch_16", "__sync_fetch_and_sub", "__atomic_fetch_add_2",
    "__atomic_is_lock_free", "__atomic_and_fetch_8", "__atomic_fetch_sub",
    "__atomic_add_fetch_4", "kr_rand"
  ],
  "Transformations": [
    { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "usage" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_trimfq" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_subseq" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_seq" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_sample" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_rename" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_reg_read" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_reg_destroy" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_randbase" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_printstr" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_printseq_renamed" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_printseq" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_mutfa" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_mergepe" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_mergefa" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_mask" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_listhet" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_kfreq" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_hrun" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_hety" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_gc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_fqchk" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_famask" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_dropse" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_cutN" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stk_comp" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "print_seq" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kseq_read" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kseq_init" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kseq_destroy" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "ks_init" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "ks_getuntil2" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "ks_getuntil" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "ks_getc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "ks_destroy" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kr_srand0" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kr_srand" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kr_rand" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_resize_reg" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_resize_64" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_put_reg" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_put_64" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_init_reg" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_init_64" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_get_reg" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_get_64" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_destroy_reg" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "kh_destroy_64" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "fqc_aux" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "find_next_cut" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cpy_kstr" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cpy_kseq" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "__ac_X31_hash_string" ]
    } }, { "TransformationNumber": 0, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ],
      "New Global Variables": {
        "_global_envp": "FUN: '_global_envp_i$nit'",
        "_global_argv": "FUN: '_global_argv_i$nit'",
        "_global_argc": "FUN: '_global_argc_i$nit'"
      }
    } }, { "TransformationNumber": -1, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "New Functions": [
        "main", "usage", "stk_fqchk", "fqc_aux", "stk_kfreq", "stk_rename",
        "stk_dropse", "stk_mergepe", "stk_gc", "stk_seq", "stk_mask",
        "stk_sample", "cpy_kseq", "cpy_kstr", "stk_hrun", "stk_cutN",
        "print_seq", "find_next_cut", "stk_listhet", "stk_mutfa",
        "stk_famask", "stk_mergefa", "stk_subseq", "stk_hety",
        "stk_randbase", "stk_comp", "stk_trimfq", "kr_rand", "kr_srand",
        "kr_srand0", "stk_printseq", "stk_printseq_renamed", "stk_printstr",
        "stk_reg_destroy", "stk_reg_read", "kh_put_64", "kh_resize_64",
        "kh_get_64", "kh_destroy_64", "kh_init_64", "kh_put_reg",
        "kh_resize_reg", "kh_get_reg", "kh_destroy_reg", "kh_init_reg",
        "__ac_X31_hash_string", "kseq_read", "kseq_destroy", "kseq_init",
        "ks_getuntil", "ks_getuntil2", "ks_getc", "ks_destroy", "ks_init"
      ],
      "New Global Variables": {
        "cutN_nonN_penalty": "FUN: 'cutN_nonN_penalty_i$nit'",
        "cutN_min_N_tract": "FUN: 'cutN_min_N_tract_i$nit'",
        "mag01": "FUN: 'mag01_i$nit'",
        "comp_tab": "FUN: 'comp_tab_i$nit'",
        "bitcnt_table": "FUN: 'bitcnt_table_i$nit'",
        "seq_nt16comp_table": "FUN: 'seq_nt16comp_table_i$nit'",
        "seq_nt16to4_table": "FUN: 'seq_nt16to4_table_i$nit'",
        "seq_nt16_rev_table": "FUN: 'seq_nt16_rev_table_i$nit'",
        "seq_nt6_table": "FUN: 'seq_nt6_table_i$nit'",
        "seq_nt16_table": "FUN: 'seq_nt16_table_i$nit'",
        "__ac_HASH_UPPER": "FUN: '__ac_HASH_UPPER_i$nit'"
      },
      "New Externs": [
        "__builtin_va_copy", "__builtin_frob_return_address",
        "__builtin_popcountll", "__builtin_atanf", "__builtin_ia32_addps",
        "__builtin_strcspn", "__builtin_asinf", "__builtin_ia32_maxps",
        "__builtin_ia32_unpckhps", "__builtin_acos",
        "__builtin___sprintf_chk", "__builtin_cosh", "__builtin_tanhf",
        "__builtin_mempcpy", "__builtin_sqrtl", "__builtin_parity",
        "__builtin_coshl", "__builtin_cosl", "__builtin_cosf",
        "__builtin_acosl", "__builtin___mempcpy_chk", "__builtin_clz",
        "__builtin_log10", "__builtin___strcat_chk", "__builtin_modff",
        "__builtin_sin", "__builtin_frexp", "__builtin_acosf",
        "__builtin_sinhl", "__builtin___stpcpy_chk", "__builtin_fabs",
        "__builtin_va_start", "__builtin_bswap16", "__builtin_ctz",
        "__builtin_strpbrk", "__builtin_strcpy", "__builtin_sqrt",
        "__builtin_next_arg", "__builtin_log10f", "__builtin_fabsl",
        "__builtin_floorl", "__builtin_floorf", "__builtin_memcpy",
        "__builtin_ia32_subps", "__builtin_parityll", "__builtin_va_end",
        "__builtin_bzero", "__builtin_strncmp", "__builtin___vsprintf_chk",
        "__builtin_sqrtf", "__builtin_nans", "__builtin_exp",
        "__builtin_strcmp", "__builtin_ldexpf", "__builtin_powif",
        "__builtin_log10l", "__builtin___memmove_chk",
        "__builtin_return_address", "__builtin_fabsf",
        "__builtin_object_size", "__builtin_alloca",
        "__builtin_va_arg_pack_len", "__builtin_tanl", "__builtin_modfl",
        "__builtin_stpcpy", "__builtin_sinl", "__builtin_asin",
        "__builtin_sinhf", "__builtin_ctzl", "__builtin_tanhl",
        "__builtin_bswap64", "__builtin_ia32_mulps", "__builtin_tan",
        "__builtin_strncpy", "__builtin_inff", "__builtin___memset_chk",
        "__builtin_huge_val", "__builtin_clzl", "__builtin_frexpf",
        "__builtin_fmodl", "__builtin_atan", "__builtin___fprintf_chk",
        "__builtin_ceilf", "__builtin_return", "__builtin_asinl",
        "__builtin_ffsll", "__builtin_va_arg_pack",
        "__builtin___strncpy_chk", "__builtin_powi", "__builtin_strchr",
        "__builtin___strncat_chk", "__builtin_huge_vall", "__builtin_ffsl",
        "__builtin___vprintf_chk", "__builtin_ia32_unpcklps",
        "__builtin_strncat", "__builtin_ctzll", "__builtin_stdarg_start",
        "__builtin_frexpl", "__builtin_tanf", "__builtin_logl",
        "__builtin_va_arg", "__builtin_expect", "__builtin___printf_chk",
        "__builtin___vfprintf_chk", "__builtin_prefetch", "__builtin_nansl",
        "__builtin_fmod", "__builtin_tanh", "__builtin_unreachable",
        "__builtin_ldexpl", "__builtin_apply", "__builtin_sinf",
        "__builtin_ceil", "__builtin_powil", "__builtin_expl",
        "__builtin_constant_p", "__builtin_log", "__builtin_expf",
        "__builtin_types_compatible_p", "__builtin_atan2l",
        "__builtin_apply_args", "__builtin_logf", "__builtin_strlen",
        "__builtin_ffs", "__builtin_inf", "__builtin___memcpy_chk",
        "__builtin_trap", "__builtin_parityl", "__builtin_strspn",
        "__builtin_varargs_start", "__builtin_nan",
        "__builtin___snprintf_chk", "__builtin_atanl", "__builtin_clzll",
        "__builtin_huge_valf", "__builtin_coshf", "__builtin_nansf",
        "__builtin___vsnprintf_chk", "__builtin_nanf", "__builtin_atan2",
        "__builtin_popcountl", "__builtin_ceill", "__builtin___strcpy_chk",
        "__builtin_floor", "__builtin_cos", "__builtin_memset",
        "__builtin_nanl", "__builtin_atan2f", "__builtin_popcount",
        "__builtin_sinh", "__builtin_bcopy", "__builtin_extract_return_addr",
        "__builtin_bswap32", "__builtin_ldexp", "__builtin_infl",
        "__builtin_fmodf", "__builtin_frame_address", "stdin", "stdout",
        "stderr", "fflush", "fwrite", "fputc", "putchar", "fputs", "puts",
        "printf", "fprintf", "fileno", "isalpha", "isdigit", "islower",
        "isspace", "isupper", "tolower", "toupper", "atoi", "atol", "atof",
        "malloc", "calloc", "realloc", "free", "drand48", "lrand48",
        "srand48", "isatty", "getopt", "optarg", "optind", "gzdopen",
        "gzread", "gzclose", "gzopen", "memcpy", "memset", "strcmp",
        "strncmp", "strlen", "strdup", "__assert_fail", "log", "pow"
      ],
      "New Types": [
        "posstat_t", "__anonstruct_posstat_t_390825615", "_krand_t",
        "krand_t", "_krand_t", "krint64_t", "reghash_t", "kh_64_t",
        "__anonstruct_kh_64_t_789978953", "kh_reg_t",
        "__anonstruct_kh_reg_t_369956422", "kh_cstr_t", "khiter_t",
        "khint_t", "khint64_t", "khint32_t", "reglist_t",
        "__anonstruct_reglist_t_947739297", "kseq_t",
        "__anonstruct_kseq_t_745567265", "kstream_t", "__kstream_t",
        "kstring_t", "__kstring_t", "gzFile_s", "gzFile", "gzFile_s",
        "voidp", "FILE", "_IO_FILE", "off_t", "size_t___0", "uint64_t",
        "uint32_t", "int64_t", "int8_t"
      ]
    } }
  ]
}
END-UNIVERSE
*/


/* BEGIN STRUCT-DECL gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */
struct gzFile_s ;
/* END STRUCT-DECL gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */

/* BEGIN STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
struct _IO_FILE ;
/* END STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN STRUCT-DECL _krand_t LOC=seqtk.c:220 */
struct _krand_t ;
/* END STRUCT-DECL _krand_t LOC=seqtk.c:220 */

/* BEGIN STRUCT-DECL __kstream_t LOC=seqtk.c:39 */
struct __kstream_t ;
/* END STRUCT-DECL __kstream_t LOC=seqtk.c:39 */

/* BEGIN STRUCT-DECL __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */
struct __anonstruct_posstat_t_390825615 ;
/* END STRUCT-DECL __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */

/* BEGIN STRUCT-DECL __kstring_t LOC=./kseq.h:83 */
struct __kstring_t ;
/* END STRUCT-DECL __kstring_t LOC=./kseq.h:83 */

/* BEGIN STRUCT-DECL __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */
struct __anonstruct_kh_64_t_789978953 ;
/* END STRUCT-DECL __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */

/* BEGIN STRUCT-DECL __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */
struct __anonstruct_kh_reg_t_369956422 ;
/* END STRUCT-DECL __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */

/* BEGIN STRUCT-DECL __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */
struct __anonstruct_reglist_t_947739297 ;
/* END STRUCT-DECL __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */

/* BEGIN STRUCT-DECL __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */
struct __anonstruct_kseq_t_745567265 ;
/* END STRUCT-DECL __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */

/* BEGIN FUNCTION-DECL __builtin_strchr LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* END FUNCTION-DECL __builtin_strchr LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_trimfq LOC=UNKNOWN */
int stk_trimfq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_trimfq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */
extern int isdigit(int  ) ;
/* END FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */

/* BEGIN FUNCTION-DECL __builtin_ctz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ctz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_acosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_acosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_acosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_acosf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* END FUNCTION-DECL __builtin_sinh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */

/* BEGIN TYPEDEF kh_reg_t LOC=seqtk.c:47 */
typedef struct __anonstruct_kh_reg_t_369956422 kh_reg_t;
/* END TYPEDEF kh_reg_t LOC=seqtk.c:47 */

/* BEGIN TYPEDEF kseq_t LOC=seqtk.c:39 */
typedef struct __anonstruct_kseq_t_745567265 kseq_t;
/* END TYPEDEF kseq_t LOC=seqtk.c:39 */

/* BEGIN FUNCTION-DECL stk_mask LOC=UNKNOWN */
void stk_mask(kseq_t *seq , kh_reg_t const   *h , int is_complement , int mask_chr ) ;
/* END FUNCTION-DECL stk_mask LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_argc LOC=UNKNOWN */
int _global_argc  ;
/* END VARIABLE-DEF _global_argc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* END FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_trap LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* END FUNCTION-DECL __builtin_trap LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* END FUNCTION-DECL __builtin_cosh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* END FUNCTION-DECL __builtin_log10f LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */

/* BEGIN TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
typedef struct _IO_FILE FILE;
/* END TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */
extern int fputs(char const   * __restrict   , FILE * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */

/* BEGIN FUNCTION-DECL stk_sample LOC=UNKNOWN */
int stk_sample(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_sample LOC=UNKNOWN */

/* BEGIN TYPEDEF reglist_t LOC=seqtk.c:41 */
typedef struct __anonstruct_reglist_t_947739297 reglist_t;
/* END TYPEDEF reglist_t LOC=seqtk.c:41 */

/* BEGIN TYPEDEF kh_cstr_t LOC=./khash.h:532 */
typedef char const   *kh_cstr_t;
/* END TYPEDEF kh_cstr_t LOC=./khash.h:532 */

/* BEGIN TYPEDEF khint32_t LOC=./khash.h:122 */
typedef unsigned int khint32_t;
/* END TYPEDEF khint32_t LOC=./khash.h:122 */

/* BEGIN TYPEDEF khint_t LOC=./khash.h:137 */
typedef khint32_t khint_t;
/* END TYPEDEF khint_t LOC=./khash.h:137 */

/* BEGIN STRUCT __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */
struct __anonstruct_kh_reg_t_369956422 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   kh_cstr_t *keys ;
   reglist_t *vals ;
};
/* END STRUCT __anonstruct_kh_reg_t_369956422 LOC=seqtk.c:47 */

/* BEGIN TYPEDEF reghash_t LOC=seqtk.c:50 */
typedef kh_reg_t reghash_t;
/* END TYPEDEF reghash_t LOC=seqtk.c:50 */

/* BEGIN FUNCTION-DECL stk_reg_destroy LOC=UNKNOWN */
void stk_reg_destroy(reghash_t *h ) ;
/* END FUNCTION-DECL stk_reg_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_acos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* END FUNCTION-DECL __builtin_acos LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_listhet LOC=UNKNOWN */
int stk_listhet(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_listhet LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */
extern int fprintf(FILE * __restrict   , char const   * __restrict    , ...) ;
/* END FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */

/* BEGIN FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_mergepe LOC=UNKNOWN */
int stk_mergepe(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_mergepe LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_parity LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_parity LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_cosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */

/* BEGIN TYPEDEF khint64_t LOC=./khash.h:130 */
typedef unsigned long long khint64_t;
/* END TYPEDEF khint64_t LOC=./khash.h:130 */

/* BEGIN STRUCT __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */
struct __anonstruct_kh_64_t_789978953 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   khint64_t *keys ;
   char *vals ;
};
/* END STRUCT __anonstruct_kh_64_t_789978953 LOC=seqtk.c:48 */

/* BEGIN FUNCTION-DECL-EXTERN fileno LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:152 */
extern int fileno(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fileno LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:152 */

/* BEGIN FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN __assert_fail LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h:19 */
extern  __attribute__((__noreturn__)) void __assert_fail(char const   * , char const   * ,
                                                         int  , char const   * ) ;
/* END FUNCTION-DECL-EXTERN __assert_fail LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h:19 */

/* BEGIN TYPEDEF uint64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:215 */
typedef unsigned long long uint64_t;
/* END TYPEDEF uint64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:215 */

/* BEGIN FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */

/* BEGIN TYPEDEF gzFile LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */
typedef struct gzFile_s *gzFile;
/* END TYPEDEF gzFile LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */

/* BEGIN TYPEDEF voidp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h:410 */
typedef void *voidp;
/* END TYPEDEF voidp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h:410 */

/* BEGIN FUNCTION-DECL-EXTERN gzread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1392 */
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
/* END FUNCTION-DECL-EXTERN gzread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1392 */

/* BEGIN TYPEDEF int64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:190 */
typedef long long int64_t;
/* END TYPEDEF int64_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:190 */

/* BEGIN TYPEDEF posstat_t LOC=seqtk.c:1572 */
typedef struct __anonstruct_posstat_t_390825615 posstat_t;
/* END TYPEDEF posstat_t LOC=seqtk.c:1572 */

/* BEGIN FUNCTION-DECL fqc_aux LOC=UNKNOWN */
static void fqc_aux(posstat_t *p , int pos , int64_t *allq , double *perr , int qthres ) ;
/* END FUNCTION-DECL fqc_aux LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_inff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* END FUNCTION-DECL __builtin_inff LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */
extern int isatty(int  ) ;
/* END FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */

/* BEGIN FUNCTION-DECL __builtin_asin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* END FUNCTION-DECL __builtin_asin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_object_size LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* END FUNCTION-DECL __builtin_object_size LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kseq_read LOC=UNKNOWN */
static int kseq_read(kseq_t *seq ) ;
/* END FUNCTION-DECL kseq_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN gzdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1342 */
extern gzFile gzdopen(int fd , char const   *mode ) ;
/* END FUNCTION-DECL-EXTERN gzdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1342 */

/* BEGIN FUNCTION-DECL __builtin_asinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_asinf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN getopt LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:137 */
extern int getopt(int  , char ** , char const   * ) ;
/* END FUNCTION-DECL-EXTERN getopt LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:137 */

/* BEGIN FUNCTION-DECL-EXTERN atol LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:24 */
extern long atol(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atol LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:24 */

/* BEGIN FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */
extern int tolower(int  ) ;
/* END FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */

/* BEGIN TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t___0;
/* END TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN FUNCTION-DECL-EXTERN malloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:40 */
extern void *malloc(size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN malloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:40 */

/* BEGIN FUNCTION-DECL stk_rename LOC=UNKNOWN */
int stk_rename(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_rename LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_coshl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_coshl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_tan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* END FUNCTION-DECL __builtin_tan LOC=BUILTIN */

/* BEGIN TYPEDEF kstream_t LOC=seqtk.c:39 */
typedef struct __kstream_t kstream_t;
/* END TYPEDEF kstream_t LOC=seqtk.c:39 */

/* BEGIN TYPEDEF kstring_t LOC=./kseq.h:83 */
typedef struct __kstring_t kstring_t;
/* END TYPEDEF kstring_t LOC=./kseq.h:83 */

/* BEGIN FUNCTION-DECL ks_getuntil LOC=UNKNOWN */
__inline static int ks_getuntil(kstream_t *ks , int delimiter , kstring_t *str , int *dret ) ;
/* END FUNCTION-DECL ks_getuntil LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_printseq_renamed LOC=UNKNOWN */
__inline static void stk_printseq_renamed(kseq_t const   *s , int line_len , char const   *prefix ,
                                          int64_t n ) ;
/* END FUNCTION-DECL stk_printseq_renamed LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* END FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_seq LOC=UNKNOWN */
int stk_seq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_seq LOC=UNKNOWN */

/* BEGIN STRUCT __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */
struct __anonstruct_posstat_t_390825615 {
   int64_t q[94] ;
   int64_t b[5] ;
};
/* END STRUCT __anonstruct_posstat_t_390825615 LOC=seqtk.c:1572 */

/* BEGIN FUNCTION-DECL kh_get_reg LOC=UNKNOWN */
__inline static khint_t kh_get_reg(kh_reg_t const   *h , kh_cstr_t key ) ;
/* END FUNCTION-DECL kh_get_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* END FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* END FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */

/* BEGIN VARIABLE-DECL-EXTERN optind LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:139 */
extern int optind ;
/* END VARIABLE-DECL-EXTERN optind LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:139 */

/* BEGIN FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */
extern size_t___0 strlen(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */

/* BEGIN FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */
extern int isspace(int  ) ;
/* END FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */

/* BEGIN FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */
extern int strncmp(char const   * , char const   * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */

/* BEGIN TYPEDEF kh_64_t LOC=seqtk.c:48 */
typedef struct __anonstruct_kh_64_t_789978953 kh_64_t;
/* END TYPEDEF kh_64_t LOC=seqtk.c:48 */

/* BEGIN FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL ks_getuntil2 LOC=UNKNOWN */
static int ks_getuntil2(kstream_t *ks , int delimiter , kstring_t *str , int *dret ,
                        int append ) ;
/* END FUNCTION-DECL ks_getuntil2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* END FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN realloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:42 */
extern void *realloc(void * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN realloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:42 */

/* BEGIN FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_coshf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* END FUNCTION-DECL __builtin_coshf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_floor LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* END FUNCTION-DECL __builtin_floor LOC=BUILTIN */

/* BEGIN FUNCTION-DECL print_seq LOC=UNKNOWN */
static void print_seq(FILE *fpout , kseq_t const   *ks , int begin , int end ) ;
/* END FUNCTION-DECL print_seq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_modfl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* END FUNCTION-DECL __builtin_modfl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_infl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* END FUNCTION-DECL __builtin_infl LOC=BUILTIN */

/* BEGIN VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */
extern FILE *stdout ;
/* END VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */

/* BEGIN FUNCTION-DECL stk_comp LOC=UNKNOWN */
int stk_comp(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_comp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_init_reg LOC=UNKNOWN */
__inline static kh_reg_t *kh_init_reg(void) ;
/* END FUNCTION-DECL kh_init_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN pow LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:307 */
extern double pow(double  , double  ) ;
/* END FUNCTION-DECL-EXTERN pow LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:307 */

/* BEGIN VARIABLE-DEF seq_nt16comp_table LOC=UNKNOWN */
unsigned char seq_nt16comp_table[16]  ;
/* END VARIABLE-DEF seq_nt16comp_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_expf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* END FUNCTION-DECL __builtin_expf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ffs LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ffs LOC=BUILTIN */

/* BEGIN STRUCT __kstream_t LOC=seqtk.c:39 */
struct __kstream_t {
   unsigned char *buf ;
   int begin ;
   int end ;
   int is_eof ;
   gzFile f ;
};
/* END STRUCT __kstream_t LOC=seqtk.c:39 */

/* BEGIN FUNCTION-DECL-EXTERN log LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:259 */
extern double log(double  ) ;
/* END FUNCTION-DECL-EXTERN log LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/math.h:259 */

/* BEGIN FUNCTION-DECL __builtin_nanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN islower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:16 */
extern int islower(int  ) ;
/* END FUNCTION-DECL-EXTERN islower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:16 */

/* BEGIN FUNCTION-DECL __builtin_sin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* END FUNCTION-DECL __builtin_sin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF seq_nt16_rev_table LOC=UNKNOWN */
char *seq_nt16_rev_table  ;
/* END VARIABLE-DEF seq_nt16_rev_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL kh_get_64 LOC=UNKNOWN */
__inline static khint_t kh_get_64(kh_64_t const   *h , khint64_t key ) ;
/* END FUNCTION-DECL kh_get_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN toupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:23 */
extern int toupper(int  ) ;
/* END FUNCTION-DECL-EXTERN toupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:23 */

/* BEGIN FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fwrite LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:100 */
extern size_t___0 fwrite(void const   * __restrict   , size_t___0  , size_t___0  ,
                         FILE * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN fwrite LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:100 */

/* BEGIN FUNCTION-DECL stk_hrun LOC=UNKNOWN */
int stk_hrun(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_hrun LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strncat LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncat LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_floorf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* END FUNCTION-DECL __builtin_floorf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_kfreq LOC=UNKNOWN */
int stk_kfreq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_kfreq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN gzopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1893 */
extern gzFile gzopen(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN gzopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1893 */

/* BEGIN FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabs LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* END FUNCTION-DECL __builtin_fabs LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_init_64 LOC=UNKNOWN */
__inline static kh_64_t *kh_init_64(void) ;
/* END FUNCTION-DECL kh_init_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF seq_nt6_table LOC=UNKNOWN */
unsigned char seq_nt6_table[256]  ;
/* END VARIABLE-DEF seq_nt6_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN atof LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:26 */
extern double atof(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atof LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:26 */

/* BEGIN FUNCTION-DECL __builtin_tanh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* END FUNCTION-DECL __builtin_tanh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */

/* BEGIN TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */
typedef long long off_t;
/* END TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */

/* BEGIN FUNCTION-DECL stk_mergefa LOC=UNKNOWN */
int stk_mergefa(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_mergefa LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_powil LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_famask LOC=UNKNOWN */
int stk_famask(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_famask LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* END FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _global_argv LOC=UNKNOWN */
char **_global_argv  ;
/* END VARIABLE-DEF _global_argv LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_atanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kseq_destroy LOC=UNKNOWN */
static void kseq_destroy(kseq_t *ks ) ;
/* END FUNCTION-DECL kseq_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nansf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansf LOC=BUILTIN */

/* BEGIN TYPEDEF krint64_t LOC=seqtk.c:218 */
typedef uint64_t krint64_t;
/* END TYPEDEF krint64_t LOC=seqtk.c:218 */

/* BEGIN STRUCT _krand_t LOC=seqtk.c:228 */
struct _krand_t {
   int mti ;
   krint64_t mt[312] ;
};
/* END STRUCT _krand_t LOC=seqtk.c:228 */

/* BEGIN FUNCTION-DECL cpy_kstr LOC=UNKNOWN */
static void cpy_kstr(kstring_t *dst , kstring_t const   *src ) ;
/* END FUNCTION-DECL cpy_kstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_dropse LOC=UNKNOWN */
int stk_dropse(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_dropse LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL ks_destroy LOC=UNKNOWN */
__inline static void ks_destroy(kstream_t *ks ) ;
/* END FUNCTION-DECL ks_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN putchar LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:109 */
extern int putchar(int  ) ;
/* END FUNCTION-DECL-EXTERN putchar LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:109 */

/* BEGIN FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_printstr LOC=UNKNOWN */
static void stk_printstr(kstring_t const   *s , unsigned int line_len ) ;
/* END FUNCTION-DECL stk_printstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nansl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* END FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_parityl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_parityl LOC=BUILTIN */

/* BEGIN TYPEDEF krand_t LOC=seqtk.c:221 */
typedef struct _krand_t krand_t;
/* END TYPEDEF krand_t LOC=seqtk.c:221 */

/* BEGIN FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* END FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ceil LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* END FUNCTION-DECL __builtin_ceil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strlen LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strlen LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN puts LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:117 */
extern int puts(char const   * ) ;
/* END FUNCTION-DECL-EXTERN puts LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:117 */

/* BEGIN FUNCTION-DECL-EXTERN fflush LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:89 */
extern int fflush(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fflush LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:89 */

/* BEGIN FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */

/* BEGIN FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* END FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_asinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_asinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */

/* BEGIN STRUCT gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1834 */
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
/* END STRUCT gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1834 */

/* BEGIN FUNCTION-DECL-EXTERN strdup LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:70 */
extern char *strdup(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strdup LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:70 */

/* BEGIN FUNCTION-DECL __builtin_atanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_atanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF __ac_HASH_UPPER LOC=UNKNOWN */
static double __ac_HASH_UPPER  ;
/* END VARIABLE-DEF __ac_HASH_UPPER LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL cpy_kseq LOC=UNKNOWN */
static void cpy_kseq(kseq_t *dst , kseq_t const   *src ) ;
/* END FUNCTION-DECL cpy_kseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_parityll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_parityll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fmod LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* END FUNCTION-DECL __builtin_fmod LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kr_rand LOC=UNKNOWN */
krint64_t kr_rand(krand_t *kr ) ;
/* END FUNCTION-DECL kr_rand LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN gzclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1631 */
extern int gzclose(gzFile file ) ;
/* END FUNCTION-DECL-EXTERN gzclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1631 */

/* BEGIN FUNCTION-DECL kseq_init LOC=UNKNOWN */
static kseq_t *kseq_init(gzFile fd ) ;
/* END FUNCTION-DECL kseq_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* END FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_tanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __ac_X31_hash_string LOC=UNKNOWN */
__inline static khint_t __ac_X31_hash_string(char const   *s ) ;
/* END FUNCTION-DECL __ac_X31_hash_string LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL kh_resize_64 LOC=UNKNOWN */
__inline static void kh_resize_64(kh_64_t *h , khint_t new_n_buckets ) ;
/* END FUNCTION-DECL kh_resize_64 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF mag01 LOC=UNKNOWN */
static krint64_t mag01[2]  ;
/* END VARIABLE-DEF mag01 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_mutfa LOC=UNKNOWN */
int stk_mutfa(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_mutfa LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floorl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_floorl LOC=BUILTIN */

/* BEGIN VARIABLE-DECL-EXTERN optarg LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:138 */
extern char *optarg ;
/* END VARIABLE-DECL-EXTERN optarg LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:138 */

/* BEGIN FUNCTION-DECL __builtin_expl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_expl LOC=BUILTIN */

/* BEGIN VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */
extern FILE *stderr ;
/* END VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */

/* BEGIN FUNCTION-DECL __builtin_log10l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* END FUNCTION-DECL __builtin_log10l LOC=BUILTIN */

/* BEGIN VARIABLE-DEF seq_nt16_table LOC=UNKNOWN */
unsigned char seq_nt16_table[256]  ;
/* END VARIABLE-DEF seq_nt16_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_popcount LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_popcount LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* END FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */
extern int strcmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */

/* BEGIN FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */

/* BEGIN STRUCT __kstring_t LOC=./kseq.h:83 */
struct __kstring_t {
   size_t___0 l ;
   size_t___0 m ;
   char *s ;
};
/* END STRUCT __kstring_t LOC=./kseq.h:83 */

/* BEGIN STRUCT __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */
struct __anonstruct_kseq_t_745567265 {
   kstring_t name ;
   kstring_t comment ;
   kstring_t seq ;
   kstring_t qual ;
   int last_char ;
   int is_fastq ;
   kstream_t *f ;
};
/* END STRUCT __anonstruct_kseq_t_745567265 LOC=seqtk.c:39 */

/* BEGIN FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */

/* BEGIN TYPEDEF int8_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:175 */
typedef signed char int8_t;
/* END TYPEDEF int8_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:175 */

/* BEGIN FUNCTION-DECL kh_put_reg LOC=UNKNOWN */
__inline static khint_t kh_put_reg(kh_reg_t *h , kh_cstr_t key , int *ret ) ;
/* END FUNCTION-DECL kh_put_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_clz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_clz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nans LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nans LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memset LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* END FUNCTION-DECL __builtin_memset LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bzero LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bzero LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_subseq LOC=UNKNOWN */
int stk_subseq(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_subseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_printseq LOC=UNKNOWN */
__inline static void stk_printseq(kseq_t const   *s , int line_len ) ;
/* END FUNCTION-DECL stk_printseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN isalpha LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:11 */
extern int isalpha(int  ) ;
/* END FUNCTION-DECL-EXTERN isalpha LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:11 */

/* BEGIN VARIABLE-DEF seq_nt16to4_table LOC=UNKNOWN */
unsigned char seq_nt16to4_table[16]  ;
/* END VARIABLE-DEF seq_nt16to4_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_clzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_clzl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ceill LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* END FUNCTION-DECL __builtin_ceill LOC=BUILTIN */

/* BEGIN TYPEDEF uint32_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:210 */
typedef unsigned int uint32_t;
/* END TYPEDEF uint32_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:210 */

/* BEGIN FUNCTION-DECL ks_getc LOC=UNKNOWN */
__inline static int ks_getc(kstream_t *ks ) ;
/* END FUNCTION-DECL ks_getc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* END FUNCTION-DECL __builtin_atan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_hety LOC=UNKNOWN */
int stk_hety(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_hety LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_return LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* END FUNCTION-DECL __builtin_return LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF bitcnt_table LOC=UNKNOWN */
int bitcnt_table[16]  ;
/* END VARIABLE-DEF bitcnt_table LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_powif LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powif LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN calloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:41 */
extern void *calloc(size_t___0  , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN calloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:41 */

/* BEGIN VARIABLE-DEF cutN_min_N_tract LOC=UNKNOWN */
static int cutN_min_N_tract  ;
/* END VARIABLE-DEF cutN_min_N_tract LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */
extern int printf(char const   * __restrict    , ...) ;
/* END FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */

/* BEGIN FUNCTION-DECL-EXTERN isupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:20 */
extern int isupper(int  ) ;
/* END FUNCTION-DECL-EXTERN isupper LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:20 */

/* BEGIN VARIABLE-DEF _global_envp LOC=UNKNOWN */
char **_global_envp  ;
/* END VARIABLE-DEF _global_envp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lrand48 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:130 */
extern long lrand48(void) ;
/* END FUNCTION-DECL-EXTERN lrand48 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:130 */

/* BEGIN FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* END FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_gc LOC=UNKNOWN */
int stk_gc(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_gc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_clzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_clzll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */
/* compiler builtin: 
   long long __builtin_bswap64(long long  ) ;  */
/* END FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_resize_reg LOC=UNKNOWN */
__inline static void kh_resize_reg(kh_reg_t *h , khint_t new_n_buckets ) ;
/* END FUNCTION-DECL kh_resize_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_logl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_logl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* END FUNCTION-DECL __builtin_log LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_end LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_end LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* END FUNCTION-DECL __builtin_cos LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN free LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:43 */
extern void free(void * ) ;
/* END FUNCTION-DECL-EXTERN free LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:43 */

/* BEGIN FUNCTION-DECL main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) ;
/* END FUNCTION-DECL main LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_exp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* END FUNCTION-DECL __builtin_exp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kr_srand0 LOC=UNKNOWN */
static void kr_srand0(krint64_t seed , krand_t *kr ) ;
/* END FUNCTION-DECL kr_srand0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL kr_srand LOC=UNKNOWN */
krand_t *kr_srand(krint64_t seed ) ;
/* END FUNCTION-DECL kr_srand LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */
extern FILE *stdin ;
/* END VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */

/* BEGIN FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */
struct __anonstruct_reglist_t_947739297 {
   int n ;
   int m ;
   uint64_t *a ;
};
/* END STRUCT __anonstruct_reglist_t_947739297 LOC=seqtk.c:41 */

/* BEGIN TYPEDEF khiter_t LOC=./khash.h:138 */
typedef khint_t khiter_t;
/* END TYPEDEF khiter_t LOC=./khash.h:138 */

/* BEGIN FUNCTION-DECL stk_fqchk LOC=UNKNOWN */
int stk_fqchk(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_fqchk LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_cosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_cosf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* END FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL find_next_cut LOC=UNKNOWN */
static int find_next_cut(kseq_t const   *ks , int k , int *begin , int *end ) ;
/* END FUNCTION-DECL find_next_cut LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stk_randbase LOC=UNKNOWN */
int stk_randbase(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_randbase LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* END FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF cutN_nonN_penalty LOC=UNKNOWN */
static int cutN_nonN_penalty  ;
/* END VARIABLE-DEF cutN_nonN_penalty LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_apply LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_apply LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_reg_read LOC=UNKNOWN */
reghash_t *stk_reg_read(char const   *fn ) ;
/* END FUNCTION-DECL stk_reg_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN srand48 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:134 */
extern void srand48(long  ) ;
/* END FUNCTION-DECL-EXTERN srand48 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:134 */

/* BEGIN FUNCTION-DECL kh_destroy_64 LOC=UNKNOWN */
__inline static void kh_destroy_64(kh_64_t *h ) ;
/* END FUNCTION-DECL kh_destroy_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL usage LOC=UNKNOWN */
static int usage(void) ;
/* END FUNCTION-DECL usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL ks_init LOC=UNKNOWN */
__inline static kstream_t *ks_init(gzFile f ) ;
/* END FUNCTION-DECL ks_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_powi LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powi LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_destroy_reg LOC=UNKNOWN */
__inline static void kh_destroy_reg(kh_reg_t *h ) ;
/* END FUNCTION-DECL kh_destroy_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_logf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* END FUNCTION-DECL __builtin_logf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_expect LOC=BUILTIN */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* END FUNCTION-DECL __builtin_expect LOC=BUILTIN */

/* BEGIN FUNCTION-DECL stk_cutN LOC=UNKNOWN */
int stk_cutN(int argc , char **argv ) ;
/* END FUNCTION-DECL stk_cutN LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN drand48 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:128 */
extern double drand48(void) ;
/* END FUNCTION-DECL-EXTERN drand48 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:128 */

/* BEGIN FUNCTION-DECL __builtin_alloca LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_alloca LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */

/* BEGIN VARIABLE-DEF comp_tab LOC=UNKNOWN */
char comp_tab[128]  ;
/* END VARIABLE-DEF comp_tab LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */
extern void *memset(void * , int  , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */

/* BEGIN FUNCTION-DECL __builtin_inf LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* END FUNCTION-DECL __builtin_inf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN atoi LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:23 */
extern int atoi(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atoi LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:23 */

/* BEGIN FUNCTION-DECL __builtin_log10 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* END FUNCTION-DECL __builtin_log10 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL kh_put_64 LOC=UNKNOWN */
__inline static khint_t kh_put_64(kh_64_t *h , khint64_t key , int *ret ) ;
/* END FUNCTION-DECL kh_put_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_modff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* END FUNCTION-DECL __builtin_modff LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */
extern int fputc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */

/* BEGIN FUNCTION-DEF stk_mergefa LOC=UNKNOWN */
int stk_mergefa(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  int c ;
  int is_intersect ;
  int is_haploid ;
  int qual ;
  int is_mask ;
  int is_randhet ;
  uint64_t cnt[5] ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c___0[2] ;
  int b[2] ;
  int is_upper ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;
  unsigned int _1_stk_mergefa_next ;

  {
  {
  _1_stk_mergefa_next = 150U;
  }
  while (1) {
    switch (_1_stk_mergefa_next) {
    case 18: ;
    if (l % 60 == 0) {
      {
      _1_stk_mergefa_next = 60U;
      }
    } else {
      {
      _1_stk_mergefa_next = 122U;
      }
    }
    break;
    case 129: ;
    if (b[1] > 1) {
      {
      _1_stk_mergefa_next = 3U;
      }
    } else {
      {
      _1_stk_mergefa_next = 52U;
      }
    }
    break;
    case 50: ;
    if (b[0] == 1) {
      {
      _1_stk_mergefa_next = 148U;
      }
    } else {
      {
      _1_stk_mergefa_next = 72U;
      }
    }
    break;
    case 80: 
    c___0[0] &= i;
    {
    _1_stk_mergefa_next = 7U;
    }
    break;
    case 108: ;
    if (is_mask) {
      {
      _1_stk_mergefa_next = 154U;
      }
    } else {
      {
      _1_stk_mergefa_next = 15U;
      }
    }
    break;
    case 166: 
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp[i] = tmp___2;
    {
    _1_stk_mergefa_next = 81U;
    }
    break;
    case 104: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 130: 
    c___0[0] = tolower(c___0[0]);
    {
    _1_stk_mergefa_next = 145U;
    }
    break;
    case 25: 
    is_upper = 1;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 52: ;
    if (is_intersect) {
      {
      _1_stk_mergefa_next = 69U;
      }
    } else {
      {
      _1_stk_mergefa_next = 31U;
      }
    }
    break;
    case 4: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 30: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Different sequence names: %s != %s\n",
            "stk_mergefa", (seq[0])->name.s, (seq[1])->name.s);
    {
    _1_stk_mergefa_next = 23U;
    }
    break;
    case 62: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 103: 
    tmp___7 = isupper(c___0[0]);
    {
    _1_stk_mergefa_next = 82U;
    }
    break;
    case 102: 
    i >>= 1;
    {
    _1_stk_mergefa_next = 109U;
    }
    break;
    case 106: ;
    if (c___0[0] == 0) {
      {
      _1_stk_mergefa_next = 6U;
      }
    } else {
      {
      _1_stk_mergefa_next = 123U;
      }
    }
    break;
    case 111: 
    tmp___21 = kseq_read(seq[0]);
    {
    _1_stk_mergefa_next = 96U;
    }
    break;
    case 145: ;
    if ((seq[1])->qual.l) {
      {
      _1_stk_mergefa_next = 144U;
      }
    } else {
      {
      _1_stk_mergefa_next = 95U;
      }
    }
    break;
    case 15: 
    tmp___15 = isupper(c___0[0]);
    {
    _1_stk_mergefa_next = 121U;
    }
    break;
    case 82: ;
    if (tmp___7) {
      {
      _1_stk_mergefa_next = 90U;
      }
    } else {
      {
      _1_stk_mergefa_next = 93U;
      }
    }
    break;
    case 133: 
    c = getopt(argc, argv, "himrq:");
    {
    _1_stk_mergefa_next = 73U;
    }
    break;
    case 89: 
    is_upper = 1;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 56: ;
    if (! is_upper) {
      {
      _1_stk_mergefa_next = 92U;
      }
    } else {
      {
      _1_stk_mergefa_next = 18U;
      }
    }
    break;
    case 79: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 53U;
    }
    break;
    case 164: ;
    if ((unsigned long )fp[1] == (unsigned long )((gzFile )0)) {
      {
      _1_stk_mergefa_next = 29U;
      }
    } else {
      {
      _1_stk_mergefa_next = 66U;
      }
    }
    break;
    case 31: ;
    if (is_mask) {
      {
      _1_stk_mergefa_next = 120U;
      }
    } else {
      {
      _1_stk_mergefa_next = 16U;
      }
    }
    break;
    case 121: ;
    if (tmp___15) {
      {
      _1_stk_mergefa_next = 153U;
      }
    } else {
      {
      _1_stk_mergefa_next = 104U;
      }
    }
    break;
    case 12: ;
    if (b[0] == 1) {
      {
      _1_stk_mergefa_next = 85U;
      }
    } else {
      {
      _1_stk_mergefa_next = 125U;
      }
    }
    break;
    case 141: 
    (cnt[3]) ++;
    {
    _1_stk_mergefa_next = 136U;
    }
    break;
    case 101: 
    _L___0: ;
    if (b[0] == 2) {
      {
      _1_stk_mergefa_next = 113U;
      }
    } else {
      {
      _1_stk_mergefa_next = 39U;
      }
    }
    break;
    case 168: ;
    return (1);
    break;
    case 69: 
    c___0[0] &= c___0[1];
    {
    _1_stk_mergefa_next = 34U;
    }
    break;
    case 152: 
    (cnt[0]) ++;
    {
    _1_stk_mergefa_next = 136U;
    }
    break;
    case 8: ;
    return (1);
    break;
    case 160: 
    i = 1;
    {
    _1_stk_mergefa_next = 110U;
    }
    break;
    case 96: ;
    if (! (tmp___21 >= 0)) {
      {
      _1_stk_mergefa_next = 127U;
      }
    } else {
      {
      _1_stk_mergefa_next = 5U;
      }
    }
    break;
    case 45: 
    _L___5: ;
    if (b[0] == 2) {
      {
      _1_stk_mergefa_next = 75U;
      }
    } else {
      {
      _1_stk_mergefa_next = 10U;
      }
    }
    break;
    case 54: 
    i = 8;
    {
    _1_stk_mergefa_next = 109U;
    }
    break;
    case 78: 
    is_randhet = 1;
    {
    _1_stk_mergefa_next = 133U;
    }
    break;
    case 124: 
    c___0[0] |= c___0[1];
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 118: 
    c___0[0] &= i;
    {
    _1_stk_mergefa_next = 102U;
    }
    break;
    case 140: ;
    return (1);
    break;
    case 1: 
    c___0[0] = (int )*((seq[0])->seq.s + l);
    c___0[1] = (int )*((seq[1])->seq.s + l);
    {
    _1_stk_mergefa_next = 163U;
    }
    break;
    case 81: 
    seq[i] = kseq_init(fp[i]);
    i ++;
    {
    _1_stk_mergefa_next = 37U;
    }
    break;
    case 23: ;
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
      {
      _1_stk_mergefa_next = 138U;
      }
    } else {
      {
      _1_stk_mergefa_next = 135U;
      }
    }
    break;
    case 77: 
    tmp___20 = lrand48();
    {
    _1_stk_mergefa_next = 171U;
    }
    break;
    case 70: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 53U;
    }
    break;
    case 3: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 52U;
    }
    break;
    case 134: ;
    return (1);
    break;
    case 16: ;
    if (is_randhet) {
      {
      _1_stk_mergefa_next = 12U;
      }
    } else {
      {
      _1_stk_mergefa_next = 48U;
      }
    }
    break;
    case 21: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage: seqtk mergefa [options] <in1.fa> <in2.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q INT   quality threshold [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -i       take intersection\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m       convert to lowercase when one of the input base is N\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -r       pick a random allele from het\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -h       suppress hets in the input\n\n");
    {
    _1_stk_mergefa_next = 134U;
    }
    break;
    case 94: ;
    if (tmp___16) {
      {
      _1_stk_mergefa_next = 25U;
      }
    } else {
      {
      _1_stk_mergefa_next = 2U;
      }
    }
    break;
    case 109: ;
    if (i >= 1) {
      {
      _1_stk_mergefa_next = 91U;
      }
    } else {
      {
      _1_stk_mergefa_next = 100U;
      }
    }
    break;
    case 167: 
    (cnt[2]) ++;
    {
    _1_stk_mergefa_next = 136U;
    }
    break;
    case 36: 
    c___0[1] = 15;
    {
    _1_stk_mergefa_next = 139U;
    }
    break;
    case 76: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 68: ;
    if (tmp___11) {
      {
      _1_stk_mergefa_next = 114U;
      }
    } else {
      {
      _1_stk_mergefa_next = 61U;
      }
    }
    break;
    case 156: ;
    if (is_intersect) {
      {
      _1_stk_mergefa_next = 116U;
      }
    } else {
      {
      _1_stk_mergefa_next = 98U;
      }
    }
    break;
    case 122: 
    putchar(c___0[0]);
    l ++;
    {
    _1_stk_mergefa_next = 176U;
    }
    break;
    case 85: ;
    if (b[1] == 1) {
      {
      _1_stk_mergefa_next = 155U;
      }
    } else {
      {
      _1_stk_mergefa_next = 125U;
      }
    }
    break;
    case 100: 
    c___0[0] = (int )*(seq_nt16_rev_table + c___0[0]);
    {
    _1_stk_mergefa_next = 56U;
    }
    break;
    case 98: ;
    if (optind + 2 > argc) {
      {
      _1_stk_mergefa_next = 21U;
      }
    } else {
      {
      _1_stk_mergefa_next = 87U;
      }
    }
    break;
    case 11: 
    tmp___19 = lrand48();
    {
    _1_stk_mergefa_next = 27U;
    }
    break;
    case 9: ;
    if (b[1] == 2) {
      {
      _1_stk_mergefa_next = 99U;
      }
    } else {
      {
      _1_stk_mergefa_next = 136U;
      }
    }
    break;
    case 135: ;
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
      {
      _1_stk_mergefa_next = 175U;
      }
    } else {
      {
      _1_stk_mergefa_next = 126U;
      }
    }
    break;
    case 176: ;
    if (l < min_l) {
      {
      _1_stk_mergefa_next = 1U;
      }
    } else {
      {
      _1_stk_mergefa_next = 107U;
      }
    }
    break;
    case 107: 
    putchar('\n');
    {
    _1_stk_mergefa_next = 111U;
    }
    break;
    case 125: 
    _L___6: ;
    if (b[0] == 1) {
      {
      _1_stk_mergefa_next = 151U;
      }
    } else {
      {
      _1_stk_mergefa_next = 45U;
      }
    }
    break;
    case 143: 
    tmp___0 = gzopen((char const   *)*(argv + (optind + i)), "r");
    fp[i] = tmp___0;
    {
    _1_stk_mergefa_next = 81U;
    }
    break;
    case 19: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergefa");
    {
    _1_stk_mergefa_next = 8U;
    }
    break;
    case 32: 
    is_mask = 1;
    {
    _1_stk_mergefa_next = 133U;
    }
    break;
    case 90: 
    is_upper = 1;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 172: ;
    if (b[0] > 1) {
      {
      _1_stk_mergefa_next = 115U;
      }
    } else {
      {
      _1_stk_mergefa_next = 129U;
      }
    }
    break;
    case 40: ;
    return (0);
    break;
    case 67: ;
    if ((int )*((seq[0])->qual.s + l) - 33 < qual) {
      {
      _1_stk_mergefa_next = 130U;
      }
    } else {
      {
      _1_stk_mergefa_next = 145U;
      }
    }
    break;
    case 55: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 117: 
    _L___3: ;
    if (c___0[0] & c___0[1]) {
      {
      _1_stk_mergefa_next = 149U;
      }
    } else {
      {
      _1_stk_mergefa_next = 10U;
      }
    }
    break;
    case 110: ;
    if (i <= 8) {
      {
      _1_stk_mergefa_next = 44U;
      }
    } else {
      {
      _1_stk_mergefa_next = 100U;
      }
    }
    break;
    case 60: 
    putchar('\n');
    {
    _1_stk_mergefa_next = 122U;
    }
    break;
    case 150: 
    is_intersect = 0;
    is_haploid = 0;
    qual = 0;
    is_mask = 0;
    is_randhet = 0;
    {
    _1_stk_mergefa_next = 133U;
    }
    break;
    case 59: ;
    if (tmp___3) {
      {
      _1_stk_mergefa_next = 143U;
      }
    } else {
      {
      _1_stk_mergefa_next = 166U;
      }
    }
    break;
    case 165: ;
    if (is_upper) {
      {
      _1_stk_mergefa_next = 50U;
      }
    } else {
      {
      _1_stk_mergefa_next = 136U;
      }
    }
    break;
    case 161: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 6: 
    c___0[0] = 15;
    {
    _1_stk_mergefa_next = 123U;
    }
    break;
    case 155: 
    c___0[0] |= c___0[1];
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 144: ;
    if ((int )*((seq[1])->qual.s + l) - 33 < qual) {
      {
      _1_stk_mergefa_next = 88U;
      }
    } else {
      {
      _1_stk_mergefa_next = 95U;
      }
    }
    break;
    case 116: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] `-i\' and `-h\' cannot be applied at the same time.\n",
            "stk_mergefa");
    {
    _1_stk_mergefa_next = 140U;
    }
    break;
    case 27: ;
    if (tmp___19 & 1L) {
      {
      _1_stk_mergefa_next = 54U;
      }
    } else {
      {
      _1_stk_mergefa_next = 160U;
      }
    }
    break;
    case 154: 
    tmp___11 = isupper(c___0[0]);
    {
    _1_stk_mergefa_next = 68U;
    }
    break;
    case 151: ;
    if (b[1] == 2) {
      {
      _1_stk_mergefa_next = 117U;
      }
    } else {
      {
      _1_stk_mergefa_next = 45U;
      }
    }
    break;
    case 157: 
    is_haploid = 1;
    {
    _1_stk_mergefa_next = 133U;
    }
    break;
    case 38: ;
    if (b[1] == 2) {
      {
      _1_stk_mergefa_next = 167U;
      }
    } else {
      {
      _1_stk_mergefa_next = 101U;
      }
    }
    break;
    case 61: 
    tmp___12 = isupper(c___0[1]);
    {
    _1_stk_mergefa_next = 174U;
    }
    break;
    case 87: 
    i = 0;
    {
    _1_stk_mergefa_next = 37U;
    }
    break;
    case 113: ;
    if (b[1] == 1) {
      {
      _1_stk_mergefa_next = 141U;
      }
    } else {
      {
      _1_stk_mergefa_next = 39U;
      }
    }
    break;
    case 138: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Unequal sequence length: %ld != %ld\n",
            "stk_mergefa", (seq[0])->seq.l, (seq[1])->seq.l);
    {
    _1_stk_mergefa_next = 135U;
    }
    break;
    case 58: ;
    if (tmp___4) {
      {
      _1_stk_mergefa_next = 30U;
      }
    } else {
      {
      _1_stk_mergefa_next = 23U;
      }
    }
    break;
    case 84: 
    is_intersect = 1;
    {
    _1_stk_mergefa_next = 133U;
    }
    break;
    case 171: ;
    if (tmp___20 & 1L) {
      {
      _1_stk_mergefa_next = 11U;
      }
    } else {
      {
      _1_stk_mergefa_next = 100U;
      }
    }
    break;
    case 34: ;
    if (c___0[0] == 0) {
      {
      _1_stk_mergefa_next = 62U;
      }
    } else {
      {
      _1_stk_mergefa_next = 100U;
      }
    }
    break;
    case 74: ;
    if ((unsigned long )fp[0] == (unsigned long )((gzFile )0)) {
      {
      _1_stk_mergefa_next = 19U;
      }
    } else {
      {
      _1_stk_mergefa_next = 164U;
      }
    }
    break;
    case 112: 
    is_upper = 1;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 75: ;
    if (b[1] == 1) {
      {
      _1_stk_mergefa_next = 117U;
      }
    } else {
      {
      _1_stk_mergefa_next = 10U;
      }
    }
    break;
    case 123: ;
    if (c___0[1] == 0) {
      {
      _1_stk_mergefa_next = 36U;
      }
    } else {
      {
      _1_stk_mergefa_next = 139U;
      }
    }
    break;
    case 48: 
    c___0[0] |= c___0[1];
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 127: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] (same,diff,hom-het,het-hom,het-het)=(%ld,%ld,%ld,%ld,%ld)\n",
            "stk_mergefa", (long )cnt[0], (long )cnt[1], (long )cnt[2], (long )cnt[3],
            (long )cnt[4]);
    {
    _1_stk_mergefa_next = 40U;
    }
    break;
    case 139: 
    b[0] = bitcnt_table[c___0[0]];
    b[1] = bitcnt_table[c___0[1]];
    {
    _1_stk_mergefa_next = 165U;
    }
    break;
    case 147: ;
    if (b[1] == 2) {
      {
      _1_stk_mergefa_next = 71U;
      }
    } else {
      {
      _1_stk_mergefa_next = 55U;
      }
    }
    break;
    case 71: ;
    if (c___0[0] == c___0[1]) {
      {
      _1_stk_mergefa_next = 77U;
      }
    } else {
      {
      _1_stk_mergefa_next = 83U;
      }
    }
    break;
    case 173: 
    printf((char const   */* __restrict  */)">%s", (seq[0])->name.s);
    l = 0;
    {
    _1_stk_mergefa_next = 176U;
    }
    break;
    case 28: 
    (cnt[1]) ++;
    {
    _1_stk_mergefa_next = 136U;
    }
    break;
    case 53: 
    c___0[0] &= c___0[1];
    {
    _1_stk_mergefa_next = 43U;
    }
    break;
    case 148: ;
    if (b[1] == 1) {
      {
      _1_stk_mergefa_next = 97U;
      }
    } else {
      {
      _1_stk_mergefa_next = 72U;
      }
    }
    break;
    case 65: ;
    switch (c) {
    case 105: 
    {
    _1_stk_mergefa_next = 84U;
    }
    break;
    case 104: 
    {
    _1_stk_mergefa_next = 157U;
    }
    break;
    case 109: 
    {
    _1_stk_mergefa_next = 32U;
    }
    break;
    case 114: 
    {
    _1_stk_mergefa_next = 78U;
    }
    break;
    case 113: 
    {
    _1_stk_mergefa_next = 0U;
    }
    break;
    default: 
    {
    _1_stk_mergefa_next = 133U;
    }
    break;
    }
    break;
    case 73: ;
    if (! (c >= 0)) {
      {
      _1_stk_mergefa_next = 119U;
      }
    } else {
      {
      _1_stk_mergefa_next = 65U;
      }
    }
    break;
    case 44: ;
    if (c___0[0] & i) {
      {
      _1_stk_mergefa_next = 80U;
      }
    } else {
      {
      _1_stk_mergefa_next = 7U;
      }
    }
    break;
    case 5: 
    kseq_read(seq[1]);
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
    {
    _1_stk_mergefa_next = 58U;
    }
    break;
    case 91: ;
    if (c___0[0] & i) {
      {
      _1_stk_mergefa_next = 118U;
      }
    } else {
      {
      _1_stk_mergefa_next = 102U;
      }
    }
    break;
    case 120: ;
    if (c___0[0] == 15) {
      {
      _1_stk_mergefa_next = 79U;
      }
    } else {
      {
      _1_stk_mergefa_next = 41U;
      }
    }
    break;
    case 97: ;
    if (c___0[0] == c___0[1]) {
      {
      _1_stk_mergefa_next = 152U;
      }
    } else {
      {
      _1_stk_mergefa_next = 28U;
      }
    }
    break;
    case 163: ;
    if ((seq[0])->qual.l) {
      {
      _1_stk_mergefa_next = 67U;
      }
    } else {
      {
      _1_stk_mergefa_next = 145U;
      }
    }
    break;
    case 72: 
    _L___1: ;
    if (b[0] == 1) {
      {
      _1_stk_mergefa_next = 38U;
      }
    } else {
      {
      _1_stk_mergefa_next = 101U;
      }
    }
    break;
    case 99: 
    (cnt[4]) ++;
    {
    _1_stk_mergefa_next = 136U;
    }
    break;
    case 114: 
    is_upper = 1;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 33: ;
    if (tmp___8) {
      {
      _1_stk_mergefa_next = 112U;
      }
    } else {
      {
      _1_stk_mergefa_next = 42U;
      }
    }
    break;
    case 37: ;
    if (i < 2) {
      {
      _1_stk_mergefa_next = 35U;
      }
    } else {
      {
      _1_stk_mergefa_next = 74U;
      }
    }
    break;
    case 64: ;
    if (tmp___18 & 1L) {
      {
      _1_stk_mergefa_next = 20U;
      }
    } else {
      {
      _1_stk_mergefa_next = 124U;
      }
    }
    break;
    case 93: 
    tmp___8 = isupper(c___0[1]);
    {
    _1_stk_mergefa_next = 33U;
    }
    break;
    case 119: ;
    if (is_mask) {
      {
      _1_stk_mergefa_next = 156U;
      }
    } else {
      {
      _1_stk_mergefa_next = 98U;
      }
    }
    break;
    case 175: 
    min_l = (int )(seq[0])->seq.l;
    {
    _1_stk_mergefa_next = 173U;
    }
    break;
    case 41: ;
    if (c___0[1] == 15) {
      {
      _1_stk_mergefa_next = 70U;
      }
    } else {
      {
      _1_stk_mergefa_next = 53U;
      }
    }
    break;
    case 95: ;
    if (is_intersect) {
      {
      _1_stk_mergefa_next = 103U;
      }
    } else {
      {
      _1_stk_mergefa_next = 108U;
      }
    }
    break;
    case 149: 
    tmp___18 = lrand48();
    {
    _1_stk_mergefa_next = 64U;
    }
    break;
    case 92: 
    c___0[0] = tolower(c___0[0]);
    {
    _1_stk_mergefa_next = 18U;
    }
    break;
    case 115: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 52U;
    }
    break;
    case 10: 
    _L___4: ;
    if (b[0] == 2) {
      {
      _1_stk_mergefa_next = 147U;
      }
    } else {
      {
      _1_stk_mergefa_next = 161U;
      }
    }
    break;
    case 42: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 0: 
    qual = atoi((char const   *)optarg);
    {
    _1_stk_mergefa_next = 133U;
    }
    break;
    case 136: ;
    if (is_haploid) {
      {
      _1_stk_mergefa_next = 172U;
      }
    } else {
      {
      _1_stk_mergefa_next = 52U;
      }
    }
    break;
    case 153: 
    tmp___16 = isupper(c___0[1]);
    {
    _1_stk_mergefa_next = 94U;
    }
    break;
    case 177: 
    c___0[0] = (int )seq_nt16_table[c___0[0]];
    c___0[1] = (int )seq_nt16_table[c___0[1]];
    {
    _1_stk_mergefa_next = 106U;
    }
    break;
    case 39: 
    _L: ;
    if (b[0] == 2) {
      {
      _1_stk_mergefa_next = 9U;
      }
    } else {
      {
      _1_stk_mergefa_next = 136U;
      }
    }
    break;
    case 66: 
    cnt[4] = (uint64_t )0;
    cnt[3] = cnt[4];
    cnt[2] = cnt[3];
    cnt[1] = cnt[2];
    cnt[0] = cnt[1];
    srand48(11L);
    {
    _1_stk_mergefa_next = 111U;
    }
    break;
    case 83: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    case 7: 
    i <<= 1;
    {
    _1_stk_mergefa_next = 110U;
    }
    break;
    case 88: 
    c___0[1] = tolower(c___0[1]);
    {
    _1_stk_mergefa_next = 95U;
    }
    break;
    case 35: 
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), "-");
    {
    _1_stk_mergefa_next = 59U;
    }
    break;
    case 174: ;
    if (tmp___12) {
      {
      _1_stk_mergefa_next = 89U;
      }
    } else {
      {
      _1_stk_mergefa_next = 76U;
      }
    }
    break;
    case 29: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergefa");
    {
    _1_stk_mergefa_next = 168U;
    }
    break;
    case 126: 
    min_l = (int )(seq[1])->seq.l;
    {
    _1_stk_mergefa_next = 173U;
    }
    break;
    case 43: ;
    if (c___0[0] == 0) {
      {
      _1_stk_mergefa_next = 4U;
      }
    } else {
      {
      _1_stk_mergefa_next = 100U;
      }
    }
    break;
    case 2: 
    is_upper = 0;
    {
    _1_stk_mergefa_next = 177U;
    }
    break;
    case 20: 
    c___0[0] &= c___0[1];
    {
    _1_stk_mergefa_next = 100U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_mergefa LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kseq_init LOC=UNKNOWN */
static kseq_t *kseq_init(gzFile fd ) 
{ 
  kseq_t *s ;
  void *tmp ;
  unsigned int _1_kseq_init_next ;

  {
  {
  _1_kseq_init_next = 0U;
  }
  while (1) {
    switch (_1_kseq_init_next) {
    case 1: ;
    return (s);
    break;
    case 0: 
    tmp = calloc((size_t___0 )1, sizeof(kseq_t ));
    s = (kseq_t *)tmp;
    s->f = ks_init(fd);
    {
    _1_kseq_init_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kseq_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF __ac_X31_hash_string LOC=UNKNOWN */
__inline static khint_t __ac_X31_hash_string(char const   *s ) 
{ 
  khint_t h ;
  unsigned int _1___ac_X31_hash_string_next ;

  {
  {
  _1___ac_X31_hash_string_next = 3U;
  }
  while (1) {
    switch (_1___ac_X31_hash_string_next) {
    case 4: ;
    return (h);
    break;
    case 1: ;
    if (*s) {
      {
      _1___ac_X31_hash_string_next = 6U;
      }
    } else {
      {
      _1___ac_X31_hash_string_next = 4U;
      }
    }
    break;
    case 3: 
    h = (khint_t )*s;
    {
    _1___ac_X31_hash_string_next = 5U;
    }
    break;
    case 6: 
    h = ((h << 5) - h) + (khint_t )*s;
    s ++;
    {
    _1___ac_X31_hash_string_next = 1U;
    }
    break;
    case 5: ;
    if (h) {
      {
      _1___ac_X31_hash_string_next = 7U;
      }
    } else {
      {
      _1___ac_X31_hash_string_next = 4U;
      }
    }
    break;
    case 7: 
    s ++;
    {
    _1___ac_X31_hash_string_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF __ac_X31_hash_string LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_getuntil LOC=UNKNOWN */
__inline static int ks_getuntil(kstream_t *ks , int delimiter , kstring_t *str , int *dret ) 
{ 
  int tmp ;
  unsigned int _1_ks_getuntil_next ;

  {
  {
  _1_ks_getuntil_next = 1U;
  }
  while (1) {
    switch (_1_ks_getuntil_next) {
    case 1: 
    tmp = ks_getuntil2(ks, delimiter, str, dret, 0);
    {
    _1_ks_getuntil_next = 0U;
    }
    break;
    case 0: ;
    return (tmp);
    break;
    }
  }
}
}
/* END FUNCTION-DEF ks_getuntil LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_reg_read LOC=UNKNOWN */
reghash_t *stk_reg_read(char const   *fn ) 
{ 
  reghash_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kstream_t *ks ;
  int dret ;
  kstring_t *str ;
  gzFile tmp___1 ;
  int tmp___2 ;
  gzFile tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int beg ;
  int end ;
  reglist_t *p ;
  khint_t k ;
  khint_t tmp___6 ;
  int ret ;
  char *s ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int _1_stk_reg_read_next ;

  {
  {
  _1_stk_reg_read_next = 47U;
  }
  while (1) {
    switch (_1_stk_reg_read_next) {
    case 18: ;
    if (dret != 10) {
      {
      _1_stk_reg_read_next = 7U;
      }
    } else {
      {
      _1_stk_reg_read_next = 1U;
      }
    }
    break;
    case 25: ;
    if (! (dret != 10)) {
      {
      _1_stk_reg_read_next = 9U;
      }
    } else {
      {
      _1_stk_reg_read_next = 5U;
      }
    }
    break;
    case 4: ;
    if (tmp___4) {
      {
      _1_stk_reg_read_next = 16U;
      }
    } else {
      {
      _1_stk_reg_read_next = 14U;
      }
    }
    break;
    case 14: 
    tmp___2 = fileno(stdin);
    tmp___3 = gzdopen(tmp___2, "r");
    fp = tmp___3;
    {
    _1_stk_reg_read_next = 38U;
    }
    break;
    case 31: 
    tmp___12 = realloc((void *)p->a, (size_t___0 )(p->m * 8));
    p->a = (uint64_t *)tmp___12;
    {
    _1_stk_reg_read_next = 28U;
    }
    break;
    case 12: 
    tmp___7 = strdup((char const   *)str->s);
    s = tmp___7;
    k = kh_put_reg(h, (kh_cstr_t )s, & ret);
    memset((void *)(h->vals + k), 0, sizeof(reglist_t ));
    {
    _1_stk_reg_read_next = 17U;
    }
    break;
    case 8: 
    end = beg;
    beg --;
    {
    _1_stk_reg_read_next = 20U;
    }
    break;
    case 45: 
    tmp___8 = ks_getuntil(ks, 0, str, & dret);
    {
    _1_stk_reg_read_next = 34U;
    }
    break;
    case 1: ;
    if (dret != 10) {
      {
      _1_stk_reg_read_next = 5U;
      }
    } else {
      {
      _1_stk_reg_read_next = 9U;
      }
    }
    break;
    case 23: 
    tmp___9 = isdigit((int )*(str->s + 0));
    {
    _1_stk_reg_read_next = 33U;
    }
    break;
    case 3: 
    p->m = 4;
    {
    _1_stk_reg_read_next = 31U;
    }
    break;
    case 16: 
    tmp___1 = gzopen(fn, "r");
    fp = tmp___1;
    {
    _1_stk_reg_read_next = 38U;
    }
    break;
    case 24: 
    beg = -1;
    end = -1;
    tmp___6 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )str->s);
    k = tmp___6;
    {
    _1_stk_reg_read_next = 35U;
    }
    break;
    case 21: ;
    if (p->n == p->m) {
      {
      _1_stk_reg_read_next = 26U;
      }
    } else {
      {
      _1_stk_reg_read_next = 28U;
      }
    }
    break;
    case 26: ;
    if (p->m) {
      {
      _1_stk_reg_read_next = 40U;
      }
    } else {
      {
      _1_stk_reg_read_next = 3U;
      }
    }
    break;
    case 11: 
    beg = 0;
    end = 2147483647;
    {
    _1_stk_reg_read_next = 21U;
    }
    break;
    case 9: ;
    if (end < 0) {
      {
      _1_stk_reg_read_next = 2U;
      }
    } else {
      {
      _1_stk_reg_read_next = 20U;
      }
    }
    break;
    case 13: ;
    return (h);
    break;
    case 19: 
    ks = ks_init(fp);
    tmp___5 = calloc((size_t___0 )1, sizeof(kstring_t ));
    str = (kstring_t *)tmp___5;
    {
    _1_stk_reg_read_next = 42U;
    }
    break;
    case 32: ;
    if (! (tmp___14 >= 0)) {
      {
      _1_stk_reg_read_next = 27U;
      }
    } else {
      {
      _1_stk_reg_read_next = 24U;
      }
    }
    break;
    case 17: 
    p = h->vals + k;
    {
    _1_stk_reg_read_next = 18U;
    }
    break;
    case 40: 
    p->m <<= 1;
    {
    _1_stk_reg_read_next = 31U;
    }
    break;
    case 6: ;
    return ((reghash_t *)0);
    break;
    case 27: 
    ks_destroy(ks);
    gzclose(fp);
    free((void *)str->s);
    free((void *)str);
    {
    _1_stk_reg_read_next = 13U;
    }
    break;
    case 38: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_reg_read_next = 6U;
      }
    } else {
      {
      _1_stk_reg_read_next = 19U;
      }
    }
    break;
    case 34: ;
    if (tmp___8 > 0) {
      {
      _1_stk_reg_read_next = 23U;
      }
    } else {
      {
      _1_stk_reg_read_next = 1U;
      }
    }
    break;
    case 48: 
    end = -1;
    {
    _1_stk_reg_read_next = 1U;
    }
    break;
    case 28: 
    tmp___13 = p->n;
    (p->n) ++;
    *(p->a + tmp___13) = ((uint64_t )beg << 32) | (unsigned long long )end;
    {
    _1_stk_reg_read_next = 42U;
    }
    break;
    case 47: 
    tmp = kh_init_reg();
    h = tmp;
    tmp___4 = strcmp(fn, "-");
    {
    _1_stk_reg_read_next = 4U;
    }
    break;
    case 44: ;
    if (tmp___11) {
      {
      _1_stk_reg_read_next = 41U;
      }
    } else {
      {
      _1_stk_reg_read_next = 1U;
      }
    }
    break;
    case 5: 
    dret = ks_getc(ks);
    {
    _1_stk_reg_read_next = 0U;
    }
    break;
    case 33: ;
    if (tmp___9) {
      {
      _1_stk_reg_read_next = 39U;
      }
    } else {
      {
      _1_stk_reg_read_next = 1U;
      }
    }
    break;
    case 37: ;
    if (tmp___10 > 0) {
      {
      _1_stk_reg_read_next = 10U;
      }
    } else {
      {
      _1_stk_reg_read_next = 1U;
      }
    }
    break;
    case 41: 
    beg = atoi((char const   *)str->s);
    {
    _1_stk_reg_read_next = 43U;
    }
    break;
    case 10: 
    tmp___11 = isdigit((int )*(str->s + 0));
    {
    _1_stk_reg_read_next = 44U;
    }
    break;
    case 42: 
    tmp___14 = ks_getuntil(ks, 0, str, & dret);
    {
    _1_stk_reg_read_next = 32U;
    }
    break;
    case 0: ;
    if (dret > 0) {
      {
      _1_stk_reg_read_next = 25U;
      }
    } else {
      {
      _1_stk_reg_read_next = 9U;
      }
    }
    break;
    case 39: 
    end = atoi((char const   *)str->s);
    {
    _1_stk_reg_read_next = 29U;
    }
    break;
    case 7: 
    tmp___10 = ks_getuntil(ks, 0, str, & dret);
    {
    _1_stk_reg_read_next = 37U;
    }
    break;
    case 35: ;
    if (k == h->n_buckets) {
      {
      _1_stk_reg_read_next = 12U;
      }
    } else {
      {
      _1_stk_reg_read_next = 17U;
      }
    }
    break;
    case 29: ;
    if (end < 0) {
      {
      _1_stk_reg_read_next = 48U;
      }
    } else {
      {
      _1_stk_reg_read_next = 1U;
      }
    }
    break;
    case 43: ;
    if (dret != 10) {
      {
      _1_stk_reg_read_next = 45U;
      }
    } else {
      {
      _1_stk_reg_read_next = 1U;
      }
    }
    break;
    case 2: ;
    if (beg > 0) {
      {
      _1_stk_reg_read_next = 8U;
      }
    } else {
      {
      _1_stk_reg_read_next = 20U;
      }
    }
    break;
    case 20: ;
    if (beg < 0) {
      {
      _1_stk_reg_read_next = 11U;
      }
    } else {
      {
      _1_stk_reg_read_next = 21U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_reg_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_trimfq LOC=UNKNOWN */
int stk_trimfq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  double param ;
  double q_int2real[128] ;
  int i ;
  int c ;
  int min_len ;
  int left ;
  int right ;
  int fixed_len ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int beg ;
  int tmp___4 ;
  int end ;
  double s ;
  double max ;
  int q ;
  int is ;
  int imax ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int _1_stk_trimfq_next ;

  {
  {
  _1_stk_trimfq_next = 59U;
  }
  while (1) {
    switch (_1_stk_trimfq_next) {
    case 18: ;
    if (q > 127) {
      {
      _1_stk_trimfq_next = 41U;
      }
    } else {
      {
      _1_stk_trimfq_next = 4U;
      }
    }
    break;
    case 25: ;
    if (seq->is_fastq) {
      {
      _1_stk_trimfq_next = 85U;
      }
    } else {
      {
      _1_stk_trimfq_next = 47U;
      }
    }
    break;
    case 49: 
    max = s;
    beg = tmp___4;
    end = i + 1;
    {
    _1_stk_trimfq_next = 53U;
    }
    break;
    case 52: ;
    if (beg >= end) {
      {
      _1_stk_trimfq_next = 62U;
      }
    } else {
      {
      _1_stk_trimfq_next = 63U;
      }
    }
    break;
    case 4: 
    s += param - q_int2real[q];
    {
    _1_stk_trimfq_next = 78U;
    }
    break;
    case 30: ;
    if (i < min_len) {
      {
      _1_stk_trimfq_next = 1U;
      }
    } else {
      {
      _1_stk_trimfq_next = 39U;
      }
    }
    break;
    case 62: 
    end = 0;
    beg = end;
    {
    _1_stk_trimfq_next = 63U;
    }
    break;
    case 14: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk trimfq [options] <in.fq>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q FLOAT    error rate threshold (disabled by -b/-e) [%.2f]\n",
            param);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT      maximally trim down to INT bp (disabled by -b/-e) [%d]\n",
            min_len);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -b INT      trim INT bp from left (non-zero to disable -q/-l) [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -e INT      trim INT bp from right (non-zero to disable -q/-l) [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -L INT      retain at most INT bp from the 5\'-end (non-zero to disable -q/-l) [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -Q          force FASTQ output\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    {
    _1_stk_trimfq_next = 37U;
    }
    break;
    case 15: ;
    if ((size_t___0 )i < seq->qual.l) {
      {
      _1_stk_trimfq_next = 46U;
      }
    } else {
      {
      _1_stk_trimfq_next = 33U;
      }
    }
    break;
    case 89: 
    i = 0;
    is = 0;
    {
    _1_stk_trimfq_next = 30U;
    }
    break;
    case 56: ;
    return (0);
    break;
    case 79: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_trimfq");
    {
    _1_stk_trimfq_next = 34U;
    }
    break;
    case 31: 
    tmp___3 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_trimfq_next = 73U;
    }
    break;
    case 12: 
    right = atoi((char const   *)optarg);
    {
    _1_stk_trimfq_next = 43U;
    }
    break;
    case 69: 
    fwrite((void const   */* __restrict  */)(seq->seq.s + beg), (size_t___0 )1, (size_t___0 )(end - beg),
           (FILE */* __restrict  */)stdout);
    putchar('\n');
    {
    _1_stk_trimfq_next = 76U;
    }
    break;
    case 78: ;
    if (s > max) {
      {
      _1_stk_trimfq_next = 49U;
      }
    } else {
      {
      _1_stk_trimfq_next = 53U;
      }
    }
    break;
    case 1: 
    is += (int )*(seq->qual.s + i) - 33;
    i ++;
    {
    _1_stk_trimfq_next = 30U;
    }
    break;
    case 23: 
    q = 36;
    {
    _1_stk_trimfq_next = 18U;
    }
    break;
    case 77: ;
    if (seq->qual.l > (size_t___0 )min_len) {
      {
      _1_stk_trimfq_next = 87U;
      }
    } else {
      {
      _1_stk_trimfq_next = 90U;
      }
    }
    break;
    case 3: ;
    if (end - beg > fixed_len) {
      {
      _1_stk_trimfq_next = 21U;
      }
    } else {
      {
      _1_stk_trimfq_next = 25U;
      }
    }
    break;
    case 16: 
    q_int2real[i] = pow(10., (double )(- (i - 33)) / 10.);
    i ++;
    {
    _1_stk_trimfq_next = 83U;
    }
    break;
    case 24: ;
    if (seq->comment.l) {
      {
      _1_stk_trimfq_next = 28U;
      }
    } else {
      {
      _1_stk_trimfq_next = 91U;
      }
    }
    break;
    case 21: 
    end = beg + fixed_len;
    {
    _1_stk_trimfq_next = 25U;
    }
    break;
    case 36: 
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_trimfq_next = 56U;
    }
    break;
    case 76: ;
    if (seq->is_fastq) {
      {
      _1_stk_trimfq_next = 6U;
      }
    } else {
      {
      _1_stk_trimfq_next = 48U;
      }
    }
    break;
    case 57: 
    beg = 0;
    end = min_len;
    {
    _1_stk_trimfq_next = 0U;
    }
    break;
    case 68: ;
    if (imax < is) {
      {
      _1_stk_trimfq_next = 13U;
      }
    } else {
      {
      _1_stk_trimfq_next = 32U;
      }
    }
    break;
    case 85: 
    tmp___5 = '@';
    {
    _1_stk_trimfq_next = 66U;
    }
    break;
    case 26: ;
    switch (c) {
    case 113: 
    {
    _1_stk_trimfq_next = 42U;
    }
    break;
    case 108: 
    {
    _1_stk_trimfq_next = 11U;
    }
    break;
    case 98: 
    {
    _1_stk_trimfq_next = 51U;
    }
    break;
    case 101: 
    {
    _1_stk_trimfq_next = 12U;
    }
    break;
    case 76: 
    {
    _1_stk_trimfq_next = 75U;
    }
    break;
    default: 
    {
    _1_stk_trimfq_next = 43U;
    }
    break;
    }
    break;
    case 11: 
    min_len = atoi((char const   *)optarg);
    {
    _1_stk_trimfq_next = 43U;
    }
    break;
    case 9: 
    i ++;
    {
    _1_stk_trimfq_next = 38U;
    }
    break;
    case 13: 
    imax = is;
    beg = (i - min_len) + 1;
    {
    _1_stk_trimfq_next = 32U;
    }
    break;
    case 63: ;
    if (fixed_len > 0) {
      {
      _1_stk_trimfq_next = 3U;
      }
    } else {
      {
      _1_stk_trimfq_next = 25U;
      }
    }
    break;
    case 51: 
    left = atoi((char const   *)optarg);
    {
    _1_stk_trimfq_next = 43U;
    }
    break;
    case 19: 
    s = (double )0;
    tmp___4 = i + 1;
    {
    _1_stk_trimfq_next = 9U;
    }
    break;
    case 32: 
    i ++;
    {
    _1_stk_trimfq_next = 15U;
    }
    break;
    case 90: 
    beg = 0;
    end = (int )seq->seq.l;
    {
    _1_stk_trimfq_next = 25U;
    }
    break;
    case 67: ;
    if (right) {
      {
      _1_stk_trimfq_next = 74U;
      }
    } else {
      {
      _1_stk_trimfq_next = 61U;
      }
    }
    break;
    case 55: 
    tmp___0 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___0;
    {
    _1_stk_trimfq_next = 2U;
    }
    break;
    case 60: ;
    if (optind == argc) {
      {
      _1_stk_trimfq_next = 14U;
      }
    } else {
      {
      _1_stk_trimfq_next = 31U;
      }
    }
    break;
    case 59: 
    param = 0.05;
    min_len = 30;
    left = 0;
    right = 0;
    fixed_len = -1;
    {
    _1_stk_trimfq_next = 43U;
    }
    break;
    case 6: 
    puts("+");
    fwrite((void const   */* __restrict  */)(seq->qual.s + beg), (size_t___0 )1, (size_t___0 )(end - beg),
           (FILE */* __restrict  */)stdout);
    putchar('\n');
    {
    _1_stk_trimfq_next = 48U;
    }
    break;
    case 38: ;
    if ((size_t___0 )i < seq->qual.l) {
      {
      _1_stk_trimfq_next = 84U;
      }
    } else {
      {
      _1_stk_trimfq_next = 7U;
      }
    }
    break;
    case 61: ;
    if (fixed_len > 0) {
      {
      _1_stk_trimfq_next = 74U;
      }
    } else {
      {
      _1_stk_trimfq_next = 77U;
      }
    }
    break;
    case 87: 
    i = 0;
    tmp___4 = 0;
    beg = tmp___4;
    end = (int )seq->qual.l;
    max = 0.;
    s = max;
    {
    _1_stk_trimfq_next = 38U;
    }
    break;
    case 58: ;
    if (left) {
      {
      _1_stk_trimfq_next = 74U;
      }
    } else {
      {
      _1_stk_trimfq_next = 67U;
      }
    }
    break;
    case 84: 
    q = (int )*(seq->qual.s + i);
    {
    _1_stk_trimfq_next = 35U;
    }
    break;
    case 34: ;
    return (1);
    break;
    case 74: 
    _L: 
    beg = left;
    end = (int )(seq->seq.l - (size_t___0 )right);
    {
    _1_stk_trimfq_next = 52U;
    }
    break;
    case 75: 
    fixed_len = atoi((char const   *)optarg);
    {
    _1_stk_trimfq_next = 43U;
    }
    break;
    case 48: 
    tmp___6 = kseq_read(seq);
    {
    _1_stk_trimfq_next = 10U;
    }
    break;
    case 28: 
    putchar(' ');
    puts((char const   *)seq->comment.s);
    {
    _1_stk_trimfq_next = 69U;
    }
    break;
    case 53: ;
    if (s < (double )0) {
      {
      _1_stk_trimfq_next = 19U;
      }
    } else {
      {
      _1_stk_trimfq_next = 9U;
      }
    }
    break;
    case 47: 
    tmp___5 = '>';
    {
    _1_stk_trimfq_next = 66U;
    }
    break;
    case 73: ;
    if (tmp___3) {
      {
      _1_stk_trimfq_next = 55U;
      }
    } else {
      {
      _1_stk_trimfq_next = 64U;
      }
    }
    break;
    case 91: 
    putchar('\n');
    {
    _1_stk_trimfq_next = 69U;
    }
    break;
    case 33: 
    end = beg + min_len;
    {
    _1_stk_trimfq_next = 25U;
    }
    break;
    case 37: ;
    return (1);
    break;
    case 64: 
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp = tmp___2;
    {
    _1_stk_trimfq_next = 2U;
    }
    break;
    case 41: 
    q = 127;
    {
    _1_stk_trimfq_next = 4U;
    }
    break;
    case 10: ;
    if (! (tmp___6 >= 0)) {
      {
      _1_stk_trimfq_next = 36U;
      }
    } else {
      {
      _1_stk_trimfq_next = 58U;
      }
    }
    break;
    case 42: 
    param = atof((char const   *)optarg);
    {
    _1_stk_trimfq_next = 43U;
    }
    break;
    case 0: ;
    if (end - beg < min_len) {
      {
      _1_stk_trimfq_next = 89U;
      }
    } else {
      {
      _1_stk_trimfq_next = 25U;
      }
    }
    break;
    case 46: 
    is += (int )*(seq->qual.s + i) - (int )*(seq->qual.s + (i - min_len));
    {
    _1_stk_trimfq_next = 68U;
    }
    break;
    case 39: 
    imax = is;
    beg = 0;
    {
    _1_stk_trimfq_next = 15U;
    }
    break;
    case 66: 
    putchar(tmp___5);
    fputs((char const   */* __restrict  */)seq->name.s, (FILE */* __restrict  */)stdout);
    {
    _1_stk_trimfq_next = 24U;
    }
    break;
    case 83: ;
    if (i < 128) {
      {
      _1_stk_trimfq_next = 16U;
      }
    } else {
      {
      _1_stk_trimfq_next = 48U;
      }
    }
    break;
    case 7: ;
    if (max == 0.) {
      {
      _1_stk_trimfq_next = 57U;
      }
    } else {
      {
      _1_stk_trimfq_next = 0U;
      }
    }
    break;
    case 88: ;
    if (! (c >= 0)) {
      {
      _1_stk_trimfq_next = 60U;
      }
    } else {
      {
      _1_stk_trimfq_next = 26U;
      }
    }
    break;
    case 35: ;
    if (q < 36) {
      {
      _1_stk_trimfq_next = 23U;
      }
    } else {
      {
      _1_stk_trimfq_next = 18U;
      }
    }
    break;
    case 29: 
    seq = kseq_init(fp);
    i = 0;
    {
    _1_stk_trimfq_next = 83U;
    }
    break;
    case 43: 
    c = getopt(argc, argv, "l:q:b:e:L:");
    {
    _1_stk_trimfq_next = 88U;
    }
    break;
    case 2: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_trimfq_next = 79U;
      }
    } else {
      {
      _1_stk_trimfq_next = 29U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_trimfq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fqc_aux LOC=UNKNOWN */
static void fqc_aux(posstat_t *p , int pos , int64_t *allq , double *perr , int qthres ) 
{ 
  int k ;
  int64_t sum ;
  int64_t qsum ;
  int64_t sum_low ;
  double psum ;
  double tmp ;
  unsigned int _1_fqc_aux_next ;

  {
  {
  _1_fqc_aux_next = 7U;
  }
  while (1) {
    switch (_1_fqc_aux_next) {
    case 18: 
    tmp = log((psum + 1e-6) / ((double )sum + 1e-6));
    printf((char const   */* __restrict  */)"\t%.1f\t%.1f", (double )qsum / (double )sum,
           - 4.343 * tmp);
    {
    _1_fqc_aux_next = 10U;
    }
    break;
    case 4: ;
    if (k < qthres) {
      {
      _1_fqc_aux_next = 3U;
      }
    } else {
      {
      _1_fqc_aux_next = 8U;
      }
    }
    break;
    case 30: 
    k ++;
    {
    _1_fqc_aux_next = 24U;
    }
    break;
    case 14: 
    printf((char const   */* __restrict  */)"\t%.1f\t%.1f", (100. * (double )sum_low) / (double )sum,
           (100. * (double )(sum - sum_low)) / (double )sum);
    {
    _1_fqc_aux_next = 15U;
    }
    break;
    case 15: 
    putchar('\n');
    {
    _1_fqc_aux_next = 27U;
    }
    break;
    case 12: 
    printf((char const   */* __restrict  */)"%d", pos);
    {
    _1_fqc_aux_next = 21U;
    }
    break;
    case 8: 
    k ++;
    {
    _1_fqc_aux_next = 9U;
    }
    break;
    case 1: ;
    if (k <= 4) {
      {
      _1_fqc_aux_next = 20U;
      }
    } else {
      {
      _1_fqc_aux_next = 0U;
      }
    }
    break;
    case 23: 
    k = 0;
    {
    _1_fqc_aux_next = 24U;
    }
    break;
    case 3: 
    sum_low += p->q[k];
    {
    _1_fqc_aux_next = 8U;
    }
    break;
    case 16: 
    sum += p->b[k];
    k ++;
    {
    _1_fqc_aux_next = 5U;
    }
    break;
    case 24: ;
    if (k <= 93) {
      {
      _1_fqc_aux_next = 17U;
      }
    } else {
      {
      _1_fqc_aux_next = 15U;
      }
    }
    break;
    case 21: 
    k = 0;
    {
    _1_fqc_aux_next = 5U;
    }
    break;
    case 9: ;
    if (k <= 93) {
      {
      _1_fqc_aux_next = 6U;
      }
    } else {
      {
      _1_fqc_aux_next = 18U;
      }
    }
    break;
    case 13: 
    printf((char const   */* __restrict  */)"\t%.2f", (100. * (double )p->q[k]) / (double )sum);
    {
    _1_fqc_aux_next = 30U;
    }
    break;
    case 19: ;
    if (pos <= 0) {
      {
      _1_fqc_aux_next = 32U;
      }
    } else {
      {
      _1_fqc_aux_next = 12U;
      }
    }
    break;
    case 32: 
    printf((char const   */* __restrict  */)"ALL");
    {
    _1_fqc_aux_next = 21U;
    }
    break;
    case 17: ;
    if (*(allq + k) > 0LL) {
      {
      _1_fqc_aux_next = 13U;
      }
    } else {
      {
      _1_fqc_aux_next = 30U;
      }
    }
    break;
    case 6: 
    qsum += p->q[k] * (int64_t )k;
    psum += (double )p->q[k] * *(perr + k);
    {
    _1_fqc_aux_next = 4U;
    }
    break;
    case 27: ;
    return;
    break;
    case 22: 
    printf((char const   */* __restrict  */)"\t%lld", sum);
    k = 0;
    {
    _1_fqc_aux_next = 1U;
    }
    break;
    case 5: ;
    if (k <= 4) {
      {
      _1_fqc_aux_next = 16U;
      }
    } else {
      {
      _1_fqc_aux_next = 22U;
      }
    }
    break;
    case 10: ;
    if (qthres <= 0) {
      {
      _1_fqc_aux_next = 23U;
      }
    } else {
      {
      _1_fqc_aux_next = 14U;
      }
    }
    break;
    case 0: 
    k = 0;
    {
    _1_fqc_aux_next = 9U;
    }
    break;
    case 7: 
    sum = (int64_t )0;
    qsum = (int64_t )0;
    sum_low = (int64_t )0;
    psum = (double )0;
    {
    _1_fqc_aux_next = 19U;
    }
    break;
    case 20: 
    printf((char const   */* __restrict  */)"\t%.1f", (100. * (double )p->b[k]) / (double )sum);
    k ++;
    {
    _1_fqc_aux_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF fqc_aux LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_rename LOC=UNKNOWN */
int stk_rename(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  kseq_t last ;
  char *prefix ;
  uint64_t n ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  kstring_t *p ;
  kstring_t *q ;
  int is_diff ;
  int l ;
  size_t___0 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int _1_stk_rename_next ;

  {
  {
  _1_stk_rename_next = 47U;
  }
  while (1) {
    switch (_1_stk_rename_next) {
    case 18: ;
    if (argc > 2) {
      {
      _1_stk_rename_next = 40U;
      }
    } else {
      {
      _1_stk_rename_next = 29U;
      }
    }
    break;
    case 25: 
    seq = kseq_init(fp);
    {
    _1_stk_rename_next = 18U;
    }
    break;
    case 4: 
    tmp___8 = p->l;
    {
    _1_stk_rename_next = 9U;
    }
    break;
    case 30: ;
    if (tmp___10) {
      {
      _1_stk_rename_next = 3U;
      }
    } else {
      {
      _1_stk_rename_next = 38U;
      }
    }
    break;
    case 14: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_rename_next = 48U;
    }
    break;
    case 15: ;
    if (! is_diff) {
      {
      _1_stk_rename_next = 20U;
      }
    } else {
      {
      _1_stk_rename_next = 35U;
      }
    }
    break;
    case 31: ;
    if ((int )*(q->s + (q->l - 2UL)) == 47) {
      {
      _1_stk_rename_next = 1U;
      }
    } else {
      {
      _1_stk_rename_next = 43U;
      }
    }
    break;
    case 12: 
    cpy_kseq(& last, (kseq_t const   *)seq);
    {
    _1_stk_rename_next = 33U;
    }
    break;
    case 8: 
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___2;
    {
    _1_stk_rename_next = 48U;
    }
    break;
    case 45: ;
    return (1);
    break;
    case 1: 
    tmp___9 = isdigit((int )*(p->s + (p->l - 1UL)));
    {
    _1_stk_rename_next = 34U;
    }
    break;
    case 23: ;
    if (tmp___0) {
      {
      _1_stk_rename_next = 13U;
      }
    } else {
      {
      _1_stk_rename_next = 24U;
      }
    }
    break;
    case 3: 
    tmp___8 = p->l - 2UL;
    {
    _1_stk_rename_next = 9U;
    }
    break;
    case 16: ;
    if (tmp___5) {
      {
      _1_stk_rename_next = 8U;
      }
    } else {
      {
      _1_stk_rename_next = 14U;
      }
    }
    break;
    case 24: ;
    if (argc > 1) {
      {
      _1_stk_rename_next = 28U;
      }
    } else {
      {
      _1_stk_rename_next = 39U;
      }
    }
    break;
    case 21: 
    tmp___8 = p->l;
    {
    _1_stk_rename_next = 9U;
    }
    break;
    case 36: 
    tmp___10 = isdigit((int )*(q->s + (q->l - 1UL)));
    {
    _1_stk_rename_next = 30U;
    }
    break;
    case 26: ;
    if (last.name.l) {
      {
      _1_stk_rename_next = 37U;
      }
    } else {
      {
      _1_stk_rename_next = 22U;
      }
    }
    break;
    case 11: ;
    if ((int )*(p->s + (p->l - 2UL)) == 47) {
      {
      _1_stk_rename_next = 31U;
      }
    } else {
      {
      _1_stk_rename_next = 4U;
      }
    }
    break;
    case 9: 
    l = (int )tmp___8;
    is_diff = strncmp((char const   *)p->s, (char const   *)q->s, (size_t___0 )l);
    {
    _1_stk_rename_next = 15U;
    }
    break;
    case 13: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk rename <in.fq> [prefix]\n");
    {
    _1_stk_rename_next = 46U;
    }
    break;
    case 32: 
    tmp = fileno(stdin);
    tmp___0 = isatty(tmp);
    {
    _1_stk_rename_next = 23U;
    }
    break;
    case 17: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_rename");
    {
    _1_stk_rename_next = 45U;
    }
    break;
    case 40: 
    prefix = *(argv + 2);
    {
    _1_stk_rename_next = 29U;
    }
    break;
    case 6: 
    tmp___8 = p->l;
    {
    _1_stk_rename_next = 9U;
    }
    break;
    case 27: ;
    if (last.name.l) {
      {
      _1_stk_rename_next = 42U;
      }
    } else {
      {
      _1_stk_rename_next = 12U;
      }
    }
    break;
    case 38: 
    tmp___8 = p->l;
    {
    _1_stk_rename_next = 9U;
    }
    break;
    case 34: ;
    if (tmp___9) {
      {
      _1_stk_rename_next = 36U;
      }
    } else {
      {
      _1_stk_rename_next = 21U;
      }
    }
    break;
    case 48: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_rename_next = 17U;
      }
    } else {
      {
      _1_stk_rename_next = 25U;
      }
    }
    break;
    case 22: 
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_rename_next = 44U;
    }
    break;
    case 28: 
    tmp___5 = strcmp((char const   *)*(argv + 1), "-");
    {
    _1_stk_rename_next = 16U;
    }
    break;
    case 47: 
    prefix = (char *)0;
    n = (uint64_t )1;
    {
    _1_stk_rename_next = 7U;
    }
    break;
    case 44: ;
    return (0);
    break;
    case 5: ;
    if (! (tmp___11 >= 0)) {
      {
      _1_stk_rename_next = 26U;
      }
    } else {
      {
      _1_stk_rename_next = 27U;
      }
    }
    break;
    case 33: 
    tmp___11 = kseq_read(seq);
    {
    _1_stk_rename_next = 5U;
    }
    break;
    case 37: 
    stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix, (int64_t )n);
    {
    _1_stk_rename_next = 22U;
    }
    break;
    case 41: 
    is_diff = 1;
    {
    _1_stk_rename_next = 15U;
    }
    break;
    case 42: 
    p = & last.name;
    q = & seq->name;
    {
    _1_stk_rename_next = 0U;
    }
    break;
    case 0: ;
    if (p->l == q->l) {
      {
      _1_stk_rename_next = 2U;
      }
    } else {
      {
      _1_stk_rename_next = 41U;
      }
    }
    break;
    case 46: ;
    return (1);
    break;
    case 39: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_rename_next = 48U;
    }
    break;
    case 7: ;
    if (argc == 1) {
      {
      _1_stk_rename_next = 32U;
      }
    } else {
      {
      _1_stk_rename_next = 24U;
      }
    }
    break;
    case 35: 
    stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix, (int64_t )n);
    n ++;
    cpy_kseq(& last, (kseq_t const   *)seq);
    {
    _1_stk_rename_next = 33U;
    }
    break;
    case 29: 
    memset((void *)(& last), 0, sizeof(kseq_t ));
    {
    _1_stk_rename_next = 33U;
    }
    break;
    case 43: 
    tmp___8 = p->l;
    {
    _1_stk_rename_next = 9U;
    }
    break;
    case 2: ;
    if (p->l > 2UL) {
      {
      _1_stk_rename_next = 11U;
      }
    } else {
      {
      _1_stk_rename_next = 6U;
      }
    }
    break;
    case 20: 
    stk_printseq_renamed((kseq_t const   *)(& last), 0, (char const   *)prefix, (int64_t )n);
    stk_printseq_renamed((kseq_t const   *)seq, 0, (char const   *)prefix, (int64_t )n);
    last.name.l = (size_t___0 )0;
    n ++;
    {
    _1_stk_rename_next = 33U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_rename LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_hrun LOC=UNKNOWN */
int stk_hrun(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *ks ;
  int min_len ;
  int l ;
  int c ;
  int beg ;
  int i ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int _1_stk_hrun_next ;

  {
  {
  _1_stk_hrun_next = 20U;
  }
  while (1) {
    switch (_1_stk_hrun_next) {
    case 18: ;
    if ((int )*(ks->seq.s + i) != c) {
      {
      _1_stk_hrun_next = 19U;
      }
    } else {
      {
      _1_stk_hrun_next = 3U;
      }
    }
    break;
    case 25: 
    tmp___4 = kseq_read(ks);
    {
    _1_stk_hrun_next = 31U;
    }
    break;
    case 4: 
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
    {
    _1_stk_hrun_next = 9U;
    }
    break;
    case 30: ;
    if (tmp___3 == 0) {
      {
      _1_stk_hrun_next = 4U;
      }
    } else {
      {
      _1_stk_hrun_next = 24U;
      }
    }
    break;
    case 14: ;
    if (l >= min_len) {
      {
      _1_stk_hrun_next = 12U;
      }
    } else {
      {
      _1_stk_hrun_next = 11U;
      }
    }
    break;
    case 15: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_hrun");
    {
    _1_stk_hrun_next = 21U;
    }
    break;
    case 31: ;
    if (! (tmp___4 >= 0)) {
      {
      _1_stk_hrun_next = 14U;
      }
    } else {
      {
      _1_stk_hrun_next = 6U;
      }
    }
    break;
    case 12: 
    printf((char const   */* __restrict  */)"%s\t%d\t%d\t%c\n", ks->name.s, beg, beg + l,
           c);
    {
    _1_stk_hrun_next = 11U;
    }
    break;
    case 8: 
    i ++;
    {
    _1_stk_hrun_next = 5U;
    }
    break;
    case 1: 
    c = (int )*(ks->seq.s + i);
    l = 1;
    beg = i;
    {
    _1_stk_hrun_next = 8U;
    }
    break;
    case 3: 
    l ++;
    {
    _1_stk_hrun_next = 8U;
    }
    break;
    case 16: 
    ks = kseq_init(fp);
    {
    _1_stk_hrun_next = 25U;
    }
    break;
    case 24: 
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
    {
    _1_stk_hrun_next = 9U;
    }
    break;
    case 21: ;
    return (1);
    break;
    case 26: ;
    if (argc == optind + 2) {
      {
      _1_stk_hrun_next = 7U;
      }
    } else {
      {
      _1_stk_hrun_next = 28U;
      }
    }
    break;
    case 11: 
    kseq_destroy(ks);
    gzclose(fp);
    {
    _1_stk_hrun_next = 10U;
    }
    break;
    case 9: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_hrun_next = 15U;
      }
    } else {
      {
      _1_stk_hrun_next = 16U;
      }
    }
    break;
    case 19: ;
    if (l >= min_len) {
      {
      _1_stk_hrun_next = 17U;
      }
    } else {
      {
      _1_stk_hrun_next = 1U;
      }
    }
    break;
    case 17: 
    printf((char const   */* __restrict  */)"%s\t%d\t%d\t%c\n", ks->name.s, beg, beg + l,
           c);
    {
    _1_stk_hrun_next = 1U;
    }
    break;
    case 6: 
    c = (int )*(ks->seq.s + 0);
    l = 1;
    beg = 0;
    i = 1;
    {
    _1_stk_hrun_next = 5U;
    }
    break;
    case 27: ;
    return (1);
    break;
    case 28: 
    tmp___3 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_hrun_next = 30U;
    }
    break;
    case 5: ;
    if ((size_t___0 )i < ks->seq.l) {
      {
      _1_stk_hrun_next = 18U;
      }
    } else {
      {
      _1_stk_hrun_next = 25U;
      }
    }
    break;
    case 10: ;
    return (0);
    break;
    case 0: ;
    if (argc == optind) {
      {
      _1_stk_hrun_next = 2U;
      }
    } else {
      {
      _1_stk_hrun_next = 26U;
      }
    }
    break;
    case 7: 
    min_len = atoi((char const   *)*(argv + (optind + 1)));
    {
    _1_stk_hrun_next = 28U;
    }
    break;
    case 2: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk hrun <in.fa> [minLen=%d]\n",
            min_len);
    {
    _1_stk_hrun_next = 27U;
    }
    break;
    case 20: 
    min_len = 7;
    l = 0;
    c = 0;
    beg = 0;
    {
    _1_stk_hrun_next = 0U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_hrun LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_get_64 LOC=UNKNOWN */
__inline static khint_t kh_get_64(kh_64_t const   *h , khint64_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t tmp ;
  unsigned int _1_kh_get_64_next ;

  {
  {
  _1_kh_get_64_next = 9U;
  }
  while (1) {
    switch (_1_kh_get_64_next) {
    case 14: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
      {
      _1_kh_get_64_next = 15U;
      }
    } else {
      {
      _1_kh_get_64_next = 2U;
      }
    }
    break;
    case 15: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
      {
      _1_kh_get_64_next = 3U;
      }
    } else {
      {
      _1_kh_get_64_next = 13U;
      }
    }
    break;
    case 12: ;
    return ((khint_t )0);
    break;
    case 8: 
    mask = (khint_t )(h->n_buckets - 1U);
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & mask;
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    {
    _1_kh_get_64_next = 14U;
    }
    break;
    case 3: ;
    if (! (! (*(h->keys + i) == key))) {
      {
      _1_kh_get_64_next = 2U;
      }
    } else {
      {
      _1_kh_get_64_next = 13U;
      }
    }
    break;
    case 16: 
    tmp = (khint_t )h->n_buckets;
    {
    _1_kh_get_64_next = 0U;
    }
    break;
    case 9: ;
    if (h->n_buckets) {
      {
      _1_kh_get_64_next = 8U;
      }
    } else {
      {
      _1_kh_get_64_next = 12U;
      }
    }
    break;
    case 13: 
    i = (i + inc) & mask;
    {
    _1_kh_get_64_next = 7U;
    }
    break;
    case 5: ;
    return ((khint_t )h->n_buckets);
    break;
    case 10: 
    tmp = i;
    {
    _1_kh_get_64_next = 0U;
    }
    break;
    case 0: ;
    return (tmp);
    break;
    case 7: ;
    if (i == last) {
      {
      _1_kh_get_64_next = 5U;
      }
    } else {
      {
      _1_kh_get_64_next = 14U;
      }
    }
    break;
    case 2: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      {
      _1_kh_get_64_next = 16U;
      }
    } else {
      {
      _1_kh_get_64_next = 10U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_get_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_put_64 LOC=UNKNOWN */
__inline static khint_t kh_put_64(kh_64_t *h , khint64_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  unsigned int _1_kh_put_64_next ;

  {
  {
  _1_kh_put_64_next = 23U;
  }
  while (1) {
    switch (_1_kh_put_64_next) {
    case 18: 
    i = (i + inc) & mask;
    {
    _1_kh_put_64_next = 30U;
    }
    break;
    case 25: 
    kh_resize_64(h, h->n_buckets - 1U);
    {
    _1_kh_put_64_next = 27U;
    }
    break;
    case 4: 
    x = i;
    {
    _1_kh_put_64_next = 26U;
    }
    break;
    case 30: ;
    if (i == last) {
      {
      _1_kh_put_64_next = 17U;
      }
    } else {
      {
      _1_kh_put_64_next = 6U;
      }
    }
    break;
    case 14: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
      {
      _1_kh_put_64_next = 11U;
      }
    } else {
      {
      _1_kh_put_64_next = 21U;
      }
    }
    break;
    case 15: 
    x = i;
    {
    _1_kh_put_64_next = 26U;
    }
    break;
    case 12: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
      {
      _1_kh_put_64_next = 0U;
      }
    } else {
      {
      _1_kh_put_64_next = 4U;
      }
    }
    break;
    case 1: 
    kh_resize_64(h, h->n_buckets + 1U);
    {
    _1_kh_put_64_next = 27U;
    }
    break;
    case 23: ;
    if (h->n_occupied >= h->upper_bound) {
      {
      _1_kh_put_64_next = 24U;
      }
    } else {
      {
      _1_kh_put_64_next = 27U;
      }
    }
    break;
    case 3: 
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
    {
    _1_kh_put_64_next = 29U;
    }
    break;
    case 16: ;
    if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
      {
      _1_kh_put_64_next = 22U;
      }
    } else {
      {
      _1_kh_put_64_next = 5U;
      }
    }
    break;
    case 24: ;
    if (h->n_buckets > h->size << 1) {
      {
      _1_kh_put_64_next = 25U;
      }
    } else {
      {
      _1_kh_put_64_next = 1U;
      }
    }
    break;
    case 21: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
      {
      _1_kh_put_64_next = 28U;
      }
    } else {
      {
      _1_kh_put_64_next = 18U;
      }
    }
    break;
    case 26: ;
    if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
      {
      _1_kh_put_64_next = 3U;
      }
    } else {
      {
      _1_kh_put_64_next = 16U;
      }
    }
    break;
    case 11: ;
    if (! (! (*(h->keys + i) == key))) {
      {
      _1_kh_put_64_next = 9U;
      }
    } else {
      {
      _1_kh_put_64_next = 21U;
      }
    }
    break;
    case 9: ;
    if (x == h->n_buckets) {
      {
      _1_kh_put_64_next = 12U;
      }
    } else {
      {
      _1_kh_put_64_next = 26U;
      }
    }
    break;
    case 13: 
    x = i;
    {
    _1_kh_put_64_next = 26U;
    }
    break;
    case 19: 
    x = site;
    {
    _1_kh_put_64_next = 26U;
    }
    break;
    case 17: 
    x = site;
    {
    _1_kh_put_64_next = 9U;
    }
    break;
    case 6: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
      {
      _1_kh_put_64_next = 14U;
      }
    } else {
      {
      _1_kh_put_64_next = 9U;
      }
    }
    break;
    case 27: 
    mask = h->n_buckets - 1U;
    site = h->n_buckets;
    x = site;
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & mask;
    {
    _1_kh_put_64_next = 20U;
    }
    break;
    case 22: 
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
    {
    _1_kh_put_64_next = 29U;
    }
    break;
    case 28: 
    site = i;
    {
    _1_kh_put_64_next = 18U;
    }
    break;
    case 5: 
    *ret = 0;
    {
    _1_kh_put_64_next = 29U;
    }
    break;
    case 0: ;
    if (site != h->n_buckets) {
      {
      _1_kh_put_64_next = 19U;
      }
    } else {
      {
      _1_kh_put_64_next = 15U;
      }
    }
    break;
    case 29: ;
    return (x);
    break;
    case 2: 
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    {
    _1_kh_put_64_next = 6U;
    }
    break;
    case 20: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
      {
      _1_kh_put_64_next = 13U;
      }
    } else {
      {
      _1_kh_put_64_next = 2U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_put_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_destroy LOC=UNKNOWN */
__inline static void ks_destroy(kstream_t *ks ) 
{ 
  unsigned int _1_ks_destroy_next ;

  {
  {
  _1_ks_destroy_next = 0U;
  }
  while (1) {
    switch (_1_ks_destroy_next) {
    case 1: ;
    return;
    break;
    case 0: ;
    if (ks) {
      {
      _1_ks_destroy_next = 2U;
      }
    } else {
      {
      _1_ks_destroy_next = 1U;
      }
    }
    break;
    case 2: 
    free((void *)ks->buf);
    free((void *)ks);
    {
    _1_ks_destroy_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF ks_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_resize_reg LOC=UNKNOWN */
__inline static void kh_resize_reg(kh_reg_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  kh_cstr_t key ;
  reglist_t val ;
  khint_t new_mask ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  kh_cstr_t tmp___4 ;
  reglist_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  unsigned int _1_kh_resize_reg_next ;

  {
  {
  _1_kh_resize_reg_next = 10U;
  }
  while (1) {
    switch (_1_kh_resize_reg_next) {
    case 18: ;
    if (new_n_buckets < 4U) {
      {
      _1_kh_resize_reg_next = 0U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 2U;
      }
    }
    break;
    case 25: 
    tmp___1 = (khint_t )1;
    {
    _1_kh_resize_reg_next = 27U;
    }
    break;
    case 4: 
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    {
    _1_kh_resize_reg_next = 5U;
    }
    break;
    case 30: 
    tmp = new_n_buckets >> 4;
    {
    _1_kh_resize_reg_next = 4U;
    }
    break;
    case 14: ;
    if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
      {
      _1_kh_resize_reg_next = 15U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 21U;
      }
    }
    break;
    case 15: 
    key = *(h->keys + j);
    new_mask = new_n_buckets - 1U;
    val = *(h->vals + j);
    *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
    {
    _1_kh_resize_reg_next = 34U;
    }
    break;
    case 12: ;
    if (i < h->n_buckets) {
      {
      _1_kh_resize_reg_next = 20U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 9U;
      }
    }
    break;
    case 1: 
    tmp___1 = new_n_buckets >> 4;
    {
    _1_kh_resize_reg_next = 27U;
    }
    break;
    case 23: 
    tmp___4 = *(h->keys + i);
    *(h->keys + i) = key;
    key = tmp___4;
    tmp___5 = *(h->vals + i);
    *(h->vals + i) = val;
    val = tmp___5;
    *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
    {
    _1_kh_resize_reg_next = 34U;
    }
    break;
    case 3: ;
    if (new_n_buckets < 16U) {
      {
      _1_kh_resize_reg_next = 36U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 30U;
      }
    }
    break;
    case 16: 
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
    {
    _1_kh_resize_reg_next = 26U;
    }
    break;
    case 24: 
    tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
    h->keys = (kh_cstr_t *)tmp___2;
    tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(reglist_t ));
    h->vals = (reglist_t *)tmp___3;
    {
    _1_kh_resize_reg_next = 13U;
    }
    break;
    case 21: 
    j ++;
    {
    _1_kh_resize_reg_next = 6U;
    }
    break;
    case 36: 
    tmp = (khint_t )1;
    {
    _1_kh_resize_reg_next = 4U;
    }
    break;
    case 26: ;
    return;
    break;
    case 9: 
    *(h->keys + i) = key;
    *(h->vals + i) = val;
    {
    _1_kh_resize_reg_next = 21U;
    }
    break;
    case 13: ;
    if (j) {
      {
      _1_kh_resize_reg_next = 33U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 26U;
      }
    }
    break;
    case 19: 
    tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
    h->keys = (kh_cstr_t *)tmp___6;
    tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(reglist_t ));
    h->vals = (reglist_t *)tmp___7;
    {
    _1_kh_resize_reg_next = 16U;
    }
    break;
    case 32: 
    j = (khint_t )0;
    {
    _1_kh_resize_reg_next = 13U;
    }
    break;
    case 40: 
    *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
    {
    _1_kh_resize_reg_next = 12U;
    }
    break;
    case 6: ;
    if (j != h->n_buckets) {
      {
      _1_kh_resize_reg_next = 14U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 29U;
      }
    }
    break;
    case 27: 
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    {
    _1_kh_resize_reg_next = 38U;
    }
    break;
    case 38: ;
    if (h->n_buckets < new_n_buckets) {
      {
      _1_kh_resize_reg_next = 24U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 13U;
      }
    }
    break;
    case 34: 
    k = __ac_X31_hash_string(key);
    i = k & new_mask;
    inc = (((k >> 3) ^ (k << 3)) | 1U) & new_mask;
    {
    _1_kh_resize_reg_next = 22U;
    }
    break;
    case 22: ;
    if (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
      {
      _1_kh_resize_reg_next = 39U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 40U;
      }
    }
    break;
    case 5: ;
    if (new_n_buckets < 16U) {
      {
      _1_kh_resize_reg_next = 25U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 1U;
      }
    }
    break;
    case 33: 
    j = (khint_t )0;
    {
    _1_kh_resize_reg_next = 6U;
    }
    break;
    case 37: 
    *(h->keys + i) = key;
    *(h->vals + i) = val;
    {
    _1_kh_resize_reg_next = 21U;
    }
    break;
    case 10: 
    new_flags = (khint32_t *)0;
    j = (khint_t )1;
    new_n_buckets --;
    new_n_buckets |= new_n_buckets >> 1;
    new_n_buckets |= new_n_buckets >> 2;
    new_n_buckets |= new_n_buckets >> 4;
    new_n_buckets |= new_n_buckets >> 8;
    new_n_buckets |= new_n_buckets >> 16;
    new_n_buckets ++;
    {
    _1_kh_resize_reg_next = 18U;
    }
    break;
    case 0: 
    new_n_buckets = (khint_t )4;
    {
    _1_kh_resize_reg_next = 2U;
    }
    break;
    case 39: 
    i = (i + inc) & new_mask;
    {
    _1_kh_resize_reg_next = 22U;
    }
    break;
    case 29: ;
    if (h->n_buckets > new_n_buckets) {
      {
      _1_kh_resize_reg_next = 19U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 16U;
      }
    }
    break;
    case 2: ;
    if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
      {
      _1_kh_resize_reg_next = 32U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 3U;
      }
    }
    break;
    case 20: ;
    if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
      {
      _1_kh_resize_reg_next = 23U;
      }
    } else {
      {
      _1_kh_resize_reg_next = 37U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_resize_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kseq_read LOC=UNKNOWN */
static int kseq_read(kseq_t *seq ) 
{ 
  int c ;
  int r ;
  kstream_t *ks ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int _1_kseq_read_next ;

  {
  {
  _1_kseq_read_next = 43U;
  }
  while (1) {
    switch (_1_kseq_read_next) {
    case 18: ;
    if (tmp___5 >= 0) {
      {
      _1_kseq_read_next = 12U;
      }
    } else {
      {
      _1_kseq_read_next = 22U;
      }
    }
    break;
    case 50: ;
    if (seq->last_char == 0) {
      {
      _1_kseq_read_next = 21U;
      }
    } else {
      {
      _1_kseq_read_next = 45U;
      }
    }
    break;
    case 25: ;
    return (-2);
    break;
    case 30: ;
    if (c >= 0) {
      {
      _1_kseq_read_next = 40U;
      }
    } else {
      {
      _1_kseq_read_next = 64U;
      }
    }
    break;
    case 62: ;
    if (c == 64) {
      {
      _1_kseq_read_next = 2U;
      }
    } else {
      {
      _1_kseq_read_next = 66U;
      }
    }
    break;
    case 14: 
    seq->last_char = c;
    {
    _1_kseq_read_next = 66U;
    }
    break;
    case 15: ;
    if (c != 10) {
      {
      _1_kseq_read_next = 61U;
      }
    } else {
      {
      _1_kseq_read_next = 7U;
      }
    }
    break;
    case 56: 
    seq->qual.m = seq->seq.m;
    tmp___4 = realloc((void *)seq->qual.s, seq->qual.m);
    seq->qual.s = (char *)tmp___4;
    {
    _1_kseq_read_next = 11U;
    }
    break;
    case 31: 
    c = tmp___6;
    {
    _1_kseq_read_next = 44U;
    }
    break;
    case 12: ;
    if (seq->qual.l < seq->seq.l) {
      {
      _1_kseq_read_next = 59U;
      }
    } else {
      {
      _1_kseq_read_next = 9U;
      }
    }
    break;
    case 45: 
    tmp___0 = (size_t___0 )0;
    seq->qual.l = tmp___0;
    tmp = tmp___0;
    seq->seq.l = tmp;
    seq->comment.l = tmp;
    r = ks_getuntil(ks, 0, & seq->name, & c);
    {
    _1_kseq_read_next = 41U;
    }
    break;
    case 1: 
    c = ks_getc(ks);
    {
    _1_kseq_read_next = 19U;
    }
    break;
    case 23: ;
    if (! (c != 64)) {
      {
      _1_kseq_read_next = 28U;
      }
    } else {
      {
      _1_kseq_read_next = 17U;
      }
    }
    break;
    case 3: 
    tmp___5 = ks_getuntil2(ks, 2, & seq->qual, (int *)0, 1);
    {
    _1_kseq_read_next = 18U;
    }
    break;
    case 16: ;
    if (c != 62) {
      {
      _1_kseq_read_next = 37U;
      }
    } else {
      {
      _1_kseq_read_next = 55U;
      }
    }
    break;
    case 21: 
    c = ks_getc(ks);
    {
    _1_kseq_read_next = 36U;
    }
    break;
    case 36: ;
    if (c >= 0) {
      {
      _1_kseq_read_next = 16U;
      }
    } else {
      {
      _1_kseq_read_next = 55U;
      }
    }
    break;
    case 57: ;
    if (c == -3) {
      {
      _1_kseq_read_next = 65U;
      }
    } else {
      {
      _1_kseq_read_next = 42U;
      }
    }
    break;
    case 26: 
    seq->last_char = c;
    {
    _1_kseq_read_next = 45U;
    }
    break;
    case 11: 
    c = ks_getc(ks);
    {
    _1_kseq_read_next = 30U;
    }
    break;
    case 9: 
    tmp___6 = 0;
    {
    _1_kseq_read_next = 31U;
    }
    break;
    case 13: 
    tmp___2 = seq->seq.l;
    (seq->seq.l) ++;
    *(seq->seq.s + tmp___2) = (char )c;
    ks_getuntil2(ks, 2, & seq->seq, (int *)0, 1);
    {
    _1_kseq_read_next = 1U;
    }
    break;
    case 63: 
    seq->seq.m = seq->seq.l + 2UL;
    (seq->seq.m) --;
    seq->seq.m |= seq->seq.m >> 1;
    seq->seq.m |= seq->seq.m >> 2;
    seq->seq.m |= seq->seq.m >> 4;
    seq->seq.m |= seq->seq.m >> 8;
    seq->seq.m |= seq->seq.m >> 16;
    (seq->seq.m) ++;
    tmp___3 = realloc((void *)seq->seq.s, seq->seq.m);
    seq->seq.s = (char *)tmp___3;
    {
    _1_kseq_read_next = 29U;
    }
    break;
    case 51: ;
    if (seq->seq.l != seq->qual.l) {
      {
      _1_kseq_read_next = 25U;
      }
    } else {
      {
      _1_kseq_read_next = 53U;
      }
    }
    break;
    case 19: ;
    if (c >= 0) {
      {
      _1_kseq_read_next = 39U;
      }
    } else {
      {
      _1_kseq_read_next = 28U;
      }
    }
    break;
    case 17: ;
    if (c == 10) {
      {
      _1_kseq_read_next = 1U;
      }
    } else {
      {
      _1_kseq_read_next = 13U;
      }
    }
    break;
    case 40: ;
    if (! (c != 10)) {
      {
      _1_kseq_read_next = 64U;
      }
    } else {
      {
      _1_kseq_read_next = 11U;
      }
    }
    break;
    case 67: ;
    return (-2);
    break;
    case 55: ;
    if (c < 0) {
      {
      _1_kseq_read_next = 60U;
      }
    } else {
      {
      _1_kseq_read_next = 26U;
      }
    }
    break;
    case 60: ;
    return (c);
    break;
    case 59: 
    tmp___6 = 1;
    {
    _1_kseq_read_next = 31U;
    }
    break;
    case 38: 
    seq->seq.m = (size_t___0 )256;
    tmp___1 = malloc(seq->seq.m);
    seq->seq.s = (char *)tmp___1;
    {
    _1_kseq_read_next = 1U;
    }
    break;
    case 61: 
    ks_getuntil(ks, 2, & seq->comment, (int *)0);
    {
    _1_kseq_read_next = 7U;
    }
    break;
    case 22: 
    tmp___6 = 0;
    {
    _1_kseq_read_next = 31U;
    }
    break;
    case 28: ;
    if (c == 62) {
      {
      _1_kseq_read_next = 14U;
      }
    } else {
      {
      _1_kseq_read_next = 62U;
      }
    }
    break;
    case 53: ;
    return ((int )seq->seq.l);
    break;
    case 65: ;
    return (-3);
    break;
    case 47: ;
    if (! seq->is_fastq) {
      {
      _1_kseq_read_next = 5U;
      }
    } else {
      {
      _1_kseq_read_next = 20U;
      }
    }
    break;
    case 44: ;
    if (! c) {
      {
      _1_kseq_read_next = 57U;
      }
    } else {
      {
      _1_kseq_read_next = 3U;
      }
    }
    break;
    case 5: ;
    return ((int )seq->seq.l);
    break;
    case 37: ;
    if (! (c != 64)) {
      {
      _1_kseq_read_next = 55U;
      }
    } else {
      {
      _1_kseq_read_next = 21U;
      }
    }
    break;
    case 64: ;
    if (c == -1) {
      {
      _1_kseq_read_next = 67U;
      }
    } else {
      {
      _1_kseq_read_next = 3U;
      }
    }
    break;
    case 41: ;
    if (r < 0) {
      {
      _1_kseq_read_next = 0U;
      }
    } else {
      {
      _1_kseq_read_next = 15U;
      }
    }
    break;
    case 10: ;
    if (c != 43) {
      {
      _1_kseq_read_next = 23U;
      }
    } else {
      {
      _1_kseq_read_next = 28U;
      }
    }
    break;
    case 42: 
    seq->last_char = 0;
    {
    _1_kseq_read_next = 51U;
    }
    break;
    case 0: ;
    return (r);
    break;
    case 39: ;
    if (c != 62) {
      {
      _1_kseq_read_next = 10U;
      }
    } else {
      {
      _1_kseq_read_next = 28U;
      }
    }
    break;
    case 66: ;
    if (seq->seq.l + 1UL >= seq->seq.m) {
      {
      _1_kseq_read_next = 63U;
      }
    } else {
      {
      _1_kseq_read_next = 29U;
      }
    }
    break;
    case 7: ;
    if ((unsigned long )seq->seq.s == (unsigned long )((char *)0)) {
      {
      _1_kseq_read_next = 38U;
      }
    } else {
      {
      _1_kseq_read_next = 1U;
      }
    }
    break;
    case 29: 
    *(seq->seq.s + seq->seq.l) = (char)0;
    seq->is_fastq = c == 43;
    {
    _1_kseq_read_next = 47U;
    }
    break;
    case 43: 
    ks = seq->f;
    {
    _1_kseq_read_next = 50U;
    }
    break;
    case 2: 
    seq->last_char = c;
    {
    _1_kseq_read_next = 66U;
    }
    break;
    case 20: ;
    if (seq->qual.m < seq->seq.m) {
      {
      _1_kseq_read_next = 56U;
      }
    } else {
      {
      _1_kseq_read_next = 11U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kseq_read LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_hety LOC=UNKNOWN */
int stk_hety(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int win_size ;
  int n_start ;
  int win_step ;
  int is_lower_mask ;
  char *buf ;
  uint32_t cnt[3] ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int x ;
  int i ;
  int y ;
  int z ;
  int next ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int _1_stk_hety_next ;

  {
  {
  _1_stk_hety_next = 8U;
  }
  while (1) {
    switch (_1_stk_hety_next) {
    case 18: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_hety");
    {
    _1_stk_hety_next = 30U;
    }
    break;
    case 25: 
    c = (int )seq_nt16_table[c];
    x = bitcnt_table[c];
    {
    _1_stk_hety_next = 1U;
    }
    break;
    case 52: ;
    if (x > 2) {
      {
      _1_stk_hety_next = 23U;
      }
    } else {
      {
      _1_stk_hety_next = 22U;
      }
    }
    break;
    case 4: ;
    if (i >= win_size) {
      {
      _1_stk_hety_next = 5U;
      }
    } else {
      {
      _1_stk_hety_next = 43U;
      }
    }
    break;
    case 30: ;
    return (1);
    break;
    case 62: 
    c = getopt(argc, argv, "w:t:m");
    {
    _1_stk_hety_next = 39U;
    }
    break;
    case 14: ;
    if (i < l) {
      {
      _1_stk_hety_next = 59U;
      }
    } else {
      {
      _1_stk_hety_next = 53U;
      }
    }
    break;
    case 15: 
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
    {
    _1_stk_hety_next = 31U;
    }
    break;
    case 56: 
    (cnt[(int )*(buf + y)]) --;
    {
    _1_stk_hety_next = 52U;
    }
    break;
    case 31: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_hety_next = 18U;
      }
    } else {
      {
      _1_stk_hety_next = 61U;
      }
    }
    break;
    case 8: 
    win_size = 50000;
    n_start = 5;
    is_lower_mask = 0;
    {
    _1_stk_hety_next = 2U;
    }
    break;
    case 45: ;
    if (! (l >= 0)) {
      {
      _1_stk_hety_next = 6U;
      }
    } else {
      {
      _1_stk_hety_next = 34U;
      }
    }
    break;
    case 54: ;
    return (0);
    break;
    case 1: ;
    if (i >= win_size) {
      {
      _1_stk_hety_next = 56U;
      }
    } else {
      {
      _1_stk_hety_next = 52U;
      }
    }
    break;
    case 23: 
    z = 0;
    {
    _1_stk_hety_next = 46U;
    }
    break;
    case 24: 
    next = i;
    {
    _1_stk_hety_next = 14U;
    }
    break;
    case 21: 
    is_lower_mask = 1;
    {
    _1_stk_hety_next = 62U;
    }
    break;
    case 36: ;
    if (tmp___5) {
      {
      _1_stk_hety_next = 26U;
      }
    } else {
      {
      _1_stk_hety_next = 25U;
      }
    }
    break;
    case 57: ;
    if (cnt[1] + cnt[2] > 0U) {
      {
      _1_stk_hety_next = 60U;
      }
    } else {
      {
      _1_stk_hety_next = 24U;
      }
    }
    break;
    case 26: 
    c = 'N';
    {
    _1_stk_hety_next = 25U;
    }
    break;
    case 9: 
    y = l - win_size;
    {
    _1_stk_hety_next = 47U;
    }
    break;
    case 13: ;
    if (l >= win_size) {
      {
      _1_stk_hety_next = 9U;
      }
    } else {
      {
      _1_stk_hety_next = 57U;
      }
    }
    break;
    case 51: ;
    return (1);
    break;
    case 19: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk hety [options] <in.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -w INT   window size [%d]\n",
            win_size);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -t INT   # start positions in a window [%d]\n",
            n_start);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m       treat lowercases as masked\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    {
    _1_stk_hety_next = 51U;
    }
    break;
    case 32: 
    tmp___6 = 2;
    {
    _1_stk_hety_next = 0U;
    }
    break;
    case 55: ;
    if (tmp___3 == 0) {
      {
      _1_stk_hety_next = 15U;
      }
    } else {
      {
      _1_stk_hety_next = 7U;
      }
    }
    break;
    case 60: 
    printf((char const   */* __restrict  */)"%s\t%d\t%d\t%.2lf\t%d\t%d\n", seq->name.s,
           next, i, ((double )cnt[2] / (double )(cnt[1] + cnt[2])) * (double )win_size,
           cnt[1] + cnt[2], cnt[2]);
    {
    _1_stk_hety_next = 24U;
    }
    break;
    case 59: 
    y = i % win_size;
    c = (int )*(seq->seq.s + i);
    {
    _1_stk_hety_next = 41U;
    }
    break;
    case 6: 
    free((void *)buf);
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_hety_next = 54U;
    }
    break;
    case 27: ;
    if (i <= l) {
      {
      _1_stk_hety_next = 4U;
      }
    } else {
      {
      _1_stk_hety_next = 28U;
      }
    }
    break;
    case 38: 
    tmp___5 = islower(c);
    {
    _1_stk_hety_next = 36U;
    }
    break;
    case 61: 
    seq = kseq_init(fp);
    win_step = win_size / n_start;
    tmp___4 = calloc((size_t___0 )win_size, (size_t___0 )1);
    buf = (char *)tmp___4;
    {
    _1_stk_hety_next = 28U;
    }
    break;
    case 34: 
    next = 0;
    cnt[2] = (uint32_t )0;
    cnt[1] = cnt[2];
    cnt[0] = cnt[1];
    i = 0;
    {
    _1_stk_hety_next = 27U;
    }
    break;
    case 22: ;
    if (x == 2) {
      {
      _1_stk_hety_next = 32U;
      }
    } else {
      {
      _1_stk_hety_next = 64U;
      }
    }
    break;
    case 28: 
    l = kseq_read(seq);
    {
    _1_stk_hety_next = 45U;
    }
    break;
    case 53: 
    i ++;
    {
    _1_stk_hety_next = 27U;
    }
    break;
    case 47: ;
    if (y < next) {
      {
      _1_stk_hety_next = 37U;
      }
    } else {
      {
      _1_stk_hety_next = 57U;
      }
    }
    break;
    case 44: 
    n_start = atoi((char const   *)optarg);
    {
    _1_stk_hety_next = 62U;
    }
    break;
    case 5: ;
    if (i % win_step == 0) {
      {
      _1_stk_hety_next = 20U;
      }
    } else {
      {
      _1_stk_hety_next = 43U;
      }
    }
    break;
    case 37: 
    (cnt[(int )*(buf + y % win_size)]) --;
    y ++;
    {
    _1_stk_hety_next = 47U;
    }
    break;
    case 64: 
    tmp___6 = 1;
    {
    _1_stk_hety_next = 0U;
    }
    break;
    case 41: ;
    if (is_lower_mask) {
      {
      _1_stk_hety_next = 38U;
      }
    } else {
      {
      _1_stk_hety_next = 25U;
      }
    }
    break;
    case 10: 
    win_size = atoi((char const   *)optarg);
    {
    _1_stk_hety_next = 62U;
    }
    break;
    case 42: 
    tmp___3 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_hety_next = 55U;
    }
    break;
    case 0: 
    z = tmp___6;
    {
    _1_stk_hety_next = 46U;
    }
    break;
    case 46: 
    *(buf + y) = (char )z;
    (cnt[z]) ++;
    {
    _1_stk_hety_next = 53U;
    }
    break;
    case 39: ;
    if (! (c >= 0)) {
      {
      _1_stk_hety_next = 42U;
      }
    } else {
      {
      _1_stk_hety_next = 29U;
      }
    }
    break;
    case 7: 
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
    {
    _1_stk_hety_next = 31U;
    }
    break;
    case 29: ;
    switch (c) {
    case 119: 
    {
    _1_stk_hety_next = 10U;
    }
    break;
    case 116: 
    {
    _1_stk_hety_next = 44U;
    }
    break;
    case 109: 
    {
    _1_stk_hety_next = 21U;
    }
    break;
    default: 
    {
    _1_stk_hety_next = 62U;
    }
    break;
    }
    break;
    case 43: 
    _L___0: ;
    if (i == l) {
      {
      _1_stk_hety_next = 20U;
      }
    } else {
      {
      _1_stk_hety_next = 14U;
      }
    }
    break;
    case 2: ;
    if (argc == 1) {
      {
      _1_stk_hety_next = 19U;
      }
    } else {
      {
      _1_stk_hety_next = 62U;
      }
    }
    break;
    case 20: 
    _L: ;
    if (i == l) {
      {
      _1_stk_hety_next = 13U;
      }
    } else {
      {
      _1_stk_hety_next = 57U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_hety LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kr_rand LOC=UNKNOWN */
krint64_t kr_rand(krand_t *kr ) 
{ 
  krint64_t x ;
  int i ;
  int tmp ;
  unsigned int _1_kr_rand_next ;

  {
  {
  _1_kr_rand_next = 8U;
  }
  while (1) {
    switch (_1_kr_rand_next) {
    case 4: 
    x = (kr->mt[i] & 0xffffffff80000000ULL) | (kr->mt[i + 1] & 2147483647ULL);
    kr->mt[i] = (kr->mt[i + -156] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
    i ++;
    {
    _1_kr_rand_next = 3U;
    }
    break;
    case 8: ;
    if (kr->mti >= 312) {
      {
      _1_kr_rand_next = 2U;
      }
    } else {
      {
      _1_kr_rand_next = 7U;
      }
    }
    break;
    case 1: ;
    if (i < 156) {
      {
      _1_kr_rand_next = 5U;
      }
    } else {
      {
      _1_kr_rand_next = 3U;
      }
    }
    break;
    case 3: ;
    if (i < 311) {
      {
      _1_kr_rand_next = 4U;
      }
    } else {
      {
      _1_kr_rand_next = 6U;
      }
    }
    break;
    case 11: 
    i = 0;
    {
    _1_kr_rand_next = 1U;
    }
    break;
    case 13: 
    kr_srand0(5489ULL, kr);
    {
    _1_kr_rand_next = 11U;
    }
    break;
    case 6: 
    x = (kr->mt[311] & 0xffffffff80000000ULL) | (kr->mt[0] & 2147483647ULL);
    kr->mt[311] = (kr->mt[155] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
    kr->mti = 0;
    {
    _1_kr_rand_next = 7U;
    }
    break;
    case 5: 
    x = (kr->mt[i] & 0xffffffff80000000ULL) | (kr->mt[i + 1] & 2147483647ULL);
    kr->mt[i] = (kr->mt[i + 156] ^ (x >> 1)) ^ (unsigned long long )mag01[(int )(x & 1ULL)];
    i ++;
    {
    _1_kr_rand_next = 1U;
    }
    break;
    case 10: ;
    return (x);
    break;
    case 7: 
    tmp = kr->mti;
    (kr->mti) ++;
    x = kr->mt[tmp];
    x ^= (x >> 29) & 6148914691236517205ULL;
    x ^= (x << 17) & 8202884508482404352ULL;
    x ^= (x << 37) & 0xfff7eee000000000ULL;
    x ^= x >> 43;
    {
    _1_kr_rand_next = 10U;
    }
    break;
    case 2: ;
    if (kr->mti == 313) {
      {
      _1_kr_rand_next = 13U;
      }
    } else {
      {
      _1_kr_rand_next = 11U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kr_rand LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_reg_destroy LOC=UNKNOWN */
void stk_reg_destroy(reghash_t *h ) 
{ 
  khint_t k ;
  unsigned int _1_stk_reg_destroy_next ;

  {
  {
  _1_stk_reg_destroy_next = 2U;
  }
  while (1) {
    switch (_1_stk_reg_destroy_next) {
    case 8: ;
    return;
    break;
    case 1: ;
    if (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      {
      _1_stk_reg_destroy_next = 6U;
      }
    } else {
      {
      _1_stk_reg_destroy_next = 10U;
      }
    }
    break;
    case 3: ;
    return;
    break;
    case 9: ;
    if (k < h->n_buckets) {
      {
      _1_stk_reg_destroy_next = 1U;
      }
    } else {
      {
      _1_stk_reg_destroy_next = 0U;
      }
    }
    break;
    case 6: 
    free((void *)(h->vals + k)->a);
    free((void *)((char *)*(h->keys + k)));
    {
    _1_stk_reg_destroy_next = 10U;
    }
    break;
    case 10: 
    k ++;
    {
    _1_stk_reg_destroy_next = 9U;
    }
    break;
    case 0: 
    kh_destroy_reg(h);
    {
    _1_stk_reg_destroy_next = 3U;
    }
    break;
    case 7: 
    k = (khint_t )0;
    {
    _1_stk_reg_destroy_next = 9U;
    }
    break;
    case 2: ;
    if ((unsigned long )h == (unsigned long )((reghash_t *)0)) {
      {
      _1_stk_reg_destroy_next = 8U;
      }
    } else {
      {
      _1_stk_reg_destroy_next = 7U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_reg_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_dropse LOC=UNKNOWN */
int stk_dropse(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  kseq_t last ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  kstring_t *p ;
  kstring_t *q ;
  int is_diff ;
  int l ;
  size_t___0 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int _1_stk_dropse_next ;

  {
  {
  _1_stk_dropse_next = 39U;
  }
  while (1) {
    switch (_1_stk_dropse_next) {
    case 18: 
    cpy_kseq(& last, (kseq_t const   *)seq);
    {
    _1_stk_dropse_next = 11U;
    }
    break;
    case 25: 
    stk_printseq((kseq_t const   *)(& last), 0);
    stk_printseq((kseq_t const   *)seq, 0);
    last.name.l = (size_t___0 )0;
    {
    _1_stk_dropse_next = 11U;
    }
    break;
    case 4: ;
    if ((int )*(q->s + (q->l - 2UL)) == 47) {
      {
      _1_stk_dropse_next = 38U;
      }
    } else {
      {
      _1_stk_dropse_next = 28U;
      }
    }
    break;
    case 15: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk dropse <in.fq>\n");
    {
    _1_stk_dropse_next = 6U;
    }
    break;
    case 31: ;
    return (0);
    break;
    case 12: ;
    if (p->l > 2UL) {
      {
      _1_stk_dropse_next = 40U;
      }
    } else {
      {
      _1_stk_dropse_next = 7U;
      }
    }
    break;
    case 8: ;
    if (tmp___5) {
      {
      _1_stk_dropse_next = 29U;
      }
    } else {
      {
      _1_stk_dropse_next = 16U;
      }
    }
    break;
    case 1: 
    tmp = fileno(stdin);
    tmp___0 = isatty(tmp);
    {
    _1_stk_dropse_next = 34U;
    }
    break;
    case 23: 
    tmp___5 = strcmp((char const   *)*(argv + 1), "-");
    {
    _1_stk_dropse_next = 8U;
    }
    break;
    case 3: 
    p = & last.name;
    q = & seq->name;
    {
    _1_stk_dropse_next = 9U;
    }
    break;
    case 16: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_dropse_next = 41U;
    }
    break;
    case 24: 
    is_diff = 1;
    {
    _1_stk_dropse_next = 2U;
    }
    break;
    case 21: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_dropse");
    {
    _1_stk_dropse_next = 0U;
    }
    break;
    case 36: 
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_dropse_next = 31U;
    }
    break;
    case 26: 
    tmp___10 = isdigit((int )*(q->s + (q->l - 1UL)));
    {
    _1_stk_dropse_next = 37U;
    }
    break;
    case 11: 
    tmp___11 = kseq_read(seq);
    {
    _1_stk_dropse_next = 22U;
    }
    break;
    case 9: ;
    if (p->l == q->l) {
      {
      _1_stk_dropse_next = 12U;
      }
    } else {
      {
      _1_stk_dropse_next = 24U;
      }
    }
    break;
    case 13: 
    tmp___8 = p->l;
    {
    _1_stk_dropse_next = 32U;
    }
    break;
    case 19: ;
    if (tmp___9) {
      {
      _1_stk_dropse_next = 26U;
      }
    } else {
      {
      _1_stk_dropse_next = 10U;
      }
    }
    break;
    case 32: 
    l = (int )tmp___8;
    is_diff = strncmp((char const   *)p->s, (char const   *)q->s, (size_t___0 )l);
    {
    _1_stk_dropse_next = 2U;
    }
    break;
    case 17: 
    cpy_kseq(& last, (kseq_t const   *)seq);
    {
    _1_stk_dropse_next = 11U;
    }
    break;
    case 40: ;
    if ((int )*(p->s + (p->l - 2UL)) == 47) {
      {
      _1_stk_dropse_next = 4U;
      }
    } else {
      {
      _1_stk_dropse_next = 13U;
      }
    }
    break;
    case 6: ;
    return (1);
    break;
    case 27: 
    tmp___8 = p->l;
    {
    _1_stk_dropse_next = 32U;
    }
    break;
    case 38: 
    tmp___9 = isdigit((int )*(p->s + (p->l - 1UL)));
    {
    _1_stk_dropse_next = 19U;
    }
    break;
    case 34: ;
    if (tmp___0) {
      {
      _1_stk_dropse_next = 15U;
      }
    } else {
      {
      _1_stk_dropse_next = 35U;
      }
    }
    break;
    case 22: ;
    if (! (tmp___11 >= 0)) {
      {
      _1_stk_dropse_next = 36U;
      }
    } else {
      {
      _1_stk_dropse_next = 20U;
      }
    }
    break;
    case 28: 
    tmp___8 = p->l;
    {
    _1_stk_dropse_next = 32U;
    }
    break;
    case 5: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_dropse_next = 41U;
    }
    break;
    case 33: 
    seq = kseq_init(fp);
    memset((void *)(& last), 0, sizeof(kseq_t ));
    {
    _1_stk_dropse_next = 11U;
    }
    break;
    case 37: ;
    if (tmp___10) {
      {
      _1_stk_dropse_next = 42U;
      }
    } else {
      {
      _1_stk_dropse_next = 27U;
      }
    }
    break;
    case 41: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_dropse_next = 21U;
      }
    } else {
      {
      _1_stk_dropse_next = 33U;
      }
    }
    break;
    case 10: 
    tmp___8 = p->l;
    {
    _1_stk_dropse_next = 32U;
    }
    break;
    case 42: 
    tmp___8 = p->l - 2UL;
    {
    _1_stk_dropse_next = 32U;
    }
    break;
    case 0: ;
    return (1);
    break;
    case 39: ;
    if (argc == 1) {
      {
      _1_stk_dropse_next = 1U;
      }
    } else {
      {
      _1_stk_dropse_next = 35U;
      }
    }
    break;
    case 7: 
    tmp___8 = p->l;
    {
    _1_stk_dropse_next = 32U;
    }
    break;
    case 35: ;
    if (argc > 1) {
      {
      _1_stk_dropse_next = 23U;
      }
    } else {
      {
      _1_stk_dropse_next = 5U;
      }
    }
    break;
    case 29: 
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___2;
    {
    _1_stk_dropse_next = 41U;
    }
    break;
    case 2: ;
    if (! is_diff) {
      {
      _1_stk_dropse_next = 25U;
      }
    } else {
      {
      _1_stk_dropse_next = 17U;
      }
    }
    break;
    case 20: ;
    if (last.name.l) {
      {
      _1_stk_dropse_next = 3U;
      }
    } else {
      {
      _1_stk_dropse_next = 18U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_dropse LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_subseq LOC=UNKNOWN */
int stk_subseq(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int i ;
  int j ;
  int c ;
  int is_tab ;
  int line ;
  khint_t k ;
  gzFile tmp___1 ;
  int tmp___2 ;
  gzFile tmp___3 ;
  int tmp___4 ;
  reglist_t *p ;
  int beg ;
  int end ;
  int tmp___5 ;
  unsigned int _1_stk_subseq_next ;

  {
  {
  _1_stk_subseq_next = 87U;
  }
  while (1) {
    switch (_1_stk_subseq_next) {
    case 50: ;
    if (beg > 0) {
      {
      _1_stk_subseq_next = 28U;
      }
    } else {
      {
      _1_stk_subseq_next = 24U;
      }
    }
    break;
    case 80: ;
    if (j == 0) {
      {
      _1_stk_subseq_next = 32U;
      }
    } else {
      {
      _1_stk_subseq_next = 49U;
      }
    }
    break;
    case 25: 
    tmp___2 = fileno(stdin);
    tmp___3 = gzdopen(tmp___2, "r");
    fp = tmp___3;
    {
    _1_stk_subseq_next = 0U;
    }
    break;
    case 49: ;
    if (line > 0) {
      {
      _1_stk_subseq_next = 76U;
      }
    } else {
      {
      _1_stk_subseq_next = 60U;
      }
    }
    break;
    case 52: 
    is_tab = 1;
    {
    _1_stk_subseq_next = 69U;
    }
    break;
    case 4: 
    end = (int )seq->seq.l;
    {
    _1_stk_subseq_next = 12U;
    }
    break;
    case 30: 
    p = h->vals + k;
    i = 0;
    {
    _1_stk_subseq_next = 19U;
    }
    break;
    case 14: ;
    if (tmp___4) {
      {
      _1_stk_subseq_next = 39U;
      }
    } else {
      {
      _1_stk_subseq_next = 25U;
      }
    }
    break;
    case 15: 
    __Cont: 
    i ++;
    {
    _1_stk_subseq_next = 19U;
    }
    break;
    case 82: 
    printf((char const   */* __restrict  */)"+");
    j = 0;
    {
    _1_stk_subseq_next = 36U;
    }
    break;
    case 56: 
    seq = kseq_init(fp);
    {
    _1_stk_subseq_next = 17U;
    }
    break;
    case 31: 
    putchar('\n');
    {
    _1_stk_subseq_next = 60U;
    }
    break;
    case 12: 
    j = 0;
    {
    _1_stk_subseq_next = 66U;
    }
    break;
    case 69: 
    c = getopt(argc, argv, "tl:");
    {
    _1_stk_subseq_next = 77U;
    }
    break;
    case 8: 
    tmp___5 = '@';
    {
    _1_stk_subseq_next = 86U;
    }
    break;
    case 45: 
    putchar('\n');
    {
    _1_stk_subseq_next = 41U;
    }
    break;
    case 54: 
    printf((char const   */* __restrict  */)"%s\t%d\t", seq->name.s, beg + 1);
    {
    _1_stk_subseq_next = 67U;
    }
    break;
    case 78: ;
    if ((size_t___0 )beg >= seq->seq.l) {
      {
      _1_stk_subseq_next = 29U;
      }
    } else {
      {
      _1_stk_subseq_next = 3U;
      }
    }
    break;
    case 1: ;
    return (1);
    break;
    case 81: 
    putchar('\n');
    {
    _1_stk_subseq_next = 59U;
    }
    break;
    case 23: 
    putchar('\n');
    {
    _1_stk_subseq_next = 59U;
    }
    break;
    case 77: ;
    if (! (c >= 0)) {
      {
      _1_stk_subseq_next = 64U;
      }
    } else {
      {
      _1_stk_subseq_next = 58U;
      }
    }
    break;
    case 70: ;
    if (k == h->n_buckets) {
      {
      _1_stk_subseq_next = 17U;
      }
    } else {
      {
      _1_stk_subseq_next = 30U;
      }
    }
    break;
    case 3: ;
    if ((size_t___0 )end > seq->seq.l) {
      {
      _1_stk_subseq_next = 75U;
      }
    } else {
      {
      _1_stk_subseq_next = 5U;
      }
    }
    break;
    case 24: ;
    if ((int )*(p->a + i) != 2147483647) {
      {
      _1_stk_subseq_next = 28U;
      }
    } else {
      {
      _1_stk_subseq_next = 73U;
      }
    }
    break;
    case 21: ;
    if (! (l >= 0)) {
      {
      _1_stk_subseq_next = 51U;
      }
    } else {
      {
      _1_stk_subseq_next = 11U;
      }
    }
    break;
    case 36: ;
    if (j < end - beg) {
      {
      _1_stk_subseq_next = 35U;
      }
    } else {
      {
      _1_stk_subseq_next = 6U;
      }
    }
    break;
    case 76: ;
    if (j % line == 0) {
      {
      _1_stk_subseq_next = 31U;
      }
    } else {
      {
      _1_stk_subseq_next = 60U;
      }
    }
    break;
    case 68: ;
    if (j % line == 0) {
      {
      _1_stk_subseq_next = 23U;
      }
    } else {
      {
      _1_stk_subseq_next = 59U;
      }
    }
    break;
    case 85: ;
    if (is_tab == 0) {
      {
      _1_stk_subseq_next = 80U;
      }
    } else {
      {
      _1_stk_subseq_next = 60U;
      }
    }
    break;
    case 11: 
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
    {
    _1_stk_subseq_next = 70U;
    }
    break;
    case 9: 
    h = stk_reg_read((char const   *)*(argv + (optind + 1)));
    {
    _1_stk_subseq_next = 74U;
    }
    break;
    case 51: 
    kseq_destroy(seq);
    gzclose(fp);
    stk_reg_destroy(h);
    {
    _1_stk_subseq_next = 61U;
    }
    break;
    case 19: ;
    if (i < p->n) {
      {
      _1_stk_subseq_next = 72U;
      }
    } else {
      {
      _1_stk_subseq_next = 17U;
      }
    }
    break;
    case 32: 
    putchar('\n');
    {
    _1_stk_subseq_next = 60U;
    }
    break;
    case 17: 
    l = kseq_read(seq);
    {
    _1_stk_subseq_next = 21U;
    }
    break;
    case 40: ;
    if (seq->qual.l == seq->seq.l) {
      {
      _1_stk_subseq_next = 8U;
      }
    } else {
      {
      _1_stk_subseq_next = 10U;
      }
    }
    break;
    case 67: ;
    if ((size_t___0 )end > seq->seq.l) {
      {
      _1_stk_subseq_next = 4U;
      }
    } else {
      {
      _1_stk_subseq_next = 12U;
      }
    }
    break;
    case 55: ;
    return (1);
    break;
    case 60: 
    putchar((int )*(seq->seq.s + (j + beg)));
    j ++;
    {
    _1_stk_subseq_next = 66U;
    }
    break;
    case 59: 
    putchar((int )*(seq->qual.s + (j + beg)));
    j ++;
    {
    _1_stk_subseq_next = 36U;
    }
    break;
    case 6: 
    putchar('\n');
    {
    _1_stk_subseq_next = 15U;
    }
    break;
    case 27: 
    printf((char const   */* __restrict  */)":%d-%d", beg + 1, end);
    {
    _1_stk_subseq_next = 73U;
    }
    break;
    case 38: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to read the list of regions in file \'%s\'\n",
            "stk_subseq", *(argv + (optind + 1)));
    {
    _1_stk_subseq_next = 1U;
    }
    break;
    case 61: ;
    return (0);
    break;
    case 87: 
    tmp = kh_init_reg();
    h = tmp;
    is_tab = 0;
    line = 0;
    {
    _1_stk_subseq_next = 69U;
    }
    break;
    case 58: ;
    switch (c) {
    case 116: 
    {
    _1_stk_subseq_next = 52U;
    }
    break;
    case 108: 
    {
    _1_stk_subseq_next = 42U;
    }
    break;
    default: 
    {
    _1_stk_subseq_next = 69U;
    }
    break;
    }
    break;
    case 84: 
    printf((char const   */* __restrict  */)":%d", beg + 1);
    {
    _1_stk_subseq_next = 73U;
    }
    break;
    case 34: ;
    if (is_tab) {
      {
      _1_stk_subseq_next = 15U;
      }
    } else {
      {
      _1_stk_subseq_next = 82U;
      }
    }
    break;
    case 74: ;
    if ((unsigned long )h == (unsigned long )((kh_reg_t *)0)) {
      {
      _1_stk_subseq_next = 38U;
      }
    } else {
      {
      _1_stk_subseq_next = 65U;
      }
    }
    break;
    case 75: 
    end = (int )seq->seq.l;
    {
    _1_stk_subseq_next = 5U;
    }
    break;
    case 71: ;
    return (1);
    break;
    case 28: 
    _L: ;
    if (end == 2147483647) {
      {
      _1_stk_subseq_next = 44U;
      }
    } else {
      {
      _1_stk_subseq_next = 27U;
      }
    }
    break;
    case 65: 
    tmp___4 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_subseq_next = 14U;
    }
    break;
    case 73: ;
    if (seq->comment.l) {
      {
      _1_stk_subseq_next = 20U;
      }
    } else {
      {
      _1_stk_subseq_next = 67U;
      }
    }
    break;
    case 44: ;
    if (beg) {
      {
      _1_stk_subseq_next = 84U;
      }
    } else {
      {
      _1_stk_subseq_next = 73U;
      }
    }
    break;
    case 5: ;
    if (is_tab == 0) {
      {
      _1_stk_subseq_next = 40U;
      }
    } else {
      {
      _1_stk_subseq_next = 54U;
      }
    }
    break;
    case 72: 
    beg = (int )(*(p->a + i) >> 32);
    end = (int )*(p->a + i);
    {
    _1_stk_subseq_next = 78U;
    }
    break;
    case 37: ;
    if (line > 0) {
      {
      _1_stk_subseq_next = 68U;
      }
    } else {
      {
      _1_stk_subseq_next = 59U;
      }
    }
    break;
    case 64: ;
    if (optind + 2 > argc) {
      {
      _1_stk_subseq_next = 83U;
      }
    } else {
      {
      _1_stk_subseq_next = 9U;
      }
    }
    break;
    case 41: ;
    if (seq->qual.l != seq->seq.l) {
      {
      _1_stk_subseq_next = 15U;
      }
    } else {
      {
      _1_stk_subseq_next = 34U;
      }
    }
    break;
    case 10: 
    tmp___5 = '>';
    {
    _1_stk_subseq_next = 86U;
    }
    break;
    case 42: 
    line = atoi((char const   *)optarg);
    {
    _1_stk_subseq_next = 69U;
    }
    break;
    case 0: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_subseq_next = 2U;
      }
    } else {
      {
      _1_stk_subseq_next = 56U;
      }
    }
    break;
    case 39: 
    tmp___1 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___1;
    {
    _1_stk_subseq_next = 0U;
    }
    break;
    case 66: ;
    if (j < end - beg) {
      {
      _1_stk_subseq_next = 85U;
      }
    } else {
      {
      _1_stk_subseq_next = 45U;
      }
    }
    break;
    case 83: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk subseq [options] <in.fa> <in.bed>|<name.list>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -t       TAB delimited output\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT   sequence line length [%d]\n\n",
            line);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Use \'samtools faidx\' if only a few regions are intended.\n\n");
    {
    _1_stk_subseq_next = 71U;
    }
    break;
    case 35: ;
    if (j == 0) {
      {
      _1_stk_subseq_next = 81U;
      }
    } else {
      {
      _1_stk_subseq_next = 37U;
      }
    }
    break;
    case 29: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[subseq] %s: %d >= %ld\n",
            seq->name.s, beg, seq->seq.l);
    {
    _1_stk_subseq_next = 15U;
    }
    break;
    case 86: 
    printf((char const   */* __restrict  */)"%c%s", tmp___5, seq->name.s);
    {
    _1_stk_subseq_next = 50U;
    }
    break;
    case 2: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream\n",
            "stk_subseq");
    {
    _1_stk_subseq_next = 55U;
    }
    break;
    case 20: 
    printf((char const   */* __restrict  */)" %s", seq->comment.s);
    {
    _1_stk_subseq_next = 67U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_subseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_listhet LOC=UNKNOWN */
int stk_listhet(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int i ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int b ;
  unsigned int _1_stk_listhet_next ;

  {
  {
  _1_stk_listhet_next = 7U;
  }
  while (1) {
    switch (_1_stk_listhet_next) {
    case 18: 
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_listhet_next = 15U;
    }
    break;
    case 4: ;
    if (i < l) {
      {
      _1_stk_listhet_next = 3U;
      }
    } else {
      {
      _1_stk_listhet_next = 16U;
      }
    }
    break;
    case 14: 
    seq = kseq_init(fp);
    {
    _1_stk_listhet_next = 16U;
    }
    break;
    case 15: ;
    return (0);
    break;
    case 12: ;
    return (1);
    break;
    case 1: 
    i ++;
    {
    _1_stk_listhet_next = 4U;
    }
    break;
    case 23: 
    tmp___3 = strcmp((char const   *)*(argv + 1), "-");
    {
    _1_stk_listhet_next = 5U;
    }
    break;
    case 3: 
    b = (int )*(seq->seq.s + i);
    {
    _1_stk_listhet_next = 2U;
    }
    break;
    case 16: 
    l = kseq_read(seq);
    {
    _1_stk_listhet_next = 19U;
    }
    break;
    case 11: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk listhet <in.fa>\n");
    {
    _1_stk_listhet_next = 13U;
    }
    break;
    case 9: 
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___2;
    {
    _1_stk_listhet_next = 6U;
    }
    break;
    case 13: ;
    return (1);
    break;
    case 19: ;
    if (! (l >= 0)) {
      {
      _1_stk_listhet_next = 18U;
      }
    } else {
      {
      _1_stk_listhet_next = 20U;
      }
    }
    break;
    case 17: 
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
    {
    _1_stk_listhet_next = 6U;
    }
    break;
    case 6: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_listhet_next = 0U;
      }
    } else {
      {
      _1_stk_listhet_next = 14U;
      }
    }
    break;
    case 22: 
    printf((char const   */* __restrict  */)"%s\t%d\t%c\n", seq->name.s, i + 1, b);
    {
    _1_stk_listhet_next = 1U;
    }
    break;
    case 5: ;
    if (tmp___3 == 0) {
      {
      _1_stk_listhet_next = 17U;
      }
    } else {
      {
      _1_stk_listhet_next = 9U;
      }
    }
    break;
    case 0: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_listhet");
    {
    _1_stk_listhet_next = 12U;
    }
    break;
    case 7: ;
    if (argc == 1) {
      {
      _1_stk_listhet_next = 11U;
      }
    } else {
      {
      _1_stk_listhet_next = 23U;
      }
    }
    break;
    case 2: ;
    if (bitcnt_table[seq_nt16_table[b]] == 2) {
      {
      _1_stk_listhet_next = 22U;
      }
    } else {
      {
      _1_stk_listhet_next = 1U;
      }
    }
    break;
    case 20: 
    i = 0;
    {
    _1_stk_listhet_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_listhet LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_famask LOC=UNKNOWN */
int stk_famask(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  int c ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c___0[2] ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int _1_stk_famask_next ;

  {
  {
  _1_stk_famask_next = 18U;
  }
  while (1) {
    switch (_1_stk_famask_next) {
    case 18: ;
    {
    _1_stk_famask_next = 24U;
    }
    break;
    case 25: 
    c___0[0] = (int )*((seq[0])->seq.s + l);
    c___0[1] = (int )*((seq[1])->seq.s + l);
    {
    _1_stk_famask_next = 35U;
    }
    break;
    case 30: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_famask");
    {
    _1_stk_famask_next = 33U;
    }
    break;
    case 14: ;
    if ((unsigned long )fp[0] == (unsigned long )((gzFile )0)) {
      {
      _1_stk_famask_next = 30U;
      }
    } else {
      {
      _1_stk_famask_next = 26U;
      }
    }
    break;
    case 31: 
    putchar('\n');
    {
    _1_stk_famask_next = 12U;
    }
    break;
    case 12: 
    putchar(c___0[0]);
    l ++;
    {
    _1_stk_famask_next = 7U;
    }
    break;
    case 8: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Different sequence names: %s != %s\n",
            "stk_famask", (seq[0])->name.s, (seq[1])->name.s);
    {
    _1_stk_famask_next = 36U;
    }
    break;
    case 45: 
    tmp___5 = kseq_read(seq[0]);
    {
    _1_stk_famask_next = 22U;
    }
    break;
    case 23: 
    min_l = (int )(seq[1])->seq.l;
    {
    _1_stk_famask_next = 20U;
    }
    break;
    case 3: 
    seq[i] = kseq_init(fp[i]);
    i ++;
    {
    _1_stk_famask_next = 38U;
    }
    break;
    case 16: ;
    if (! (c >= 0)) {
      {
      _1_stk_famask_next = 6U;
      }
    } else {
      {
      _1_stk_famask_next = 24U;
      }
    }
    break;
    case 24: 
    c = getopt(argc, argv, "");
    {
    _1_stk_famask_next = 16U;
    }
    break;
    case 21: ;
    if (tmp___4) {
      {
      _1_stk_famask_next = 8U;
      }
    } else {
      {
      _1_stk_famask_next = 36U;
      }
    }
    break;
    case 36: ;
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
      {
      _1_stk_famask_next = 11U;
      }
    } else {
      {
      _1_stk_famask_next = 0U;
      }
    }
    break;
    case 26: ;
    if ((unsigned long )fp[1] == (unsigned long )((gzFile )0)) {
      {
      _1_stk_famask_next = 41U;
      }
    } else {
      {
      _1_stk_famask_next = 45U;
      }
    }
    break;
    case 11: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Unequal sequence length: %ld != %ld\n",
            "stk_famask", (seq[0])->seq.l, (seq[1])->seq.l);
    {
    _1_stk_famask_next = 0U;
    }
    break;
    case 9: ;
    if (l % 60 == 0) {
      {
      _1_stk_famask_next = 31U;
      }
    } else {
      {
      _1_stk_famask_next = 12U;
      }
    }
    break;
    case 13: ;
    if (c___0[1] != 88) {
      {
      _1_stk_famask_next = 17U;
      }
    } else {
      {
      _1_stk_famask_next = 9U;
      }
    }
    break;
    case 19: 
    min_l = (int )(seq[0])->seq.l;
    {
    _1_stk_famask_next = 20U;
    }
    break;
    case 32: 
    i = 0;
    {
    _1_stk_famask_next = 38U;
    }
    break;
    case 17: 
    c___0[0] = c___0[1];
    {
    _1_stk_famask_next = 9U;
    }
    break;
    case 40: 
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), "-");
    {
    _1_stk_famask_next = 5U;
    }
    break;
    case 6: ;
    if (argc - optind < 2) {
      {
      _1_stk_famask_next = 42U;
      }
    } else {
      {
      _1_stk_famask_next = 32U;
      }
    }
    break;
    case 27: ;
    return (0);
    break;
    case 38: ;
    if (i < 2) {
      {
      _1_stk_famask_next = 40U;
      }
    } else {
      {
      _1_stk_famask_next = 14U;
      }
    }
    break;
    case 34: 
    tmp___0 = gzopen((char const   *)*(argv + (optind + i)), "r");
    fp[i] = tmp___0;
    {
    _1_stk_famask_next = 3U;
    }
    break;
    case 22: ;
    if (! (tmp___5 >= 0)) {
      {
      _1_stk_famask_next = 27U;
      }
    } else {
      {
      _1_stk_famask_next = 28U;
      }
    }
    break;
    case 28: 
    kseq_read(seq[1]);
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
    {
    _1_stk_famask_next = 21U;
    }
    break;
    case 47: ;
    return (1);
    break;
    case 44: 
    putchar('\n');
    {
    _1_stk_famask_next = 45U;
    }
    break;
    case 5: ;
    if (tmp___3) {
      {
      _1_stk_famask_next = 34U;
      }
    } else {
      {
      _1_stk_famask_next = 10U;
      }
    }
    break;
    case 33: ;
    return (1);
    break;
    case 37: 
    c___0[0] = tolower(c___0[0]);
    {
    _1_stk_famask_next = 9U;
    }
    break;
    case 41: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_famask");
    {
    _1_stk_famask_next = 39U;
    }
    break;
    case 10: 
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp[i] = tmp___2;
    {
    _1_stk_famask_next = 3U;
    }
    break;
    case 42: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk famask <src.fa> <mask.fa>\n");
    {
    _1_stk_famask_next = 47U;
    }
    break;
    case 0: ;
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
      {
      _1_stk_famask_next = 19U;
      }
    } else {
      {
      _1_stk_famask_next = 23U;
      }
    }
    break;
    case 39: ;
    return (1);
    break;
    case 7: ;
    if (l < min_l) {
      {
      _1_stk_famask_next = 25U;
      }
    } else {
      {
      _1_stk_famask_next = 44U;
      }
    }
    break;
    case 35: ;
    if (c___0[1] == 120) {
      {
      _1_stk_famask_next = 37U;
      }
    } else {
      {
      _1_stk_famask_next = 13U;
      }
    }
    break;
    case 20: 
    printf((char const   */* __restrict  */)">%s", (seq[0])->name.s);
    l = 0;
    {
    _1_stk_famask_next = 7U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_famask LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_printseq LOC=UNKNOWN */
__inline static void stk_printseq(kseq_t const   *s , int line_len ) 
{ 
  unsigned int _1_stk_printseq_next ;

  {
  {
  _1_stk_printseq_next = 0U;
  }
  while (1) {
    switch (_1_stk_printseq_next) {
    case 1: ;
    return;
    break;
    case 0: 
    stk_printseq_renamed(s, line_len, (char const   *)0, (int64_t )-1);
    {
    _1_stk_printseq_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_printseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int _BARRIER_0 ;
  unsigned int _1_main_next ;

  {
  {
  {
  {
  {
  cutN_nonN_penalty = 10;
  goto cutN_nonN_penalty_i$nit_INLINE_cutN_nonN_penalty_i$nit;
  }
  cutN_nonN_penalty_i$nit_INLINE_cutN_nonN_penalty_i$nit: /* CIL Label */ ;
  }
  {
  {
  cutN_min_N_tract = 1000;
  goto cutN_min_N_tract_i$nit_INLINE_cutN_min_N_tract_i$nit;
  }
  cutN_min_N_tract_i$nit_INLINE_cutN_min_N_tract_i$nit: /* CIL Label */ ;
  }
  {
  {
  mag01[0] = (krint64_t const   )0;
  mag01[1] = (krint64_t const   )0xb5026f5aa96619e9ULL;
  goto mag01_i$nit_INLINE_mag01_i$nit;
  }
  mag01_i$nit_INLINE_mag01_i$nit: /* CIL Label */ ;
  }
  {
  {
  comp_tab[0] = (char)0;
  comp_tab[1] = (char)1;
  comp_tab[2] = (char)2;
  comp_tab[3] = (char)3;
  comp_tab[4] = (char)4;
  comp_tab[5] = (char)5;
  comp_tab[6] = (char)6;
  comp_tab[7] = (char)7;
  comp_tab[8] = (char)8;
  comp_tab[9] = (char)9;
  comp_tab[10] = (char)10;
  comp_tab[11] = (char)11;
  comp_tab[12] = (char)12;
  comp_tab[13] = (char)13;
  comp_tab[14] = (char)14;
  comp_tab[15] = (char)15;
  comp_tab[16] = (char)16;
  comp_tab[17] = (char)17;
  comp_tab[18] = (char)18;
  comp_tab[19] = (char)19;
  comp_tab[20] = (char)20;
  comp_tab[21] = (char)21;
  comp_tab[22] = (char)22;
  comp_tab[23] = (char)23;
  comp_tab[24] = (char)24;
  comp_tab[25] = (char)25;
  comp_tab[26] = (char)26;
  comp_tab[27] = (char)27;
  comp_tab[28] = (char)28;
  comp_tab[29] = (char)29;
  comp_tab[30] = (char)30;
  comp_tab[31] = (char)31;
  comp_tab[32] = (char)32;
  comp_tab[33] = (char)33;
  comp_tab[34] = (char)34;
  comp_tab[35] = (char)35;
  comp_tab[36] = (char)36;
  comp_tab[37] = (char)37;
  comp_tab[38] = (char)38;
  comp_tab[39] = (char)39;
  comp_tab[40] = (char)40;
  comp_tab[41] = (char)41;
  comp_tab[42] = (char)42;
  comp_tab[43] = (char)43;
  comp_tab[44] = (char)44;
  comp_tab[45] = (char)45;
  comp_tab[46] = (char)46;
  comp_tab[47] = (char)47;
  comp_tab[48] = (char)48;
  comp_tab[49] = (char)49;
  comp_tab[50] = (char)50;
  comp_tab[51] = (char)51;
  comp_tab[52] = (char)52;
  comp_tab[53] = (char)53;
  comp_tab[54] = (char)54;
  comp_tab[55] = (char)55;
  comp_tab[56] = (char)56;
  comp_tab[57] = (char)57;
  comp_tab[58] = (char)58;
  comp_tab[59] = (char)59;
  comp_tab[60] = (char)60;
  comp_tab[61] = (char)61;
  comp_tab[62] = (char)62;
  comp_tab[63] = (char)63;
  comp_tab[64] = (char)64;
  comp_tab[65] = (char )'T';
  comp_tab[66] = (char )'V';
  comp_tab[67] = (char )'G';
  comp_tab[68] = (char )'H';
  comp_tab[69] = (char )'E';
  comp_tab[70] = (char )'F';
  comp_tab[71] = (char )'C';
  comp_tab[72] = (char )'D';
  comp_tab[73] = (char )'I';
  comp_tab[74] = (char )'J';
  comp_tab[75] = (char )'M';
  comp_tab[76] = (char )'L';
  comp_tab[77] = (char )'K';
  comp_tab[78] = (char )'N';
  comp_tab[79] = (char )'O';
  comp_tab[80] = (char )'P';
  comp_tab[81] = (char )'Q';
  comp_tab[82] = (char )'Y';
  comp_tab[83] = (char )'S';
  comp_tab[84] = (char )'A';
  comp_tab[85] = (char )'A';
  comp_tab[86] = (char )'B';
  comp_tab[87] = (char )'W';
  comp_tab[88] = (char )'X';
  comp_tab[89] = (char )'R';
  comp_tab[90] = (char )'Z';
  comp_tab[91] = (char)91;
  comp_tab[92] = (char)92;
  comp_tab[93] = (char)93;
  comp_tab[94] = (char)94;
  comp_tab[95] = (char)95;
  comp_tab[96] = (char)64;
  comp_tab[97] = (char )'t';
  comp_tab[98] = (char )'v';
  comp_tab[99] = (char )'g';
  comp_tab[100] = (char )'h';
  comp_tab[101] = (char )'e';
  comp_tab[102] = (char )'f';
  comp_tab[103] = (char )'c';
  comp_tab[104] = (char )'d';
  comp_tab[105] = (char )'i';
  comp_tab[106] = (char )'j';
  comp_tab[107] = (char )'m';
  comp_tab[108] = (char )'l';
  comp_tab[109] = (char )'k';
  comp_tab[110] = (char )'n';
  comp_tab[111] = (char )'o';
  comp_tab[112] = (char )'p';
  comp_tab[113] = (char )'q';
  comp_tab[114] = (char )'y';
  comp_tab[115] = (char )'s';
  comp_tab[116] = (char )'a';
  comp_tab[117] = (char )'a';
  comp_tab[118] = (char )'b';
  comp_tab[119] = (char )'w';
  comp_tab[120] = (char )'x';
  comp_tab[121] = (char )'r';
  comp_tab[122] = (char )'z';
  comp_tab[123] = (char)123;
  comp_tab[124] = (char)124;
  comp_tab[125] = (char)125;
  comp_tab[126] = (char)126;
  comp_tab[127] = (char)127;
  goto comp_tab_i$nit_INLINE_comp_tab_i$nit;
  }
  comp_tab_i$nit_INLINE_comp_tab_i$nit: /* CIL Label */ ;
  }
  {
  {
  bitcnt_table[0] = 4;
  bitcnt_table[1] = 1;
  bitcnt_table[2] = 1;
  bitcnt_table[3] = 2;
  bitcnt_table[4] = 1;
  bitcnt_table[5] = 2;
  bitcnt_table[6] = 2;
  bitcnt_table[7] = 3;
  bitcnt_table[8] = 1;
  bitcnt_table[9] = 2;
  bitcnt_table[10] = 2;
  bitcnt_table[11] = 3;
  bitcnt_table[12] = 2;
  bitcnt_table[13] = 3;
  bitcnt_table[14] = 3;
  bitcnt_table[15] = 4;
  goto bitcnt_table_i$nit_INLINE_bitcnt_table_i$nit;
  }
  bitcnt_table_i$nit_INLINE_bitcnt_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16comp_table[0] = (unsigned char)0;
  seq_nt16comp_table[1] = (unsigned char)8;
  seq_nt16comp_table[2] = (unsigned char)4;
  seq_nt16comp_table[3] = (unsigned char)12;
  seq_nt16comp_table[4] = (unsigned char)2;
  seq_nt16comp_table[5] = (unsigned char)10;
  seq_nt16comp_table[6] = (unsigned char)9;
  seq_nt16comp_table[7] = (unsigned char)14;
  seq_nt16comp_table[8] = (unsigned char)1;
  seq_nt16comp_table[9] = (unsigned char)6;
  seq_nt16comp_table[10] = (unsigned char)5;
  seq_nt16comp_table[11] = (unsigned char)13;
  seq_nt16comp_table[12] = (unsigned char)3;
  seq_nt16comp_table[13] = (unsigned char)11;
  seq_nt16comp_table[14] = (unsigned char)7;
  seq_nt16comp_table[15] = (unsigned char)15;
  goto seq_nt16comp_table_i$nit_INLINE_seq_nt16comp_table_i$nit;
  }
  seq_nt16comp_table_i$nit_INLINE_seq_nt16comp_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16to4_table[0] = (unsigned char)4;
  seq_nt16to4_table[1] = (unsigned char)0;
  seq_nt16to4_table[2] = (unsigned char)1;
  seq_nt16to4_table[3] = (unsigned char)4;
  seq_nt16to4_table[4] = (unsigned char)2;
  seq_nt16to4_table[5] = (unsigned char)4;
  seq_nt16to4_table[6] = (unsigned char)4;
  seq_nt16to4_table[7] = (unsigned char)4;
  seq_nt16to4_table[8] = (unsigned char)3;
  seq_nt16to4_table[9] = (unsigned char)4;
  seq_nt16to4_table[10] = (unsigned char)4;
  seq_nt16to4_table[11] = (unsigned char)4;
  seq_nt16to4_table[12] = (unsigned char)4;
  seq_nt16to4_table[13] = (unsigned char)4;
  seq_nt16to4_table[14] = (unsigned char)4;
  seq_nt16to4_table[15] = (unsigned char)4;
  goto seq_nt16to4_table_i$nit_INLINE_seq_nt16to4_table_i$nit;
  }
  seq_nt16to4_table_i$nit_INLINE_seq_nt16to4_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16_rev_table = (char *)"XACMGRSVTWYHKDBN";
  goto seq_nt16_rev_table_i$nit_INLINE_seq_nt16_rev_table_i$nit;
  }
  seq_nt16_rev_table_i$nit_INLINE_seq_nt16_rev_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt6_table[0] = (unsigned char)0;
  seq_nt6_table[1] = (unsigned char)5;
  seq_nt6_table[2] = (unsigned char)5;
  seq_nt6_table[3] = (unsigned char)5;
  seq_nt6_table[4] = (unsigned char)5;
  seq_nt6_table[5] = (unsigned char)5;
  seq_nt6_table[6] = (unsigned char)5;
  seq_nt6_table[7] = (unsigned char)5;
  seq_nt6_table[8] = (unsigned char)5;
  seq_nt6_table[9] = (unsigned char)5;
  seq_nt6_table[10] = (unsigned char)5;
  seq_nt6_table[11] = (unsigned char)5;
  seq_nt6_table[12] = (unsigned char)5;
  seq_nt6_table[13] = (unsigned char)5;
  seq_nt6_table[14] = (unsigned char)5;
  seq_nt6_table[15] = (unsigned char)5;
  seq_nt6_table[16] = (unsigned char)5;
  seq_nt6_table[17] = (unsigned char)5;
  seq_nt6_table[18] = (unsigned char)5;
  seq_nt6_table[19] = (unsigned char)5;
  seq_nt6_table[20] = (unsigned char)5;
  seq_nt6_table[21] = (unsigned char)5;
  seq_nt6_table[22] = (unsigned char)5;
  seq_nt6_table[23] = (unsigned char)5;
  seq_nt6_table[24] = (unsigned char)5;
  seq_nt6_table[25] = (unsigned char)5;
  seq_nt6_table[26] = (unsigned char)5;
  seq_nt6_table[27] = (unsigned char)5;
  seq_nt6_table[28] = (unsigned char)5;
  seq_nt6_table[29] = (unsigned char)5;
  seq_nt6_table[30] = (unsigned char)5;
  seq_nt6_table[31] = (unsigned char)5;
  seq_nt6_table[32] = (unsigned char)5;
  seq_nt6_table[33] = (unsigned char)5;
  seq_nt6_table[34] = (unsigned char)5;
  seq_nt6_table[35] = (unsigned char)5;
  seq_nt6_table[36] = (unsigned char)5;
  seq_nt6_table[37] = (unsigned char)5;
  seq_nt6_table[38] = (unsigned char)5;
  seq_nt6_table[39] = (unsigned char)5;
  seq_nt6_table[40] = (unsigned char)5;
  seq_nt6_table[41] = (unsigned char)5;
  seq_nt6_table[42] = (unsigned char)5;
  seq_nt6_table[43] = (unsigned char)5;
  seq_nt6_table[44] = (unsigned char)5;
  seq_nt6_table[45] = (unsigned char)5;
  seq_nt6_table[46] = (unsigned char)5;
  seq_nt6_table[47] = (unsigned char)5;
  seq_nt6_table[48] = (unsigned char)5;
  seq_nt6_table[49] = (unsigned char)5;
  seq_nt6_table[50] = (unsigned char)5;
  seq_nt6_table[51] = (unsigned char)5;
  seq_nt6_table[52] = (unsigned char)5;
  seq_nt6_table[53] = (unsigned char)5;
  seq_nt6_table[54] = (unsigned char)5;
  seq_nt6_table[55] = (unsigned char)5;
  seq_nt6_table[56] = (unsigned char)5;
  seq_nt6_table[57] = (unsigned char)5;
  seq_nt6_table[58] = (unsigned char)5;
  seq_nt6_table[59] = (unsigned char)5;
  seq_nt6_table[60] = (unsigned char)5;
  seq_nt6_table[61] = (unsigned char)5;
  seq_nt6_table[62] = (unsigned char)5;
  seq_nt6_table[63] = (unsigned char)5;
  seq_nt6_table[64] = (unsigned char)5;
  seq_nt6_table[65] = (unsigned char)1;
  seq_nt6_table[66] = (unsigned char)5;
  seq_nt6_table[67] = (unsigned char)2;
  seq_nt6_table[68] = (unsigned char)5;
  seq_nt6_table[69] = (unsigned char)5;
  seq_nt6_table[70] = (unsigned char)5;
  seq_nt6_table[71] = (unsigned char)3;
  seq_nt6_table[72] = (unsigned char)5;
  seq_nt6_table[73] = (unsigned char)5;
  seq_nt6_table[74] = (unsigned char)5;
  seq_nt6_table[75] = (unsigned char)5;
  seq_nt6_table[76] = (unsigned char)5;
  seq_nt6_table[77] = (unsigned char)5;
  seq_nt6_table[78] = (unsigned char)5;
  seq_nt6_table[79] = (unsigned char)5;
  seq_nt6_table[80] = (unsigned char)5;
  seq_nt6_table[81] = (unsigned char)5;
  seq_nt6_table[82] = (unsigned char)5;
  seq_nt6_table[83] = (unsigned char)5;
  seq_nt6_table[84] = (unsigned char)4;
  seq_nt6_table[85] = (unsigned char)5;
  seq_nt6_table[86] = (unsigned char)5;
  seq_nt6_table[87] = (unsigned char)5;
  seq_nt6_table[88] = (unsigned char)5;
  seq_nt6_table[89] = (unsigned char)5;
  seq_nt6_table[90] = (unsigned char)5;
  seq_nt6_table[91] = (unsigned char)5;
  seq_nt6_table[92] = (unsigned char)5;
  seq_nt6_table[93] = (unsigned char)5;
  seq_nt6_table[94] = (unsigned char)5;
  seq_nt6_table[95] = (unsigned char)5;
  seq_nt6_table[96] = (unsigned char)5;
  seq_nt6_table[97] = (unsigned char)1;
  seq_nt6_table[98] = (unsigned char)5;
  seq_nt6_table[99] = (unsigned char)2;
  seq_nt6_table[100] = (unsigned char)5;
  seq_nt6_table[101] = (unsigned char)5;
  seq_nt6_table[102] = (unsigned char)5;
  seq_nt6_table[103] = (unsigned char)3;
  seq_nt6_table[104] = (unsigned char)5;
  seq_nt6_table[105] = (unsigned char)5;
  seq_nt6_table[106] = (unsigned char)5;
  seq_nt6_table[107] = (unsigned char)5;
  seq_nt6_table[108] = (unsigned char)5;
  seq_nt6_table[109] = (unsigned char)5;
  seq_nt6_table[110] = (unsigned char)5;
  seq_nt6_table[111] = (unsigned char)5;
  seq_nt6_table[112] = (unsigned char)5;
  seq_nt6_table[113] = (unsigned char)5;
  seq_nt6_table[114] = (unsigned char)5;
  seq_nt6_table[115] = (unsigned char)5;
  seq_nt6_table[116] = (unsigned char)4;
  seq_nt6_table[117] = (unsigned char)5;
  seq_nt6_table[118] = (unsigned char)5;
  seq_nt6_table[119] = (unsigned char)5;
  seq_nt6_table[120] = (unsigned char)5;
  seq_nt6_table[121] = (unsigned char)5;
  seq_nt6_table[122] = (unsigned char)5;
  seq_nt6_table[123] = (unsigned char)5;
  seq_nt6_table[124] = (unsigned char)5;
  seq_nt6_table[125] = (unsigned char)5;
  seq_nt6_table[126] = (unsigned char)5;
  seq_nt6_table[127] = (unsigned char)5;
  seq_nt6_table[128] = (unsigned char)5;
  seq_nt6_table[129] = (unsigned char)5;
  seq_nt6_table[130] = (unsigned char)5;
  seq_nt6_table[131] = (unsigned char)5;
  seq_nt6_table[132] = (unsigned char)5;
  seq_nt6_table[133] = (unsigned char)5;
  seq_nt6_table[134] = (unsigned char)5;
  seq_nt6_table[135] = (unsigned char)5;
  seq_nt6_table[136] = (unsigned char)5;
  seq_nt6_table[137] = (unsigned char)5;
  seq_nt6_table[138] = (unsigned char)5;
  seq_nt6_table[139] = (unsigned char)5;
  seq_nt6_table[140] = (unsigned char)5;
  seq_nt6_table[141] = (unsigned char)5;
  seq_nt6_table[142] = (unsigned char)5;
  seq_nt6_table[143] = (unsigned char)5;
  seq_nt6_table[144] = (unsigned char)5;
  seq_nt6_table[145] = (unsigned char)5;
  seq_nt6_table[146] = (unsigned char)5;
  seq_nt6_table[147] = (unsigned char)5;
  seq_nt6_table[148] = (unsigned char)5;
  seq_nt6_table[149] = (unsigned char)5;
  seq_nt6_table[150] = (unsigned char)5;
  seq_nt6_table[151] = (unsigned char)5;
  seq_nt6_table[152] = (unsigned char)5;
  seq_nt6_table[153] = (unsigned char)5;
  seq_nt6_table[154] = (unsigned char)5;
  seq_nt6_table[155] = (unsigned char)5;
  seq_nt6_table[156] = (unsigned char)5;
  seq_nt6_table[157] = (unsigned char)5;
  seq_nt6_table[158] = (unsigned char)5;
  seq_nt6_table[159] = (unsigned char)5;
  seq_nt6_table[160] = (unsigned char)5;
  seq_nt6_table[161] = (unsigned char)5;
  seq_nt6_table[162] = (unsigned char)5;
  seq_nt6_table[163] = (unsigned char)5;
  seq_nt6_table[164] = (unsigned char)5;
  seq_nt6_table[165] = (unsigned char)5;
  seq_nt6_table[166] = (unsigned char)5;
  seq_nt6_table[167] = (unsigned char)5;
  seq_nt6_table[168] = (unsigned char)5;
  seq_nt6_table[169] = (unsigned char)5;
  seq_nt6_table[170] = (unsigned char)5;
  seq_nt6_table[171] = (unsigned char)5;
  seq_nt6_table[172] = (unsigned char)5;
  seq_nt6_table[173] = (unsigned char)5;
  seq_nt6_table[174] = (unsigned char)5;
  seq_nt6_table[175] = (unsigned char)5;
  seq_nt6_table[176] = (unsigned char)5;
  seq_nt6_table[177] = (unsigned char)5;
  seq_nt6_table[178] = (unsigned char)5;
  seq_nt6_table[179] = (unsigned char)5;
  seq_nt6_table[180] = (unsigned char)5;
  seq_nt6_table[181] = (unsigned char)5;
  seq_nt6_table[182] = (unsigned char)5;
  seq_nt6_table[183] = (unsigned char)5;
  seq_nt6_table[184] = (unsigned char)5;
  seq_nt6_table[185] = (unsigned char)5;
  seq_nt6_table[186] = (unsigned char)5;
  seq_nt6_table[187] = (unsigned char)5;
  seq_nt6_table[188] = (unsigned char)5;
  seq_nt6_table[189] = (unsigned char)5;
  seq_nt6_table[190] = (unsigned char)5;
  seq_nt6_table[191] = (unsigned char)5;
  seq_nt6_table[192] = (unsigned char)5;
  seq_nt6_table[193] = (unsigned char)5;
  seq_nt6_table[194] = (unsigned char)5;
  seq_nt6_table[195] = (unsigned char)5;
  seq_nt6_table[196] = (unsigned char)5;
  seq_nt6_table[197] = (unsigned char)5;
  seq_nt6_table[198] = (unsigned char)5;
  seq_nt6_table[199] = (unsigned char)5;
  seq_nt6_table[200] = (unsigned char)5;
  seq_nt6_table[201] = (unsigned char)5;
  seq_nt6_table[202] = (unsigned char)5;
  seq_nt6_table[203] = (unsigned char)5;
  seq_nt6_table[204] = (unsigned char)5;
  seq_nt6_table[205] = (unsigned char)5;
  seq_nt6_table[206] = (unsigned char)5;
  seq_nt6_table[207] = (unsigned char)5;
  seq_nt6_table[208] = (unsigned char)5;
  seq_nt6_table[209] = (unsigned char)5;
  seq_nt6_table[210] = (unsigned char)5;
  seq_nt6_table[211] = (unsigned char)5;
  seq_nt6_table[212] = (unsigned char)5;
  seq_nt6_table[213] = (unsigned char)5;
  seq_nt6_table[214] = (unsigned char)5;
  seq_nt6_table[215] = (unsigned char)5;
  seq_nt6_table[216] = (unsigned char)5;
  seq_nt6_table[217] = (unsigned char)5;
  seq_nt6_table[218] = (unsigned char)5;
  seq_nt6_table[219] = (unsigned char)5;
  seq_nt6_table[220] = (unsigned char)5;
  seq_nt6_table[221] = (unsigned char)5;
  seq_nt6_table[222] = (unsigned char)5;
  seq_nt6_table[223] = (unsigned char)5;
  seq_nt6_table[224] = (unsigned char)5;
  seq_nt6_table[225] = (unsigned char)5;
  seq_nt6_table[226] = (unsigned char)5;
  seq_nt6_table[227] = (unsigned char)5;
  seq_nt6_table[228] = (unsigned char)5;
  seq_nt6_table[229] = (unsigned char)5;
  seq_nt6_table[230] = (unsigned char)5;
  seq_nt6_table[231] = (unsigned char)5;
  seq_nt6_table[232] = (unsigned char)5;
  seq_nt6_table[233] = (unsigned char)5;
  seq_nt6_table[234] = (unsigned char)5;
  seq_nt6_table[235] = (unsigned char)5;
  seq_nt6_table[236] = (unsigned char)5;
  seq_nt6_table[237] = (unsigned char)5;
  seq_nt6_table[238] = (unsigned char)5;
  seq_nt6_table[239] = (unsigned char)5;
  seq_nt6_table[240] = (unsigned char)5;
  seq_nt6_table[241] = (unsigned char)5;
  seq_nt6_table[242] = (unsigned char)5;
  seq_nt6_table[243] = (unsigned char)5;
  seq_nt6_table[244] = (unsigned char)5;
  seq_nt6_table[245] = (unsigned char)5;
  seq_nt6_table[246] = (unsigned char)5;
  seq_nt6_table[247] = (unsigned char)5;
  seq_nt6_table[248] = (unsigned char)5;
  seq_nt6_table[249] = (unsigned char)5;
  seq_nt6_table[250] = (unsigned char)5;
  seq_nt6_table[251] = (unsigned char)5;
  seq_nt6_table[252] = (unsigned char)5;
  seq_nt6_table[253] = (unsigned char)5;
  seq_nt6_table[254] = (unsigned char)5;
  seq_nt6_table[255] = (unsigned char)5;
  goto seq_nt6_table_i$nit_INLINE_seq_nt6_table_i$nit;
  }
  seq_nt6_table_i$nit_INLINE_seq_nt6_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  seq_nt16_table[0] = (unsigned char)15;
  seq_nt16_table[1] = (unsigned char)15;
  seq_nt16_table[2] = (unsigned char)15;
  seq_nt16_table[3] = (unsigned char)15;
  seq_nt16_table[4] = (unsigned char)15;
  seq_nt16_table[5] = (unsigned char)15;
  seq_nt16_table[6] = (unsigned char)15;
  seq_nt16_table[7] = (unsigned char)15;
  seq_nt16_table[8] = (unsigned char)15;
  seq_nt16_table[9] = (unsigned char)15;
  seq_nt16_table[10] = (unsigned char)15;
  seq_nt16_table[11] = (unsigned char)15;
  seq_nt16_table[12] = (unsigned char)15;
  seq_nt16_table[13] = (unsigned char)15;
  seq_nt16_table[14] = (unsigned char)15;
  seq_nt16_table[15] = (unsigned char)15;
  seq_nt16_table[16] = (unsigned char)15;
  seq_nt16_table[17] = (unsigned char)15;
  seq_nt16_table[18] = (unsigned char)15;
  seq_nt16_table[19] = (unsigned char)15;
  seq_nt16_table[20] = (unsigned char)15;
  seq_nt16_table[21] = (unsigned char)15;
  seq_nt16_table[22] = (unsigned char)15;
  seq_nt16_table[23] = (unsigned char)15;
  seq_nt16_table[24] = (unsigned char)15;
  seq_nt16_table[25] = (unsigned char)15;
  seq_nt16_table[26] = (unsigned char)15;
  seq_nt16_table[27] = (unsigned char)15;
  seq_nt16_table[28] = (unsigned char)15;
  seq_nt16_table[29] = (unsigned char)15;
  seq_nt16_table[30] = (unsigned char)15;
  seq_nt16_table[31] = (unsigned char)15;
  seq_nt16_table[32] = (unsigned char)15;
  seq_nt16_table[33] = (unsigned char)15;
  seq_nt16_table[34] = (unsigned char)15;
  seq_nt16_table[35] = (unsigned char)15;
  seq_nt16_table[36] = (unsigned char)15;
  seq_nt16_table[37] = (unsigned char)15;
  seq_nt16_table[38] = (unsigned char)15;
  seq_nt16_table[39] = (unsigned char)15;
  seq_nt16_table[40] = (unsigned char)15;
  seq_nt16_table[41] = (unsigned char)15;
  seq_nt16_table[42] = (unsigned char)15;
  seq_nt16_table[43] = (unsigned char)15;
  seq_nt16_table[44] = (unsigned char)15;
  seq_nt16_table[45] = (unsigned char)15;
  seq_nt16_table[46] = (unsigned char)15;
  seq_nt16_table[47] = (unsigned char)15;
  seq_nt16_table[48] = (unsigned char)15;
  seq_nt16_table[49] = (unsigned char)15;
  seq_nt16_table[50] = (unsigned char)15;
  seq_nt16_table[51] = (unsigned char)15;
  seq_nt16_table[52] = (unsigned char)15;
  seq_nt16_table[53] = (unsigned char)15;
  seq_nt16_table[54] = (unsigned char)15;
  seq_nt16_table[55] = (unsigned char)15;
  seq_nt16_table[56] = (unsigned char)15;
  seq_nt16_table[57] = (unsigned char)15;
  seq_nt16_table[58] = (unsigned char)15;
  seq_nt16_table[59] = (unsigned char)15;
  seq_nt16_table[60] = (unsigned char)15;
  seq_nt16_table[61] = (unsigned char)15;
  seq_nt16_table[62] = (unsigned char)15;
  seq_nt16_table[63] = (unsigned char)15;
  seq_nt16_table[64] = (unsigned char)15;
  seq_nt16_table[65] = (unsigned char)1;
  seq_nt16_table[66] = (unsigned char)14;
  seq_nt16_table[67] = (unsigned char)2;
  seq_nt16_table[68] = (unsigned char)13;
  seq_nt16_table[69] = (unsigned char)15;
  seq_nt16_table[70] = (unsigned char)15;
  seq_nt16_table[71] = (unsigned char)4;
  seq_nt16_table[72] = (unsigned char)11;
  seq_nt16_table[73] = (unsigned char)15;
  seq_nt16_table[74] = (unsigned char)15;
  seq_nt16_table[75] = (unsigned char)12;
  seq_nt16_table[76] = (unsigned char)15;
  seq_nt16_table[77] = (unsigned char)3;
  seq_nt16_table[78] = (unsigned char)15;
  seq_nt16_table[79] = (unsigned char)15;
  seq_nt16_table[80] = (unsigned char)15;
  seq_nt16_table[81] = (unsigned char)15;
  seq_nt16_table[82] = (unsigned char)5;
  seq_nt16_table[83] = (unsigned char)6;
  seq_nt16_table[84] = (unsigned char)8;
  seq_nt16_table[85] = (unsigned char)15;
  seq_nt16_table[86] = (unsigned char)7;
  seq_nt16_table[87] = (unsigned char)9;
  seq_nt16_table[88] = (unsigned char)0;
  seq_nt16_table[89] = (unsigned char)10;
  seq_nt16_table[90] = (unsigned char)15;
  seq_nt16_table[91] = (unsigned char)15;
  seq_nt16_table[92] = (unsigned char)15;
  seq_nt16_table[93] = (unsigned char)15;
  seq_nt16_table[94] = (unsigned char)15;
  seq_nt16_table[95] = (unsigned char)15;
  seq_nt16_table[96] = (unsigned char)15;
  seq_nt16_table[97] = (unsigned char)1;
  seq_nt16_table[98] = (unsigned char)14;
  seq_nt16_table[99] = (unsigned char)2;
  seq_nt16_table[100] = (unsigned char)13;
  seq_nt16_table[101] = (unsigned char)15;
  seq_nt16_table[102] = (unsigned char)15;
  seq_nt16_table[103] = (unsigned char)4;
  seq_nt16_table[104] = (unsigned char)11;
  seq_nt16_table[105] = (unsigned char)15;
  seq_nt16_table[106] = (unsigned char)15;
  seq_nt16_table[107] = (unsigned char)12;
  seq_nt16_table[108] = (unsigned char)15;
  seq_nt16_table[109] = (unsigned char)3;
  seq_nt16_table[110] = (unsigned char)15;
  seq_nt16_table[111] = (unsigned char)15;
  seq_nt16_table[112] = (unsigned char)15;
  seq_nt16_table[113] = (unsigned char)15;
  seq_nt16_table[114] = (unsigned char)5;
  seq_nt16_table[115] = (unsigned char)6;
  seq_nt16_table[116] = (unsigned char)8;
  seq_nt16_table[117] = (unsigned char)15;
  seq_nt16_table[118] = (unsigned char)7;
  seq_nt16_table[119] = (unsigned char)9;
  seq_nt16_table[120] = (unsigned char)0;
  seq_nt16_table[121] = (unsigned char)10;
  seq_nt16_table[122] = (unsigned char)15;
  seq_nt16_table[123] = (unsigned char)15;
  seq_nt16_table[124] = (unsigned char)15;
  seq_nt16_table[125] = (unsigned char)15;
  seq_nt16_table[126] = (unsigned char)15;
  seq_nt16_table[127] = (unsigned char)15;
  seq_nt16_table[128] = (unsigned char)15;
  seq_nt16_table[129] = (unsigned char)15;
  seq_nt16_table[130] = (unsigned char)15;
  seq_nt16_table[131] = (unsigned char)15;
  seq_nt16_table[132] = (unsigned char)15;
  seq_nt16_table[133] = (unsigned char)15;
  seq_nt16_table[134] = (unsigned char)15;
  seq_nt16_table[135] = (unsigned char)15;
  seq_nt16_table[136] = (unsigned char)15;
  seq_nt16_table[137] = (unsigned char)15;
  seq_nt16_table[138] = (unsigned char)15;
  seq_nt16_table[139] = (unsigned char)15;
  seq_nt16_table[140] = (unsigned char)15;
  seq_nt16_table[141] = (unsigned char)15;
  seq_nt16_table[142] = (unsigned char)15;
  seq_nt16_table[143] = (unsigned char)15;
  seq_nt16_table[144] = (unsigned char)15;
  seq_nt16_table[145] = (unsigned char)15;
  seq_nt16_table[146] = (unsigned char)15;
  seq_nt16_table[147] = (unsigned char)15;
  seq_nt16_table[148] = (unsigned char)15;
  seq_nt16_table[149] = (unsigned char)15;
  seq_nt16_table[150] = (unsigned char)15;
  seq_nt16_table[151] = (unsigned char)15;
  seq_nt16_table[152] = (unsigned char)15;
  seq_nt16_table[153] = (unsigned char)15;
  seq_nt16_table[154] = (unsigned char)15;
  seq_nt16_table[155] = (unsigned char)15;
  seq_nt16_table[156] = (unsigned char)15;
  seq_nt16_table[157] = (unsigned char)15;
  seq_nt16_table[158] = (unsigned char)15;
  seq_nt16_table[159] = (unsigned char)15;
  seq_nt16_table[160] = (unsigned char)15;
  seq_nt16_table[161] = (unsigned char)15;
  seq_nt16_table[162] = (unsigned char)15;
  seq_nt16_table[163] = (unsigned char)15;
  seq_nt16_table[164] = (unsigned char)15;
  seq_nt16_table[165] = (unsigned char)15;
  seq_nt16_table[166] = (unsigned char)15;
  seq_nt16_table[167] = (unsigned char)15;
  seq_nt16_table[168] = (unsigned char)15;
  seq_nt16_table[169] = (unsigned char)15;
  seq_nt16_table[170] = (unsigned char)15;
  seq_nt16_table[171] = (unsigned char)15;
  seq_nt16_table[172] = (unsigned char)15;
  seq_nt16_table[173] = (unsigned char)15;
  seq_nt16_table[174] = (unsigned char)15;
  seq_nt16_table[175] = (unsigned char)15;
  seq_nt16_table[176] = (unsigned char)15;
  seq_nt16_table[177] = (unsigned char)15;
  seq_nt16_table[178] = (unsigned char)15;
  seq_nt16_table[179] = (unsigned char)15;
  seq_nt16_table[180] = (unsigned char)15;
  seq_nt16_table[181] = (unsigned char)15;
  seq_nt16_table[182] = (unsigned char)15;
  seq_nt16_table[183] = (unsigned char)15;
  seq_nt16_table[184] = (unsigned char)15;
  seq_nt16_table[185] = (unsigned char)15;
  seq_nt16_table[186] = (unsigned char)15;
  seq_nt16_table[187] = (unsigned char)15;
  seq_nt16_table[188] = (unsigned char)15;
  seq_nt16_table[189] = (unsigned char)15;
  seq_nt16_table[190] = (unsigned char)15;
  seq_nt16_table[191] = (unsigned char)15;
  seq_nt16_table[192] = (unsigned char)15;
  seq_nt16_table[193] = (unsigned char)15;
  seq_nt16_table[194] = (unsigned char)15;
  seq_nt16_table[195] = (unsigned char)15;
  seq_nt16_table[196] = (unsigned char)15;
  seq_nt16_table[197] = (unsigned char)15;
  seq_nt16_table[198] = (unsigned char)15;
  seq_nt16_table[199] = (unsigned char)15;
  seq_nt16_table[200] = (unsigned char)15;
  seq_nt16_table[201] = (unsigned char)15;
  seq_nt16_table[202] = (unsigned char)15;
  seq_nt16_table[203] = (unsigned char)15;
  seq_nt16_table[204] = (unsigned char)15;
  seq_nt16_table[205] = (unsigned char)15;
  seq_nt16_table[206] = (unsigned char)15;
  seq_nt16_table[207] = (unsigned char)15;
  seq_nt16_table[208] = (unsigned char)15;
  seq_nt16_table[209] = (unsigned char)15;
  seq_nt16_table[210] = (unsigned char)15;
  seq_nt16_table[211] = (unsigned char)15;
  seq_nt16_table[212] = (unsigned char)15;
  seq_nt16_table[213] = (unsigned char)15;
  seq_nt16_table[214] = (unsigned char)15;
  seq_nt16_table[215] = (unsigned char)15;
  seq_nt16_table[216] = (unsigned char)15;
  seq_nt16_table[217] = (unsigned char)15;
  seq_nt16_table[218] = (unsigned char)15;
  seq_nt16_table[219] = (unsigned char)15;
  seq_nt16_table[220] = (unsigned char)15;
  seq_nt16_table[221] = (unsigned char)15;
  seq_nt16_table[222] = (unsigned char)15;
  seq_nt16_table[223] = (unsigned char)15;
  seq_nt16_table[224] = (unsigned char)15;
  seq_nt16_table[225] = (unsigned char)15;
  seq_nt16_table[226] = (unsigned char)15;
  seq_nt16_table[227] = (unsigned char)15;
  seq_nt16_table[228] = (unsigned char)15;
  seq_nt16_table[229] = (unsigned char)15;
  seq_nt16_table[230] = (unsigned char)15;
  seq_nt16_table[231] = (unsigned char)15;
  seq_nt16_table[232] = (unsigned char)15;
  seq_nt16_table[233] = (unsigned char)15;
  seq_nt16_table[234] = (unsigned char)15;
  seq_nt16_table[235] = (unsigned char)15;
  seq_nt16_table[236] = (unsigned char)15;
  seq_nt16_table[237] = (unsigned char)15;
  seq_nt16_table[238] = (unsigned char)15;
  seq_nt16_table[239] = (unsigned char)15;
  seq_nt16_table[240] = (unsigned char)15;
  seq_nt16_table[241] = (unsigned char)15;
  seq_nt16_table[242] = (unsigned char)15;
  seq_nt16_table[243] = (unsigned char)15;
  seq_nt16_table[244] = (unsigned char)15;
  seq_nt16_table[245] = (unsigned char)15;
  seq_nt16_table[246] = (unsigned char)15;
  seq_nt16_table[247] = (unsigned char)15;
  seq_nt16_table[248] = (unsigned char)15;
  seq_nt16_table[249] = (unsigned char)15;
  seq_nt16_table[250] = (unsigned char)15;
  seq_nt16_table[251] = (unsigned char)15;
  seq_nt16_table[252] = (unsigned char)15;
  seq_nt16_table[253] = (unsigned char)15;
  seq_nt16_table[254] = (unsigned char)15;
  seq_nt16_table[255] = (unsigned char)15;
  goto seq_nt16_table_i$nit_INLINE_seq_nt16_table_i$nit;
  }
  seq_nt16_table_i$nit_INLINE_seq_nt16_table_i$nit: /* CIL Label */ ;
  }
  {
  {
  __ac_HASH_UPPER = (double const   )0.77;
  goto __ac_HASH_UPPER_i$nit_INLINE___ac_HASH_UPPER_i$nit;
  }
  __ac_HASH_UPPER_i$nit_INLINE___ac_HASH_UPPER_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_envp_i$nit_INLINE__global_envp_i$nit;
  }
  _global_envp_i$nit_INLINE__global_envp_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argv_i$nit_INLINE__global_argv_i$nit;
  }
  _global_argv_i$nit_INLINE__global_argv_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argc_i$nit_INLINE__global_argc_i$nit;
  }
  _global_argc_i$nit_INLINE__global_argc_i$nit: /* CIL Label */ ;
  }
  goto megaInit_INLINE_megaInit;
  }
  megaInit_INLINE_megaInit: /* CIL Label */ ;
  }
  _global_argc = argc;
  _global_argv = argv;
  _global_envp = _formal_envp;
  _BARRIER_0 = 1;
  {
  _1_main_next = 19U;
  }
  while (1) {
    switch (_1_main_next) {
    case 50: ;
    if (tmp___29 == 0) {
      {
      _1_main_next = 76U;
      }
    } else {
      {
      _1_main_next = 68U;
      }
    }
    break;
    case 80: ;
    return (tmp___18);
    break;
    case 25: ;
    if (tmp___24 == 0) {
      {
      _1_main_next = 53U;
      }
    } else {
      {
      _1_main_next = 0U;
      }
    }
    break;
    case 49: ;
    if (tmp___32 == 0) {
      {
      _1_main_next = 3U;
      }
    } else {
      {
      _1_main_next = 46U;
      }
    }
    break;
    case 52: ;
    return (tmp___6);
    break;
    case 4: ;
    return (tmp___4);
    break;
    case 30: 
    tmp___22 = strcmp((char const   *)*(argv + 1), "sample");
    {
    _1_main_next = 8U;
    }
    break;
    case 62: 
    tmp___9 = stk_randbase(argc - 1, argv + 1);
    {
    _1_main_next = 67U;
    }
    break;
    case 14: 
    tmp = usage();
    {
    _1_main_next = 38U;
    }
    break;
    case 15: 
    tmp___15 = stk_sample(argc - 1, argv + 1);
    {
    _1_main_next = 79U;
    }
    break;
    case 82: 
    tmp___11 = stk_listhet(argc - 1, argv + 1);
    {
    _1_main_next = 39U;
    }
    break;
    case 56: 
    tmp___10 = stk_cutN(argc - 1, argv + 1);
    {
    _1_main_next = 57U;
    }
    break;
    case 79: ;
    return (tmp___15);
    break;
    case 31: 
    tmp___34 = strcmp((char const   *)*(argv + 1), "gc");
    {
    _1_main_next = 77U;
    }
    break;
    case 12: ;
    if (tmp___25 == 0) {
      {
      _1_main_next = 29U;
      }
    } else {
      {
      _1_main_next = 13U;
      }
    }
    break;
    case 69: 
    tmp___29 = strcmp((char const   *)*(argv + 1), "dropse");
    {
    _1_main_next = 50U;
    }
    break;
    case 8: ;
    if (tmp___22 == 0) {
      {
      _1_main_next = 15U;
      }
    } else {
      {
      _1_main_next = 74U;
      }
    }
    break;
    case 45: ;
    if (tmp___21 == 0) {
      {
      _1_main_next = 22U;
      }
    } else {
      {
      _1_main_next = 7U;
      }
    }
    break;
    case 54: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[main] unrecognized command \'%s\'. Abort!\n",
            *(argv + 1));
    {
    _1_main_next = 5U;
    }
    break;
    case 78: 
    tmp___3 = stk_gc(argc - 1, argv + 1);
    {
    _1_main_next = 20U;
    }
    break;
    case 1: ;
    if (tmp___19 == 0) {
      {
      _1_main_next = 51U;
      }
    } else {
      {
      _1_main_next = 54U;
      }
    }
    break;
    case 81: ;
    if (tmp___31 == 0) {
      {
      _1_main_next = 66U;
      }
    } else {
      {
      _1_main_next = 40U;
      }
    }
    break;
    case 23: ;
    if (tmp___36 == 0) {
      {
      _1_main_next = 16U;
      }
    } else {
      {
      _1_main_next = 9U;
      }
    }
    break;
    case 77: ;
    if (tmp___34 == 0) {
      {
      _1_main_next = 78U;
      }
    } else {
      {
      _1_main_next = 44U;
      }
    }
    break;
    case 70: ;
    if (tmp___35 == 0) {
      {
      _1_main_next = 58U;
      }
    } else {
      {
      _1_main_next = 31U;
      }
    }
    break;
    case 3: 
    tmp___5 = stk_mutfa(argc - 1, argv + 1);
    {
    _1_main_next = 65U;
    }
    break;
    case 16: 
    tmp___1 = stk_fqchk(argc - 1, argv + 1);
    {
    _1_main_next = 10U;
    }
    break;
    case 24: 
    tmp___26 = strcmp((char const   *)*(argv + 1), "listhet");
    {
    _1_main_next = 36U;
    }
    break;
    case 21: 
    tmp___7 = stk_mergepe(argc - 1, argv + 1);
    {
    _1_main_next = 59U;
    }
    break;
    case 36: ;
    if (tmp___26 == 0) {
      {
      _1_main_next = 82U;
      }
    } else {
      {
      _1_main_next = 63U;
      }
    }
    break;
    case 76: 
    tmp___8 = stk_dropse(argc - 1, argv + 1);
    {
    _1_main_next = 11U;
    }
    break;
    case 57: ;
    return (tmp___10);
    break;
    case 68: 
    tmp___28 = strcmp((char const   *)*(argv + 1), "randbase");
    {
    _1_main_next = 6U;
    }
    break;
    case 26: ;
    if (argc == 1) {
      {
      _1_main_next = 14U;
      }
    } else {
      {
      _1_main_next = 34U;
      }
    }
    break;
    case 11: ;
    return (tmp___8);
    break;
    case 9: 
    tmp___35 = strcmp((char const   *)*(argv + 1), "hety");
    {
    _1_main_next = 70U;
    }
    break;
    case 13: 
    tmp___24 = strcmp((char const   *)*(argv + 1), "trimfq");
    {
    _1_main_next = 25U;
    }
    break;
    case 63: 
    tmp___25 = strcmp((char const   *)*(argv + 1), "famask");
    {
    _1_main_next = 12U;
    }
    break;
    case 51: 
    tmp___18 = stk_rename(argc - 1, argv + 1);
    {
    _1_main_next = 80U;
    }
    break;
    case 19: 
    optind = 1;
    {
    _1_main_next = 26U;
    }
    break;
    case 32: 
    tmp___19 = strcmp((char const   *)*(argv + 1), "rename");
    {
    _1_main_next = 1U;
    }
    break;
    case 17: 
    tmp___27 = strcmp((char const   *)*(argv + 1), "cutN");
    {
    _1_main_next = 55U;
    }
    break;
    case 40: 
    tmp___30 = strcmp((char const   *)*(argv + 1), "mergepe");
    {
    _1_main_next = 33U;
    }
    break;
    case 67: ;
    return (tmp___9);
    break;
    case 55: ;
    if (tmp___27 == 0) {
      {
      _1_main_next = 56U;
      }
    } else {
      {
      _1_main_next = 24U;
      }
    }
    break;
    case 60: ;
    return (tmp___2);
    break;
    case 59: ;
    return (tmp___7);
    break;
    case 6: ;
    if (tmp___28 == 0) {
      {
      _1_main_next = 62U;
      }
    } else {
      {
      _1_main_next = 17U;
      }
    }
    break;
    case 27: ;
    return (tmp___14);
    break;
    case 38: ;
    return (tmp);
    break;
    case 61: ;
    if (tmp___37 == 0) {
      {
      _1_main_next = 72U;
      }
    } else {
      {
      _1_main_next = 48U;
      }
    }
    break;
    case 58: 
    tmp___2 = stk_hety(argc - 1, argv + 1);
    {
    _1_main_next = 60U;
    }
    break;
    case 34: 
    tmp___37 = strcmp((char const   *)*(argv + 1), "comp");
    {
    _1_main_next = 61U;
    }
    break;
    case 74: 
    tmp___21 = strcmp((char const   *)*(argv + 1), "seq");
    {
    _1_main_next = 45U;
    }
    break;
    case 75: 
    tmp___32 = strcmp((char const   *)*(argv + 1), "mutfa");
    {
    _1_main_next = 49U;
    }
    break;
    case 48: 
    tmp___36 = strcmp((char const   *)*(argv + 1), "fqchk");
    {
    _1_main_next = 23U;
    }
    break;
    case 71: ;
    if (tmp___20 == 0) {
      {
      _1_main_next = 47U;
      }
    } else {
      {
      _1_main_next = 32U;
      }
    }
    break;
    case 22: 
    tmp___16 = stk_seq(argc - 1, argv + 1);
    {
    _1_main_next = 2U;
    }
    break;
    case 28: ;
    if (tmp___33 == 0) {
      {
      _1_main_next = 37U;
      }
    } else {
      {
      _1_main_next = 75U;
      }
    }
    break;
    case 53: 
    tmp___13 = stk_trimfq(argc - 1, argv + 1);
    {
    _1_main_next = 42U;
    }
    break;
    case 65: ;
    return (tmp___5);
    break;
    case 47: 
    tmp___17 = stk_kfreq(argc - 1, argv + 1);
    {
    _1_main_next = 64U;
    }
    break;
    case 73: ;
    return (tmp___12);
    break;
    case 44: 
    tmp___33 = strcmp((char const   *)*(argv + 1), "subseq");
    {
    _1_main_next = 28U;
    }
    break;
    case 5: ;
    return (1);
    break;
    case 72: 
    tmp___0 = stk_comp(argc - 1, argv + 1);
    {
    _1_main_next = 41U;
    }
    break;
    case 33: ;
    if (tmp___30 == 0) {
      {
      _1_main_next = 21U;
      }
    } else {
      {
      _1_main_next = 69U;
      }
    }
    break;
    case 37: 
    tmp___4 = stk_subseq(argc - 1, argv + 1);
    {
    _1_main_next = 4U;
    }
    break;
    case 64: ;
    return (tmp___17);
    break;
    case 41: ;
    return (tmp___0);
    break;
    case 10: ;
    return (tmp___1);
    break;
    case 42: ;
    return (tmp___13);
    break;
    case 0: 
    tmp___23 = strcmp((char const   *)*(argv + 1), "hrun");
    {
    _1_main_next = 35U;
    }
    break;
    case 46: 
    tmp___31 = strcmp((char const   *)*(argv + 1), "mergefa");
    {
    _1_main_next = 81U;
    }
    break;
    case 39: ;
    return (tmp___11);
    break;
    case 66: 
    tmp___6 = stk_mergefa(argc - 1, argv + 1);
    {
    _1_main_next = 52U;
    }
    break;
    case 7: 
    tmp___20 = strcmp((char const   *)*(argv + 1), "kfreq");
    {
    _1_main_next = 71U;
    }
    break;
    case 35: ;
    if (tmp___23 == 0) {
      {
      _1_main_next = 43U;
      }
    } else {
      {
      _1_main_next = 30U;
      }
    }
    break;
    case 29: 
    tmp___12 = stk_famask(argc - 1, argv + 1);
    {
    _1_main_next = 73U;
    }
    break;
    case 43: 
    tmp___14 = stk_hrun(argc - 1, argv + 1);
    {
    _1_main_next = 27U;
    }
    break;
    case 2: ;
    return (tmp___16);
    break;
    case 20: ;
    return (tmp___3);
    break;
    }
  }
}
}
/* END FUNCTION-DEF main LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cpy_kstr LOC=UNKNOWN */
static void cpy_kstr(kstring_t *dst , kstring_t const   *src ) 
{ 
  void *tmp ;
  unsigned int _1_cpy_kstr_next ;

  {
  {
  _1_cpy_kstr_next = 1U;
  }
  while (1) {
    switch (_1_cpy_kstr_next) {
    case 4: 
    dst->m = (size_t___0 )(src->l + 1UL);
    (dst->m) --;
    dst->m |= dst->m >> 1;
    dst->m |= dst->m >> 2;
    dst->m |= dst->m >> 4;
    dst->m |= dst->m >> 8;
    dst->m |= dst->m >> 16;
    (dst->m) ++;
    tmp = realloc((void *)dst->s, dst->m);
    dst->s = (char *)tmp;
    {
    _1_cpy_kstr_next = 5U;
    }
    break;
    case 1: ;
    if (src->l == 0UL) {
      {
      _1_cpy_kstr_next = 3U;
      }
    } else {
      {
      _1_cpy_kstr_next = 2U;
      }
    }
    break;
    case 3: ;
    return;
    break;
    case 5: 
    dst->l = (size_t___0 )src->l;
    memcpy((void */* __restrict  */)dst->s, (void const   */* __restrict  */)src->s,
           (size_t___0 )(src->l + 1UL));
    {
    _1_cpy_kstr_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    case 2: ;
    if (src->l + 1UL > (size_t___0 const   )dst->m) {
      {
      _1_cpy_kstr_next = 4U;
      }
    } else {
      {
      _1_cpy_kstr_next = 5U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cpy_kstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_printstr LOC=UNKNOWN */
static void stk_printstr(kstring_t const   *s , unsigned int line_len ) 
{ 
  int i ;
  int rest ;
  unsigned int _1_stk_printstr_next ;

  {
  {
  _1_stk_printstr_next = 1U;
  }
  while (1) {
    switch (_1_stk_printstr_next) {
    case 14: 
    i = (int )((unsigned int )i + line_len);
    rest = (int )((unsigned int )rest - line_len);
    {
    _1_stk_printstr_next = 6U;
    }
    break;
    case 12: ;
    return;
    break;
    case 8: 
    fwrite((void const   */* __restrict  */)(s->s + i), (size_t___0 )1, (size_t___0 )line_len,
           (FILE */* __restrict  */)stdout);
    {
    _1_stk_printstr_next = 14U;
    }
    break;
    case 1: ;
    if (line_len != 4294967295U) {
      {
      _1_stk_printstr_next = 2U;
      }
    } else {
      {
      _1_stk_printstr_next = 13U;
      }
    }
    break;
    case 3: 
    putchar('\n');
    puts((char const   *)s->s);
    {
    _1_stk_printstr_next = 12U;
    }
    break;
    case 11: 
    rest = (int )s->l;
    i = 0;
    {
    _1_stk_printstr_next = 6U;
    }
    break;
    case 9: ;
    if ((unsigned int )rest > line_len) {
      {
      _1_stk_printstr_next = 8U;
      }
    } else {
      {
      _1_stk_printstr_next = 7U;
      }
    }
    break;
    case 13: 
    putchar('\n');
    puts((char const   *)s->s);
    {
    _1_stk_printstr_next = 12U;
    }
    break;
    case 6: ;
    if ((size_t___0 )i < (size_t___0 )s->l) {
      {
      _1_stk_printstr_next = 10U;
      }
    } else {
      {
      _1_stk_printstr_next = 0U;
      }
    }
    break;
    case 10: 
    putchar('\n');
    {
    _1_stk_printstr_next = 9U;
    }
    break;
    case 0: 
    putchar('\n');
    {
    _1_stk_printstr_next = 12U;
    }
    break;
    case 7: 
    fwrite((void const   */* __restrict  */)(s->s + i), (size_t___0 )1, (size_t___0 )rest,
           (FILE */* __restrict  */)stdout);
    {
    _1_stk_printstr_next = 14U;
    }
    break;
    case 2: ;
    if (line_len != 0U) {
      {
      _1_stk_printstr_next = 11U;
      }
    } else {
      {
      _1_stk_printstr_next = 3U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_printstr LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kseq_destroy LOC=UNKNOWN */
static void kseq_destroy(kseq_t *ks ) 
{ 
  unsigned int _1_kseq_destroy_next ;

  {
  {
  _1_kseq_destroy_next = 1U;
  }
  while (1) {
    switch (_1_kseq_destroy_next) {
    case 1: ;
    if (! ks) {
      {
      _1_kseq_destroy_next = 0U;
      }
    } else {
      {
      _1_kseq_destroy_next = 2U;
      }
    }
    break;
    case 3: ;
    return;
    break;
    case 0: ;
    return;
    break;
    case 2: 
    free((void *)ks->name.s);
    free((void *)ks->comment.s);
    free((void *)ks->seq.s);
    free((void *)ks->qual.s);
    ks_destroy(ks->f);
    free((void *)ks);
    {
    _1_kseq_destroy_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kseq_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF print_seq LOC=UNKNOWN */
static void print_seq(FILE *fpout , kseq_t const   *ks , int begin , int end ) 
{ 
  int i ;
  int tmp ;
  unsigned int _1_print_seq_next ;

  {
  {
  _1_print_seq_next = 26U;
  }
  while (1) {
    switch (_1_print_seq_next) {
    case 25: 
    fputc((int )*(ks->seq.s + i), fpout);
    i ++;
    {
    _1_print_seq_next = 5U;
    }
    break;
    case 4: 
    fputc('\n', fpout);
    {
    _1_print_seq_next = 0U;
    }
    break;
    case 14: ;
    if ((i - begin) % 60 == 0) {
      {
      _1_print_seq_next = 9U;
      }
    } else {
      {
      _1_print_seq_next = 25U;
      }
    }
    break;
    case 15: ;
    if (! ((size_t___0 )i < (size_t___0 )ks->seq.l)) {
      {
      _1_print_seq_next = 24U;
      }
    } else {
      {
      _1_print_seq_next = 14U;
      }
    }
    break;
    case 12: ;
    if (i < end) {
      {
      _1_print_seq_next = 19U;
      }
    } else {
      {
      _1_print_seq_next = 16U;
      }
    }
    break;
    case 1: ;
    if (ks->qual.l == 0UL) {
      {
      _1_print_seq_next = 2U;
      }
    } else {
      {
      _1_print_seq_next = 3U;
      }
    }
    break;
    case 23: ;
    if ((i - begin) % 60 == 0) {
      {
      _1_print_seq_next = 4U;
      }
    } else {
      {
      _1_print_seq_next = 0U;
      }
    }
    break;
    case 3: 
    fputs((char const   */* __restrict  */)"+\n", (FILE */* __restrict  */)fpout);
    i = begin;
    {
    _1_print_seq_next = 12U;
    }
    break;
    case 16: 
    fputc('\n', fpout);
    {
    _1_print_seq_next = 7U;
    }
    break;
    case 24: 
    fputc('\n', fpout);
    {
    _1_print_seq_next = 1U;
    }
    break;
    case 21: 
    fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%c%s:%d-%d",
            tmp, ks->name.s, begin + 1, end);
    i = begin;
    {
    _1_print_seq_next = 5U;
    }
    break;
    case 26: ;
    if (begin >= end) {
      {
      _1_print_seq_next = 27U;
      }
    } else {
      {
      _1_print_seq_next = 6U;
      }
    }
    break;
    case 11: 
    tmp = '@';
    {
    _1_print_seq_next = 21U;
    }
    break;
    case 9: 
    fputc('\n', fpout);
    {
    _1_print_seq_next = 25U;
    }
    break;
    case 19: ;
    if (! ((size_t___0 )i < (size_t___0 )ks->qual.l)) {
      {
      _1_print_seq_next = 16U;
      }
    } else {
      {
      _1_print_seq_next = 23U;
      }
    }
    break;
    case 17: 
    tmp = '>';
    {
    _1_print_seq_next = 21U;
    }
    break;
    case 6: ;
    if (ks->qual.l) {
      {
      _1_print_seq_next = 11U;
      }
    } else {
      {
      _1_print_seq_next = 17U;
      }
    }
    break;
    case 27: ;
    return;
    break;
    case 5: ;
    if (i < end) {
      {
      _1_print_seq_next = 15U;
      }
    } else {
      {
      _1_print_seq_next = 24U;
      }
    }
    break;
    case 0: 
    fputc((int )*(ks->qual.s + i), fpout);
    i ++;
    {
    _1_print_seq_next = 12U;
    }
    break;
    case 7: ;
    return;
    break;
    case 2: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF print_seq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_destroy_64 LOC=UNKNOWN */
__inline static void kh_destroy_64(kh_64_t *h ) 
{ 
  unsigned int _1_kh_destroy_64_next ;

  {
  {
  _1_kh_destroy_64_next = 2U;
  }
  while (1) {
    switch (_1_kh_destroy_64_next) {
    case 1: 
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
    {
    _1_kh_destroy_64_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    case 2: ;
    if (h) {
      {
      _1_kh_destroy_64_next = 1U;
      }
    } else {
      {
      _1_kh_destroy_64_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_destroy_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_fqchk LOC=UNKNOWN */
int stk_fqchk(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int i ;
  int c ;
  int k ;
  int max_len ;
  int min_len ;
  int max_alloc ;
  int offset ;
  int n_diffQ ;
  int qthres ;
  int64_t tot_len ;
  int64_t n ;
  double perr[94] ;
  posstat_t all ;
  posstat_t *pos ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int old_max ;
  void *tmp___4 ;
  int q ;
  int b ;
  int tmp___5 ;
  unsigned int _1_stk_fqchk_next ;

  {
  {
  _1_stk_fqchk_next = 86U;
  }
  while (1) {
    switch (_1_stk_fqchk_next) {
    case 18: 
    ((pos + i)->q[q]) ++;
    ((pos + i)->b[b]) ++;
    i ++;
    {
    _1_stk_fqchk_next = 81U;
    }
    break;
    case 50: 
    tmp___5 = kseq_read(seq);
    {
    _1_stk_fqchk_next = 9U;
    }
    break;
    case 80: 
    i = 0;
    {
    _1_stk_fqchk_next = 81U;
    }
    break;
    case 49: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk fqchk [-q %d] <in.fq>\n",
            qthres);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: use -q0 to get the distribution of all quality values\n");
    {
    _1_stk_fqchk_next = 60U;
    }
    break;
    case 52: ;
    if (i < max_len) {
      {
      _1_stk_fqchk_next = 17U;
      }
    } else {
      {
      _1_stk_fqchk_next = 2U;
      }
    }
    break;
    case 4: ;
    if (all.q[k]) {
      {
      _1_stk_fqchk_next = 59U;
      }
    } else {
      {
      _1_stk_fqchk_next = 31U;
      }
    }
    break;
    case 30: ;
    if (k <= 93) {
      {
      _1_stk_fqchk_next = 26U;
      }
    } else {
      {
      _1_stk_fqchk_next = 74U;
      }
    }
    break;
    case 62: ;
    return (0);
    break;
    case 14: 
    perr[3] = .5;
    perr[2] = perr[3];
    perr[1] = perr[2];
    perr[0] = perr[1];
    {
    _1_stk_fqchk_next = 50U;
    }
    break;
    case 15: 
    q = (int )*(seq->qual.s + i) - offset;
    b = (int )seq_nt6_table[(int )*(seq->seq.s + i)];
    {
    _1_stk_fqchk_next = 5U;
    }
    break;
    case 82: 
    b = 4;
    {
    _1_stk_fqchk_next = 39U;
    }
    break;
    case 56: 
    printf((char const   */* __restrict  */)"\t%%Q%d", k);
    {
    _1_stk_fqchk_next = 64U;
    }
    break;
    case 79: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_fqchk");
    {
    _1_stk_fqchk_next = 11U;
    }
    break;
    case 31: 
    k ++;
    {
    _1_stk_fqchk_next = 27U;
    }
    break;
    case 12: ;
    if (seq->qual.l == 0UL) {
      {
      _1_stk_fqchk_next = 50U;
      }
    } else {
      {
      _1_stk_fqchk_next = 67U;
      }
    }
    break;
    case 69: ;
    if (tmp___3 == 0) {
      {
      _1_stk_fqchk_next = 41U;
      }
    } else {
      {
      _1_stk_fqchk_next = 72U;
      }
    }
    break;
    case 8: 
    putchar('\n');
    fqc_aux(& all, 0, all.q, perr, qthres);
    i = 0;
    {
    _1_stk_fqchk_next = 52U;
    }
    break;
    case 45: 
    printf((char const   */* __restrict  */)"\t%%low\t%%high");
    {
    _1_stk_fqchk_next = 8U;
    }
    break;
    case 54: ;
    if (k <= 93) {
      {
      _1_stk_fqchk_next = 43U;
      }
    } else {
      {
      _1_stk_fqchk_next = 14U;
      }
    }
    break;
    case 78: 
    min_len = min_len;
    {
    _1_stk_fqchk_next = 73U;
    }
    break;
    case 1: ;
    if (max_len > max_alloc) {
      {
      _1_stk_fqchk_next = 36U;
      }
    } else {
      {
      _1_stk_fqchk_next = 80U;
      }
    }
    break;
    case 81: ;
    if ((size_t___0 )i < seq->qual.l) {
      {
      _1_stk_fqchk_next = 15U;
      }
    } else {
      {
      _1_stk_fqchk_next = 50U;
      }
    }
    break;
    case 23: ;
    if ((size_t___0 )min_len < seq->seq.l) {
      {
      _1_stk_fqchk_next = 78U;
      }
    } else {
      {
      _1_stk_fqchk_next = 21U;
      }
    }
    break;
    case 77: ;
    if (k <= 93) {
      {
      _1_stk_fqchk_next = 63U;
      }
    } else {
      {
      _1_stk_fqchk_next = 8U;
      }
    }
    break;
    case 70: 
    n_diffQ = 0;
    k = n_diffQ;
    {
    _1_stk_fqchk_next = 27U;
    }
    break;
    case 3: ;
    if (c == 113) {
      {
      _1_stk_fqchk_next = 6U;
      }
    } else {
      {
      _1_stk_fqchk_next = 29U;
      }
    }
    break;
    case 16: ;
    if (i < max_len) {
      {
      _1_stk_fqchk_next = 65U;
      }
    } else {
      {
      _1_stk_fqchk_next = 70U;
      }
    }
    break;
    case 24: 
    b --;
    {
    _1_stk_fqchk_next = 39U;
    }
    break;
    case 21: 
    min_len = (int )seq->seq.l;
    {
    _1_stk_fqchk_next = 73U;
    }
    break;
    case 36: 
    old_max = max_alloc;
    max_alloc = max_len;
    max_alloc --;
    max_alloc |= max_alloc >> 1;
    max_alloc |= max_alloc >> 2;
    max_alloc |= max_alloc >> 4;
    max_alloc |= max_alloc >> 8;
    max_alloc |= max_alloc >> 16;
    max_alloc ++;
    tmp___4 = realloc((void *)pos, (unsigned long )max_alloc * sizeof(posstat_t ));
    pos = (posstat_t *)tmp___4;
    memset((void *)(pos + old_max), 0, (unsigned long )(max_alloc - old_max) * sizeof(posstat_t ));
    {
    _1_stk_fqchk_next = 80U;
    }
    break;
    case 76: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_fqchk_next = 79U;
      }
    } else {
      {
      _1_stk_fqchk_next = 28U;
      }
    }
    break;
    case 85: 
    tmp___3 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_fqchk_next = 69U;
    }
    break;
    case 26: 
    all.q[k] += (pos + i)->q[k];
    k ++;
    {
    _1_stk_fqchk_next = 30U;
    }
    break;
    case 11: ;
    return (1);
    break;
    case 9: ;
    if (! (tmp___5 >= 0)) {
      {
      _1_stk_fqchk_next = 88U;
      }
    } else {
      {
      _1_stk_fqchk_next = 12U;
      }
    }
    break;
    case 13: 
    max_len = (int )seq->seq.l;
    {
    _1_stk_fqchk_next = 1U;
    }
    break;
    case 63: ;
    if (all.q[k] > 0LL) {
      {
      _1_stk_fqchk_next = 56U;
      }
    } else {
      {
      _1_stk_fqchk_next = 64U;
      }
    }
    break;
    case 19: 
    all.b[k] += (pos + i)->b[k];
    k ++;
    {
    _1_stk_fqchk_next = 84U;
    }
    break;
    case 32: ;
    if (optind == argc) {
      {
      _1_stk_fqchk_next = 49U;
      }
    } else {
      {
      _1_stk_fqchk_next = 85U;
      }
    }
    break;
    case 17: 
    fqc_aux(pos + i, i + 1, all.q, perr, qthres);
    i ++;
    {
    _1_stk_fqchk_next = 52U;
    }
    break;
    case 67: 
    n ++;
    tot_len = (int64_t )((unsigned long long )tot_len + (unsigned long long )seq->seq.l);
    {
    _1_stk_fqchk_next = 23U;
    }
    break;
    case 55: 
    q = q;
    {
    _1_stk_fqchk_next = 18U;
    }
    break;
    case 60: ;
    return (1);
    break;
    case 59: 
    n_diffQ ++;
    {
    _1_stk_fqchk_next = 31U;
    }
    break;
    case 6: 
    qthres = atoi((char const   *)optarg);
    {
    _1_stk_fqchk_next = 29U;
    }
    break;
    case 27: ;
    if (k <= 93) {
      {
      _1_stk_fqchk_next = 4U;
      }
    } else {
      {
      _1_stk_fqchk_next = 7U;
      }
    }
    break;
    case 84: ;
    if (k <= 4) {
      {
      _1_stk_fqchk_next = 19U;
      }
    } else {
      {
      _1_stk_fqchk_next = 44U;
      }
    }
    break;
    case 74: 
    k = 0;
    {
    _1_stk_fqchk_next = 84U;
    }
    break;
    case 28: 
    seq = kseq_init(fp);
    k = 0;
    {
    _1_stk_fqchk_next = 54U;
    }
    break;
    case 53: 
    max_len = max_len;
    {
    _1_stk_fqchk_next = 1U;
    }
    break;
    case 65: 
    k = 0;
    {
    _1_stk_fqchk_next = 30U;
    }
    break;
    case 73: ;
    if ((size_t___0 )max_len > seq->seq.l) {
      {
      _1_stk_fqchk_next = 53U;
      }
    } else {
      {
      _1_stk_fqchk_next = 13U;
      }
    }
    break;
    case 44: 
    i ++;
    {
    _1_stk_fqchk_next = 16U;
    }
    break;
    case 5: ;
    if (b) {
      {
      _1_stk_fqchk_next = 24U;
      }
    } else {
      {
      _1_stk_fqchk_next = 82U;
      }
    }
    break;
    case 72: 
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
    {
    _1_stk_fqchk_next = 76U;
    }
    break;
    case 64: 
    k ++;
    {
    _1_stk_fqchk_next = 77U;
    }
    break;
    case 41: 
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
    {
    _1_stk_fqchk_next = 76U;
    }
    break;
    case 46: ;
    if (! (c >= 0)) {
      {
      _1_stk_fqchk_next = 32U;
      }
    } else {
      {
      _1_stk_fqchk_next = 3U;
      }
    }
    break;
    case 39: ;
    if (q < 93) {
      {
      _1_stk_fqchk_next = 55U;
      }
    } else {
      {
      _1_stk_fqchk_next = 83U;
      }
    }
    break;
    case 83: 
    q = 93;
    {
    _1_stk_fqchk_next = 18U;
    }
    break;
    case 7: 
    printf((char const   */* __restrict  */)"min_len: %d; max_len: %d; avg_len: %.2f; %d distinct quality values\n",
           min_len, max_len, (double )tot_len / (double )n, n_diffQ);
    printf((char const   */* __restrict  */)"POS\t#bases\t%%A\t%%C\t%%G\t%%T\t%%N\tavgQ\terrQ");
    {
    _1_stk_fqchk_next = 35U;
    }
    break;
    case 88: 
    kseq_destroy(seq);
    gzclose(fp);
    memset((void *)(& all), 0, sizeof(posstat_t ));
    i = 0;
    {
    _1_stk_fqchk_next = 16U;
    }
    break;
    case 35: ;
    if (qthres <= 0) {
      {
      _1_stk_fqchk_next = 20U;
      }
    } else {
      {
      _1_stk_fqchk_next = 45U;
      }
    }
    break;
    case 29: 
    c = getopt(argc, argv, "q:");
    {
    _1_stk_fqchk_next = 46U;
    }
    break;
    case 43: 
    perr[k] = pow(10., - .1 * (double )k);
    k ++;
    {
    _1_stk_fqchk_next = 54U;
    }
    break;
    case 86: 
    max_len = 0;
    min_len = 2147483647;
    max_alloc = 0;
    offset = 33;
    n_diffQ = 0;
    qthres = 20;
    tot_len = (int64_t )0;
    n = (int64_t )0;
    pos = (posstat_t *)0;
    {
    _1_stk_fqchk_next = 29U;
    }
    break;
    case 2: 
    free((void *)pos);
    {
    _1_stk_fqchk_next = 62U;
    }
    break;
    case 20: 
    k = 0;
    {
    _1_stk_fqchk_next = 77U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_fqchk LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_getc LOC=UNKNOWN */
__inline static int ks_getc(kstream_t *ks ) 
{ 
  int tmp ;
  unsigned int _1_ks_getc_next ;

  {
  {
  _1_ks_getc_next = 13U;
  }
  while (1) {
    switch (_1_ks_getc_next) {
    case 4: ;
    return (-3);
    break;
    case 14: ;
    return ((int )*(ks->buf + tmp));
    break;
    case 12: ;
    if (ks->begin >= ks->end) {
      {
      _1_ks_getc_next = 8U;
      }
    } else {
      {
      _1_ks_getc_next = 0U;
      }
    }
    break;
    case 8: 
    ks->begin = 0;
    ks->end = gzread(ks->f, (voidp )ks->buf, 16384U);
    {
    _1_ks_getc_next = 11U;
    }
    break;
    case 1: ;
    return (-1);
    break;
    case 3: ;
    return (-1);
    break;
    case 11: ;
    if (ks->end == 0) {
      {
      _1_ks_getc_next = 5U;
      }
    } else {
      {
      _1_ks_getc_next = 7U;
      }
    }
    break;
    case 9: 
    ks->is_eof = 1;
    {
    _1_ks_getc_next = 10U;
    }
    break;
    case 13: ;
    if (ks->end < 0) {
      {
      _1_ks_getc_next = 4U;
      }
    } else {
      {
      _1_ks_getc_next = 2U;
      }
    }
    break;
    case 6: ;
    if (ks->begin >= ks->end) {
      {
      _1_ks_getc_next = 1U;
      }
    } else {
      {
      _1_ks_getc_next = 12U;
      }
    }
    break;
    case 5: 
    ks->is_eof = 1;
    {
    _1_ks_getc_next = 3U;
    }
    break;
    case 10: ;
    return (-3);
    break;
    case 0: 
    tmp = ks->begin;
    (ks->begin) ++;
    {
    _1_ks_getc_next = 14U;
    }
    break;
    case 7: ;
    if (ks->end < 0) {
      {
      _1_ks_getc_next = 9U;
      }
    } else {
      {
      _1_ks_getc_next = 0U;
      }
    }
    break;
    case 2: ;
    if (ks->is_eof) {
      {
      _1_ks_getc_next = 6U;
      }
    } else {
      {
      _1_ks_getc_next = 12U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF ks_getc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kr_srand0 LOC=UNKNOWN */
static void kr_srand0(krint64_t seed , krand_t *kr ) 
{ 
  unsigned int _1_kr_srand0_next ;

  {
  {
  _1_kr_srand0_next = 5U;
  }
  while (1) {
    switch (_1_kr_srand0_next) {
    case 4: ;
    return;
    break;
    case 1: ;
    if (kr->mti < 312) {
      {
      _1_kr_srand0_next = 0U;
      }
    } else {
      {
      _1_kr_srand0_next = 4U;
      }
    }
    break;
    case 5: 
    kr->mt[0] = seed;
    kr->mti = 1;
    {
    _1_kr_srand0_next = 1U;
    }
    break;
    case 0: 
    kr->mt[kr->mti] = 6364136223846793005ULL * (kr->mt[kr->mti - 1] ^ (kr->mt[kr->mti - 1] >> 62)) + (unsigned long long )kr->mti;
    (kr->mti) ++;
    {
    _1_kr_srand0_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kr_srand0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_mask LOC=UNKNOWN */
void stk_mask(kseq_t *seq , kh_reg_t const   *h , int is_complement , int mask_chr ) 
{ 
  unsigned int i ;
  unsigned int j ;
  khiter_t k ;
  int tmp ;
  reglist_t *p ;
  unsigned int beg ;
  unsigned int end ;
  int tmp___0 ;
  int8_t *mask ;
  void *tmp___1 ;
  unsigned int beg___0 ;
  unsigned int end___0 ;
  int tmp___2 ;
  unsigned int _1_stk_mask_next ;

  {
  {
  _1_stk_mask_next = 0U;
  }
  while (1) {
    switch (_1_stk_mask_next) {
    case 18: ;
    if ((size_t___0 )j < seq->seq.l) {
      {
      _1_stk_mask_next = 26U;
      }
    } else {
      {
      _1_stk_mask_next = 41U;
      }
    }
    break;
    case 4: 
    i ++;
    {
    _1_stk_mask_next = 39U;
    }
    break;
    case 62: 
    j = beg___0;
    {
    _1_stk_mask_next = 53U;
    }
    break;
    case 14: ;
    if (! mask_chr) {
      {
      _1_stk_mask_next = 24U;
      }
    } else {
      {
      _1_stk_mask_next = 63U;
      }
    }
    break;
    case 15: ;
    if (mask_chr) {
      {
      _1_stk_mask_next = 20U;
      }
    } else {
      {
      _1_stk_mask_next = 5U;
      }
    }
    break;
    case 56: ;
    if ((size_t___0 )end > seq->seq.l) {
      {
      _1_stk_mask_next = 16U;
      }
    } else {
      {
      _1_stk_mask_next = 14U;
      }
    }
    break;
    case 31: 
    beg___0 = (unsigned int )(*(p->a + i) >> 32);
    end___0 = (unsigned int )*(p->a + i);
    {
    _1_stk_mask_next = 45U;
    }
    break;
    case 12: ;
    if ((int )*(mask + j) == 0) {
      {
      _1_stk_mask_next = 47U;
      }
    } else {
      {
      _1_stk_mask_next = 6U;
      }
    }
    break;
    case 8: ;
    if (k == (khiter_t )h->n_buckets) {
      {
      _1_stk_mask_next = 38U;
      }
    } else {
      {
      _1_stk_mask_next = 2U;
      }
    }
    break;
    case 45: ;
    if ((size_t___0 )end___0 >= seq->seq.l) {
      {
      _1_stk_mask_next = 60U;
      }
    } else {
      {
      _1_stk_mask_next = 62U;
      }
    }
    break;
    case 16: 
    end = (unsigned int )seq->seq.l;
    {
    _1_stk_mask_next = 14U;
    }
    break;
    case 24: 
    j = beg;
    {
    _1_stk_mask_next = 32U;
    }
    break;
    case 57: 
    *(seq->seq.s + j) = (char )mask_chr;
    j ++;
    {
    _1_stk_mask_next = 44U;
    }
    break;
    case 26: 
    *(seq->seq.s + j) = (char )mask_chr;
    j ++;
    {
    _1_stk_mask_next = 18U;
    }
    break;
    case 11: 
    *(mask + j) = (int8_t )1;
    j ++;
    {
    _1_stk_mask_next = 53U;
    }
    break;
    case 9: 
    j = 0U;
    {
    _1_stk_mask_next = 18U;
    }
    break;
    case 13: ;
    if ((size_t___0 )beg >= seq->seq.l) {
      {
      _1_stk_mask_next = 22U;
      }
    } else {
      {
      _1_stk_mask_next = 56U;
      }
    }
    break;
    case 63: 
    j = beg;
    {
    _1_stk_mask_next = 44U;
    }
    break;
    case 51: ;
    if ((int )*(mask + j) == 0) {
      {
      _1_stk_mask_next = 61U;
      }
    } else {
      {
      _1_stk_mask_next = 58U;
      }
    }
    break;
    case 32: ;
    if (j < end) {
      {
      _1_stk_mask_next = 65U;
      }
    } else {
      {
      _1_stk_mask_next = 22U;
      }
    }
    break;
    case 17: ;
    if (mask_chr) {
      {
      _1_stk_mask_next = 9U;
      }
    } else {
      {
      _1_stk_mask_next = 33U;
      }
    }
    break;
    case 40: ;
    if (i < (unsigned int )p->n) {
      {
      _1_stk_mask_next = 43U;
      }
    } else {
      {
      _1_stk_mask_next = 41U;
      }
    }
    break;
    case 60: 
    end___0 = (unsigned int )seq->seq.l;
    {
    _1_stk_mask_next = 62U;
    }
    break;
    case 6: 
    j ++;
    {
    _1_stk_mask_next = 7U;
    }
    break;
    case 27: 
    free((void *)mask);
    {
    _1_stk_mask_next = 41U;
    }
    break;
    case 38: ;
    if (is_complement) {
      {
      _1_stk_mask_next = 17U;
      }
    } else {
      {
      _1_stk_mask_next = 41U;
      }
    }
    break;
    case 61: 
    tmp___2 = tolower((int )*(seq->seq.s + j));
    *(seq->seq.s + j) = (char )tmp___2;
    {
    _1_stk_mask_next = 58U;
    }
    break;
    case 58: 
    j ++;
    {
    _1_stk_mask_next = 37U;
    }
    break;
    case 48: 
    tmp = tolower((int )*(seq->seq.s + j));
    *(seq->seq.s + j) = (char )tmp;
    j ++;
    {
    _1_stk_mask_next = 10U;
    }
    break;
    case 22: 
    __Cont: 
    i ++;
    {
    _1_stk_mask_next = 40U;
    }
    break;
    case 53: ;
    if (j < end___0) {
      {
      _1_stk_mask_next = 11U;
      }
    } else {
      {
      _1_stk_mask_next = 4U;
      }
    }
    break;
    case 65: 
    tmp___0 = tolower((int )*(seq->seq.s + j));
    *(seq->seq.s + j) = (char )tmp___0;
    j ++;
    {
    _1_stk_mask_next = 32U;
    }
    break;
    case 47: 
    *(seq->seq.s + j) = (char )mask_chr;
    {
    _1_stk_mask_next = 6U;
    }
    break;
    case 44: ;
    if (j < end) {
      {
      _1_stk_mask_next = 57U;
      }
    } else {
      {
      _1_stk_mask_next = 22U;
      }
    }
    break;
    case 5: 
    j = 0U;
    {
    _1_stk_mask_next = 37U;
    }
    break;
    case 33: 
    j = 0U;
    {
    _1_stk_mask_next = 10U;
    }
    break;
    case 37: ;
    if ((size_t___0 )j < seq->seq.l) {
      {
      _1_stk_mask_next = 51U;
      }
    } else {
      {
      _1_stk_mask_next = 27U;
      }
    }
    break;
    case 64: 
    tmp___1 = calloc(seq->seq.l, (size_t___0 )1);
    mask = (int8_t *)tmp___1;
    i = 0U;
    {
    _1_stk_mask_next = 39U;
    }
    break;
    case 41: ;
    return;
    break;
    case 10: ;
    if ((size_t___0 )j < seq->seq.l) {
      {
      _1_stk_mask_next = 48U;
      }
    } else {
      {
      _1_stk_mask_next = 41U;
      }
    }
    break;
    case 42: 
    i = 0U;
    {
    _1_stk_mask_next = 40U;
    }
    break;
    case 0: 
    k = kh_get_reg(h, (kh_cstr_t )seq->name.s);
    {
    _1_stk_mask_next = 8U;
    }
    break;
    case 39: ;
    if (i < (unsigned int )p->n) {
      {
      _1_stk_mask_next = 31U;
      }
    } else {
      {
      _1_stk_mask_next = 15U;
      }
    }
    break;
    case 7: ;
    if ((size_t___0 )j < seq->seq.l) {
      {
      _1_stk_mask_next = 12U;
      }
    } else {
      {
      _1_stk_mask_next = 27U;
      }
    }
    break;
    case 29: ;
    if (! is_complement) {
      {
      _1_stk_mask_next = 42U;
      }
    } else {
      {
      _1_stk_mask_next = 64U;
      }
    }
    break;
    case 43: 
    beg = (unsigned int )(*(p->a + i) >> 32);
    end = (unsigned int )*(p->a + i);
    {
    _1_stk_mask_next = 13U;
    }
    break;
    case 2: 
    p = (reglist_t *)(h->vals + k);
    {
    _1_stk_mask_next = 29U;
    }
    break;
    case 20: 
    j = 0U;
    {
    _1_stk_mask_next = 7U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_mask LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF find_next_cut LOC=UNKNOWN */
static int find_next_cut(kseq_t const   *ks , int k , int *begin , int *end ) 
{ 
  int i ;
  int b ;
  int e ;
  int score ;
  int max ;
  unsigned int _1_find_next_cut_next ;

  {
  {
  _1_find_next_cut_next = 14U;
  }
  while (1) {
    switch (_1_find_next_cut_next) {
    case 18: 
    score = 0;
    max = -1;
    b = max;
    i = e;
    {
    _1_find_next_cut_next = 30U;
    }
    break;
    case 4: ;
    if ((int )seq_nt16_table[(int )*(ks->seq.s + k)] == 15) {
      {
      _1_find_next_cut_next = 2U;
      }
    } else {
      {
      _1_find_next_cut_next = 5U;
      }
    }
    break;
    case 30: ;
    if (i >= 0) {
      {
      _1_find_next_cut_next = 13U;
      }
    } else {
      {
      _1_find_next_cut_next = 15U;
      }
    }
    break;
    case 14: ;
    {
    _1_find_next_cut_next = 12U;
    }
    break;
    case 15: ;
    if ((e + 1) - b >= cutN_min_N_tract) {
      {
      _1_find_next_cut_next = 17U;
      }
    } else {
      {
      _1_find_next_cut_next = 16U;
      }
    }
    break;
    case 31: ;
    return (-1);
    break;
    case 12: ;
    if ((size_t___0 )k < (size_t___0 )ks->seq.l) {
      {
      _1_find_next_cut_next = 4U;
      }
    } else {
      {
      _1_find_next_cut_next = 31U;
      }
    }
    break;
    case 1: ;
    if (score > max) {
      {
      _1_find_next_cut_next = 33U;
      }
    } else {
      {
      _1_find_next_cut_next = 11U;
      }
    }
    break;
    case 3: ;
    if ((size_t___0 )i < (size_t___0 )ks->seq.l) {
      {
      _1_find_next_cut_next = 21U;
      }
    } else {
      {
      _1_find_next_cut_next = 18U;
      }
    }
    break;
    case 16: 
    k = e + 1;
    {
    _1_find_next_cut_next = 12U;
    }
    break;
    case 24: 
    i --;
    {
    _1_find_next_cut_next = 30U;
    }
    break;
    case 21: ;
    if (! (score >= 0)) {
      {
      _1_find_next_cut_next = 18U;
      }
    } else {
      {
      _1_find_next_cut_next = 9U;
      }
    }
    break;
    case 26: 
    score ++;
    {
    _1_find_next_cut_next = 6U;
    }
    break;
    case 11: 
    i ++;
    {
    _1_find_next_cut_next = 3U;
    }
    break;
    case 9: ;
    if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
      {
      _1_find_next_cut_next = 27U;
      }
    } else {
      {
      _1_find_next_cut_next = 22U;
      }
    }
    break;
    case 13: ;
    if (! (score >= 0)) {
      {
      _1_find_next_cut_next = 15U;
      }
    } else {
      {
      _1_find_next_cut_next = 19U;
      }
    }
    break;
    case 19: ;
    if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
      {
      _1_find_next_cut_next = 26U;
      }
    } else {
      {
      _1_find_next_cut_next = 28U;
      }
    }
    break;
    case 17: 
    *begin = b;
    *end = e + 1;
    {
    _1_find_next_cut_next = 0U;
    }
    break;
    case 6: ;
    if (score > max) {
      {
      _1_find_next_cut_next = 29U;
      }
    } else {
      {
      _1_find_next_cut_next = 24U;
      }
    }
    break;
    case 27: 
    score ++;
    {
    _1_find_next_cut_next = 1U;
    }
    break;
    case 22: 
    score -= cutN_nonN_penalty;
    {
    _1_find_next_cut_next = 1U;
    }
    break;
    case 28: 
    score -= cutN_nonN_penalty;
    {
    _1_find_next_cut_next = 6U;
    }
    break;
    case 5: 
    k ++;
    {
    _1_find_next_cut_next = 12U;
    }
    break;
    case 33: 
    max = score;
    e = i;
    {
    _1_find_next_cut_next = 11U;
    }
    break;
    case 0: ;
    return (*end);
    break;
    case 29: 
    max = score;
    b = i;
    {
    _1_find_next_cut_next = 24U;
    }
    break;
    case 2: 
    score = 0;
    max = -1;
    e = max;
    i = k;
    {
    _1_find_next_cut_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF find_next_cut LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kr_srand LOC=UNKNOWN */
krand_t *kr_srand(krint64_t seed ) 
{ 
  krand_t *kr ;
  void *tmp ;
  unsigned int _1_kr_srand_next ;

  {
  {
  _1_kr_srand_next = 0U;
  }
  while (1) {
    switch (_1_kr_srand_next) {
    case 1: ;
    return (kr);
    break;
    case 0: 
    tmp = malloc(sizeof(krand_t ));
    kr = (krand_t *)tmp;
    kr_srand0(seed, kr);
    {
    _1_kr_srand_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kr_srand LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF usage LOC=UNKNOWN */
static int usage(void) 
{ 
  unsigned int _1_usage_next ;

  {
  {
  _1_usage_next = 0U;
  }
  while (1) {
    switch (_1_usage_next) {
    case 1: ;
    return (1);
    break;
    case 0: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk <command> <arguments>\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version: 1.3-r106\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Command: seq       common transformation of FASTA/Q\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         comp      get the nucleotide composition of FASTA/Q\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         sample    subsample sequences\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         subseq    extract subsequences from FASTA/Q\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         fqchk     fastq QC (base/quality summary)\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mergepe   interleave two PE FASTA/Q files\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         trimfq    trim FASTQ using the Phred algorithm\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         hety      regional heterozygosity\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         gc        identify high- or low-GC regions\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mutfa     point mutate FASTA at specified positions\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mergefa   merge two FASTA/Q files\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         famask    apply a X-coded FASTA to a source FASTA\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         dropse    drop unpaired from interleaved PE FASTA/Q\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         rename    rename sequence names\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         randbase  choose a random base from hets\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         cutN      cut sequence at long N\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         listhet   extract the position of each het\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    {
    _1_usage_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_destroy_reg LOC=UNKNOWN */
__inline static void kh_destroy_reg(kh_reg_t *h ) 
{ 
  unsigned int _1_kh_destroy_reg_next ;

  {
  {
  _1_kh_destroy_reg_next = 2U;
  }
  while (1) {
    switch (_1_kh_destroy_reg_next) {
    case 1: 
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
    {
    _1_kh_destroy_reg_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    case 2: ;
    if (h) {
      {
      _1_kh_destroy_reg_next = 1U;
      }
    } else {
      {
      _1_kh_destroy_reg_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_destroy_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_put_reg LOC=UNKNOWN */
__inline static khint_t kh_put_reg(kh_reg_t *h , kh_cstr_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  int tmp ;
  unsigned int _1_kh_put_reg_next ;

  {
  {
  _1_kh_put_reg_next = 27U;
  }
  while (1) {
    switch (_1_kh_put_reg_next) {
    case 18: 
    x = site;
    {
    _1_kh_put_reg_next = 30U;
    }
    break;
    case 25: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
      {
      _1_kh_put_reg_next = 4U;
      }
    } else {
      {
      _1_kh_put_reg_next = 11U;
      }
    }
    break;
    case 4: 
    x = i;
    {
    _1_kh_put_reg_next = 5U;
    }
    break;
    case 30: ;
    if (x == h->n_buckets) {
      {
      _1_kh_put_reg_next = 23U;
      }
    } else {
      {
      _1_kh_put_reg_next = 5U;
      }
    }
    break;
    case 15: ;
    if (i == last) {
      {
      _1_kh_put_reg_next = 18U;
      }
    } else {
      {
      _1_kh_put_reg_next = 24U;
      }
    }
    break;
    case 31: 
    x = i;
    {
    _1_kh_put_reg_next = 5U;
    }
    break;
    case 12: 
    kh_resize_reg(h, h->n_buckets + 1U);
    {
    _1_kh_put_reg_next = 0U;
    }
    break;
    case 8: ;
    if (tmp == 0) {
      {
      _1_kh_put_reg_next = 30U;
      }
    } else {
      {
      _1_kh_put_reg_next = 6U;
      }
    }
    break;
    case 1: 
    x = i;
    {
    _1_kh_put_reg_next = 5U;
    }
    break;
    case 23: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
      {
      _1_kh_put_reg_next = 13U;
      }
    } else {
      {
      _1_kh_put_reg_next = 1U;
      }
    }
    break;
    case 3: 
    site = i;
    {
    _1_kh_put_reg_next = 22U;
    }
    break;
    case 24: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
      {
      _1_kh_put_reg_next = 20U;
      }
    } else {
      {
      _1_kh_put_reg_next = 30U;
      }
    }
    break;
    case 26: 
    *ret = 0;
    {
    _1_kh_put_reg_next = 9U;
    }
    break;
    case 11: 
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    {
    _1_kh_put_reg_next = 24U;
    }
    break;
    case 9: ;
    return (x);
    break;
    case 13: ;
    if (site != h->n_buckets) {
      {
      _1_kh_put_reg_next = 29U;
      }
    } else {
      {
      _1_kh_put_reg_next = 31U;
      }
    }
    break;
    case 19: 
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
    {
    _1_kh_put_reg_next = 9U;
    }
    break;
    case 32: 
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
    {
    _1_kh_put_reg_next = 9U;
    }
    break;
    case 17: 
    kh_resize_reg(h, h->n_buckets - 1U);
    {
    _1_kh_put_reg_next = 0U;
    }
    break;
    case 6: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
      {
      _1_kh_put_reg_next = 3U;
      }
    } else {
      {
      _1_kh_put_reg_next = 22U;
      }
    }
    break;
    case 27: ;
    if (h->n_occupied >= h->upper_bound) {
      {
      _1_kh_put_reg_next = 7U;
      }
    } else {
      {
      _1_kh_put_reg_next = 0U;
      }
    }
    break;
    case 22: 
    i = (i + inc) & mask;
    {
    _1_kh_put_reg_next = 15U;
    }
    break;
    case 28: 
    tmp = strcmp(*(h->keys + i), key);
    {
    _1_kh_put_reg_next = 8U;
    }
    break;
    case 5: ;
    if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
      {
      _1_kh_put_reg_next = 32U;
      }
    } else {
      {
      _1_kh_put_reg_next = 2U;
      }
    }
    break;
    case 0: 
    mask = h->n_buckets - 1U;
    site = h->n_buckets;
    x = site;
    k = __ac_X31_hash_string(key);
    i = k & mask;
    {
    _1_kh_put_reg_next = 25U;
    }
    break;
    case 7: ;
    if (h->n_buckets > h->size << 1) {
      {
      _1_kh_put_reg_next = 17U;
      }
    } else {
      {
      _1_kh_put_reg_next = 12U;
      }
    }
    break;
    case 29: 
    x = site;
    {
    _1_kh_put_reg_next = 5U;
    }
    break;
    case 2: ;
    if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
      {
      _1_kh_put_reg_next = 19U;
      }
    } else {
      {
      _1_kh_put_reg_next = 26U;
      }
    }
    break;
    case 20: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
      {
      _1_kh_put_reg_next = 28U;
      }
    } else {
      {
      _1_kh_put_reg_next = 6U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_put_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_sample LOC=UNKNOWN */
int stk_sample(int argc , char **argv ) 
{ 
  int c ;
  int twopass ;
  uint64_t i ;
  uint64_t num ;
  uint64_t n_seqs ;
  double frac ;
  gzFile fp ;
  kseq_t *seq ;
  krand_t *kr ;
  long tmp ;
  kseq_t *buf ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  double r ;
  krint64_t tmp___6 ;
  uint64_t y ;
  uint64_t tmp___7 ;
  int tmp___8 ;
  kseq_t *p ;
  uint64_t *buf___0 ;
  kh_64_t *hash ;
  int absent ;
  int tmp___9 ;
  void *tmp___10 ;
  double r___0 ;
  krint64_t tmp___11 ;
  uint64_t y___0 ;
  int tmp___12 ;
  khint_t tmp___13 ;
  int tmp___14 ;
  unsigned int _1_stk_sample_next ;

  {
  {
  _1_stk_sample_next = 15U;
  }
  while (1) {
    switch (_1_stk_sample_next) {
    case 18: 
    free((void *)buf);
    {
    _1_stk_sample_next = 72U;
    }
    break;
    case 50: ;
    if (c == 50) {
      {
      _1_stk_sample_next = 79U;
      }
    } else {
      {
      _1_stk_sample_next = 11U;
      }
    }
    break;
    case 80: 
    kh_destroy_64(hash);
    {
    _1_stk_sample_next = 72U;
    }
    break;
    case 25: 
    y = tmp___7;
    {
    _1_stk_sample_next = 81U;
    }
    break;
    case 49: ;
    return (1);
    break;
    case 4: ;
    if (tmp___9 == 0) {
      {
      _1_stk_sample_next = 10U;
      }
    } else {
      {
      _1_stk_sample_next = 97U;
      }
    }
    break;
    case 30: 
    kh_put_64(hash, *(buf___0 + i), & absent);
    i ++;
    {
    _1_stk_sample_next = 19U;
    }
    break;
    case 14: 
    kseq_destroy(seq);
    gzclose(fp);
    hash = kh_init_64();
    i = (uint64_t )0;
    {
    _1_stk_sample_next = 19U;
    }
    break;
    case 15: 
    twopass = 0;
    num = (uint64_t )0;
    n_seqs = (uint64_t )0;
    frac = 0.;
    kr = (krand_t *)0;
    {
    _1_stk_sample_next = 11U;
    }
    break;
    case 82: ;
    if (r < frac) {
      {
      _1_stk_sample_next = 66U;
      }
    } else {
      {
      _1_stk_sample_next = 89U;
      }
    }
    break;
    case 89: 
    tmp___8 = kseq_read(seq);
    {
    _1_stk_sample_next = 91U;
    }
    break;
    case 56: 
    tmp = atol((char const   *)optarg);
    kr = kr_srand((krint64_t )tmp);
    {
    _1_stk_sample_next = 11U;
    }
    break;
    case 79: 
    twopass = 1;
    {
    _1_stk_sample_next = 11U;
    }
    break;
    case 12: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_sample_next = 68U;
      }
    } else {
      {
      _1_stk_sample_next = 38U;
      }
    }
    break;
    case 69: 
    fp = gzopen((char const   *)*(argv + optind), "r");
    {
    _1_stk_sample_next = 63U;
    }
    break;
    case 8: ;
    if (n_seqs - 1ULL < num) {
      {
      _1_stk_sample_next = 27U;
      }
    } else {
      {
      _1_stk_sample_next = 36U;
      }
    }
    break;
    case 96: 
    tmp___14 = kseq_read(seq);
    {
    _1_stk_sample_next = 51U;
    }
    break;
    case 45: 
    tmp___9 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_sample_next = 4U;
    }
    break;
    case 54: ;
    if (num) {
      {
      _1_stk_sample_next = 8U;
      }
    } else {
      {
      _1_stk_sample_next = 82U;
      }
    }
    break;
    case 1: ;
    if (y___0 < num) {
      {
      _1_stk_sample_next = 85U;
      }
    } else {
      {
      _1_stk_sample_next = 74U;
      }
    }
    break;
    case 81: ;
    if (y < num) {
      {
      _1_stk_sample_next = 70U;
      }
    } else {
      {
      _1_stk_sample_next = 89U;
      }
    }
    break;
    case 77: 
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
    {
    _1_stk_sample_next = 12U;
    }
    break;
    case 70: 
    cpy_kseq(buf + y, (kseq_t const   *)seq);
    {
    _1_stk_sample_next = 89U;
    }
    break;
    case 3: 
    p = buf + i;
    {
    _1_stk_sample_next = 44U;
    }
    break;
    case 16: 
    kr = kr_srand((krint64_t )11);
    {
    _1_stk_sample_next = 47U;
    }
    break;
    case 21: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk sample [-2] [-s seed=11] <in.fa> <frac>|<number>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -s INT       RNG seed [11]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -2           2-pass mode: twice as slow but with much reduced memory\n\n");
    {
    _1_stk_sample_next = 73U;
    }
    break;
    case 94: 
    tmp___0 = calloc((size_t___0 )num, sizeof(kseq_t ));
    buf = (kseq_t *)tmp___0;
    {
    _1_stk_sample_next = 76U;
    }
    break;
    case 36: 
    tmp___7 = (uint64_t )(r * (double )n_seqs);
    {
    _1_stk_sample_next = 25U;
    }
    break;
    case 76: ;
    if (num > 0ULL) {
      {
      _1_stk_sample_next = 46U;
      }
    } else {
      {
      _1_stk_sample_next = 26U;
      }
    }
    break;
    case 57: 
    i = (uint64_t )0;
    {
    _1_stk_sample_next = 55U;
    }
    break;
    case 68: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_sample");
    {
    _1_stk_sample_next = 49U;
    }
    break;
    case 85: 
    *(buf___0 + y___0) = n_seqs;
    {
    _1_stk_sample_next = 74U;
    }
    break;
    case 26: 
    tmp___5 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_sample_next = 29U;
    }
    break;
    case 98: ;
    if (i < num) {
      {
      _1_stk_sample_next = 86U;
      }
    } else {
      {
      _1_stk_sample_next = 69U;
      }
    }
    break;
    case 11: 
    c = getopt(argc, argv, "2s:");
    {
    _1_stk_sample_next = 53U;
    }
    break;
    case 9: ;
    if (twopass) {
      {
      _1_stk_sample_next = 83U;
      }
    } else {
      {
      _1_stk_sample_next = 35U;
      }
    }
    break;
    case 13: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_sample");
    {
    _1_stk_sample_next = 87U;
    }
    break;
    case 63: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_sample_next = 13U;
      }
    } else {
      {
      _1_stk_sample_next = 28U;
      }
    }
    break;
    case 51: ;
    if (! (tmp___14 >= 0)) {
      {
      _1_stk_sample_next = 80U;
      }
    } else {
      {
      _1_stk_sample_next = 64U;
      }
    }
    break;
    case 19: ;
    if (i < num) {
      {
      _1_stk_sample_next = 30U;
      }
    } else {
      {
      _1_stk_sample_next = 43U;
      }
    }
    break;
    case 17: ;
    return (1);
    break;
    case 90: ;
    if (! (tmp___12 >= 0)) {
      {
      _1_stk_sample_next = 14U;
      }
    } else {
      {
      _1_stk_sample_next = 92U;
      }
    }
    break;
    case 40: 
    free((void *)p->seq.s);
    free((void *)p->qual.s);
    free((void *)p->name.s);
    i ++;
    {
    _1_stk_sample_next = 55U;
    }
    break;
    case 55: ;
    if (i < num) {
      {
      _1_stk_sample_next = 3U;
      }
    } else {
      {
      _1_stk_sample_next = 59U;
      }
    }
    break;
    case 60: ;
    return (1);
    break;
    case 59: ;
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
      _1_stk_sample_next = 18U;
      }
    } else {
      {
      _1_stk_sample_next = 72U;
      }
    }
    break;
    case 6: ;
    if (tmp___13 != hash->n_buckets) {
      {
      _1_stk_sample_next = 7U;
      }
    } else {
      {
      _1_stk_sample_next = 96U;
      }
    }
    break;
    case 27: 
    tmp___7 = n_seqs - 1ULL;
    {
    _1_stk_sample_next = 25U;
    }
    break;
    case 38: 
    seq = kseq_init(fp);
    n_seqs = (uint64_t )0;
    {
    _1_stk_sample_next = 89U;
    }
    break;
    case 61: 
    tmp___6 = kr_rand(kr);
    r = (double )(tmp___6 >> 11) * (1.0 / 9007199254740992.0);
    n_seqs ++;
    {
    _1_stk_sample_next = 54U;
    }
    break;
    case 87: ;
    return (1);
    break;
    case 84: 
    buf = (kseq_t *)0;
    {
    _1_stk_sample_next = 75U;
    }
    break;
    case 74: 
    tmp___12 = kseq_read(seq);
    {
    _1_stk_sample_next = 90U;
    }
    break;
    case 75: ;
    if (num > 0ULL) {
      {
      _1_stk_sample_next = 94U;
      }
    } else {
      {
      _1_stk_sample_next = 76U;
      }
    }
    break;
    case 48: 
    y___0 = (uint64_t )(r___0 * (double )n_seqs);
    {
    _1_stk_sample_next = 1U;
    }
    break;
    case 71: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_sample_next = 12U;
    }
    break;
    case 22: 
    frac = atof((char const   *)*(argv + (optind + 1)));
    {
    _1_stk_sample_next = 93U;
    }
    break;
    case 28: 
    seq = kseq_init(fp);
    n_seqs = (uint64_t )0;
    {
    _1_stk_sample_next = 74U;
    }
    break;
    case 53: ;
    if (! (c >= 0)) {
      {
      _1_stk_sample_next = 65U;
      }
    } else {
      {
      _1_stk_sample_next = 2U;
      }
    }
    break;
    case 65: ;
    if (optind + 2 > argc) {
      {
      _1_stk_sample_next = 21U;
      }
    } else {
      {
      _1_stk_sample_next = 22U;
      }
    }
    break;
    case 47: ;
    if (! twopass) {
      {
      _1_stk_sample_next = 84U;
      }
    } else {
      {
      _1_stk_sample_next = 45U;
      }
    }
    break;
    case 73: ;
    return (1);
    break;
    case 44: ;
    if (p->seq.l) {
      {
      _1_stk_sample_next = 39U;
      }
    } else {
      {
      _1_stk_sample_next = 40U;
      }
    }
    break;
    case 5: ;
    return (0);
    break;
    case 91: ;
    if (! (tmp___8 >= 0)) {
      {
      _1_stk_sample_next = 57U;
      }
    } else {
      {
      _1_stk_sample_next = 61U;
      }
    }
    break;
    case 97: 
    tmp___10 = malloc((size_t___0 )(num * 8ULL));
    buf___0 = (uint64_t *)tmp___10;
    i = (uint64_t )0;
    {
    _1_stk_sample_next = 98U;
    }
    break;
    case 72: 
    kseq_destroy(seq);
    gzclose(fp);
    free((void *)kr);
    {
    _1_stk_sample_next = 5U;
    }
    break;
    case 64: 
    n_seqs ++;
    tmp___13 = kh_get_64((kh_64_t const   *)hash, n_seqs);
    {
    _1_stk_sample_next = 6U;
    }
    break;
    case 93: ;
    if (frac >= 1.0) {
      {
      _1_stk_sample_next = 20U;
      }
    } else {
      {
      _1_stk_sample_next = 9U;
      }
    }
    break;
    case 95: 
    y___0 = n_seqs - 1ULL;
    {
    _1_stk_sample_next = 1U;
    }
    break;
    case 92: 
    tmp___11 = kr_rand(kr);
    r___0 = (double )(tmp___11 >> 11) * (1.0 / 9007199254740992.0);
    n_seqs ++;
    {
    _1_stk_sample_next = 0U;
    }
    break;
    case 10: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] in the 2-pass mode, the input cannot be STDIN.\n",
            "stk_sample");
    free((void *)kr);
    {
    _1_stk_sample_next = 60U;
    }
    break;
    case 0: ;
    if (n_seqs - 1ULL < num) {
      {
      _1_stk_sample_next = 95U;
      }
    } else {
      {
      _1_stk_sample_next = 48U;
      }
    }
    break;
    case 46: ;
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
      _1_stk_sample_next = 88U;
      }
    } else {
      {
      _1_stk_sample_next = 26U;
      }
    }
    break;
    case 39: 
    stk_printseq((kseq_t const   *)p, -1);
    {
    _1_stk_sample_next = 40U;
    }
    break;
    case 66: 
    stk_printseq((kseq_t const   *)seq, -1);
    {
    _1_stk_sample_next = 89U;
    }
    break;
    case 83: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[W::%s] when sampling a fraction, option -2 is ignored.",
            "stk_sample");
    twopass = 0;
    {
    _1_stk_sample_next = 35U;
    }
    break;
    case 7: 
    stk_printseq((kseq_t const   *)seq, -1);
    {
    _1_stk_sample_next = 96U;
    }
    break;
    case 88: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] Could not allocate enough memory for %llu sequences. Exiting...\n",
            "stk_sample", num);
    free((void *)kr);
    {
    _1_stk_sample_next = 17U;
    }
    break;
    case 35: ;
    if ((unsigned long )kr == (unsigned long )((krand_t *)0)) {
      {
      _1_stk_sample_next = 16U;
      }
    } else {
      {
      _1_stk_sample_next = 47U;
      }
    }
    break;
    case 29: ;
    if (tmp___5) {
      {
      _1_stk_sample_next = 77U;
      }
    } else {
      {
      _1_stk_sample_next = 71U;
      }
    }
    break;
    case 43: 
    free((void *)buf___0);
    fp = gzopen((char const   *)*(argv + optind), "r");
    seq = kseq_init(fp);
    n_seqs = (uint64_t )0;
    {
    _1_stk_sample_next = 96U;
    }
    break;
    case 86: 
    *(buf___0 + i) = 0xffffffffffffffffULL;
    i ++;
    {
    _1_stk_sample_next = 98U;
    }
    break;
    case 2: ;
    if (c == 115) {
      {
      _1_stk_sample_next = 56U;
      }
    } else {
      {
      _1_stk_sample_next = 50U;
      }
    }
    break;
    case 20: 
    num = (uint64_t )(frac + .499);
    frac = 0.;
    {
    _1_stk_sample_next = 35U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_sample LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_seq LOC=UNKNOWN */
int stk_seq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int c ;
  int qual_thres ;
  int flag ;
  int qual_shift ;
  int mask_chr ;
  int min_len ;
  int max_q ;
  int fake_qual ;
  unsigned int i ;
  unsigned int line_len ;
  int64_t n_seqs ;
  double frac ;
  kh_reg_t *h ;
  krand_t *kr ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  gzFile tmp___6 ;
  int tmp___7 ;
  krint64_t tmp___8 ;
  int k ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  int c0 ;
  int c1 ;
  int tmp___16 ;
  unsigned int _1_stk_seq_next ;

  {
  {
  _1_stk_seq_next = 112U;
  }
  while (1) {
    switch (_1_stk_seq_next) {
    case 18: 
    seq->qual.m = seq->seq.m;
    tmp___15 = realloc((void *)seq->qual.s, seq->qual.m);
    seq->qual.s = (char *)tmp___15;
    {
    _1_stk_seq_next = 38U;
    }
    break;
    case 50: 
    min_len = atoi((char const   *)optarg);
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 108: ;
    if ((unsigned long )kr == (unsigned long )((krand_t *)0)) {
      {
      _1_stk_seq_next = 151U;
      }
    } else {
      {
      _1_stk_seq_next = 173U;
      }
    }
    break;
    case 104: 
    tmp___11 = k;
    k ++;
    *(seq->seq.s + tmp___11) = *(seq->seq.s + i);
    {
    _1_stk_seq_next = 8U;
    }
    break;
    case 130: ;
    if (flag & 16) {
      {
      _1_stk_seq_next = 5U;
      }
    } else {
      {
      _1_stk_seq_next = 133U;
      }
    }
    break;
    case 49: 
    flag |= 1;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 52: 
    i = 0U;
    {
    _1_stk_seq_next = 97U;
    }
    break;
    case 4: 
    i = 0U;
    {
    _1_stk_seq_next = 2U;
    }
    break;
    case 30: 
    tmp___5 = fileno(stdin);
    tmp___6 = gzdopen(tmp___5, "r");
    fp = tmp___6;
    {
    _1_stk_seq_next = 11U;
    }
    break;
    case 62: 
    tmp___14 = toupper((int )*(seq->seq.s + i));
    *(seq->seq.s + i) = (char )tmp___14;
    i ++;
    {
    _1_stk_seq_next = 117U;
    }
    break;
    case 103: 
    flag |= 32;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 102: 
    *(seq->seq.s + i) = (char )mask_chr;
    {
    _1_stk_seq_next = 15U;
    }
    break;
    case 106: 
    flag |= 128;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 111: ;
    if (seq->seq.l & 1UL) {
      {
      _1_stk_seq_next = 65U;
      }
    } else {
      {
      _1_stk_seq_next = 42U;
      }
    }
    break;
    case 145: ;
    if (fake_qual <= 127) {
      {
      _1_stk_seq_next = 150U;
      }
    } else {
      {
      _1_stk_seq_next = 45U;
      }
    }
    break;
    case 15: 
    i ++;
    {
    _1_stk_seq_next = 152U;
    }
    break;
    case 82: ;
    if (h) {
      {
      _1_stk_seq_next = 90U;
      }
    } else {
      {
      _1_stk_seq_next = 58U;
      }
    }
    break;
    case 133: ;
    if (flag & 32) {
      {
      _1_stk_seq_next = 81U;
      }
    } else {
      {
      _1_stk_seq_next = 154U;
      }
    }
    break;
    case 89: 
    tmp___16 = kseq_read(seq);
    {
    _1_stk_seq_next = 74U;
    }
    break;
    case 56: 
    i ++;
    {
    _1_stk_seq_next = 33U;
    }
    break;
    case 31: 
    i ++;
    {
    _1_stk_seq_next = 77U;
    }
    break;
    case 121: ;
    if (seq->qual.l) {
      {
      _1_stk_seq_next = 51U;
      }
    } else {
      {
      _1_stk_seq_next = 107U;
      }
    }
    break;
    case 101: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_seq_next = 134U;
      }
    } else {
      {
      _1_stk_seq_next = 44U;
      }
    }
    break;
    case 168: ;
    if (! tmp___10) {
      {
      _1_stk_seq_next = 21U;
      }
    } else {
      {
      _1_stk_seq_next = 56U;
      }
    }
    break;
    case 69: 
    line_len = 4294967295U;
    {
    _1_stk_seq_next = 88U;
    }
    break;
    case 152: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_seq_next = 34U;
      }
    } else {
      {
      _1_stk_seq_next = 169U;
      }
    }
    break;
    case 8: 
    i ++;
    {
    _1_stk_seq_next = 101U;
    }
    break;
    case 45: ;
    if (flag & 2) {
      {
      _1_stk_seq_next = 3U;
      }
    } else {
      {
      _1_stk_seq_next = 82U;
      }
    }
    break;
    case 54: ;
    if (! tmp___12) {
      {
      _1_stk_seq_next = 104U;
      }
    } else {
      {
      _1_stk_seq_next = 8U;
      }
    }
    break;
    case 124: ;
    switch (c) {
    case 97: 
    case 65: 
    {
    _1_stk_seq_next = 49U;
    }
    break;
    case 67: 
    {
    _1_stk_seq_next = 36U;
    }
    break;
    case 114: 
    {
    _1_stk_seq_next = 146U;
    }
    break;
    case 99: 
    {
    _1_stk_seq_next = 63U;
    }
    break;
    case 49: 
    {
    _1_stk_seq_next = 127U;
    }
    break;
    case 50: 
    {
    _1_stk_seq_next = 103U;
    }
    break;
    case 86: 
    {
    _1_stk_seq_next = 159U;
    }
    break;
    case 78: 
    {
    _1_stk_seq_next = 106U;
    }
    break;
    case 85: 
    {
    _1_stk_seq_next = 57U;
    }
    break;
    case 83: 
    {
    _1_stk_seq_next = 6U;
    }
    break;
    case 77: 
    {
    _1_stk_seq_next = 47U;
    }
    break;
    case 110: 
    {
    _1_stk_seq_next = 73U;
    }
    break;
    case 81: 
    {
    _1_stk_seq_next = 162U;
    }
    break;
    case 113: 
    {
    _1_stk_seq_next = 170U;
    }
    break;
    case 88: 
    {
    _1_stk_seq_next = 39U;
    }
    break;
    case 108: 
    {
    _1_stk_seq_next = 167U;
    }
    break;
    case 76: 
    {
    _1_stk_seq_next = 50U;
    }
    break;
    case 115: 
    {
    _1_stk_seq_next = 148U;
    }
    break;
    case 102: 
    {
    _1_stk_seq_next = 95U;
    }
    break;
    case 70: 
    {
    _1_stk_seq_next = 19U;
    }
    break;
    default: 
    {
    _1_stk_seq_next = 72U;
    }
    break;
    }
    break;
    case 118: ;
    if (flag & 1) {
      {
      _1_stk_seq_next = 70U;
      }
    } else {
      {
      _1_stk_seq_next = 71U;
      }
    }
    break;
    case 140: 
    stk_printseq((kseq_t const   *)seq, (int )line_len);
    {
    _1_stk_seq_next = 89U;
    }
    break;
    case 81: ;
    if ((n_seqs & 1LL) == 1LL) {
      {
      _1_stk_seq_next = 89U;
      }
    } else {
      {
      _1_stk_seq_next = 154U;
      }
    }
    break;
    case 23: 
    tmp___4 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___4;
    {
    _1_stk_seq_next = 11U;
    }
    break;
    case 77: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_seq_next = 83U;
      }
    } else {
      {
      _1_stk_seq_next = 28U;
      }
    }
    break;
    case 70: 
    seq->qual.l = (size_t___0 )0;
    {
    _1_stk_seq_next = 45U;
    }
    break;
    case 159: 
    flag |= 64;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 3: 
    seq->comment.l = (size_t___0 )0;
    {
    _1_stk_seq_next = 82U;
    }
    break;
    case 134: 
    tmp___12 = isspace((int )*(seq->seq.s + i));
    {
    _1_stk_seq_next = 54U;
    }
    break;
    case 24: 
    n_seqs ++;
    {
    _1_stk_seq_next = 157U;
    }
    break;
    case 21: 
    tmp___9 = k;
    k ++;
    *(seq->qual.s + tmp___9) = *(seq->qual.s + i);
    {
    _1_stk_seq_next = 56U;
    }
    break;
    case 94: 
    tmp___10 = isspace((int )*(seq->seq.s + i));
    {
    _1_stk_seq_next = 168U;
    }
    break;
    case 109: ;
    if (tmp___7) {
      {
      _1_stk_seq_next = 23U;
      }
    } else {
      {
      _1_stk_seq_next = 26U;
      }
    }
    break;
    case 167: 
    tmp = atoi((char const   *)optarg);
    line_len = (unsigned int )tmp;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 36: 
    flag |= 2;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 57: 
    flag |= 256;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 100: ;
    if (mask_chr) {
      {
      _1_stk_seq_next = 27U;
      }
    } else {
      {
      _1_stk_seq_next = 126U;
      }
    }
    break;
    case 26: 
    tmp___5 = fileno(stdin);
    tmp___6 = gzdopen(tmp___5, "r");
    fp = tmp___6;
    {
    _1_stk_seq_next = 11U;
    }
    break;
    case 98: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk seq [options] <in.fq>|<in.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q INT    mask bases with quality lower than INT [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -X INT    mask bases with quality higher than INT [255]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -n CHAR   masked bases converted to CHAR; 0 for lowercase [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT    number of residues per line; 0 for 2^32-1 [%d]\n",
            line_len);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -Q INT    quality shift: ASCII-INT gives base quality [%d]\n",
            qual_shift);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -s INT    random seed (effective with -f) [11]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -f FLOAT  sample FLOAT fraction of sequences [1]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -M FILE   mask regions in BED or name list FILE [null]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -L INT    drop sequences with length shorter than INT [0]\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -F CHAR   fake FASTQ quality []\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -c        mask complement region (effective with -M)\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -r        reverse complement\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -A        force FASTA output (discard quality)\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -C        drop comments at the header lines\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -N        drop sequences containing ambiguous bases\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -1        output the 2n-1 reads only\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -2        output the 2n reads only\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -V        shift quality by \'(-Q) - 33\'\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -U        convert all bases to uppercases\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -S        strip of white spaces in sequences\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    free((void *)kr);
    {
    _1_stk_seq_next = 59U;
    }
    break;
    case 11: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_seq_next = 113U;
      }
    } else {
      {
      _1_stk_seq_next = 147U;
      }
    }
    break;
    case 9: 
    *(seq->qual.s + i) = (char )((int )*(seq->qual.s + i) - (qual_shift - 33));
    i ++;
    {
    _1_stk_seq_next = 2U;
    }
    break;
    case 63: 
    flag |= 8;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 51: 
    k = 0;
    i = (unsigned int )k;
    {
    _1_stk_seq_next = 33U;
    }
    break;
    case 107: 
    k = 0;
    i = (unsigned int )k;
    {
    _1_stk_seq_next = 101U;
    }
    break;
    case 146: 
    flag |= 4;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 143: ;
    if ((int )*(seq->qual.s + i) > max_q) {
      {
      _1_stk_seq_next = 149U;
      }
    } else {
      {
      _1_stk_seq_next = 15U;
      }
    }
    break;
    case 19: 
    fake_qual = (int )*optarg;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 32: ;
    if ((double )(tmp___8 >> 11) * (1.0 / 9007199254740992.0) >= frac) {
      {
      _1_stk_seq_next = 89U;
      }
    } else {
      {
      _1_stk_seq_next = 153U;
      }
    }
    break;
    case 17: 
    i = 0U;
    {
    _1_stk_seq_next = 117U;
    }
    break;
    case 90: 
    stk_mask(seq, (kh_reg_t const   *)h, flag & 8, mask_chr);
    {
    _1_stk_seq_next = 58U;
    }
    break;
    case 67: 
    c0 = (int )comp_tab[(int )*(seq->seq.s + i)];
    c1 = (int )comp_tab[(int )*(seq->seq.s + ((seq->seq.l - 1UL) - (size_t___0 )i))];
    *(seq->seq.s + i) = (char )c1;
    *(seq->seq.s + ((seq->seq.l - 1UL) - (size_t___0 )i)) = (char )c0;
    i ++;
    {
    _1_stk_seq_next = 110U;
    }
    break;
    case 55: ;
    if (frac < 1.) {
      {
      _1_stk_seq_next = 20U;
      }
    } else {
      {
      _1_stk_seq_next = 153U;
      }
    }
    break;
    case 117: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_seq_next = 62U;
      }
    } else {
      {
      _1_stk_seq_next = 118U;
      }
    }
    break;
    case 132: 
    i = 0U;
    {
    _1_stk_seq_next = 110U;
    }
    break;
    case 110: ;
    if ((size_t___0 )i < seq->seq.l >> 1) {
      {
      _1_stk_seq_next = 67U;
      }
    } else {
      {
      _1_stk_seq_next = 111U;
      }
    }
    break;
    case 60: 
    kseq_destroy(seq);
    gzclose(fp);
    stk_reg_destroy(h);
    free((void *)kr);
    {
    _1_stk_seq_next = 161U;
    }
    break;
    case 150: ;
    if (seq->qual.m < seq->seq.m) {
      {
      _1_stk_seq_next = 18U;
      }
    } else {
      {
      _1_stk_seq_next = 38U;
      }
    }
    break;
    case 59: ;
    return (1);
    break;
    case 161: ;
    return (0);
    break;
    case 6: 
    flag |= 512;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 155: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_seq_next = 99U;
      }
    } else {
      {
      _1_stk_seq_next = 169U;
      }
    }
    break;
    case 142: 
    seq->qual.l = (size_t___0 )k;
    {
    _1_stk_seq_next = 107U;
    }
    break;
    case 116: ;
    if (tmp___2) {
      {
      _1_stk_seq_next = 98U;
      }
    } else {
      {
      _1_stk_seq_next = 87U;
      }
    }
    break;
    case 27: 
    i = 0U;
    {
    _1_stk_seq_next = 152U;
    }
    break;
    case 154: ;
    if (flag & 512) {
      {
      _1_stk_seq_next = 121U;
      }
    } else {
      {
      _1_stk_seq_next = 92U;
      }
    }
    break;
    case 151: 
    kr = kr_srand((krint64_t )11);
    {
    _1_stk_seq_next = 173U;
    }
    break;
    case 157: ;
    if (seq->seq.l < (size_t___0 )min_len) {
      {
      _1_stk_seq_next = 89U;
      }
    } else {
      {
      _1_stk_seq_next = 55U;
      }
    }
    break;
    case 38: 
    seq->qual.l = seq->seq.l;
    memset((void *)seq->qual.s, fake_qual, seq->qual.l);
    *(seq->qual.s + seq->qual.l) = (char)0;
    {
    _1_stk_seq_next = 45U;
    }
    break;
    case 61: 
    tmp___13 = tolower((int )*(seq->seq.s + i));
    *(seq->seq.s + i) = (char )tmp___13;
    {
    _1_stk_seq_next = 136U;
    }
    break;
    case 158: 
    tmp___7 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_seq_next = 109U;
    }
    break;
    case 87: ;
    if (line_len == 0U) {
      {
      _1_stk_seq_next = 69U;
      }
    } else {
      {
      _1_stk_seq_next = 88U;
      }
    }
    break;
    case 113: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_seq");
    {
    _1_stk_seq_next = 174U;
    }
    break;
    case 138: ;
    if (qual_thres > qual_shift) {
      {
      _1_stk_seq_next = 100U;
      }
    } else {
      {
      _1_stk_seq_next = 169U;
      }
    }
    break;
    case 58: ;
    if (flag & 4) {
      {
      _1_stk_seq_next = 132U;
      }
    } else {
      {
      _1_stk_seq_next = 163U;
      }
    }
    break;
    case 170: 
    qual_thres = atoi((char const   *)optarg);
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 34: ;
    if ((int )*(seq->qual.s + i) < qual_thres) {
      {
      _1_stk_seq_next = 102U;
      }
    } else {
      {
      _1_stk_seq_next = 143U;
      }
    }
    break;
    case 74: ;
    if (! (tmp___16 >= 0)) {
      {
      _1_stk_seq_next = 60U;
      }
    } else {
      {
      _1_stk_seq_next = 24U;
      }
    }
    break;
    case 112: 
    qual_thres = 0;
    flag = 0;
    qual_shift = 33;
    mask_chr = 0;
    min_len = 0;
    max_q = 255;
    fake_qual = -1;
    line_len = 0U;
    n_seqs = (int64_t )0;
    frac = 1.;
    h = (kh_reg_t *)0;
    kr = (krand_t *)0;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 123: 
    tmp___13 = tolower((int )*(seq->seq.s + i));
    *(seq->seq.s + i) = (char )tmp___13;
    {
    _1_stk_seq_next = 136U;
    }
    break;
    case 169: ;
    if (flag & 256) {
      {
      _1_stk_seq_next = 17U;
      }
    } else {
      {
      _1_stk_seq_next = 118U;
      }
    }
    break;
    case 127: 
    flag |= 16;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 147: 
    seq = kseq_init(fp);
    qual_thres += qual_shift;
    {
    _1_stk_seq_next = 89U;
    }
    break;
    case 71: ;
    if (fake_qual >= 33) {
      {
      _1_stk_seq_next = 145U;
      }
    } else {
      {
      _1_stk_seq_next = 45U;
      }
    }
    break;
    case 22: 
    tmp___1 = fileno(stdin);
    tmp___2 = isatty(tmp___1);
    {
    _1_stk_seq_next = 116U;
    }
    break;
    case 173: ;
    if (argc == optind) {
      {
      _1_stk_seq_next = 22U;
      }
    } else {
      {
      _1_stk_seq_next = 87U;
      }
    }
    break;
    case 28: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_seq_next = 89U;
      }
    } else {
      {
      _1_stk_seq_next = 140U;
      }
    }
    break;
    case 53: ;
    if (! (c >= 0)) {
      {
      _1_stk_seq_next = 108U;
      }
    } else {
      {
      _1_stk_seq_next = 124U;
      }
    }
    break;
    case 148: 
    tmp___0 = atol((char const   *)optarg);
    kr = kr_srand((krint64_t )tmp___0);
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 65: 
    *(seq->seq.s + (seq->seq.l >> 1)) = comp_tab[(int )*(seq->seq.s + (seq->seq.l >> 1))];
    {
    _1_stk_seq_next = 42U;
    }
    break;
    case 47: 
    h = stk_reg_read((char const   *)optarg);
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 73: 
    mask_chr = (int )*optarg;
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 44: 
    seq->seq.l = (size_t___0 )k;
    {
    _1_stk_seq_next = 92U;
    }
    break;
    case 5: ;
    if ((n_seqs & 1LL) == 0LL) {
      {
      _1_stk_seq_next = 89U;
      }
    } else {
      {
      _1_stk_seq_next = 133U;
      }
    }
    break;
    case 97: ;
    if ((size_t___0 )i < seq->seq.l >> 1) {
      {
      _1_stk_seq_next = 41U;
      }
    } else {
      {
      _1_stk_seq_next = 163U;
      }
    }
    break;
    case 162: 
    qual_shift = atoi((char const   *)optarg);
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 163: ;
    if (flag & 64) {
      {
      _1_stk_seq_next = 64U;
      }
    } else {
      {
      _1_stk_seq_next = 119U;
      }
    }
    break;
    case 72: 
    c = getopt(argc, argv, "N12q:l:Q:aACrn:s:f:M:L:cVUX:SF:");
    {
    _1_stk_seq_next = 53U;
    }
    break;
    case 99: ;
    if ((int )*(seq->qual.s + i) < qual_thres) {
      {
      _1_stk_seq_next = 61U;
      }
    } else {
      {
      _1_stk_seq_next = 0U;
      }
    }
    break;
    case 114: ;
    if (qual_shift != 33) {
      {
      _1_stk_seq_next = 4U;
      }
    } else {
      {
      _1_stk_seq_next = 119U;
      }
    }
    break;
    case 33: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_seq_next = 94U;
      }
    } else {
      {
      _1_stk_seq_next = 142U;
      }
    }
    break;
    case 64: ;
    if (seq->qual.l) {
      {
      _1_stk_seq_next = 114U;
      }
    } else {
      {
      _1_stk_seq_next = 119U;
      }
    }
    break;
    case 119: ;
    if (flag & 128) {
      {
      _1_stk_seq_next = 46U;
      }
    } else {
      {
      _1_stk_seq_next = 140U;
      }
    }
    break;
    case 41: 
    c0 = (int )*(seq->qual.s + i);
    *(seq->qual.s + i) = *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t___0 )i));
    *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t___0 )i)) = (char )c0;
    i ++;
    {
    _1_stk_seq_next = 97U;
    }
    break;
    case 95: 
    frac = atof((char const   *)optarg);
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 149: 
    *(seq->seq.s + i) = (char )mask_chr;
    {
    _1_stk_seq_next = 15U;
    }
    break;
    case 92: ;
    if (seq->qual.l) {
      {
      _1_stk_seq_next = 138U;
      }
    } else {
      {
      _1_stk_seq_next = 169U;
      }
    }
    break;
    case 42: ;
    if (seq->qual.l) {
      {
      _1_stk_seq_next = 52U;
      }
    } else {
      {
      _1_stk_seq_next = 163U;
      }
    }
    break;
    case 0: ;
    if ((int )*(seq->qual.s + i) > max_q) {
      {
      _1_stk_seq_next = 123U;
      }
    } else {
      {
      _1_stk_seq_next = 136U;
      }
    }
    break;
    case 136: 
    i ++;
    {
    _1_stk_seq_next = 155U;
    }
    break;
    case 46: 
    i = 0U;
    {
    _1_stk_seq_next = 77U;
    }
    break;
    case 153: ;
    if (flag & 48) {
      {
      _1_stk_seq_next = 130U;
      }
    } else {
      {
      _1_stk_seq_next = 154U;
      }
    }
    break;
    case 39: 
    max_q = atoi((char const   *)optarg);
    {
    _1_stk_seq_next = 72U;
    }
    break;
    case 83: ;
    if ((int )seq_nt16to4_table[seq_nt16_table[(int )*(seq->seq.s + i)]] > 3) {
      {
      _1_stk_seq_next = 28U;
      }
    } else {
      {
      _1_stk_seq_next = 31U;
      }
    }
    break;
    case 88: ;
    if (optind < argc) {
      {
      _1_stk_seq_next = 158U;
      }
    } else {
      {
      _1_stk_seq_next = 30U;
      }
    }
    break;
    case 174: ;
    return (1);
    break;
    case 126: 
    i = 0U;
    {
    _1_stk_seq_next = 155U;
    }
    break;
    case 2: ;
    if ((size_t___0 )i < seq->qual.l) {
      {
      _1_stk_seq_next = 9U;
      }
    } else {
      {
      _1_stk_seq_next = 119U;
      }
    }
    break;
    case 20: 
    tmp___8 = kr_rand(kr);
    {
    _1_stk_seq_next = 32U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_seq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cpy_kseq LOC=UNKNOWN */
static void cpy_kseq(kseq_t *dst , kseq_t const   *src ) 
{ 
  unsigned int _1_cpy_kseq_next ;

  {
  {
  _1_cpy_kseq_next = 0U;
  }
  while (1) {
    switch (_1_cpy_kseq_next) {
    case 1: ;
    return;
    break;
    case 0: 
    cpy_kstr(& dst->name, & src->name);
    cpy_kstr(& dst->seq, & src->seq);
    cpy_kstr(& dst->qual, & src->qual);
    cpy_kstr(& dst->comment, & src->comment);
    {
    _1_cpy_kseq_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cpy_kseq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_randbase LOC=UNKNOWN */
int stk_randbase(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int i ;
  int c ;
  int b ;
  int a ;
  int j ;
  int k ;
  int m ;
  double tmp___4 ;
  int tmp___6 ;
  unsigned int _1_stk_randbase_next ;

  {
  {
  _1_stk_randbase_next = 22U;
  }
  while (1) {
    switch (_1_stk_randbase_next) {
    case 18: 
    printf((char const   */* __restrict  */)">%s", seq->name.s);
    i = 0;
    {
    _1_stk_randbase_next = 25U;
    }
    break;
    case 25: ;
    if (i < l) {
      {
      _1_stk_randbase_next = 40U;
      }
    } else {
      {
      _1_stk_randbase_next = 1U;
      }
    }
    break;
    case 4: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk randbase <in.fa>\n");
    {
    _1_stk_randbase_next = 14U;
    }
    break;
    case 14: ;
    return (1);
    break;
    case 15: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_randbase");
    {
    _1_stk_randbase_next = 11U;
    }
    break;
    case 31: ;
    if (i % 60 == 0) {
      {
      _1_stk_randbase_next = 19U;
      }
    } else {
      {
      _1_stk_randbase_next = 32U;
      }
    }
    break;
    case 8: 
    tmp___3 = strcmp((char const   *)*(argv + 1), "-");
    {
    _1_stk_randbase_next = 37U;
    }
    break;
    case 1: 
    putchar('\n');
    {
    _1_stk_randbase_next = 35U;
    }
    break;
    case 3: 
    tmp___4 = drand48();
    m = tmp___4 < 0.5;
    k = 0;
    j = k;
    {
    _1_stk_randbase_next = 21U;
    }
    break;
    case 16: 
    tmp___6 = islower(b);
    {
    _1_stk_randbase_next = 29U;
    }
    break;
    case 24: ;
    if (k == m) {
      {
      _1_stk_randbase_next = 16U;
      }
    } else {
      {
      _1_stk_randbase_next = 13U;
      }
    }
    break;
    case 21: ;
    if (j < 4) {
      {
      _1_stk_randbase_next = 26U;
      }
    } else {
      {
      _1_stk_randbase_next = 16U;
      }
    }
    break;
    case 26: ;
    if (((1 << j) & c) == 0) {
      {
      _1_stk_randbase_next = 7U;
      }
    } else {
      {
      _1_stk_randbase_next = 24U;
      }
    }
    break;
    case 11: ;
    return (1);
    break;
    case 13: 
    k ++;
    {
    _1_stk_randbase_next = 7U;
    }
    break;
    case 19: 
    putchar('\n');
    {
    _1_stk_randbase_next = 32U;
    }
    break;
    case 32: 
    putchar((int )*(seq->seq.s + i));
    i ++;
    {
    _1_stk_randbase_next = 25U;
    }
    break;
    case 40: 
    b = (int )*(seq->seq.s + i);
    c = (int )seq_nt16_table[b];
    a = bitcnt_table[c];
    {
    _1_stk_randbase_next = 34U;
    }
    break;
    case 6: 
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___2;
    {
    _1_stk_randbase_next = 27U;
    }
    break;
    case 27: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_randbase_next = 15U;
      }
    } else {
      {
      _1_stk_randbase_next = 33U;
      }
    }
    break;
    case 38: 
    *(seq->seq.s + i) = (char )*("ACGT" + j);
    {
    _1_stk_randbase_next = 31U;
    }
    break;
    case 34: ;
    if (a == 2) {
      {
      _1_stk_randbase_next = 3U;
      }
    } else {
      {
      _1_stk_randbase_next = 31U;
      }
    }
    break;
    case 22: ;
    if (argc == 1) {
      {
      _1_stk_randbase_next = 4U;
      }
    } else {
      {
      _1_stk_randbase_next = 8U;
      }
    }
    break;
    case 5: ;
    return (0);
    break;
    case 33: 
    seq = kseq_init(fp);
    {
    _1_stk_randbase_next = 35U;
    }
    break;
    case 37: ;
    if (tmp___3 == 0) {
      {
      _1_stk_randbase_next = 2U;
      }
    } else {
      {
      _1_stk_randbase_next = 6U;
      }
    }
    break;
    case 0: 
    *(seq->seq.s + i) = (char )*("acgt" + j);
    {
    _1_stk_randbase_next = 31U;
    }
    break;
    case 39: 
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_randbase_next = 5U;
    }
    break;
    case 7: 
    __Cont: 
    j ++;
    {
    _1_stk_randbase_next = 21U;
    }
    break;
    case 35: 
    l = kseq_read(seq);
    {
    _1_stk_randbase_next = 20U;
    }
    break;
    case 29: ;
    if (tmp___6) {
      {
      _1_stk_randbase_next = 0U;
      }
    } else {
      {
      _1_stk_randbase_next = 38U;
      }
    }
    break;
    case 2: 
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
    {
    _1_stk_randbase_next = 27U;
    }
    break;
    case 20: ;
    if (! (l >= 0)) {
      {
      _1_stk_randbase_next = 39U;
      }
    } else {
      {
      _1_stk_randbase_next = 18U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_randbase LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_get_reg LOC=UNKNOWN */
__inline static khint_t kh_get_reg(kh_reg_t const   *h , kh_cstr_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  int tmp ;
  khint_t tmp___0 ;
  unsigned int _1_kh_get_reg_next ;

  {
  {
  _1_kh_get_reg_next = 12U;
  }
  while (1) {
    switch (_1_kh_get_reg_next) {
    case 14: 
    tmp = strcmp(*(h->keys + i), key);
    {
    _1_kh_get_reg_next = 13U;
    }
    break;
    case 15: ;
    return ((khint_t )h->n_buckets);
    break;
    case 12: ;
    if (h->n_buckets) {
      {
      _1_kh_get_reg_next = 5U;
      }
    } else {
      {
      _1_kh_get_reg_next = 0U;
      }
    }
    break;
    case 8: ;
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      {
      _1_kh_get_reg_next = 16U;
      }
    } else {
      {
      _1_kh_get_reg_next = 6U;
      }
    }
    break;
    case 16: 
    tmp___0 = (khint_t )h->n_buckets;
    {
    _1_kh_get_reg_next = 11U;
    }
    break;
    case 11: ;
    return (tmp___0);
    break;
    case 13: ;
    if (tmp == 0) {
      {
      _1_kh_get_reg_next = 8U;
      }
    } else {
      {
      _1_kh_get_reg_next = 2U;
      }
    }
    break;
    case 17: ;
    if (i == last) {
      {
      _1_kh_get_reg_next = 15U;
      }
    } else {
      {
      _1_kh_get_reg_next = 10U;
      }
    }
    break;
    case 6: 
    tmp___0 = i;
    {
    _1_kh_get_reg_next = 11U;
    }
    break;
    case 5: 
    mask = (khint_t )(h->n_buckets - 1U);
    k = __ac_X31_hash_string(key);
    i = k & mask;
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
    last = i;
    {
    _1_kh_get_reg_next = 10U;
    }
    break;
    case 10: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
      {
      _1_kh_get_reg_next = 7U;
      }
    } else {
      {
      _1_kh_get_reg_next = 8U;
      }
    }
    break;
    case 0: ;
    return ((khint_t )0);
    break;
    case 7: ;
    if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
      {
      _1_kh_get_reg_next = 14U;
      }
    } else {
      {
      _1_kh_get_reg_next = 2U;
      }
    }
    break;
    case 2: 
    i = (i + inc) & mask;
    {
    _1_kh_get_reg_next = 17U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_get_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_cutN LOC=UNKNOWN */
int stk_cutN(int argc , char **argv ) 
{ 
  int c ;
  int l ;
  int gap_only ;
  gzFile fp ;
  kseq_t *ks ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int k ;
  int begin ;
  int end ;
  int tmp___4 ;
  unsigned int _1_stk_cutN_next ;

  {
  {
  _1_stk_cutN_next = 25U;
  }
  while (1) {
    switch (_1_stk_cutN_next) {
    case 18: 
    print_seq(stdout, (kseq_t const   *)ks, k, begin);
    {
    _1_stk_cutN_next = 13U;
    }
    break;
    case 25: 
    gap_only = 0;
    {
    _1_stk_cutN_next = 38U;
    }
    break;
    case 14: ;
    if (! (c >= 0)) {
      {
      _1_stk_cutN_next = 1U;
      }
    } else {
      {
      _1_stk_cutN_next = 24U;
      }
    }
    break;
    case 31: 
    cutN_nonN_penalty = atoi((char const   *)optarg);
    {
    _1_stk_cutN_next = 38U;
    }
    break;
    case 8: 
    print_seq(stdout, (kseq_t const   *)ks, k, l);
    {
    _1_stk_cutN_next = 19U;
    }
    break;
    case 1: ;
    if (argc == optind) {
      {
      _1_stk_cutN_next = 34U;
      }
    } else {
      {
      _1_stk_cutN_next = 33U;
      }
    }
    break;
    case 23: ;
    return (1);
    break;
    case 3: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_cutN_next = 27U;
      }
    } else {
      {
      _1_stk_cutN_next = 29U;
      }
    }
    break;
    case 16: 
    gap_only = 1;
    {
    _1_stk_cutN_next = 38U;
    }
    break;
    case 24: ;
    switch (c) {
    case 110: 
    {
    _1_stk_cutN_next = 7U;
    }
    break;
    case 112: 
    {
    _1_stk_cutN_next = 31U;
    }
    break;
    case 103: 
    {
    _1_stk_cutN_next = 16U;
    }
    break;
    default: 
    {
    _1_stk_cutN_next = 23U;
    }
    break;
    }
    break;
    case 36: ;
    if (! (l >= 0)) {
      {
      _1_stk_cutN_next = 10U;
      }
    } else {
      {
      _1_stk_cutN_next = 26U;
      }
    }
    break;
    case 26: 
    k = 0;
    begin = 0;
    end = 0;
    {
    _1_stk_cutN_next = 35U;
    }
    break;
    case 9: ;
    if (! gap_only) {
      {
      _1_stk_cutN_next = 8U;
      }
    } else {
      {
      _1_stk_cutN_next = 19U;
      }
    }
    break;
    case 13: 
    k = end;
    {
    _1_stk_cutN_next = 35U;
    }
    break;
    case 19: 
    l = kseq_read(ks);
    {
    _1_stk_cutN_next = 36U;
    }
    break;
    case 32: ;
    return (0);
    break;
    case 17: ;
    if (gap_only) {
      {
      _1_stk_cutN_next = 40U;
      }
    } else {
      {
      _1_stk_cutN_next = 18U;
      }
    }
    break;
    case 40: 
    printf((char const   */* __restrict  */)"%s\t%d\t%d\n", ks->name.s, begin, end);
    {
    _1_stk_cutN_next = 13U;
    }
    break;
    case 27: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_cutN");
    {
    _1_stk_cutN_next = 28U;
    }
    break;
    case 38: 
    c = getopt(argc, argv, "n:p:g");
    {
    _1_stk_cutN_next = 14U;
    }
    break;
    case 34: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk cutN [options] <in.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -n INT    min size of N tract [%d]\n",
            cutN_min_N_tract);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -p INT    penalty for a non-N [%d]\n",
            cutN_nonN_penalty);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -g        print gaps only, no sequence\n\n");
    {
    _1_stk_cutN_next = 5U;
    }
    break;
    case 22: 
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
    {
    _1_stk_cutN_next = 3U;
    }
    break;
    case 28: ;
    return (1);
    break;
    case 5: ;
    return (1);
    break;
    case 33: 
    tmp___3 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_cutN_next = 37U;
    }
    break;
    case 37: ;
    if (tmp___3 == 0) {
      {
      _1_stk_cutN_next = 0U;
      }
    } else {
      {
      _1_stk_cutN_next = 22U;
      }
    }
    break;
    case 41: ;
    if (! (tmp___4 >= 0)) {
      {
      _1_stk_cutN_next = 9U;
      }
    } else {
      {
      _1_stk_cutN_next = 20U;
      }
    }
    break;
    case 10: 
    kseq_destroy(ks);
    gzclose(fp);
    {
    _1_stk_cutN_next = 32U;
    }
    break;
    case 0: 
    tmp___0 = fileno(stdin);
    tmp___1 = gzdopen(tmp___0, "r");
    fp = tmp___1;
    {
    _1_stk_cutN_next = 3U;
    }
    break;
    case 7: 
    cutN_min_N_tract = atoi((char const   *)optarg);
    {
    _1_stk_cutN_next = 38U;
    }
    break;
    case 35: 
    tmp___4 = find_next_cut((kseq_t const   *)ks, k, & begin, & end);
    {
    _1_stk_cutN_next = 41U;
    }
    break;
    case 29: 
    ks = kseq_init(fp);
    {
    _1_stk_cutN_next = 19U;
    }
    break;
    case 20: ;
    if (begin != 0) {
      {
      _1_stk_cutN_next = 17U;
      }
    } else {
      {
      _1_stk_cutN_next = 13U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_cutN LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_gc LOC=UNKNOWN */
int stk_gc(int argc , char **argv ) 
{ 
  int c ;
  int is_at ;
  int min_l ;
  double frac ;
  double xdropoff ;
  double q ;
  gzFile fp ;
  kseq_t *seq ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int i ;
  int start ;
  int max_i ;
  int n_hits ;
  int start_hits ;
  int max_hits ;
  double sc ;
  double max ;
  int hit ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int _1_stk_gc_next ;

  {
  {
  _1_stk_gc_next = 19U;
  }
  while (1) {
    switch (_1_stk_gc_next) {
    case 18: 
    frac = atof((char const   *)optarg);
    {
    _1_stk_gc_next = 17U;
    }
    break;
    case 50: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_gc_next = 45U;
      }
    } else {
      {
      _1_stk_gc_next = 12U;
      }
    }
    break;
    case 25: ;
    if (c == 120) {
      {
      _1_stk_gc_next = 34U;
      }
    } else {
      {
      _1_stk_gc_next = 44U;
      }
    }
    break;
    case 49: 
    hit = tmp___5;
    {
    _1_stk_gc_next = 3U;
    }
    break;
    case 52: ;
    if (sc == (double )0) {
      {
      _1_stk_gc_next = 20U;
      }
    } else {
      {
      _1_stk_gc_next = 57U;
      }
    }
    break;
    case 4: 
    hit = tmp___4;
    {
    _1_stk_gc_next = 3U;
    }
    break;
    case 30: 
    max = (double )0;
    sc = max;
    i = max_i;
    {
    _1_stk_gc_next = 61U;
    }
    break;
    case 62: ;
    if (! (tmp___6 >= 0)) {
      {
      _1_stk_gc_next = 56U;
      }
    } else {
      {
      _1_stk_gc_next = 41U;
      }
    }
    break;
    case 14: ;
    return (1);
    break;
    case 15: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk gc [options] <in.fa>\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -w         identify high-AT regions\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f FLOAT   min GC fraction (or AT fraction for -w) [%.2f]\n",
            frac);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l INT     min region length to output [%d]\n",
            min_l);
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -x FLOAT   X-dropoff [%.1f]\n",
            xdropoff);
    {
    _1_stk_gc_next = 14U;
    }
    break;
    case 56: 
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_gc_next = 40U;
    }
    break;
    case 12: 
    seq = kseq_init(fp);
    {
    _1_stk_gc_next = 42U;
    }
    break;
    case 69: 
    _L: ;
    if ((max_i + 1) - start >= min_l) {
      {
      _1_stk_gc_next = 24U;
      }
    } else {
      {
      _1_stk_gc_next = 30U;
      }
    }
    break;
    case 8: ;
    if (sc > (double )0) {
      {
      _1_stk_gc_next = 32U;
      }
    } else {
      {
      _1_stk_gc_next = 61U;
      }
    }
    break;
    case 45: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_gc");
    {
    _1_stk_gc_next = 58U;
    }
    break;
    case 54: ;
    if (optind + 1 > argc) {
      {
      _1_stk_gc_next = 15U;
      }
    } else {
      {
      _1_stk_gc_next = 67U;
      }
    }
    break;
    case 1: 
    min_l = atoi((char const   *)optarg);
    {
    _1_stk_gc_next = 17U;
    }
    break;
    case 23: 
    is_at = 1;
    {
    _1_stk_gc_next = 17U;
    }
    break;
    case 70: 
    printf((char const   */* __restrict  */)"%s\t%d\t%d\t%d\n", seq->name.s, start,
           max_i + 1, (max_hits - start_hits) + 1);
    {
    _1_stk_gc_next = 42U;
    }
    break;
    case 3: 
    n_hits += hit;
    {
    _1_stk_gc_next = 26U;
    }
    break;
    case 16: ;
    if (sc > max) {
      {
      _1_stk_gc_next = 7U;
      }
    } else {
      {
      _1_stk_gc_next = 61U;
      }
    }
    break;
    case 24: 
    printf((char const   */* __restrict  */)"%s\t%d\t%d\t%d\n", seq->name.s, start,
           max_i + 1, (max_hits - start_hits) + 1);
    {
    _1_stk_gc_next = 30U;
    }
    break;
    case 21: ;
    if (c == 108) {
      {
      _1_stk_gc_next = 1U;
      }
    } else {
      {
      _1_stk_gc_next = 17U;
      }
    }
    break;
    case 36: 
    tmp___4 = 1;
    {
    _1_stk_gc_next = 4U;
    }
    break;
    case 57: 
    sc += q;
    {
    _1_stk_gc_next = 16U;
    }
    break;
    case 68: ;
    if (max - sc > xdropoff) {
      {
      _1_stk_gc_next = 69U;
      }
    } else {
      {
      _1_stk_gc_next = 61U;
      }
    }
    break;
    case 26: ;
    if (hit) {
      {
      _1_stk_gc_next = 52U;
      }
    } else {
      {
      _1_stk_gc_next = 8U;
      }
    }
    break;
    case 11: 
    tmp___5 = 1;
    {
    _1_stk_gc_next = 49U;
    }
    break;
    case 9: ;
    if (c == 8) {
      {
      _1_stk_gc_next = 60U;
      }
    } else {
      {
      _1_stk_gc_next = 0U;
      }
    }
    break;
    case 13: 
    tmp___4 = 1;
    {
    _1_stk_gc_next = 4U;
    }
    break;
    case 51: ;
    if (c == 6) {
      {
      _1_stk_gc_next = 38U;
      }
    } else {
      {
      _1_stk_gc_next = 46U;
      }
    }
    break;
    case 19: 
    is_at = 0;
    min_l = 20;
    frac = (double )0.6f;
    xdropoff = (double )10.0f;
    {
    _1_stk_gc_next = 17U;
    }
    break;
    case 32: 
    sc += (double )(- 1.0f);
    {
    _1_stk_gc_next = 10U;
    }
    break;
    case 17: 
    c = getopt(argc, argv, "wx:f:l:");
    {
    _1_stk_gc_next = 22U;
    }
    break;
    case 40: ;
    return (0);
    break;
    case 67: 
    q = ((double )1.0f - frac) / frac;
    tmp___3 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_gc_next = 43U;
    }
    break;
    case 55: ;
    if (max > 0.) {
      {
      _1_stk_gc_next = 48U;
      }
    } else {
      {
      _1_stk_gc_next = 42U;
      }
    }
    break;
    case 60: 
    tmp___4 = 1;
    {
    _1_stk_gc_next = 4U;
    }
    break;
    case 59: ;
    if (c == 1) {
      {
      _1_stk_gc_next = 36U;
      }
    } else {
      {
      _1_stk_gc_next = 9U;
      }
    }
    break;
    case 6: ;
    if (c == 2) {
      {
      _1_stk_gc_next = 39U;
      }
    } else {
      {
      _1_stk_gc_next = 2U;
      }
    }
    break;
    case 38: 
    tmp___5 = 1;
    {
    _1_stk_gc_next = 49U;
    }
    break;
    case 61: 
    i ++;
    {
    _1_stk_gc_next = 65U;
    }
    break;
    case 58: ;
    return (1);
    break;
    case 34: 
    xdropoff = atof((char const   *)optarg);
    {
    _1_stk_gc_next = 17U;
    }
    break;
    case 48: ;
    if ((max_i + 1) - start >= min_l) {
      {
      _1_stk_gc_next = 70U;
      }
    } else {
      {
      _1_stk_gc_next = 42U;
      }
    }
    break;
    case 22: ;
    if (! (c >= 0)) {
      {
      _1_stk_gc_next = 54U;
      }
    } else {
      {
      _1_stk_gc_next = 25U;
      }
    }
    break;
    case 53: ;
    if (c == 102) {
      {
      _1_stk_gc_next = 18U;
      }
    } else {
      {
      _1_stk_gc_next = 21U;
      }
    }
    break;
    case 65: ;
    if ((size_t___0 )i < seq->seq.l) {
      {
      _1_stk_gc_next = 47U;
      }
    } else {
      {
      _1_stk_gc_next = 55U;
      }
    }
    break;
    case 47: 
    c = (int )seq_nt16_table[(int )*(seq->seq.s + i)];
    {
    _1_stk_gc_next = 33U;
    }
    break;
    case 44: ;
    if (c == 119) {
      {
      _1_stk_gc_next = 23U;
      }
    } else {
      {
      _1_stk_gc_next = 53U;
      }
    }
    break;
    case 5: 
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp = tmp___2;
    {
    _1_stk_gc_next = 50U;
    }
    break;
    case 33: ;
    if (is_at) {
      {
      _1_stk_gc_next = 59U;
      }
    } else {
      {
      _1_stk_gc_next = 6U;
      }
    }
    break;
    case 37: 
    tmp___4 = 0;
    {
    _1_stk_gc_next = 4U;
    }
    break;
    case 64: 
    tmp___0 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___0;
    {
    _1_stk_gc_next = 50U;
    }
    break;
    case 41: 
    start = 0;
    max_i = 0;
    n_hits = 0;
    start_hits = 0;
    max_hits = 0;
    sc = 0.;
    max = 0.;
    i = 0;
    {
    _1_stk_gc_next = 65U;
    }
    break;
    case 10: ;
    if (sc < (double )0) {
      {
      _1_stk_gc_next = 69U;
      }
    } else {
      {
      _1_stk_gc_next = 68U;
      }
    }
    break;
    case 42: 
    tmp___6 = kseq_read(seq);
    {
    _1_stk_gc_next = 62U;
    }
    break;
    case 0: ;
    if (c == 9) {
      {
      _1_stk_gc_next = 13U;
      }
    } else {
      {
      _1_stk_gc_next = 37U;
      }
    }
    break;
    case 46: 
    tmp___5 = 0;
    {
    _1_stk_gc_next = 49U;
    }
    break;
    case 39: 
    tmp___5 = 1;
    {
    _1_stk_gc_next = 49U;
    }
    break;
    case 7: 
    max = sc;
    max_i = i;
    max_hits = n_hits;
    {
    _1_stk_gc_next = 61U;
    }
    break;
    case 43: ;
    if (tmp___3) {
      {
      _1_stk_gc_next = 64U;
      }
    } else {
      {
      _1_stk_gc_next = 5U;
      }
    }
    break;
    case 2: ;
    if (c == 4) {
      {
      _1_stk_gc_next = 11U;
      }
    } else {
      {
      _1_stk_gc_next = 51U;
      }
    }
    break;
    case 20: 
    start = i;
    start_hits = n_hits;
    {
    _1_stk_gc_next = 57U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_gc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_kfreq LOC=UNKNOWN */
int stk_kfreq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *ks ;
  int kmer ;
  int i ;
  int l ;
  int mask ;
  char *nei ;
  size_t___0 tmp ;
  int c ;
  int tmp___0 ;
  void *tmp___1 ;
  int j ;
  int x ;
  int tmp___3 ;
  gzFile tmp___4 ;
  gzFile tmp___5 ;
  int tmp___6 ;
  int k ;
  int x___0[2] ;
  int cnt[2] ;
  int cnt_nei[2] ;
  int which ;
  int c___0 ;
  int tmp___7 ;
  unsigned int _1_stk_kfreq_next ;

  {
  {
  _1_stk_kfreq_next = 59U;
  }
  while (1) {
    switch (_1_stk_kfreq_next) {
    case 18: 
    x___0[0] = ((x___0[0] << 2) | (c___0 - 1)) & mask;
    x___0[1] = (x___0[1] >> 2) | ((4 - c___0) << 2 * (l - 1));
    {
    _1_stk_kfreq_next = 25U;
    }
    break;
    case 50: 
    c = (int )seq_nt6_table[(int )*(*(argv + 1) + i)];
    {
    _1_stk_kfreq_next = 52U;
    }
    break;
    case 25: ;
    if (k < l) {
      {
      _1_stk_kfreq_next = 48U;
      }
    } else {
      {
      _1_stk_kfreq_next = 42U;
      }
    }
    break;
    case 52: ;
    if (c >= 1) {
      {
      _1_stk_kfreq_next = 35U;
      }
    } else {
      {
      _1_stk_kfreq_next = 41U;
      }
    }
    break;
    case 4: 
    which = 1;
    {
    _1_stk_kfreq_next = 17U;
    }
    break;
    case 30: 
    (cnt[0]) ++;
    {
    _1_stk_kfreq_next = 60U;
    }
    break;
    case 62: 
    tmp = strlen((char const   *)*(argv + 1));
    l = (int )tmp;
    kmer = 0;
    i = kmer;
    {
    _1_stk_kfreq_next = 43U;
    }
    break;
    case 15: 
    x = kmer & ~ (3 << 2 * i);
    j = 0;
    {
    _1_stk_kfreq_next = 27U;
    }
    break;
    case 56: 
    (cnt[1]) ++;
    {
    _1_stk_kfreq_next = 60U;
    }
    break;
    case 31: 
    k = 0;
    {
    _1_stk_kfreq_next = 57U;
    }
    break;
    case 12: ;
    return (1);
    break;
    case 8: ;
    return (1);
    break;
    case 45: 
    tmp___5 = gzopen((char const   *)*(argv + 2), "r");
    fp = tmp___5;
    {
    _1_stk_kfreq_next = 29U;
    }
    break;
    case 54: 
    tmp___7 = kseq_read(ks);
    {
    _1_stk_kfreq_next = 26U;
    }
    break;
    case 1: ;
    return (0);
    break;
    case 23: ;
    if (cnt_nei[0] > cnt_nei[1]) {
      {
      _1_stk_kfreq_next = 47U;
      }
    } else {
      {
      _1_stk_kfreq_next = 4U;
      }
    }
    break;
    case 3: 
    ks = kseq_init(fp);
    {
    _1_stk_kfreq_next = 54U;
    }
    break;
    case 16: 
    kseq_destroy(ks);
    gzclose(fp);
    {
    _1_stk_kfreq_next = 1U;
    }
    break;
    case 24: 
    i ++;
    {
    _1_stk_kfreq_next = 28U;
    }
    break;
    case 21: ;
    if (*(nei + x___0[1])) {
      {
      _1_stk_kfreq_next = 22U;
      }
    } else {
      {
      _1_stk_kfreq_next = 57U;
      }
    }
    break;
    case 36: ;
    if (tmp___6 == 0) {
      {
      _1_stk_kfreq_next = 2U;
      }
    } else {
      {
      _1_stk_kfreq_next = 45U;
      }
    }
    break;
    case 57: 
    i ++;
    {
    _1_stk_kfreq_next = 20U;
    }
    break;
    case 26: ;
    if (! (tmp___7 >= 0)) {
      {
      _1_stk_kfreq_next = 16U;
      }
    } else {
      {
      _1_stk_kfreq_next = 19U;
      }
    }
    break;
    case 11: ;
    if (c___0 >= 1) {
      {
      _1_stk_kfreq_next = 44U;
      }
    } else {
      {
      _1_stk_kfreq_next = 31U;
      }
    }
    break;
    case 9: 
    tmp___0 = 1;
    {
    _1_stk_kfreq_next = 13U;
    }
    break;
    case 13: 
    kmer = (kmer << 2) | (c - 1);
    i ++;
    {
    _1_stk_kfreq_next = 43U;
    }
    break;
    case 51: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_kfreq_next = 29U;
    }
    break;
    case 19: 
    cnt_nei[1] = 0;
    cnt_nei[0] = cnt_nei[1];
    cnt[1] = cnt_nei[0];
    cnt[0] = cnt[1];
    k = cnt[0];
    x___0[1] = k;
    x___0[0] = x___0[1];
    i = 0;
    {
    _1_stk_kfreq_next = 20U;
    }
    break;
    case 32: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_kfreq");
    {
    _1_stk_kfreq_next = 12U;
    }
    break;
    case 17: 
    printf((char const   */* __restrict  */)"%s\t%ld\t%c\t%d\t%d\n", ks->name.s, ks->seq.l,
           (int )*("+-" + which), cnt_nei[which], cnt[which]);
    {
    _1_stk_kfreq_next = 54U;
    }
    break;
    case 40: 
    *(nei + (x | (j << 2 * i))) = (char)1;
    j ++;
    {
    _1_stk_kfreq_next = 27U;
    }
    break;
    case 55: ;
    if (argc == 2) {
      {
      _1_stk_kfreq_next = 51U;
      }
    } else {
      {
      _1_stk_kfreq_next = 61U;
      }
    }
    break;
    case 60: ;
    if (*(nei + x___0[0])) {
      {
      _1_stk_kfreq_next = 58U;
      }
    } else {
      {
      _1_stk_kfreq_next = 21U;
      }
    }
    break;
    case 59: ;
    if (argc < 2) {
      {
      _1_stk_kfreq_next = 37U;
      }
    } else {
      {
      _1_stk_kfreq_next = 62U;
      }
    }
    break;
    case 27: ;
    if (j < 4) {
      {
      _1_stk_kfreq_next = 40U;
      }
    } else {
      {
      _1_stk_kfreq_next = 24U;
      }
    }
    break;
    case 38: 
    mask = (1 << 2 * l) - 1;
    tmp___1 = calloc((size_t___0 )1, (size_t___0 )(1 << 2 * l));
    nei = (char *)tmp___1;
    i = 0;
    {
    _1_stk_kfreq_next = 28U;
    }
    break;
    case 61: 
    tmp___6 = strcmp((char const   *)*(argv + 2), "-");
    {
    _1_stk_kfreq_next = 36U;
    }
    break;
    case 58: 
    (cnt_nei[0]) ++;
    {
    _1_stk_kfreq_next = 57U;
    }
    break;
    case 34: ;
    if (x___0[1] == kmer) {
      {
      _1_stk_kfreq_next = 56U;
      }
    } else {
      {
      _1_stk_kfreq_next = 60U;
      }
    }
    break;
    case 48: 
    k ++;
    {
    _1_stk_kfreq_next = 42U;
    }
    break;
    case 22: 
    (cnt_nei[1]) ++;
    {
    _1_stk_kfreq_next = 57U;
    }
    break;
    case 28: ;
    if (i < l) {
      {
      _1_stk_kfreq_next = 15U;
      }
    } else {
      {
      _1_stk_kfreq_next = 55U;
      }
    }
    break;
    case 47: 
    which = 0;
    {
    _1_stk_kfreq_next = 17U;
    }
    break;
    case 44: ;
    if (c___0 <= 4) {
      {
      _1_stk_kfreq_next = 18U;
      }
    } else {
      {
      _1_stk_kfreq_next = 46U;
      }
    }
    break;
    case 33: 
    c___0 = (int )seq_nt6_table[(int )*(ks->seq.s + i)];
    {
    _1_stk_kfreq_next = 11U;
    }
    break;
    case 37: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk kfreq <kmer> <in.fa>\n");
    {
    _1_stk_kfreq_next = 8U;
    }
    break;
    case 41: 
    __assert_fail("c >= 1 && c <= 4", "seqtk.c", 1525, "stk_kfreq");
    tmp___0 = 0;

    break;
    case 10: ;
    if (x___0[0] == kmer) {
      {
      _1_stk_kfreq_next = 30U;
      }
    } else {
      {
      _1_stk_kfreq_next = 34U;
      }
    }
    break;
    case 42: ;
    if (k == l) {
      {
      _1_stk_kfreq_next = 10U;
      }
    } else {
      {
      _1_stk_kfreq_next = 57U;
      }
    }
    break;
    case 0: 
    __assert_fail("c >= 1 && c <= 4", "seqtk.c", 1525, "stk_kfreq");
    tmp___0 = 0;

    break;
    case 46: 
    k = 0;
    {
    _1_stk_kfreq_next = 57U;
    }
    break;
    case 35: ;
    if (c <= 4) {
      {
      _1_stk_kfreq_next = 9U;
      }
    } else {
      {
      _1_stk_kfreq_next = 0U;
      }
    }
    break;
    case 29: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_kfreq_next = 32U;
      }
    } else {
      {
      _1_stk_kfreq_next = 3U;
      }
    }
    break;
    case 43: ;
    if (i < l) {
      {
      _1_stk_kfreq_next = 50U;
      }
    } else {
      {
      _1_stk_kfreq_next = 38U;
      }
    }
    break;
    case 2: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_kfreq_next = 29U;
    }
    break;
    case 20: ;
    if ((size_t___0 )i < ks->seq.l) {
      {
      _1_stk_kfreq_next = 33U;
      }
    } else {
      {
      _1_stk_kfreq_next = 23U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_kfreq LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_comp LOC=UNKNOWN */
int stk_comp(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int upper_only ;
  reghash_t *h ;
  reglist_t dummy ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int i ;
  int k ;
  reglist_t *p ;
  khint_t k___0 ;
  khint_t tmp___7 ;
  int beg ;
  int end ;
  int la ;
  int lb ;
  int lc ;
  int na ;
  int nb ;
  int nc ;
  int cnt[11] ;
  int is_CpG ;
  int a ;
  int b ;
  int c___0 ;
  int tmp___8 ;
  unsigned int _1_stk_comp_next ;

  {
  {
  _1_stk_comp_next = 0U;
  }
  while (1) {
    switch (_1_stk_comp_next) {
    case 18: ;
    if (h) {
      {
      _1_stk_comp_next = 57U;
      }
    } else {
      {
      _1_stk_comp_next = 9U;
      }
    }
    break;
    case 80: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_comp_next = 40U;
    }
    break;
    case 25: 
    la = 'a';
    lb = -1;
    lc = 0;
    {
    _1_stk_comp_next = 83U;
    }
    break;
    case 49: 
    (cnt[8]) ++;
    {
    _1_stk_comp_next = 78U;
    }
    break;
    case 52: 
    (cnt[seq_nt16to4_table[b]]) ++;
    {
    _1_stk_comp_next = 11U;
    }
    break;
    case 4: 
    is_CpG = 1;
    {
    _1_stk_comp_next = 10U;
    }
    break;
    case 30: 
    (cnt[9]) ++;
    {
    _1_stk_comp_next = 78U;
    }
    break;
    case 62: 
    upper_only = 1;
    {
    _1_stk_comp_next = 92U;
    }
    break;
    case 15: 
    is_CpG = 0;
    a = na;
    b = nb;
    c___0 = nc;
    na = (int )*(seq->seq.s + (i + 1));
    nb = (int )seq_nt16_table[na];
    nc = bitcnt_table[nb];
    {
    _1_stk_comp_next = 20U;
    }
    break;
    case 82: ;
    if (beg > 0) {
      {
      _1_stk_comp_next = 24U;
      }
    } else {
      {
      _1_stk_comp_next = 25U;
      }
    }
    break;
    case 89: 
    _L___0: ;
    if (nb == 4) {
      {
      _1_stk_comp_next = 74U;
      }
    } else {
      {
      _1_stk_comp_next = 2U;
      }
    }
    break;
    case 56: 
    printf((char const   */* __restrict  */)"%s\t%d\t%d", seq->name.s, beg, end);
    {
    _1_stk_comp_next = 35U;
    }
    break;
    case 31: ;
    if (tmp___5) {
      {
      _1_stk_comp_next = 64U;
      }
    } else {
      {
      _1_stk_comp_next = 23U;
      }
    }
    break;
    case 12: ;
    if (b == 4) {
      {
      _1_stk_comp_next = 44U;
      }
    } else {
      {
      _1_stk_comp_next = 94U;
      }
    }
    break;
    case 8: 
    l = kseq_read(seq);
    {
    _1_stk_comp_next = 43U;
    }
    break;
    case 96: ;
    if (b == 5) {
      {
      _1_stk_comp_next = 90U;
      }
    } else {
      {
      _1_stk_comp_next = 58U;
      }
    }
    break;
    case 54: 
    (cnt[9]) ++;
    {
    _1_stk_comp_next = 78U;
    }
    break;
    case 78: ;
    if (is_CpG) {
      {
      _1_stk_comp_next = 85U;
      }
    } else {
      {
      _1_stk_comp_next = 58U;
      }
    }
    break;
    case 81: 
    fflush(stdout);
    {
    _1_stk_comp_next = 8U;
    }
    break;
    case 23: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_comp_next = 40U;
    }
    break;
    case 70: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_comp");
    {
    _1_stk_comp_next = 28U;
    }
    break;
    case 16: 
    (cnt[c___0 + 2]) ++;
    {
    _1_stk_comp_next = 17U;
    }
    break;
    case 24: 
    la = (int )*(seq->seq.s + (beg - 1));
    lb = (int )seq_nt16_table[la];
    lc = bitcnt_table[lb];
    {
    _1_stk_comp_next = 83U;
    }
    break;
    case 21: ;
    return (1);
    break;
    case 94: ;
    if (b == 5) {
      {
      _1_stk_comp_next = 44U;
      }
    } else {
      {
      _1_stk_comp_next = 10U;
      }
    }
    break;
    case 76: 
    k = 0;
    {
    _1_stk_comp_next = 72U;
    }
    break;
    case 57: 
    tmp___7 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
    k___0 = tmp___7;
    {
    _1_stk_comp_next = 88U;
    }
    break;
    case 68: ;
    if (b == 5) {
      {
      _1_stk_comp_next = 54U;
      }
    } else {
      {
      _1_stk_comp_next = 55U;
      }
    }
    break;
    case 85: 
    (cnt[7]) ++;
    {
    _1_stk_comp_next = 51U;
    }
    break;
    case 26: ;
    return (0);
    break;
    case 11: ;
    if (b == 10) {
      {
      _1_stk_comp_next = 30U;
      }
    } else {
      {
      _1_stk_comp_next = 68U;
      }
    }
    break;
    case 9: 
    p = & dummy;
    *(dummy.a + 0) = (uint64_t )l;
    {
    _1_stk_comp_next = 76U;
    }
    break;
    case 13: ;
    if (b == 10) {
      {
      _1_stk_comp_next = 89U;
      }
    } else {
      {
      _1_stk_comp_next = 12U;
      }
    }
    break;
    case 63: ;
    if (tmp___0) {
      {
      _1_stk_comp_next = 59U;
      }
    } else {
      {
      _1_stk_comp_next = 37U;
      }
    }
    break;
    case 51: ;
    if (b == 10) {
      {
      _1_stk_comp_next = 42U;
      }
    } else {
      {
      _1_stk_comp_next = 96U;
      }
    }
    break;
    case 32: 
    p = h->vals + k___0;
    {
    _1_stk_comp_next = 76U;
    }
    break;
    case 17: ;
    if (c___0 == 1) {
      {
      _1_stk_comp_next = 52U;
      }
    } else {
      {
      _1_stk_comp_next = 11U;
      }
    }
    break;
    case 90: 
    (cnt[10]) ++;
    {
    _1_stk_comp_next = 58U;
    }
    break;
    case 40: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_comp_next = 70U;
      }
    } else {
      {
      _1_stk_comp_next = 71U;
      }
    }
    break;
    case 67: 
    is_CpG = 1;
    {
    _1_stk_comp_next = 10U;
    }
    break;
    case 55: ;
    if (c___0 == 2) {
      {
      _1_stk_comp_next = 49U;
      }
    } else {
      {
      _1_stk_comp_next = 78U;
      }
    }
    break;
    case 60: 
    free((void *)dummy.a);
    kseq_destroy(seq);
    gzclose(fp);
    {
    _1_stk_comp_next = 26U;
    }
    break;
    case 59: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:  seqtk comp [-u] [-r in.bed] <in.fa>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output format: chr, length, #A, #C, #G, #T, #2, #3, #4, #CpG, #tv, #ts, #CpG-ts\n");
    {
    _1_stk_comp_next = 21U;
    }
    break;
    case 6: ;
    if (i < 11) {
      {
      _1_stk_comp_next = 47U;
      }
    } else {
      {
      _1_stk_comp_next = 53U;
      }
    }
    break;
    case 38: ;
    switch (c) {
    case 117: 
    {
    _1_stk_comp_next = 62U;
    }
    break;
    case 114: 
    {
    _1_stk_comp_next = 87U;
    }
    break;
    default: 
    {
    _1_stk_comp_next = 92U;
    }
    break;
    }
    break;
    case 61: ;
    if (! (c >= 0)) {
      {
      _1_stk_comp_next = 22U;
      }
    } else {
      {
      _1_stk_comp_next = 38U;
      }
    }
    break;
    case 87: 
    h = stk_reg_read((char const   *)optarg);
    {
    _1_stk_comp_next = 92U;
    }
    break;
    case 58: 
    la = a;
    lb = b;
    lc = c___0;
    i ++;
    {
    _1_stk_comp_next = 29U;
    }
    break;
    case 84: 
    _L___1: ;
    if (c___0 > 1) {
      {
      _1_stk_comp_next = 16U;
      }
    } else {
      {
      _1_stk_comp_next = 17U;
      }
    }
    break;
    case 74: 
    is_CpG = 1;
    {
    _1_stk_comp_next = 10U;
    }
    break;
    case 75: ;
    if (tmp___8) {
      {
      _1_stk_comp_next = 84U;
      }
    } else {
      {
      _1_stk_comp_next = 58U;
      }
    }
    break;
    case 48: ;
    if (lb == 10) {
      {
      _1_stk_comp_next = 39U;
      }
    } else {
      {
      _1_stk_comp_next = 10U;
      }
    }
    break;
    case 71: 
    seq = kseq_init(fp);
    dummy.m = 1;
    dummy.n = dummy.m;
    tmp___6 = calloc((size_t___0 )1, (size_t___0 )8);
    dummy.a = (uint64_t *)tmp___6;
    {
    _1_stk_comp_next = 8U;
    }
    break;
    case 22: ;
    if (argc == optind) {
      {
      _1_stk_comp_next = 66U;
      }
    } else {
      {
      _1_stk_comp_next = 37U;
      }
    }
    break;
    case 28: ;
    return (1);
    break;
    case 53: 
    putchar('\n');
    k ++;
    {
    _1_stk_comp_next = 72U;
    }
    break;
    case 65: ;
    if (! (k < p->n)) {
      {
      _1_stk_comp_next = 81U;
      }
    } else {
      {
      _1_stk_comp_next = 41U;
      }
    }
    break;
    case 47: 
    printf((char const   */* __restrict  */)"\t%d", cnt[i]);
    i ++;
    {
    _1_stk_comp_next = 6U;
    }
    break;
    case 44: 
    _L: ;
    if (lb == 2) {
      {
      _1_stk_comp_next = 67U;
      }
    } else {
      {
      _1_stk_comp_next = 48U;
      }
    }
    break;
    case 5: 
    p = (reglist_t *)0;
    {
    _1_stk_comp_next = 18U;
    }
    break;
    case 91: 
    printf((char const   */* __restrict  */)"%s\t%d", seq->name.s, l);
    {
    _1_stk_comp_next = 35U;
    }
    break;
    case 72: ;
    if (p) {
      {
      _1_stk_comp_next = 65U;
      }
    } else {
      {
      _1_stk_comp_next = 81U;
      }
    }
    break;
    case 33: ;
    if (h) {
      {
      _1_stk_comp_next = 56U;
      }
    } else {
      {
      _1_stk_comp_next = 91U;
      }
    }
    break;
    case 37: ;
    if (optind < argc) {
      {
      _1_stk_comp_next = 93U;
      }
    } else {
      {
      _1_stk_comp_next = 80U;
      }
    }
    break;
    case 64: 
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
    fp = tmp___2;
    {
    _1_stk_comp_next = 40U;
    }
    break;
    case 93: 
    tmp___5 = strcmp((char const   *)*(argv + optind), "-");
    {
    _1_stk_comp_next = 31U;
    }
    break;
    case 41: 
    beg = (int )(*(p->a + k) >> 32);
    end = (int )(*(p->a + k) & 4294967295ULL);
    {
    _1_stk_comp_next = 82U;
    }
    break;
    case 92: 
    c = getopt(argc, argv, "ur:");
    {
    _1_stk_comp_next = 61U;
    }
    break;
    case 10: ;
    if (upper_only == 0) {
      {
      _1_stk_comp_next = 84U;
      }
    } else {
      {
      _1_stk_comp_next = 7U;
      }
    }
    break;
    case 42: 
    (cnt[10]) ++;
    {
    _1_stk_comp_next = 58U;
    }
    break;
    case 0: 
    upper_only = 0;
    h = (reghash_t *)0;
    {
    _1_stk_comp_next = 92U;
    }
    break;
    case 39: 
    is_CpG = 1;
    {
    _1_stk_comp_next = 10U;
    }
    break;
    case 66: 
    tmp = fileno(stdin);
    tmp___0 = isatty(tmp);
    {
    _1_stk_comp_next = 63U;
    }
    break;
    case 83: 
    na = (int )*(seq->seq.s + beg);
    nb = (int )seq_nt16_table[na];
    nc = bitcnt_table[nb];
    memset((void *)(cnt), 0, 11UL * sizeof(int ));
    i = beg;
    {
    _1_stk_comp_next = 29U;
    }
    break;
    case 7: 
    tmp___8 = isupper(a);
    {
    _1_stk_comp_next = 75U;
    }
    break;
    case 88: ;
    if (k___0 != h->n_buckets) {
      {
      _1_stk_comp_next = 32U;
      }
    } else {
      {
      _1_stk_comp_next = 76U;
      }
    }
    break;
    case 35: 
    i = 0;
    {
    _1_stk_comp_next = 6U;
    }
    break;
    case 29: ;
    if (i < end) {
      {
      _1_stk_comp_next = 15U;
      }
    } else {
      {
      _1_stk_comp_next = 33U;
      }
    }
    break;
    case 43: ;
    if (! (l >= 0)) {
      {
      _1_stk_comp_next = 60U;
      }
    } else {
      {
      _1_stk_comp_next = 5U;
      }
    }
    break;
    case 2: ;
    if (nb == 5) {
      {
      _1_stk_comp_next = 4U;
      }
    } else {
      {
      _1_stk_comp_next = 10U;
      }
    }
    break;
    case 20: ;
    if (b == 2) {
      {
      _1_stk_comp_next = 89U;
      }
    } else {
      {
      _1_stk_comp_next = 13U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_comp LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_getuntil2 LOC=UNKNOWN */
static int ks_getuntil2(kstream_t *ks , int delimiter , kstring_t *str , int *dret ,
                        int append ) 
{ 
  int gotany ;
  int i ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int _1_ks_getuntil2_next ;

  {
  {
  _1_ks_getuntil2_next = 47U;
  }
  while (1) {
    switch (_1_ks_getuntil2_next) {
    case 50: ;
    if (ks->is_eof) {
      {
      _1_ks_getuntil2_next = 14U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 65U;
      }
    }
    break;
    case 25: 
    i = ks->begin;
    {
    _1_ks_getuntil2_next = 23U;
    }
    break;
    case 49: ;
    return (-1);
    break;
    case 4: ;
    if ((int )*(str->s + (str->l - 1UL)) == 13) {
      {
      _1_ks_getuntil2_next = 66U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 68U;
      }
    }
    break;
    case 30: ;
    if (ks->end == 0) {
      {
      _1_ks_getuntil2_next = 9U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 32U;
      }
    }
    break;
    case 62: ;
    if (tmp___0) {
      {
      _1_ks_getuntil2_next = 46U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 10U;
      }
    }
    break;
    case 14: ;
    if (ks->begin >= ks->end) {
      {
      _1_ks_getuntil2_next = 49U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 65U;
      }
    }
    break;
    case 15: 
    ks->is_eof = 1;
    {
    _1_ks_getuntil2_next = 55U;
    }
    break;
    case 56: 
    i ++;
    {
    _1_ks_getuntil2_next = 23U;
    }
    break;
    case 31: 
    *dret = 0;
    {
    _1_ks_getuntil2_next = 1U;
    }
    break;
    case 12: ;
    return (-3);
    break;
    case 69: 
    gotany = 1;
    memcpy((void */* __restrict  */)(str->s + str->l), (void const   */* __restrict  */)(ks->buf + ks->begin),
           (size_t___0 )(i - ks->begin));
    str->l += (size_t___0 )(i - ks->begin);
    ks->begin = i + 1;
    {
    _1_ks_getuntil2_next = 39U;
    }
    break;
    case 1: ;
    if (append) {
      {
      _1_ks_getuntil2_next = 22U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 34U;
      }
    }
    break;
    case 23: ;
    if (i < ks->end) {
      {
      _1_ks_getuntil2_next = 41U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 44U;
      }
    }
    break;
    case 16: 
    str->m = (size_t___0 )1;
    tmp___2 = calloc((size_t___0 )1, (size_t___0 )1);
    str->s = (char *)tmp___2;
    {
    _1_ks_getuntil2_next = 68U;
    }
    break;
    case 24: ;
    if ((int )*(ks->buf + i) == delimiter) {
      {
      _1_ks_getuntil2_next = 44U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 58U;
      }
    }
    break;
    case 21: ;
    if (delimiter == 1) {
      {
      _1_ks_getuntil2_next = 7U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 13U;
      }
    }
    break;
    case 68: 
    *(str->s + str->l) = (char )'\000';
    {
    _1_ks_getuntil2_next = 53U;
    }
    break;
    case 26: ;
    if (tmp) {
      {
      _1_ks_getuntil2_next = 44U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 56U;
      }
    }
    break;
    case 11: ;
    if (dret) {
      {
      _1_ks_getuntil2_next = 37U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 63U;
      }
    }
    break;
    case 9: 
    ks->is_eof = 1;
    {
    _1_ks_getuntil2_next = 63U;
    }
    break;
    case 13: 
    i = 0;
    {
    _1_ks_getuntil2_next = 44U;
    }
    break;
    case 63: ;
    if (! gotany) {
      {
      _1_ks_getuntil2_next = 50U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 65U;
      }
    }
    break;
    case 51: 
    i ++;
    {
    _1_ks_getuntil2_next = 43U;
    }
    break;
    case 19: ;
    if (! ks->is_eof) {
      {
      _1_ks_getuntil2_next = 33U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 63U;
      }
    }
    break;
    case 32: ;
    if (ks->end == -1) {
      {
      _1_ks_getuntil2_next = 15U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 42U;
      }
    }
    break;
    case 17: 
    str->m = (str->l + (size_t___0 )(i - ks->begin)) + 1UL;
    (str->m) --;
    str->m |= str->m >> 1;
    str->m |= str->m >> 2;
    str->m |= str->m >> 4;
    str->m |= str->m >> 8;
    str->m |= str->m >> 16;
    (str->m) ++;
    tmp___1 = realloc((void *)str->s, str->m);
    str->s = (char *)tmp___1;
    {
    _1_ks_getuntil2_next = 69U;
    }
    break;
    case 67: ;
    if (i < ks->end) {
      {
      _1_ks_getuntil2_next = 24U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 44U;
      }
    }
    break;
    case 55: ;
    return (-3);
    break;
    case 6: ;
    if (dret) {
      {
      _1_ks_getuntil2_next = 31U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 1U;
      }
    }
    break;
    case 38: ;
    if (ks->begin >= ks->end) {
      {
      _1_ks_getuntil2_next = 19U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 42U;
      }
    }
    break;
    case 61: ;
    if (delimiter > 2) {
      {
      _1_ks_getuntil2_next = 20U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 28U;
      }
    }
    break;
    case 58: 
    i ++;
    {
    _1_ks_getuntil2_next = 67U;
    }
    break;
    case 34: 
    str->l = (size_t___0 )0;
    {
    _1_ks_getuntil2_next = 5U;
    }
    break;
    case 22: 
    str->l = str->l;
    {
    _1_ks_getuntil2_next = 5U;
    }
    break;
    case 28: ;
    if (delimiter == 0) {
      {
      _1_ks_getuntil2_next = 25U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 21U;
      }
    }
    break;
    case 53: ;
    return ((int )str->l);
    break;
    case 65: ;
    if ((unsigned long )str->s == (unsigned long )((char *)0)) {
      {
      _1_ks_getuntil2_next = 16U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 0U;
      }
    }
    break;
    case 47: 
    gotany = 0;
    {
    _1_ks_getuntil2_next = 6U;
    }
    break;
    case 73: 
    tmp___0 = isspace((int )*(ks->buf + i));
    {
    _1_ks_getuntil2_next = 62U;
    }
    break;
    case 44: ;
    if (str->m - str->l < (size_t___0 )((i - ks->begin) + 1)) {
      {
      _1_ks_getuntil2_next = 17U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 69U;
      }
    }
    break;
    case 5: ;
    if (ks->end < 0) {
      {
      _1_ks_getuntil2_next = 12U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 38U;
      }
    }
    break;
    case 72: ;
    if (i < ks->end) {
      {
      _1_ks_getuntil2_next = 73U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 44U;
      }
    }
    break;
    case 33: 
    ks->begin = 0;
    ks->end = gzread(ks->f, (voidp )ks->buf, 16384U);
    {
    _1_ks_getuntil2_next = 30U;
    }
    break;
    case 37: 
    *dret = (int )*(ks->buf + i);
    {
    _1_ks_getuntil2_next = 63U;
    }
    break;
    case 64: ;
    if ((int )*(ks->buf + i) == 10) {
      {
      _1_ks_getuntil2_next = 44U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 51U;
      }
    }
    break;
    case 41: 
    tmp = isspace((int )*(ks->buf + i));
    {
    _1_ks_getuntil2_next = 26U;
    }
    break;
    case 10: 
    i ++;
    {
    _1_ks_getuntil2_next = 72U;
    }
    break;
    case 42: ;
    if (delimiter == 2) {
      {
      _1_ks_getuntil2_next = 29U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 61U;
      }
    }
    break;
    case 0: ;
    if (delimiter == 2) {
      {
      _1_ks_getuntil2_next = 2U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 68U;
      }
    }
    break;
    case 46: ;
    if ((int )*(ks->buf + i) != 32) {
      {
      _1_ks_getuntil2_next = 44U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 10U;
      }
    }
    break;
    case 39: ;
    if (i < ks->end) {
      {
      _1_ks_getuntil2_next = 11U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 5U;
      }
    }
    break;
    case 66: 
    (str->l) --;
    {
    _1_ks_getuntil2_next = 68U;
    }
    break;
    case 7: 
    i = ks->begin;
    {
    _1_ks_getuntil2_next = 72U;
    }
    break;
    case 29: 
    i = ks->begin;
    {
    _1_ks_getuntil2_next = 43U;
    }
    break;
    case 43: ;
    if (i < ks->end) {
      {
      _1_ks_getuntil2_next = 64U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 44U;
      }
    }
    break;
    case 2: ;
    if (str->l > 1UL) {
      {
      _1_ks_getuntil2_next = 4U;
      }
    } else {
      {
      _1_ks_getuntil2_next = 68U;
      }
    }
    break;
    case 20: 
    i = ks->begin;
    {
    _1_ks_getuntil2_next = 67U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF ks_getuntil2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ks_init LOC=UNKNOWN */
__inline static kstream_t *ks_init(gzFile f ) 
{ 
  kstream_t *ks ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int _1_ks_init_next ;

  {
  {
  _1_ks_init_next = 1U;
  }
  while (1) {
    switch (_1_ks_init_next) {
    case 1: 
    tmp = calloc((size_t___0 )1, sizeof(kstream_t ));
    ks = (kstream_t *)tmp;
    ks->f = f;
    tmp___0 = malloc((size_t___0 )16384);
    ks->buf = (unsigned char *)tmp___0;
    {
    _1_ks_init_next = 0U;
    }
    break;
    case 0: ;
    return (ks);
    break;
    }
  }
}
}
/* END FUNCTION-DEF ks_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_mergepe LOC=UNKNOWN */
int stk_mergepe(int argc , char **argv ) 
{ 
  gzFile fp1 ;
  gzFile fp2 ;
  kseq_t *seq[2] ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___5 ;
  int tmp___6 ;
  gzFile tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int _1_stk_mergepe_next ;

  {
  {
  _1_stk_mergepe_next = 18U;
  }
  while (1) {
    switch (_1_stk_mergepe_next) {
    case 18: ;
    if (argc < 3) {
      {
      _1_stk_mergepe_next = 8U;
      }
    } else {
      {
      _1_stk_mergepe_next = 22U;
      }
    }
    break;
    case 25: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergepe");
    {
    _1_stk_mergepe_next = 17U;
    }
    break;
    case 4: ;
    return (1);
    break;
    case 30: 
    tmp___5 = gzopen((char const   *)*(argv + 2), "r");
    fp2 = tmp___5;
    {
    _1_stk_mergepe_next = 3U;
    }
    break;
    case 14: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[W::%s] the 2nd file has fewer records.\n",
            "stk_mergepe");
    {
    _1_stk_mergepe_next = 9U;
    }
    break;
    case 15: 
    tmp___0 = gzopen((char const   *)*(argv + 1), "r");
    fp1 = tmp___0;
    {
    _1_stk_mergepe_next = 20U;
    }
    break;
    case 31: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mergepe");
    {
    _1_stk_mergepe_next = 23U;
    }
    break;
    case 12: ;
    if (tmp___3) {
      {
      _1_stk_mergepe_next = 15U;
      }
    } else {
      {
      _1_stk_mergepe_next = 10U;
      }
    }
    break;
    case 8: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk mergepe <in1.fq> <in2.fq>\n");
    {
    _1_stk_mergepe_next = 4U;
    }
    break;
    case 1: ;
    if (tmp___11 >= 0) {
      {
      _1_stk_mergepe_next = 19U;
      }
    } else {
      {
      _1_stk_mergepe_next = 28U;
      }
    }
    break;
    case 23: ;
    return (1);
    break;
    case 3: ;
    if ((unsigned long )fp1 == (unsigned long )((gzFile )0)) {
      {
      _1_stk_mergepe_next = 25U;
      }
    } else {
      {
      _1_stk_mergepe_next = 6U;
      }
    }
    break;
    case 16: ;
    if (! (tmp___10 >= 0)) {
      {
      _1_stk_mergepe_next = 9U;
      }
    } else {
      {
      _1_stk_mergepe_next = 0U;
      }
    }
    break;
    case 24: ;
    return (0);
    break;
    case 26: 
    tmp___10 = kseq_read(seq[0]);
    {
    _1_stk_mergepe_next = 16U;
    }
    break;
    case 11: ;
    if (tmp___8) {
      {
      _1_stk_mergepe_next = 30U;
      }
    } else {
      {
      _1_stk_mergepe_next = 27U;
      }
    }
    break;
    case 9: 
    tmp___11 = kseq_read(seq[1]);
    {
    _1_stk_mergepe_next = 1U;
    }
    break;
    case 13: 
    seq[0] = kseq_init(fp1);
    seq[1] = kseq_init(fp2);
    {
    _1_stk_mergepe_next = 26U;
    }
    break;
    case 19: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[W::%s] the 1st file has fewer records.\n",
            "stk_mergepe");
    {
    _1_stk_mergepe_next = 28U;
    }
    break;
    case 17: ;
    return (1);
    break;
    case 6: ;
    if ((unsigned long )fp2 == (unsigned long )((gzFile )0)) {
      {
      _1_stk_mergepe_next = 31U;
      }
    } else {
      {
      _1_stk_mergepe_next = 13U;
      }
    }
    break;
    case 27: 
    tmp___6 = fileno(stdin);
    tmp___7 = gzdopen(tmp___6, "r");
    fp2 = tmp___7;
    {
    _1_stk_mergepe_next = 3U;
    }
    break;
    case 22: 
    tmp___3 = strcmp((char const   *)*(argv + 1), "-");
    {
    _1_stk_mergepe_next = 12U;
    }
    break;
    case 28: 
    kseq_destroy(seq[0]);
    gzclose(fp1);
    kseq_destroy(seq[1]);
    gzclose(fp2);
    {
    _1_stk_mergepe_next = 24U;
    }
    break;
    case 5: ;
    if (tmp___9 < 0) {
      {
      _1_stk_mergepe_next = 14U;
      }
    } else {
      {
      _1_stk_mergepe_next = 2U;
      }
    }
    break;
    case 10: 
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp1 = tmp___2;
    {
    _1_stk_mergepe_next = 20U;
    }
    break;
    case 0: 
    tmp___9 = kseq_read(seq[1]);
    {
    _1_stk_mergepe_next = 5U;
    }
    break;
    case 2: 
    stk_printseq((kseq_t const   *)seq[0], 0);
    stk_printseq((kseq_t const   *)seq[1], 0);
    {
    _1_stk_mergepe_next = 26U;
    }
    break;
    case 20: 
    tmp___8 = strcmp((char const   *)*(argv + 2), "-");
    {
    _1_stk_mergepe_next = 11U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_mergepe LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_mutfa LOC=UNKNOWN */
int stk_mutfa(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  kstream_t *ks ;
  int l ;
  int i ;
  int dret ;
  kstring_t *str ;
  khint_t k ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  char *s ;
  char *tmp___6 ;
  int beg ;
  int ret ;
  reglist_t *p ;
  long tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  gzFile tmp___14 ;
  int tmp___15 ;
  gzFile tmp___16 ;
  int tmp___17 ;
  reglist_t *p___0 ;
  int beg___0 ;
  unsigned int _1_stk_mutfa_next ;

  {
  {
  _1_stk_mutfa_next = 57U;
  }
  while (1) {
    switch (_1_stk_mutfa_next) {
    case 18: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_mutfa_next = 42U;
      }
    } else {
      {
      _1_stk_mutfa_next = 12U;
      }
    }
    break;
    case 50: 
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
    {
    _1_stk_mutfa_next = 58U;
    }
    break;
    case 25: 
    k = kh_put_reg(h, (kh_cstr_t )s, & ret);
    memset((void *)(h->vals + k), 0, sizeof(reglist_t ));
    {
    _1_stk_mutfa_next = 77U;
    }
    break;
    case 49: ;
    if (argc < 3) {
      {
      _1_stk_mutfa_next = 26U;
      }
    } else {
      {
      _1_stk_mutfa_next = 30U;
      }
    }
    break;
    case 52: ;
    if (p->n == p->m) {
      {
      _1_stk_mutfa_next = 68U;
      }
    } else {
      {
      _1_stk_mutfa_next = 21U;
      }
    }
    break;
    case 4: 
    p->m <<= 1;
    {
    _1_stk_mutfa_next = 34U;
    }
    break;
    case 30: 
    tmp___0 = calloc((size_t___0 )1, sizeof(kstring_t ));
    str = (kstring_t *)tmp___0;
    tmp___5 = strcmp((char const   *)*(argv + 2), "-");
    {
    _1_stk_mutfa_next = 36U;
    }
    break;
    case 62: ;
    if (i < p___0->n) {
      {
      _1_stk_mutfa_next = 46U;
      }
    } else {
      {
      _1_stk_mutfa_next = 38U;
      }
    }
    break;
    case 14: ;
    if (tmp___11) {
      {
      _1_stk_mutfa_next = 19U;
      }
    } else {
      {
      _1_stk_mutfa_next = 24U;
      }
    }
    break;
    case 15: 
    tmp___14 = gzopen((char const   *)*(argv + 1), "r");
    fp = tmp___14;
    {
    _1_stk_mutfa_next = 18U;
    }
    break;
    case 56: 
    tmp___15 = fileno(stdin);
    tmp___16 = gzdopen(tmp___15, "r");
    fp = tmp___16;
    {
    _1_stk_mutfa_next = 18U;
    }
    break;
    case 12: 
    seq = kseq_init(fp);
    {
    _1_stk_mutfa_next = 7U;
    }
    break;
    case 69: ;
    if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
      {
      _1_stk_mutfa_next = 65U;
      }
    } else {
      {
      _1_stk_mutfa_next = 2U;
      }
    }
    break;
    case 8: 
    putchar((int )*(seq->seq.s + i));
    i ++;
    {
    _1_stk_mutfa_next = 28U;
    }
    break;
    case 45: 
    kseq_destroy(seq);
    gzclose(fp);
    k = (khint_t )0;
    {
    _1_stk_mutfa_next = 1U;
    }
    break;
    case 54: ;
    if (tmp___8 > 0) {
      {
      _1_stk_mutfa_next = 23U;
      }
    } else {
      {
      _1_stk_mutfa_next = 72U;
      }
    }
    break;
    case 1: ;
    if (k < h->n_buckets) {
      {
      _1_stk_mutfa_next = 73U;
      }
    } else {
      {
      _1_stk_mutfa_next = 13U;
      }
    }
    break;
    case 23: 
    tmp___7 = atol((char const   *)str->s);
    beg = (int )(tmp___7 - 1L);
    {
    _1_stk_mutfa_next = 72U;
    }
    break;
    case 77: 
    p = h->vals + k;
    tmp___8 = ks_getuntil(ks, 0, str, & dret);
    {
    _1_stk_mutfa_next = 54U;
    }
    break;
    case 3: ;
    if (! (tmp___12 >= 0)) {
      {
      _1_stk_mutfa_next = 32U;
      }
    } else {
      {
      _1_stk_mutfa_next = 22U;
      }
    }
    break;
    case 24: 
    tmp___12 = ks_getuntil(ks, 0, str, & dret);
    {
    _1_stk_mutfa_next = 3U;
    }
    break;
    case 21: 
    tmp___10 = p->n;
    (p->n) ++;
    *(p->a + tmp___10) = ((uint64_t )beg << 32) | (unsigned long long )*(str->s + 0);
    {
    _1_stk_mutfa_next = 24U;
    }
    break;
    case 36: ;
    if (tmp___5) {
      {
      _1_stk_mutfa_next = 6U;
      }
    } else {
      {
      _1_stk_mutfa_next = 27U;
      }
    }
    break;
    case 57: 
    tmp = kh_init_reg();
    h = tmp;
    {
    _1_stk_mutfa_next = 49U;
    }
    break;
    case 68: ;
    if (p->m) {
      {
      _1_stk_mutfa_next = 4U;
      }
    } else {
      {
      _1_stk_mutfa_next = 63U;
      }
    }
    break;
    case 26: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk mutfa <in.fa> <in.snp>\n\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: <in.snp> contains at least four columns per line which are:\n");
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      \'chr  1-based-pos  any  base-changed-to\'.\n");
    {
    _1_stk_mutfa_next = 64U;
    }
    break;
    case 11: 
    free((void *)(h->vals + k)->a);
    free((void *)((char *)*(h->keys + k)));
    {
    _1_stk_mutfa_next = 29U;
    }
    break;
    case 13: 
    kh_destroy_reg(h);
    {
    _1_stk_mutfa_next = 39U;
    }
    break;
    case 63: 
    p->m = 4;
    {
    _1_stk_mutfa_next = 34U;
    }
    break;
    case 19: ;
    if (str->l == 1UL) {
      {
      _1_stk_mutfa_next = 52U;
      }
    } else {
      {
      _1_stk_mutfa_next = 24U;
      }
    }
    break;
    case 32: 
    ks_destroy(ks);
    gzclose(fp);
    free((void *)str->s);
    free((void *)str);
    tmp___17 = strcmp((char const   *)*(argv + 1), "-");
    {
    _1_stk_mutfa_next = 0U;
    }
    break;
    case 40: ;
    if ((size_t___0 )beg___0 < seq->seq.l) {
      {
      _1_stk_mutfa_next = 20U;
      }
    } else {
      {
      _1_stk_mutfa_next = 61U;
      }
    }
    break;
    case 55: 
    p___0 = h->vals + k;
    i = 0;
    {
    _1_stk_mutfa_next = 62U;
    }
    break;
    case 60: ;
    if (dret > 0) {
      {
      _1_stk_mutfa_next = 47U;
      }
    } else {
      {
      _1_stk_mutfa_next = 35U;
      }
    }
    break;
    case 59: ;
    if (i % 60 == 0) {
      {
      _1_stk_mutfa_next = 41U;
      }
    } else {
      {
      _1_stk_mutfa_next = 8U;
      }
    }
    break;
    case 6: 
    tmp___2 = gzopen((char const   *)*(argv + 2), "r");
    fp = tmp___2;
    {
    _1_stk_mutfa_next = 69U;
    }
    break;
    case 27: 
    tmp___3 = fileno(stdin);
    tmp___4 = gzdopen(tmp___3, "r");
    fp = tmp___4;
    {
    _1_stk_mutfa_next = 69U;
    }
    break;
    case 38: 
    printf((char const   */* __restrict  */)">%s", seq->name.s);
    i = 0;
    {
    _1_stk_mutfa_next = 28U;
    }
    break;
    case 61: 
    i ++;
    {
    _1_stk_mutfa_next = 62U;
    }
    break;
    case 58: ;
    if (k != h->n_buckets) {
      {
      _1_stk_mutfa_next = 55U;
      }
    } else {
      {
      _1_stk_mutfa_next = 38U;
      }
    }
    break;
    case 34: 
    tmp___9 = realloc((void *)p->a, (size_t___0 )(p->m * 8));
    p->a = (uint64_t *)tmp___9;
    {
    _1_stk_mutfa_next = 21U;
    }
    break;
    case 74: ;
    if (! (l >= 0)) {
      {
      _1_stk_mutfa_next = 45U;
      }
    } else {
      {
      _1_stk_mutfa_next = 50U;
      }
    }
    break;
    case 48: ;
    return (1);
    break;
    case 71: 
    dret = ks_getc(ks);
    {
    _1_stk_mutfa_next = 60U;
    }
    break;
    case 22: 
    tmp___6 = strdup((char const   *)str->s);
    s = tmp___6;
    beg = 0;
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )s);
    {
    _1_stk_mutfa_next = 5U;
    }
    break;
    case 28: ;
    if (i < l) {
      {
      _1_stk_mutfa_next = 59U;
      }
    } else {
      {
      _1_stk_mutfa_next = 10U;
      }
    }
    break;
    case 65: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mutfa");
    {
    _1_stk_mutfa_next = 48U;
    }
    break;
    case 47: ;
    if (! (dret != 10)) {
      {
      _1_stk_mutfa_next = 35U;
      }
    } else {
      {
      _1_stk_mutfa_next = 71U;
      }
    }
    break;
    case 73: ;
    if (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      {
      _1_stk_mutfa_next = 11U;
      }
    } else {
      {
      _1_stk_mutfa_next = 29U;
      }
    }
    break;
    case 44: ;
    if (dret != 10) {
      {
      _1_stk_mutfa_next = 71U;
      }
    } else {
      {
      _1_stk_mutfa_next = 35U;
      }
    }
    break;
    case 5: ;
    if (k == h->n_buckets) {
      {
      _1_stk_mutfa_next = 25U;
      }
    } else {
      {
      _1_stk_mutfa_next = 77U;
      }
    }
    break;
    case 72: 
    ks_getuntil(ks, 0, str, & dret);
    ks_getuntil(ks, 0, str, & dret);
    {
    _1_stk_mutfa_next = 44U;
    }
    break;
    case 64: ;
    return (1);
    break;
    case 41: 
    putchar('\n');
    {
    _1_stk_mutfa_next = 8U;
    }
    break;
    case 10: 
    putchar('\n');
    {
    _1_stk_mutfa_next = 7U;
    }
    break;
    case 42: 
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[E::%s] failed to open the input file/stream.\n",
            "stk_mutfa");
    {
    _1_stk_mutfa_next = 66U;
    }
    break;
    case 0: ;
    if (tmp___17) {
      {
      _1_stk_mutfa_next = 15U;
      }
    } else {
      {
      _1_stk_mutfa_next = 56U;
      }
    }
    break;
    case 46: 
    beg___0 = (int )(*(p___0->a + i) >> 32);
    {
    _1_stk_mutfa_next = 40U;
    }
    break;
    case 39: ;
    return (0);
    break;
    case 66: ;
    return (1);
    break;
    case 7: 
    l = kseq_read(seq);
    {
    _1_stk_mutfa_next = 74U;
    }
    break;
    case 35: 
    tmp___11 = isalpha((int )*(str->s + 0));
    {
    _1_stk_mutfa_next = 14U;
    }
    break;
    case 29: 
    k ++;
    {
    _1_stk_mutfa_next = 1U;
    }
    break;
    case 2: 
    ks = ks_init(fp);
    {
    _1_stk_mutfa_next = 24U;
    }
    break;
    case 20: 
    *(seq->seq.s + beg___0) = (char )((int )*(p___0->a + i));
    {
    _1_stk_mutfa_next = 61U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_mutfa LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_init_reg LOC=UNKNOWN */
__inline static kh_reg_t *kh_init_reg(void) 
{ 
  void *tmp ;
  unsigned int _1_kh_init_reg_next ;

  {
  {
  _1_kh_init_reg_next = 0U;
  }
  while (1) {
    switch (_1_kh_init_reg_next) {
    case 1: ;
    return ((kh_reg_t *)tmp);
    break;
    case 0: 
    tmp = calloc((size_t___0 )1, sizeof(kh_reg_t ));
    {
    _1_kh_init_reg_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_init_reg LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stk_printseq_renamed LOC=UNKNOWN */
__inline static void stk_printseq_renamed(kseq_t const   *s , int line_len , char const   *prefix ,
                                          int64_t n ) 
{ 
  int tmp ;
  unsigned int _1_stk_printseq_renamed_next ;

  {
  {
  _1_stk_printseq_renamed_next = 14U;
  }
  while (1) {
    switch (_1_stk_printseq_renamed_next) {
    case 4: 
    printf((char const   */* __restrict  */)"%lld", n);
    {
    _1_stk_printseq_renamed_next = 0U;
    }
    break;
    case 14: ;
    if (s->qual.l) {
      {
      _1_stk_printseq_renamed_next = 10U;
      }
    } else {
      {
      _1_stk_printseq_renamed_next = 8U;
      }
    }
    break;
    case 12: ;
    return;
    break;
    case 8: 
    tmp = '>';
    {
    _1_stk_printseq_renamed_next = 13U;
    }
    break;
    case 1: 
    fputs((char const   */* __restrict  */)prefix, (FILE */* __restrict  */)stdout);
    {
    _1_stk_printseq_renamed_next = 4U;
    }
    break;
    case 3: ;
    if (s->qual.l) {
      {
      _1_stk_printseq_renamed_next = 7U;
      }
    } else {
      {
      _1_stk_printseq_renamed_next = 12U;
      }
    }
    break;
    case 11: 
    putchar(' ');
    fputs((char const   */* __restrict  */)s->comment.s, (FILE */* __restrict  */)stdout);
    {
    _1_stk_printseq_renamed_next = 2U;
    }
    break;
    case 9: 
    fputs((char const   */* __restrict  */)s->name.s, (FILE */* __restrict  */)stdout);
    {
    _1_stk_printseq_renamed_next = 0U;
    }
    break;
    case 13: 
    putchar(tmp);
    {
    _1_stk_printseq_renamed_next = 6U;
    }
    break;
    case 6: ;
    if (n >= 0LL) {
      {
      _1_stk_printseq_renamed_next = 5U;
      }
    } else {
      {
      _1_stk_printseq_renamed_next = 9U;
      }
    }
    break;
    case 5: ;
    if (prefix) {
      {
      _1_stk_printseq_renamed_next = 1U;
      }
    } else {
      {
      _1_stk_printseq_renamed_next = 4U;
      }
    }
    break;
    case 10: 
    tmp = '@';
    {
    _1_stk_printseq_renamed_next = 13U;
    }
    break;
    case 0: ;
    if (s->comment.l) {
      {
      _1_stk_printseq_renamed_next = 11U;
      }
    } else {
      {
      _1_stk_printseq_renamed_next = 2U;
      }
    }
    break;
    case 7: 
    putchar('+');
    stk_printstr(& s->qual, (unsigned int )line_len);
    {
    _1_stk_printseq_renamed_next = 12U;
    }
    break;
    case 2: 
    stk_printstr(& s->seq, (unsigned int )line_len);
    {
    _1_stk_printseq_renamed_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stk_printseq_renamed LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_resize_64 LOC=UNKNOWN */
__inline static void kh_resize_64(kh_64_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  void *tmp___2 ;
  khint64_t key ;
  khint_t new_mask ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint64_t tmp___4 ;
  void *tmp___6 ;
  unsigned int _1_kh_resize_64_next ;

  {
  {
  _1_kh_resize_64_next = 27U;
  }
  while (1) {
    switch (_1_kh_resize_64_next) {
    case 18: 
    *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
    {
    _1_kh_resize_64_next = 9U;
    }
    break;
    case 25: 
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
    {
    _1_kh_resize_64_next = 37U;
    }
    break;
    case 4: 
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    {
    _1_kh_resize_64_next = 38U;
    }
    break;
    case 30: 
    j = (khint_t )0;
    {
    _1_kh_resize_64_next = 40U;
    }
    break;
    case 14: 
    key = *(h->keys + j);
    new_mask = new_n_buckets - 1U;
    *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
    {
    _1_kh_resize_64_next = 16U;
    }
    break;
    case 15: 
    *(h->keys + i) = key;
    {
    _1_kh_resize_64_next = 29U;
    }
    break;
    case 31: 
    j = (khint_t )0;
    {
    _1_kh_resize_64_next = 1U;
    }
    break;
    case 12: ;
    if (new_n_buckets < 4U) {
      {
      _1_kh_resize_64_next = 0U;
      }
    } else {
      {
      _1_kh_resize_64_next = 21U;
      }
    }
    break;
    case 1: ;
    if (j) {
      {
      _1_kh_resize_64_next = 30U;
      }
    } else {
      {
      _1_kh_resize_64_next = 37U;
      }
    }
    break;
    case 23: 
    tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
    h->keys = (khint64_t *)tmp___6;
    {
    _1_kh_resize_64_next = 25U;
    }
    break;
    case 16: 
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & new_mask;
    inc = (((k >> 3) ^ (k << 3)) | 1U) & new_mask;
    {
    _1_kh_resize_64_next = 5U;
    }
    break;
    case 21: ;
    if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
      {
      _1_kh_resize_64_next = 31U;
      }
    } else {
      {
      _1_kh_resize_64_next = 34U;
      }
    }
    break;
    case 26: 
    tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
    h->keys = (khint64_t *)tmp___2;
    {
    _1_kh_resize_64_next = 1U;
    }
    break;
    case 11: 
    tmp = (khint_t )1;
    {
    _1_kh_resize_64_next = 22U;
    }
    break;
    case 9: ;
    if (i < h->n_buckets) {
      {
      _1_kh_resize_64_next = 20U;
      }
    } else {
      {
      _1_kh_resize_64_next = 15U;
      }
    }
    break;
    case 13: 
    tmp___1 = (khint_t )1;
    {
    _1_kh_resize_64_next = 4U;
    }
    break;
    case 19: 
    *(h->keys + i) = key;
    {
    _1_kh_resize_64_next = 29U;
    }
    break;
    case 32: ;
    if (new_n_buckets < 16U) {
      {
      _1_kh_resize_64_next = 13U;
      }
    } else {
      {
      _1_kh_resize_64_next = 28U;
      }
    }
    break;
    case 40: ;
    if (j != h->n_buckets) {
      {
      _1_kh_resize_64_next = 39U;
      }
    } else {
      {
      _1_kh_resize_64_next = 6U;
      }
    }
    break;
    case 6: ;
    if (h->n_buckets > new_n_buckets) {
      {
      _1_kh_resize_64_next = 23U;
      }
    } else {
      {
      _1_kh_resize_64_next = 25U;
      }
    }
    break;
    case 27: 
    new_flags = (khint32_t *)0;
    j = (khint_t )1;
    new_n_buckets --;
    new_n_buckets |= new_n_buckets >> 1;
    new_n_buckets |= new_n_buckets >> 2;
    new_n_buckets |= new_n_buckets >> 4;
    new_n_buckets |= new_n_buckets >> 8;
    new_n_buckets |= new_n_buckets >> 16;
    new_n_buckets ++;
    {
    _1_kh_resize_64_next = 12U;
    }
    break;
    case 38: ;
    if (h->n_buckets < new_n_buckets) {
      {
      _1_kh_resize_64_next = 26U;
      }
    } else {
      {
      _1_kh_resize_64_next = 1U;
      }
    }
    break;
    case 34: ;
    if (new_n_buckets < 16U) {
      {
      _1_kh_resize_64_next = 11U;
      }
    } else {
      {
      _1_kh_resize_64_next = 10U;
      }
    }
    break;
    case 22: 
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    {
    _1_kh_resize_64_next = 32U;
    }
    break;
    case 28: 
    tmp___1 = new_n_buckets >> 4;
    {
    _1_kh_resize_64_next = 4U;
    }
    break;
    case 5: ;
    if (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
      {
      _1_kh_resize_64_next = 33U;
      }
    } else {
      {
      _1_kh_resize_64_next = 18U;
      }
    }
    break;
    case 33: 
    i = (i + inc) & new_mask;
    {
    _1_kh_resize_64_next = 5U;
    }
    break;
    case 37: ;
    return;
    break;
    case 10: 
    tmp = new_n_buckets >> 4;
    {
    _1_kh_resize_64_next = 22U;
    }
    break;
    case 0: 
    new_n_buckets = (khint_t )4;
    {
    _1_kh_resize_64_next = 21U;
    }
    break;
    case 39: ;
    if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
      {
      _1_kh_resize_64_next = 14U;
      }
    } else {
      {
      _1_kh_resize_64_next = 29U;
      }
    }
    break;
    case 7: 
    tmp___4 = *(h->keys + i);
    *(h->keys + i) = key;
    key = tmp___4;
    *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
    {
    _1_kh_resize_64_next = 16U;
    }
    break;
    case 29: 
    j ++;
    {
    _1_kh_resize_64_next = 40U;
    }
    break;
    case 20: ;
    if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
      {
      _1_kh_resize_64_next = 7U;
      }
    } else {
      {
      _1_kh_resize_64_next = 19U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_resize_64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF kh_init_64 LOC=UNKNOWN */
__inline static kh_64_t *kh_init_64(void) 
{ 
  void *tmp ;
  unsigned int _1_kh_init_64_next ;

  {
  {
  _1_kh_init_64_next = 0U;
  }
  while (1) {
    switch (_1_kh_init_64_next) {
    case 1: ;
    return ((kh_64_t *)tmp);
    break;
    case 0: 
    tmp = calloc((size_t___0 )1, sizeof(kh_64_t ));
    {
    _1_kh_init_64_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF kh_init_64 LOC=UNKNOWN */
