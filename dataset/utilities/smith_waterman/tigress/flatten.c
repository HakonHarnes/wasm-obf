
/* Generated by Tigress v3.2 (https://tigress.wtf), 06:21:44-2023/04/21 */


/*
BEGIN-UNIVERSE
{
  "Not added to universe": [
    "__sync_and_and_fetch", "__sync_fetch_and_or", "__atomic_or_fetch",
    "__atomic_nand_fetch_8", "__atomic_fetch_and", "__atomic_xor_fetch_16",
    "__atomic_fetch_nand_16", "__atomic_sub_fetch_1", "__atomic_fetch_or",
    "__sync_synchronize", "__sync_or_and_fetch", "__atomic_nand_fetch_4",
    "__atomic_sub_fetch_4", "__atomic_compare_exchange_n",
    "__sync_add_and_fetch", "__atomic_signal_fence", "__atomic_fetch_nand_1",
    "__atomic_and_fetch_16", "__sync_fetch_and_nand", "__atomic_xor_fetch_8",
    "__atomic_xor_fetch_2", "__atomic_thread_fence", "__atomic_store_16",
    "__atomic_fetch_and_8", "__atomic_and_fetch_2", "__atomic_test_and_set",
    "__atomic_fetch_add_8", "__atomic_fetch_nand", "__atomic_exchange_16",
    "__atomic_clear", "__atomic_store", "__atomic_add_fetch_2",
    "__atomic_fetch_xor_1", "__atomic_and_fetch",
    "__atomic_compare_exchange_4", "__sync_sub_and_fetch",
    "__sync_nand_and_fetch", "__atomic_load_16", "__atomic_always_lock_free",
    "__atomic_nand_fetch_16", "__sync_xor_and_fetch", "__atomic_fetch_xor_8",
    "__atomic_exchange_8", "__atomic_exchange_1", "__sync_fetch_and_and",
    "__atomic_feraiseexcept", "__atomic_and_fetch_4", "__atomic_or_fetch_8",
    "__atomic_or_fetch_4", "__atomic_or_fetch_1", "__atomic_fetch_and_2",
    "__sync_lock_release", "__atomic_fetch_nand_8", "__atomic_fetch_add",
    "__atomic_nand_fetch_1", "__atomic_fetch_nand_2", "__atomic_load_n",
    "__atomic_compare_exchange_16", "__atomic_exchange_n",
    "__atomic_fetch_or_1", "__atomic_fetch_or_8", "__atomic_fetch_add_1",
    "__atomic_fetch_sub_1", "__atomic_fetch_or_4", "__atomic_load_2",
    "__atomic_store_2", "__atomic_exchange_4", "__sync_fetch_and_xor",
    "__atomic_fetch_sub_4", "__atomic_fetch_and_4",
    "__atomic_compare_exchange", "__atomic_load_1",
    "__atomic_compare_exchange_1", "__atomic_fetch_xor_2", "__atomic_load",
    "__atomic_or_fetch_16", "__atomic_add_fetch_16",
    "__sync_val_compare_and_swap", "__atomic_store_4",
    "__atomic_fetch_and_1", "__atomic_fetch_nand_4", "__atomic_fetch_add_16",
    "__atomic_compare_exchange_2", "__atomic_exchange",
    "__atomic_sub_fetch_8", "__atomic_fetch_sub_16", "__atomic_exchange_2",
    "__atomic_sub_fetch_2", "__atomic_fetch_xor_16", "__atomic_fetch_or_16",
    "__atomic_load_4", "__atomic_store_n", "__atomic_fetch_add_4",
    "__atomic_nand_fetch_2", "__sync_lock_test_and_set",
    "__atomic_sub_fetch", "__atomic_fetch_and_16",
    "__atomic_compare_exchange_8", "__atomic_nand_fetch", "__atomic_load_8",
    "__atomic_xor_fetch_4", "__atomic_fetch_sub_2", "__atomic_add_fetch",
    "__atomic_store_8", "__atomic_xor_fetch", "__sync_fetch_and_add",
    "__atomic_or_fetch_2", "__atomic_add_fetch_1", "__atomic_fetch_xor",
    "__atomic_add_fetch_8", "__atomic_fetch_xor_4", "__atomic_fetch_sub_8",
    "__sync_bool_compare_and_swap", "__atomic_and_fetch_1",
    "__atomic_store_1", "__atomic_xor_fetch_1", "__atomic_fetch_or_2",
    "__atomic_sub_fetch_16", "__sync_fetch_and_sub", "__atomic_fetch_add_2",
    "__atomic_is_lock_free", "__atomic_and_fetch_8", "__atomic_fetch_sub",
    "__atomic_add_fetch_4", "scoring_lookup", "align_col_mismatch",
    "align_col_indel", "align_col_context", "align_col_stop",
    "aligner_align", "aligner_destroy", "alignment_create",
    "alignment_ensure_capacity", "alignment_free", "alignment_reverse_move",
    "alignment_print_matrices", "alignment_colour_print_against",
    "alignment_print_spacer", "scoring_add_wildcard", "scoring_system_PAM30",
    "scoring_system_PAM70", "scoring_system_BLOSUM80",
    "scoring_system_BLOSUM62", "scoring_system_DNA_hybridization",
    "parse_entire_int", "parse_entire_uint", "cmdline_new", "cmdline_free",
    "cmdline_add_files", "cmdline_get_num_of_file_pairs",
    "cmdline_get_file1", "cmdline_get_file2", "align_from_file",
    "align_scoring_load_matrix", "align_scoring_load_pairwise",
    "print_usage", "scoring_init", "scoring_add_mutation", "scoring_print",
    "scoring_system_default", "_loading_error", "needleman_wunsch_new",
    "needleman_wunsch_free", "needleman_wunsch_align",
    "needleman_wunsch_align2", "smith_waterman_new", "smith_waterman_free",
    "smith_waterman_get_aligner", "smith_waterman_align",
    "smith_waterman_align2", "smith_waterman_fetch"
  ],
  "Transformations": [
    { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "ungetc_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "sw_set_default_scoring" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "strm_buf_dealloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "strm_buf_alloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "strbuf_free" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "sort_r_simple" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "sort_r_cmpswap" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "sort_r" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "sort_match_indices" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "smith_waterman_new" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "smith_waterman_get_aligner" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "smith_waterman_free" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "smith_waterman_fetch" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "smith_waterman_align2" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "smith_waterman_align" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_read_reset" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_read_free" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_read_dealloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_read_alloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_open2" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_open" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [
        "seq_guess_filetype_from_extension"
      ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_dopen" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "seq_close" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_system_default" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_system_PAM70" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_system_PAM30" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [
        "scoring_system_DNA_hybridization"
      ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_system_BLOSUM80" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_system_BLOSUM62" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_print" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_lookup" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_init" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_add_wildcard" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_add_mutations" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "scoring_add_mutation" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "print_usage" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "print_alignment_part" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "parse_entire_uint" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "parse_entire_int" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "open_seq_file" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "needleman_wunsch_new" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "needleman_wunsch_free" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "needleman_wunsch_align2" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "needleman_wunsch_align" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gzskipline_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gzskipline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gzreadline_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gzreadline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gzread2" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gzgetc_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "get_next_hit" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "fskipline_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "fskipline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "freadline_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "freadline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "fgetc_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cmdline_new" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [
        "cmdline_get_num_of_file_pairs"
      ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cmdline_get_file2" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cmdline_get_file1" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cmdline_free" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cmdline_add_files" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cbuf_chomp" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cbuf_capacity" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cbuf_append_char" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "bitset_set_length" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "bitset_dealloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "bitset_alloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alignment_reverse_move" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alignment_print_spacer" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alignment_print_matrices" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alignment_free" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alignment_fill_matrices" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alignment_ensure_capacity" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alignment_create" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [
        "alignment_colour_print_against"
      ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "aligner_destroy" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "aligner_align" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "align_scoring_load_pairwise" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "align_scoring_load_matrix" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "align_pair_from_file" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "align_from_file" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "align" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_setup" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_unknown_gz_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_unknown_gz" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_unknown_f_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_unknown_f" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_plain_gz_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_plain_gz" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_plain_f_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_plain_f" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fastq_gz_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fastq_gz" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fastq_f_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fastq_f" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fasta_gz_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fasta_gz" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fasta_f_buf" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_seq_read_fasta_f" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_scoring_check_wildcards" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_rndup2pow64___0" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_rndup2pow64" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_loading_error" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_init_history" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_follow_hit" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "_ensure_history_capacity" ]
    } }, { "TransformationNumber": 0, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ],
      "New Global Variables": {
        "_global_envp": "FUN: '_global_envp_i$nit'",
        "_global_argv": "FUN: '_global_argv_i$nit'",
        "_global_argc": "FUN: '_global_argc_i$nit'"
      }
    } }, { "TransformationNumber": -1, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "New Functions": [
        "main", "align_pair_from_file", "align", "get_next_hit",
        "print_alignment_part", "sw_set_default_scoring",
        "smith_waterman_fetch", "_follow_hit", "smith_waterman_align2",
        "smith_waterman_align", "smith_waterman_get_aligner",
        "smith_waterman_free", "smith_waterman_new",
        "_ensure_history_capacity", "_init_history", "sort_match_indices",
        "bitset_set_length", "bitset_dealloc", "bitset_alloc",
        "_rndup2pow64___0", "sort_r", "sort_r_simple", "sort_r_cmpswap",
        "needleman_wunsch_align2", "needleman_wunsch_align",
        "needleman_wunsch_free", "needleman_wunsch_new",
        "align_scoring_load_pairwise", "align_scoring_load_matrix",
        "_loading_error", "strbuf_free", "scoring_system_default",
        "scoring_system_DNA_hybridization", "scoring_system_BLOSUM62",
        "scoring_system_BLOSUM80", "scoring_system_PAM70",
        "scoring_system_PAM30", "scoring_lookup", "_scoring_check_wildcards",
        "scoring_print", "scoring_add_mutations", "scoring_add_mutation",
        "scoring_add_wildcard", "scoring_init", "align_from_file",
        "open_seq_file", "cmdline_get_file2", "cmdline_get_file1",
        "cmdline_get_num_of_file_pairs", "cmdline_add_files", "cmdline_new",
        "cmdline_free", "print_usage", "parse_entire_uint",
        "parse_entire_int", "seq_close", "seq_open", "seq_dopen",
        "seq_open2", "seq_guess_filetype_from_extension", "_seq_setup",
        "_seq_read_unknown_gz_buf", "_seq_read_unknown_f_buf",
        "_seq_read_unknown_gz", "_seq_read_unknown_f",
        "_seq_read_plain_gz_buf", "_seq_read_plain_f_buf",
        "_seq_read_plain_gz", "_seq_read_plain_f", "_seq_read_fasta_gz_buf",
        "_seq_read_fasta_f_buf", "_seq_read_fasta_gz", "_seq_read_fasta_f",
        "_seq_read_fastq_gz_buf", "_seq_read_fastq_f_buf",
        "_seq_read_fastq_gz", "_seq_read_fastq_f", "seq_read_free",
        "seq_read_alloc", "seq_read_dealloc", "seq_read_reset",
        "fskipline_buf", "gzskipline_buf", "freadline_buf", "gzreadline_buf",
        "ungetc_buf", "gzgetc_buf", "fgetc_buf", "fskipline", "gzskipline",
        "freadline", "gzreadline", "gzread2", "strm_buf_dealloc",
        "strm_buf_alloc", "cbuf_chomp", "cbuf_append_char", "cbuf_capacity",
        "alignment_print_spacer", "alignment_colour_print_against",
        "alignment_print_matrices", "alignment_reverse_move",
        "alignment_free", "alignment_ensure_capacity", "alignment_create",
        "aligner_destroy", "aligner_align", "alignment_fill_matrices",
        "_rndup2pow64"
      ],
      "New Global Variables": {
        "wait_on_keystroke": "FUN: 'wait_on_keystroke_i$nit'",
        "alignment_index": "FUN: 'alignment_index_i$nit'",
        "result": "None",
        "sw": "None",
        "scoring": "None",
        "cmd": "None",
        "sub_matrix": "FUN: 'sub_matrix_i$nit'",
        "dna_bases": "FUN: 'dna_bases_i$nit'",
        "blosum62": "FUN: 'blosum62_i$nit'",
        "blosum80": "FUN: 'blosum80_i$nit'",
        "pam70": "FUN: 'pam70_i$nit'",
        "pam30": "FUN: 'pam30_i$nit'",
        "amino_acids": "FUN: 'amino_acids_i$nit'",
        "file_paths2": "FUN: 'file_paths2_i$nit'",
        "file_paths1": "FUN: 'file_paths1_i$nit'",
        "file_list_capacity": "FUN: 'file_list_capacity_i$nit'",
        "file_list_length": "FUN: 'file_list_length_i$nit'",
        "align_col_stop": "FUN: 'align_col_stop_i$nit'",
        "align_col_context": "FUN: 'align_col_context_i$nit'",
        "align_col_indel": "FUN: 'align_col_indel_i$nit'",
        "align_col_mismatch": "FUN: 'align_col_mismatch_i$nit'"
      },
      "New Externs": [
        "__builtin_va_copy", "__builtin_frob_return_address",
        "__builtin_popcountll", "__builtin_atanf", "__builtin_ia32_addps",
        "__builtin_strcspn", "__builtin_asinf", "__builtin_ia32_maxps",
        "__builtin_ia32_unpckhps", "__builtin_acos",
        "__builtin___sprintf_chk", "__builtin_cosh", "__builtin_tanhf",
        "__builtin_mempcpy", "__builtin_sqrtl", "__builtin_parity",
        "__builtin_coshl", "__builtin_cosl", "__builtin_cosf",
        "__builtin_acosl", "__builtin___mempcpy_chk", "__builtin_clz",
        "__builtin_log10", "__builtin___strcat_chk", "__builtin_modff",
        "__builtin_sin", "__builtin_frexp", "__builtin_acosf",
        "__builtin_sinhl", "__builtin___stpcpy_chk", "__builtin_fabs",
        "__builtin_va_start", "__builtin_bswap16", "__builtin_ctz",
        "__builtin_strpbrk", "__builtin_strcpy", "__builtin_sqrt",
        "__builtin_next_arg", "__builtin_log10f", "__builtin_fabsl",
        "__builtin_floorl", "__builtin_floorf", "__builtin_memcpy",
        "__builtin_ia32_subps", "__builtin_parityll", "__builtin_va_end",
        "__builtin_bzero", "__builtin_strncmp", "__builtin___vsprintf_chk",
        "__builtin_sqrtf", "__builtin_nans", "__builtin_exp",
        "__builtin_strcmp", "__builtin_ldexpf", "__builtin_powif",
        "__builtin_log10l", "__builtin___memmove_chk",
        "__builtin_return_address", "__builtin_fabsf",
        "__builtin_object_size", "__builtin_alloca",
        "__builtin_va_arg_pack_len", "__builtin_tanl", "__builtin_modfl",
        "__builtin_stpcpy", "__builtin_sinl", "__builtin_asin",
        "__builtin_sinhf", "__builtin_ctzl", "__builtin_tanhl",
        "__builtin_bswap64", "__builtin_ia32_mulps", "__builtin_tan",
        "__builtin_strncpy", "__builtin_inff", "__builtin___memset_chk",
        "__builtin_huge_val", "__builtin_clzl", "__builtin_frexpf",
        "__builtin_fmodl", "__builtin_atan", "__builtin___fprintf_chk",
        "__builtin_ceilf", "__builtin_return", "__builtin_asinl",
        "__builtin_ffsll", "__builtin_va_arg_pack",
        "__builtin___strncpy_chk", "__builtin_powi", "__builtin_strchr",
        "__builtin___strncat_chk", "__builtin_huge_vall", "__builtin_ffsl",
        "__builtin___vprintf_chk", "__builtin_ia32_unpcklps",
        "__builtin_strncat", "__builtin_ctzll", "__builtin_stdarg_start",
        "__builtin_frexpl", "__builtin_tanf", "__builtin_logl",
        "__builtin_va_arg", "__builtin_expect", "__builtin___printf_chk",
        "__builtin___vfprintf_chk", "__builtin_prefetch", "__builtin_nansl",
        "__builtin_fmod", "__builtin_tanh", "__builtin_unreachable",
        "__builtin_ldexpl", "__builtin_apply", "__builtin_sinf",
        "__builtin_ceil", "__builtin_powil", "__builtin_expl",
        "__builtin_constant_p", "__builtin_log", "__builtin_expf",
        "__builtin_types_compatible_p", "__builtin_atan2l",
        "__builtin_apply_args", "__builtin_logf", "__builtin_strlen",
        "__builtin_ffs", "__builtin_inf", "__builtin___memcpy_chk",
        "__builtin_trap", "__builtin_parityl", "__builtin_strspn",
        "__builtin_varargs_start", "__builtin_nan",
        "__builtin___snprintf_chk", "__builtin_atanl", "__builtin_clzll",
        "__builtin_huge_valf", "__builtin_coshf", "__builtin_nansf",
        "__builtin___vsnprintf_chk", "__builtin_nanf", "__builtin_atan2",
        "__builtin_popcountl", "__builtin_ceill", "__builtin___strcpy_chk",
        "__builtin_floor", "__builtin_cos", "__builtin_memset",
        "__builtin_nanl", "__builtin_atan2f", "__builtin_popcount",
        "__builtin_sinh", "__builtin_bcopy", "__builtin_extract_return_addr",
        "__builtin_bswap32", "__builtin_ldexp", "__builtin_infl",
        "__builtin_fmodf", "__builtin_frame_address", "malloc", "realloc",
        "free", "exit", "abs", "stdout", "stderr", "putc", "fputs", "printf",
        "fprintf", "tolower", "strtol", "strtoul", "calloc", "stdin",
        "fopen", "fclose", "fflush", "fread", "fgetc", "ungetc", "fgets",
        "vfprintf", "fdopen", "fileno", "memcpy", "memset", "strcmp",
        "strlen", "strcasecmp", "strdup", "isspace", "gzdopen", "gzread",
        "gzgets", "gzgetc", "gzungetc", "gzclose", "gzopen", "__assert_fail",
        "seq_close", "strbuf_new", "strbuf_chomp", "strbuf_reset_gzreadline",
        "string_is_all_whitespace", "string_next_nonwhitespace", "memmove",
        "getc"
      ],
      "New Types": [
        "MatrixSort", "__anonstruct_MatrixSort_459211137", "sw_aligner_t",
        "sw_history_t", "__anonstruct_sw_history_t_920808153", "BitSet",
        "__anonstruct_BitSet_909456816", "sw_aligner_t", "sw_aligner_t",
        "nw_aligner_t", "StrBuf", "__anonstruct_StrBuf_483684869",
        "cmdline_t", "__anonstruct_cmdline_t_751155579", "SeqAlignCmdType",
        "read_struct", "seq_buf_t", "__anonstruct_seq_buf_t_653462437",
        "seq_file_struct", "read_t", "read_struct", "seq_file_t",
        "seq_file_struct", "seq_format", "__anonenum_seq_format_498167330",
        "StreamBuffer", "__anonstruct_StreamBuffer_653462436", "gzFile_s",
        "gzFile", "gzFile_s", "voidp", "va_list___0", "off_t",
        "__isoc_va_list", "Matrix", "alignment_t",
        "__anonstruct_alignment_t_970931537", "aligner_t",
        "__anonstruct_aligner_t_94193678", "scoring_t",
        "__anonstruct_scoring_t_699705047", "score_t", "FILE", "_IO_FILE",
        "uint32_t", "size_t___0", "size_t"
      ],
      "New Texts/Asms/Pragmas": [
        "Pragma", "Pragma", "Pragma", "Pragma", "Pragma", "Pragma", "Pragma"
      ]
    } }
  ]
}
END-UNIVERSE
*/

/* #pragma merger("0","/tmp/cil-gVNDjOEE.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-T1QJN6Ho.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-gozfzZtd.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-CoKbL_gb.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-x62wnsfL.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-82ZQMc5Q.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-p536F_L_.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */

/* BEGIN STRUCT-DECL read_struct LOC=libs/seq_file/seq_file.h:42 */
struct read_struct ;
/* END STRUCT-DECL read_struct LOC=libs/seq_file/seq_file.h:42 */

/* BEGIN STRUCT-DECL seq_file_struct LOC=libs/seq_file/seq_file.h:41 */
struct seq_file_struct ;
/* END STRUCT-DECL seq_file_struct LOC=libs/seq_file/seq_file.h:41 */

/* BEGIN STRUCT-DECL gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */
struct gzFile_s ;
/* END STRUCT-DECL gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */

/* BEGIN STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
struct _IO_FILE ;
/* END STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN STRUCT-DECL sw_aligner_t LOC=src/smith_waterman.h:15 */
struct sw_aligner_t ;
/* END STRUCT-DECL sw_aligner_t LOC=src/smith_waterman.h:15 */

/* BEGIN STRUCT-DECL __anonstruct_BitSet_909456816 LOC=src/smith_waterman.c:21 */
struct __anonstruct_BitSet_909456816 ;
/* END STRUCT-DECL __anonstruct_BitSet_909456816 LOC=src/smith_waterman.c:21 */

/* BEGIN STRUCT-DECL __anonstruct_scoring_t_699705047 LOC=src/alignment_scoring.h:19 */
struct __anonstruct_scoring_t_699705047 ;
/* END STRUCT-DECL __anonstruct_scoring_t_699705047 LOC=src/alignment_scoring.h:19 */

/* BEGIN ENUM-DECL Matrix LOC=src/alignment.h:43 */
enum Matrix ;
/* END ENUM-DECL Matrix LOC=src/alignment.h:43 */

/* BEGIN STRUCT-DECL __anonstruct_seq_buf_t_653462437 LOC=libs/seq_file/seq_file.h:61 */
struct __anonstruct_seq_buf_t_653462437 ;
/* END STRUCT-DECL __anonstruct_seq_buf_t_653462437 LOC=libs/seq_file/seq_file.h:61 */

/* BEGIN ENUM-DECL __anonenum_seq_format_498167330 LOC=libs/seq_file/seq_file.h:34 */
enum __anonenum_seq_format_498167330 ;
/* END ENUM-DECL __anonenum_seq_format_498167330 LOC=libs/seq_file/seq_file.h:34 */

/* BEGIN STRUCT-DECL __anonstruct_MatrixSort_459211137 LOC=src/smith_waterman.c:64 */
struct __anonstruct_MatrixSort_459211137 ;
/* END STRUCT-DECL __anonstruct_MatrixSort_459211137 LOC=src/smith_waterman.c:64 */

/* BEGIN STRUCT-DECL __anonstruct_cmdline_t_751155579 LOC=src/alignment_cmdline.h:23 */
struct __anonstruct_cmdline_t_751155579 ;
/* END STRUCT-DECL __anonstruct_cmdline_t_751155579 LOC=src/alignment_cmdline.h:23 */

/* BEGIN STRUCT-DECL __anonstruct_alignment_t_970931537 LOC=src/alignment.h:33 */
struct __anonstruct_alignment_t_970931537 ;
/* END STRUCT-DECL __anonstruct_alignment_t_970931537 LOC=src/alignment.h:33 */

/* BEGIN STRUCT-DECL __anonstruct_StrBuf_483684869 LOC=libs/string_buffer/string_buffer.h:20 */
struct __anonstruct_StrBuf_483684869 ;
/* END STRUCT-DECL __anonstruct_StrBuf_483684869 LOC=libs/string_buffer/string_buffer.h:20 */

/* BEGIN STRUCT-DECL __anonstruct_StreamBuffer_653462436 LOC=libs/seq_file/stream_buffer.h:67 */
struct __anonstruct_StreamBuffer_653462436 ;
/* END STRUCT-DECL __anonstruct_StreamBuffer_653462436 LOC=libs/seq_file/stream_buffer.h:67 */

/* BEGIN STRUCT-DECL __anonstruct_sw_history_t_920808153 LOC=src/smith_waterman.c:49 */
struct __anonstruct_sw_history_t_920808153 ;
/* END STRUCT-DECL __anonstruct_sw_history_t_920808153 LOC=src/smith_waterman.c:49 */

/* BEGIN ENUM-DECL SeqAlignCmdType LOC=src/alignment_cmdline.h:21 */
enum SeqAlignCmdType ;
/* END ENUM-DECL SeqAlignCmdType LOC=src/alignment_cmdline.h:21 */

/* BEGIN STRUCT-DECL __anonstruct_aligner_t_94193678 LOC=src/alignment.h:23 */
struct __anonstruct_aligner_t_94193678 ;
/* END STRUCT-DECL __anonstruct_aligner_t_94193678 LOC=src/alignment.h:23 */

/* BEGIN FUNCTION-DECL __builtin_strchr LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* END FUNCTION-DECL __builtin_strchr LOC=BUILTIN */

/* BEGIN TYPEDEF seq_file_t LOC=libs/seq_file/seq_file.h:41 */
typedef struct seq_file_struct seq_file_t;
/* END TYPEDEF seq_file_t LOC=libs/seq_file/seq_file.h:41 */

/* BEGIN TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:46 */
typedef unsigned long size_t___0;
/* END TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:46 */

/* BEGIN FUNCTION-DECL seq_open2 LOC=UNKNOWN */
__inline static seq_file_t *seq_open2(char const   *p , _Bool ishts , _Bool use_zlib ,
                                      size_t___0 buf_size ) ;
/* END FUNCTION-DECL seq_open2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ctz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ctz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_acosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_acosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_acosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_acosf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */

/* BEGIN TYPEDEF read_t LOC=libs/seq_file/seq_file.h:42 */
typedef struct read_struct read_t;
/* END TYPEDEF read_t LOC=libs/seq_file/seq_file.h:42 */

/* BEGIN FUNCTION-DECL _seq_read_unknown_gz LOC=UNKNOWN */
__inline static int _seq_read_unknown_gz(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_unknown_gz LOC=UNKNOWN */

/* BEGIN TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
typedef struct _IO_FILE FILE;
/* END TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN FUNCTION-DECL-EXTERN putc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:108 */
extern int putc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN putc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:108 */

/* BEGIN TYPEDEF cmdline_t LOC=src/alignment_cmdline.h:23 */
typedef struct __anonstruct_cmdline_t_751155579 cmdline_t;
/* END TYPEDEF cmdline_t LOC=src/alignment_cmdline.h:23 */

/* BEGIN FUNCTION-DECL cmdline_add_files LOC=UNKNOWN */
void cmdline_add_files(cmdline_t *cmd___0 , char *p1 , char *p2 ) ;
/* END FUNCTION-DECL cmdline_add_files LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* END FUNCTION-DECL __builtin_sinh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */

/* BEGIN TYPEDEF StrBuf LOC=libs/string_buffer/string_buffer.h:20 */
typedef struct __anonstruct_StrBuf_483684869 StrBuf;
/* END TYPEDEF StrBuf LOC=libs/string_buffer/string_buffer.h:20 */

/* BEGIN FUNCTION-DECL-EXTERN strbuf_new LOC=libs/string_buffer/string_buffer.h:33 */
extern StrBuf *strbuf_new(size_t___0 len ) ;
/* END FUNCTION-DECL-EXTERN strbuf_new LOC=libs/string_buffer/string_buffer.h:33 */

/* BEGIN VARIABLE-DEF wait_on_keystroke LOC=UNKNOWN */
_Bool wait_on_keystroke  ;
/* END VARIABLE-DEF wait_on_keystroke LOC=UNKNOWN */

/* BEGIN TYPEDEF scoring_t LOC=src/alignment_scoring.h:19 */
typedef struct __anonstruct_scoring_t_699705047 scoring_t;
/* END TYPEDEF scoring_t LOC=src/alignment_scoring.h:19 */

/* BEGIN FUNCTION-DECL scoring_system_BLOSUM80 LOC=UNKNOWN */
void scoring_system_BLOSUM80(scoring_t *scoring___0 ) ;
/* END FUNCTION-DECL scoring_system_BLOSUM80 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_argc LOC=UNKNOWN */
int _global_argc  ;
/* END VARIABLE-DEF _global_argc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* END FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_trap LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* END FUNCTION-DECL __builtin_trap LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* END FUNCTION-DECL __builtin_cosh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* END FUNCTION-DECL __builtin_log10f LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */
extern int fputs(char const   * , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */

/* BEGIN FUNCTION-DECL cmdline_get_num_of_file_pairs LOC=UNKNOWN */
size_t___0 cmdline_get_num_of_file_pairs(cmdline_t *cmd___0 ) ;
/* END FUNCTION-DECL cmdline_get_num_of_file_pairs LOC=UNKNOWN */

/* BEGIN TYPEDEF alignment_t LOC=src/alignment.h:33 */
typedef struct __anonstruct_alignment_t_970931537 alignment_t;
/* END TYPEDEF alignment_t LOC=src/alignment.h:33 */

/* BEGIN TYPEDEF score_t LOC=src/alignment_scoring.h:16 */
typedef int score_t;
/* END TYPEDEF score_t LOC=src/alignment_scoring.h:16 */

/* BEGIN STRUCT __anonstruct_aligner_t_94193678 LOC=src/alignment.h:23 */
struct __anonstruct_aligner_t_94193678 {
   scoring_t const   *scoring ;
   char const   *seq_a ;
   char const   *seq_b ;
   size_t___0 score_width ;
   size_t___0 score_height ;
   score_t *match_scores ;
   score_t *gap_a_scores ;
   score_t *gap_b_scores ;
   size_t___0 capacity ;
};
/* END STRUCT __anonstruct_aligner_t_94193678 LOC=src/alignment.h:23 */

/* BEGIN TYPEDEF aligner_t LOC=src/alignment.h:23 */
typedef struct __anonstruct_aligner_t_94193678 aligner_t;
/* END TYPEDEF aligner_t LOC=src/alignment.h:23 */

/* BEGIN TYPEDEF nw_aligner_t LOC=src/needleman_wunsch.h:16 */
typedef aligner_t nw_aligner_t;
/* END TYPEDEF nw_aligner_t LOC=src/needleman_wunsch.h:16 */

/* BEGIN FUNCTION-DECL needleman_wunsch_align2 LOC=UNKNOWN */
void needleman_wunsch_align2(char const   *a , char const   *b , size_t___0 len_a ,
                             size_t___0 len_b , scoring_t const   *scoring___0 , nw_aligner_t *nw ,
                             alignment_t *result___0 ) ;
/* END FUNCTION-DECL needleman_wunsch_align2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF file_paths1 LOC=UNKNOWN */
char **file_paths1  ;
/* END VARIABLE-DEF file_paths1 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL open_seq_file LOC=UNKNOWN */
static seq_file_t *open_seq_file(char const   *path , _Bool use_zlib ) ;
/* END FUNCTION-DECL open_seq_file LOC=UNKNOWN */

/* BEGIN TYPEDEF StreamBuffer LOC=libs/seq_file/stream_buffer.h:67 */
typedef struct __anonstruct_StreamBuffer_653462436 StreamBuffer;
/* END TYPEDEF StreamBuffer LOC=libs/seq_file/stream_buffer.h:67 */

/* BEGIN FUNCTION-DECL ungetc_buf LOC=UNKNOWN */
__inline static int ungetc_buf(int c , StreamBuffer *in ) ;
/* END FUNCTION-DECL ungetc_buf LOC=UNKNOWN */

/* BEGIN TYPEDEF sw_history_t LOC=src/smith_waterman.c:49 */
typedef struct __anonstruct_sw_history_t_920808153 sw_history_t;
/* END TYPEDEF sw_history_t LOC=src/smith_waterman.c:49 */

/* BEGIN FUNCTION-DECL __builtin_acos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* END FUNCTION-DECL __builtin_acos LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:99 */
extern size_t___0 fread(void * __restrict   , size_t___0  , size_t___0  , FILE * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN fread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:99 */

/* BEGIN TYPEDEF gzFile LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */
typedef struct gzFile_s *gzFile;
/* END TYPEDEF gzFile LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1302 */

/* BEGIN FUNCTION-DECL-EXTERN gzgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1491 */
extern char *gzgets(gzFile file , char *buf , int len ) ;
/* END FUNCTION-DECL-EXTERN gzgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1491 */

/* BEGIN ENUM __anonenum_seq_format_498167330 LOC=libs/seq_file/seq_file.h:34 */
enum __anonenum_seq_format_498167330 {
    SEQ_FMT_UNKNOWN = 0,
    SEQ_FMT_PLAIN = 1,
    SEQ_FMT_FASTA = 2,
    SEQ_FMT_FASTQ = 4,
    SEQ_FMT_SAM = 8,
    SEQ_FMT_BAM = 16,
    SEQ_FMT_CRAM = 16
} ;
/* END ENUM __anonenum_seq_format_498167330 LOC=libs/seq_file/seq_file.h:34 */

/* BEGIN FUNCTION-DECL sort_match_indices LOC=UNKNOWN */
int sort_match_indices(void const   *aa , void const   *bb , void *arg ) ;
/* END FUNCTION-DECL sort_match_indices LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL sort_r_simple LOC=UNKNOWN */
__inline static void sort_r_simple(void *base , size_t___0 nel , size_t___0 w , int (*compar)(void const   *_a ,
                                                                                              void const   *_b ,
                                                                                              void *_arg ) ,
                                   void *arg ) ;
/* END FUNCTION-DECL sort_r_simple LOC=UNKNOWN */

/* BEGIN ENUM SeqAlignCmdType LOC=src/alignment_cmdline.h:21 */
enum SeqAlignCmdType {
    SEQ_ALIGN_SW_CMD = 0,
    SEQ_ALIGN_NW_CMD = 1,
    SEQ_ALIGN_LCS_CMD = 2
} ;
/* END ENUM SeqAlignCmdType LOC=src/alignment_cmdline.h:21 */

/* BEGIN FUNCTION-DECL cmdline_new LOC=UNKNOWN */
cmdline_t *cmdline_new(int argc , char **argv , scoring_t *scoring___0 , enum SeqAlignCmdType cmd_type ) ;
/* END FUNCTION-DECL cmdline_new LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */
extern int fprintf(FILE * , char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */

/* BEGIN FUNCTION-DECL gzreadline LOC=UNKNOWN */
__inline static size_t___0 gzreadline(gzFile file , char **buf , size_t___0 *len ,
                                      size_t___0 *size ) ;
/* END FUNCTION-DECL gzreadline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL scoring_system_default LOC=UNKNOWN */
void scoring_system_default(scoring_t *scoring___0 ) ;
/* END FUNCTION-DECL scoring_system_default LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN string_is_all_whitespace LOC=libs/string_buffer/string_buffer.h:280 */
extern char string_is_all_whitespace(char const   *s ) ;
/* END FUNCTION-DECL-EXTERN string_is_all_whitespace LOC=libs/string_buffer/string_buffer.h:280 */

/* BEGIN FUNCTION-DECL __builtin_parity LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_parity LOC=BUILTIN */

/* BEGIN FUNCTION-DECL seq_read_reset LOC=UNKNOWN */
__inline static void seq_read_reset(read_t *r ) ;
/* END FUNCTION-DECL seq_read_reset LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN gzgetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1511 */
extern int gzgetc(gzFile file ) ;
/* END FUNCTION-DECL-EXTERN gzgetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1511 */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_alignment_t_970931537 LOC=src/alignment.h:33 */
struct __anonstruct_alignment_t_970931537 {
   char *result_a ;
   char *result_b ;
   size_t___0 capacity ;
   size_t___0 length ;
   size_t___0 pos_a ;
   size_t___0 pos_b ;
   size_t___0 len_a ;
   size_t___0 len_b ;
   score_t score ;
};
/* END STRUCT __anonstruct_alignment_t_970931537 LOC=src/alignment.h:33 */

/* BEGIN FUNCTION-DECL alignment_print_spacer LOC=UNKNOWN */
void alignment_print_spacer(char const   *alignment_a , char const   *alignment_b ,
                            scoring_t const   *scoring___0 ) ;
/* END FUNCTION-DECL alignment_print_spacer LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_cosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_cosl LOC=BUILTIN */

/* BEGIN TYPEDEF uint32_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:210 */
typedef unsigned int uint32_t;
/* END TYPEDEF uint32_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:210 */

/* BEGIN STRUCT __anonstruct_BitSet_909456816 LOC=src/smith_waterman.c:21 */
struct __anonstruct_BitSet_909456816 {
   uint32_t *b ;
   size_t___0 l ;
   size_t___0 s ;
};
/* END STRUCT __anonstruct_BitSet_909456816 LOC=src/smith_waterman.c:21 */

/* BEGIN TYPEDEF BitSet LOC=src/smith_waterman.c:21 */
typedef struct __anonstruct_BitSet_909456816 BitSet;
/* END TYPEDEF BitSet LOC=src/smith_waterman.c:21 */

/* BEGIN STRUCT __anonstruct_sw_history_t_920808153 LOC=src/smith_waterman.c:49 */
struct __anonstruct_sw_history_t_920808153 {
   BitSet match_scores_mask ;
   size_t___0 *sorted_match_indices ;
   size_t___0 hits_capacity ;
   size_t___0 num_of_hits ;
   size_t___0 next_hit ;
};
/* END STRUCT __anonstruct_sw_history_t_920808153 LOC=src/smith_waterman.c:49 */

/* BEGIN FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL bitset_dealloc LOC=UNKNOWN */
__inline static void bitset_dealloc(BitSet *bs ) ;
/* END FUNCTION-DECL bitset_dealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strbuf_chomp LOC=libs/string_buffer/string_buffer.h:159 */
extern size_t___0 strbuf_chomp(StrBuf *sb ) ;
/* END FUNCTION-DECL-EXTERN strbuf_chomp LOC=libs/string_buffer/string_buffer.h:159 */

/* BEGIN FUNCTION-DECL _init_history LOC=UNKNOWN */
static void _init_history(sw_history_t *hist ) ;
/* END FUNCTION-DECL _init_history LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN fileno LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:152 */
extern int fileno(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fileno LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:152 */

/* BEGIN FUNCTION-DECL fgetc_buf LOC=UNKNOWN */
__inline static int fgetc_buf(FILE *file , StreamBuffer *in ) ;
/* END FUNCTION-DECL fgetc_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN __assert_fail LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h:19 */
extern  __attribute__((__noreturn__)) void __assert_fail(char const   * , char const   * ,
                                                         int  , char const   * ) ;
/* END FUNCTION-DECL-EXTERN __assert_fail LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h:19 */

/* BEGIN FUNCTION-DECL align_scoring_load_pairwise LOC=UNKNOWN */
void align_scoring_load_pairwise(gzFile file , char const   *file_path , scoring_t *scoring___0 ,
                                 char case_sensitive ) ;
/* END FUNCTION-DECL align_scoring_load_pairwise LOC=UNKNOWN */

/* BEGIN TYPEDEF sw_aligner_t LOC=src/smith_waterman.h:15 */
typedef struct sw_aligner_t sw_aligner_t;
/* END TYPEDEF sw_aligner_t LOC=src/smith_waterman.h:15 */

/* BEGIN FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */

/* BEGIN TYPEDEF voidp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h:410 */
typedef void *voidp;
/* END TYPEDEF voidp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h:410 */

/* BEGIN FUNCTION-DECL-EXTERN gzread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1392 */
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
/* END FUNCTION-DECL-EXTERN gzread LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1392 */

/* BEGIN FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_fasta_gz LOC=UNKNOWN */
__inline static int _seq_read_fasta_gz(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fasta_gz LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strcasecmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h:29 */
extern int strcasecmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcasecmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h:29 */

/* BEGIN STRUCT __anonstruct_MatrixSort_459211137 LOC=src/smith_waterman.c:64 */
struct __anonstruct_MatrixSort_459211137 {
   score_t *match_scores ;
   unsigned int score_width ;
};
/* END STRUCT __anonstruct_MatrixSort_459211137 LOC=src/smith_waterman.c:64 */

/* BEGIN FUNCTION-DECL __builtin_inff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* END FUNCTION-DECL __builtin_inff LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_fasta_f LOC=UNKNOWN */
__inline static int _seq_read_fasta_f(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fasta_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_asin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* END FUNCTION-DECL __builtin_asin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL alignment_colour_print_against LOC=UNKNOWN */
void alignment_colour_print_against(char const   *alignment_a , char const   *alignment_b ,
                                    char case_sensitive ) ;
/* END FUNCTION-DECL alignment_colour_print_against LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_object_size LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* END FUNCTION-DECL __builtin_object_size LOC=BUILTIN */

/* BEGIN VARIABLE-DEF alignment_index LOC=UNKNOWN */
size_t___0 alignment_index  ;
/* END VARIABLE-DEF alignment_index LOC=UNKNOWN */

/* BEGIN STRUCT __anonstruct_StreamBuffer_653462436 LOC=libs/seq_file/stream_buffer.h:67 */
struct __anonstruct_StreamBuffer_653462436 {
   char *b ;
   size_t___0 begin ;
   size_t___0 end ;
   size_t___0 size ;
};
/* END STRUCT __anonstruct_StreamBuffer_653462436 LOC=libs/seq_file/stream_buffer.h:67 */

/* BEGIN FUNCTION-DECL-EXTERN gzdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1342 */
extern gzFile gzdopen(int fd , char const   *mode ) ;
/* END FUNCTION-DECL-EXTERN gzdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1342 */

/* BEGIN FUNCTION-DECL _seq_read_fastq_gz LOC=UNKNOWN */
__inline static int _seq_read_fastq_gz(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fastq_gz LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_asinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_asinf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */
extern int tolower(int  ) ;
/* END FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */

/* BEGIN STRUCT __anonstruct_cmdline_t_751155579 LOC=src/alignment_cmdline.h:23 */
struct __anonstruct_cmdline_t_751155579 {
   size_t___0 file_list_length ;
   size_t___0 file_list_capacity ;
   char **file_paths1 ;
   char **file_paths2 ;
   _Bool case_sensitive ;
   int match ;
   int mismatch ;
   int gap_open ;
   int gap_extend ;
   score_t min_score ;
   unsigned int print_context ;
   unsigned int max_hits_per_alignment ;
   _Bool min_score_set ;
   _Bool max_hits_per_alignment_set ;
   _Bool print_seq ;
   _Bool freestartgap_set ;
   _Bool freeendgap_set ;
   _Bool print_matrices ;
   _Bool print_scores ;
   _Bool zam_stle_output ;
   _Bool interactive ;
   _Bool print_fasta ;
   _Bool print_pretty ;
   _Bool print_colour ;
   _Bool no_gaps_in1 ;
   _Bool no_gaps_in2 ;
   _Bool no_mismatches ;
   char const   *seq1 ;
   char const   *seq2 ;
};
/* END STRUCT __anonstruct_cmdline_t_751155579 LOC=src/alignment_cmdline.h:23 */

/* BEGIN FUNCTION-DECL __builtin_coshl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_coshl LOC=BUILTIN */

/* BEGIN TYPEDEF size_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t;
/* END TYPEDEF size_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN FUNCTION-DECL-EXTERN malloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:40 */
extern void *malloc(size_t  ) ;
/* END FUNCTION-DECL-EXTERN malloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:40 */

/* BEGIN FUNCTION-DECL __builtin_tan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* END FUNCTION-DECL __builtin_tan LOC=BUILTIN */

/* BEGIN TYPEDEF seq_format LOC=libs/seq_file/seq_file.h:34 */
typedef enum __anonenum_seq_format_498167330 seq_format;
/* END TYPEDEF seq_format LOC=libs/seq_file/seq_file.h:34 */

/* BEGIN STRUCT seq_file_struct LOC=libs/seq_file/seq_file.h:44 */
struct seq_file_struct {
   char *path ;
   FILE *f_file ;
   gzFile gz_file ;
   void *hts_file ;
   void *bam_hdr ;
   int (*readfunc)(seq_file_t *sf , read_t *r ) ;
   StreamBuffer in ;
   seq_format format ;
   read_t *rhead ;
   read_t *rtail ;
   int (*origreadfunc)(seq_file_t *sf , read_t *r ) ;
};
/* END STRUCT seq_file_struct LOC=libs/seq_file/seq_file.h:44 */

/* BEGIN FUNCTION-DECL smith_waterman_align2 LOC=UNKNOWN */
void smith_waterman_align2(char const   *a , char const   *b , size_t___0 len_a ,
                           size_t___0 len_b , scoring_t const   *scoring___0 , sw_aligner_t *sw___0 ) ;
/* END FUNCTION-DECL smith_waterman_align2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN gzungetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1520 */
extern int gzungetc(int c , gzFile file ) ;
/* END FUNCTION-DECL-EXTERN gzungetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1520 */

/* BEGIN FUNCTION-DECL seq_dopen LOC=UNKNOWN */
__inline static seq_file_t *seq_dopen(int fd , char ishts , _Bool use_zlib , size_t___0 buf_size ) ;
/* END FUNCTION-DECL seq_dopen LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL smith_waterman_free LOC=UNKNOWN */
void smith_waterman_free(sw_aligner_t *sw___0 ) ;
/* END FUNCTION-DECL smith_waterman_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* END FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */

/* BEGIN VARIABLE-DEF align_col_context LOC=UNKNOWN */
char align_col_context[6]  ;
/* END VARIABLE-DEF align_col_context LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL scoring_add_wildcard LOC=UNKNOWN */
void scoring_add_wildcard(scoring_t *scoring___0 , char c , int score ) ;
/* END FUNCTION-DECL scoring_add_wildcard LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL bitset_set_length LOC=UNKNOWN */
__inline static BitSet *bitset_set_length(BitSet *bs , size_t___0 l ) ;
/* END FUNCTION-DECL bitset_set_length LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* END FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* END FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */
extern size_t___0 strlen(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */

/* BEGIN FUNCTION-DECL scoring_add_mutations LOC=UNKNOWN */
void scoring_add_mutations(scoring_t *scoring___0 , char const   *str , int const   *scores ,
                           char use_match_mismatch ) ;
/* END FUNCTION-DECL scoring_add_mutations LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */
extern int isspace(int  ) ;
/* END FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */

/* BEGIN FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL parse_entire_int LOC=UNKNOWN */
char parse_entire_int(char *str , int *result___0 ) ;
/* END FUNCTION-DECL parse_entire_int LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL smith_waterman_align LOC=UNKNOWN */
void smith_waterman_align(char const   *a , char const   *b , scoring_t const   *scoring___0 ,
                          sw_aligner_t *sw___0 ) ;
/* END FUNCTION-DECL smith_waterman_align LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* END FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN realloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:42 */
extern void *realloc(void * , size_t  ) ;
/* END FUNCTION-DECL-EXTERN realloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:42 */

/* BEGIN FUNCTION-DECL cmdline_get_file2 LOC=UNKNOWN */
char *cmdline_get_file2(cmdline_t *cmd___0 , size_t___0 i ) ;
/* END FUNCTION-DECL cmdline_get_file2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_coshf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* END FUNCTION-DECL __builtin_coshf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF pam70 LOC=UNKNOWN */
static int pam70[576]  ;
/* END VARIABLE-DEF pam70 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL aligner_destroy LOC=UNKNOWN */
void aligner_destroy(aligner_t *aligner ) ;
/* END FUNCTION-DECL aligner_destroy LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF sw LOC=UNKNOWN */
sw_aligner_t *sw  ;
/* END VARIABLE-DEF sw LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floor LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* END FUNCTION-DECL __builtin_floor LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_modfl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* END FUNCTION-DECL __builtin_modfl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL seq_read_dealloc LOC=UNKNOWN */
__inline static void seq_read_dealloc(read_t *r ) ;
/* END FUNCTION-DECL seq_read_dealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_infl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* END FUNCTION-DECL __builtin_infl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL scoring_add_mutation LOC=UNKNOWN */
void scoring_add_mutation(scoring_t *scoring___0 , char a , char b , int score ) ;
/* END FUNCTION-DECL scoring_add_mutation LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */
extern FILE *stdout ;
/* END VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */

/* BEGIN FUNCTION-DECL __builtin_strspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL sort_r_cmpswap LOC=UNKNOWN */
__inline static int sort_r_cmpswap(char * __restrict  a , char * __restrict  b , size_t___0 w ,
                                   int (*compar)(void const   *_a , void const   *_b ,
                                                 void *_arg ) , void *arg ) ;
/* END FUNCTION-DECL sort_r_cmpswap LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN exit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:48 */
extern  __attribute__((__noreturn__)) void exit(int  ) ;
/* END FUNCTION-DECL-EXTERN exit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:48 */

/* BEGIN FUNCTION-DECL parse_entire_uint LOC=UNKNOWN */
char parse_entire_uint(char *str , unsigned int *result___0 ) ;
/* END FUNCTION-DECL parse_entire_uint LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_expf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* END FUNCTION-DECL __builtin_expf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ffs LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ffs LOC=BUILTIN */

/* BEGIN FUNCTION-DECL scoring_init LOC=UNKNOWN */
void scoring_init(scoring_t *scoring___0 , int match , int mismatch , int gap_open ,
                  int gap_extend , _Bool no_start_gap_penalty , _Bool no_end_gap_penalty ,
                  _Bool no_gaps_in_a , _Bool no_gaps_in_b , _Bool no_mismatches ,
                  _Bool case_sensitive ) ;
/* END FUNCTION-DECL scoring_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL needleman_wunsch_new LOC=UNKNOWN */
nw_aligner_t *needleman_wunsch_new(void) ;
/* END FUNCTION-DECL needleman_wunsch_new LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN abs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:60 */
extern int abs(int  ) ;
/* END FUNCTION-DECL-EXTERN abs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:60 */

/* BEGIN FUNCTION-DECL __builtin_nanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanl LOC=BUILTIN */

/* BEGIN STRUCT sw_aligner_t LOC=src/smith_waterman.c:56 */
struct sw_aligner_t {
   aligner_t aligner ;
   sw_history_t history ;
};
/* END STRUCT sw_aligner_t LOC=src/smith_waterman.c:56 */

/* BEGIN VARIABLE-DEF align_col_indel LOC=UNKNOWN */
char align_col_indel[6]  ;
/* END VARIABLE-DEF align_col_indel LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* END FUNCTION-DECL __builtin_sin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL align LOC=UNKNOWN */
void align(char const   *seq_a , char const   *seq_b , char const   *seq_a_name ,
           char const   *seq_b_name ) ;
/* END FUNCTION-DECL align LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN fclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:82 */
extern int fclose(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:82 */

/* BEGIN FUNCTION-DECL-EXTERN memmove LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:28 */
extern void *memmove(void * , void const   * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memmove LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:28 */

/* BEGIN FUNCTION-DECL alignment_print_matrices LOC=UNKNOWN */
void alignment_print_matrices(aligner_t const   *aligner ) ;
/* END FUNCTION-DECL alignment_print_matrices LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL _rndup2pow64 LOC=UNKNOWN */
__inline static size_t___0 _rndup2pow64(unsigned long long x ) ;
/* END FUNCTION-DECL _rndup2pow64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _rndup2pow64___0 LOC=UNKNOWN */
__inline static size_t___0 _rndup2pow64___0(unsigned long long x ) ;
/* END FUNCTION-DECL _rndup2pow64___0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_plain_f LOC=UNKNOWN */
__inline static int _seq_read_plain_f(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_plain_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strncat LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncat LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_floorf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* END FUNCTION-DECL __builtin_floorf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN gzopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1893 */
extern gzFile gzopen(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN gzopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1893 */

/* BEGIN FUNCTION-DECL-EXTERN fopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:80 */
extern FILE *fopen(char const   * __restrict   , char const   * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN fopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:80 */

/* BEGIN FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL gzskipline LOC=UNKNOWN */
__inline static size_t___0 gzskipline(gzFile file ) ;
/* END FUNCTION-DECL gzskipline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabs LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* END FUNCTION-DECL __builtin_fabs LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtol LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:32 */
extern long strtol(char const   * , char ** , int  ) ;
/* END FUNCTION-DECL-EXTERN strtol LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:32 */

/* BEGIN FUNCTION-DECL gzread2 LOC=UNKNOWN */
__inline static size_t___0 gzread2(gzFile gz , void *ptr , size_t___0 len ) ;
/* END FUNCTION-DECL gzread2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_tanh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* END FUNCTION-DECL __builtin_tanh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_fastq_f LOC=UNKNOWN */
__inline static int _seq_read_fastq_f(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fastq_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_scoring_t_699705047 LOC=src/alignment_scoring.h:19 */
struct __anonstruct_scoring_t_699705047 {
   int gap_open ;
   int gap_extend ;
   _Bool no_start_gap_penalty ;
   _Bool no_end_gap_penalty ;
   _Bool no_gaps_in_a ;
   _Bool no_gaps_in_b ;
   _Bool no_mismatches ;
   _Bool use_match_mismatch ;
   int match ;
   int mismatch ;
   _Bool case_sensitive ;
   uint32_t wildcards[8] ;
   uint32_t swap_set[256][8] ;
   score_t wildscores[256] ;
   score_t swap_scores[256][256] ;
   int min_penalty ;
   int max_penalty ;
};
/* END STRUCT __anonstruct_scoring_t_699705047 LOC=src/alignment_scoring.h:19 */

/* BEGIN TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */
typedef long long off_t;
/* END TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */

/* BEGIN FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_powil LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powil LOC=BUILTIN */

/* BEGIN VARIABLE-DEF dna_bases LOC=UNKNOWN */
static char dna_bases[9]  ;
/* END VARIABLE-DEF dna_bases LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* END FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL cbuf_append_char LOC=UNKNOWN */
__inline static void cbuf_append_char(char **buf , size_t___0 *lenptr , size_t___0 *sizeptr ,
                                      char c ) ;
/* END FUNCTION-DECL cbuf_append_char LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _global_argv LOC=UNKNOWN */
char **_global_argv  ;
/* END VARIABLE-DEF _global_argv LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_atanf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF amino_acids LOC=UNKNOWN */
static char amino_acids[25]  ;
/* END VARIABLE-DEF amino_acids LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_fastq_f_buf LOC=UNKNOWN */
__inline static int _seq_read_fastq_f_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fastq_f_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL freadline_buf LOC=UNKNOWN */
__inline static size_t___0 freadline_buf(FILE *file , StreamBuffer *in , char **buf ,
                                         size_t___0 *len , size_t___0 *size ) ;
/* END FUNCTION-DECL freadline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nansf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL align_from_file LOC=UNKNOWN */
void align_from_file(char const   *path1 , char const   *path2 , void (*align___0)(read_t *r1 ,
                                                                                   read_t *r2 ) ,
                     _Bool use_zlib ) ;
/* END FUNCTION-DECL align_from_file LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL cbuf_chomp LOC=UNKNOWN */
__inline static void cbuf_chomp(char *buf , size_t___0 *lenptr ) ;
/* END FUNCTION-DECL cbuf_chomp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN fgetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:102 */
extern int fgetc(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fgetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:102 */

/* BEGIN FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL strm_buf_dealloc LOC=UNKNOWN */
__inline static void strm_buf_dealloc(StreamBuffer *b ) ;
/* END FUNCTION-DECL strm_buf_dealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL strbuf_free LOC=UNKNOWN */
__inline static void strbuf_free(StrBuf *sb ) ;
/* END FUNCTION-DECL strbuf_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL bitset_alloc LOC=UNKNOWN */
__inline static BitSet *bitset_alloc(BitSet *bs , size_t___0 l ) ;
/* END FUNCTION-DECL bitset_alloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL scoring_system_PAM70 LOC=UNKNOWN */
void scoring_system_PAM70(scoring_t *scoring___0 ) ;
/* END FUNCTION-DECL scoring_system_PAM70 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* END FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nansl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL alignment_ensure_capacity LOC=UNKNOWN */
void alignment_ensure_capacity(alignment_t *result___0 , size_t___0 strlength ) ;
/* END FUNCTION-DECL alignment_ensure_capacity LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN getc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:103 */
extern int getc(FILE * ) ;
/* END FUNCTION-DECL-EXTERN getc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:103 */

/* BEGIN FUNCTION-DECL __builtin_parityl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_parityl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* END FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ceil LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* END FUNCTION-DECL __builtin_ceil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:149 */
extern FILE *fdopen(int  , char const   * ) ;
/* END FUNCTION-DECL-EXTERN fdopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:149 */

/* BEGIN FUNCTION-DECL scoring_lookup LOC=UNKNOWN */
void scoring_lookup(scoring_t const   *scoring___0 , char a , char b , int *score ,
                    _Bool *is_match ) ;
/* END FUNCTION-DECL scoring_lookup LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strlen LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strlen LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fflush LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:89 */
extern int fflush(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fflush LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:89 */

/* BEGIN FUNCTION-DECL _seq_read_fasta_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_fasta_gz_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fasta_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN ungetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:105 */
extern int ungetc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN ungetc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:105 */

/* BEGIN FUNCTION-DECL-EXTERN fgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:111 */
extern char *fgets(char * __restrict   , int  , FILE * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN fgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:111 */

/* BEGIN FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */

/* BEGIN FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* END FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_asinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_asinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL print_alignment_part LOC=UNKNOWN */
void print_alignment_part(char const   *seq1 , char const   *seq2 , size_t___0 pos ,
                          size_t___0 len , char const   *context_str , size_t___0 spaces_left ,
                          size_t___0 spaces_right , size_t___0 context_left , size_t___0 context_right ) ;
/* END FUNCTION-DECL print_alignment_part LOC=UNKNOWN */

/* BEGIN STRUCT gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1834 */
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
/* END STRUCT gzFile_s LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1834 */

/* BEGIN FUNCTION-DECL-EXTERN strdup LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:70 */
extern char *strdup(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strdup LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:70 */

/* BEGIN FUNCTION-DECL __builtin_atanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_atanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL scoring_system_BLOSUM62 LOC=UNKNOWN */
void scoring_system_BLOSUM62(scoring_t *scoring___0 ) ;
/* END FUNCTION-DECL scoring_system_BLOSUM62 LOC=UNKNOWN */

/* BEGIN ENUM Matrix LOC=src/alignment.h:43 */
enum Matrix {
    MATCH = 0,
    GAP_A = 1,
    GAP_B = 2
} ;
/* END ENUM Matrix LOC=src/alignment.h:43 */

/* BEGIN FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL smith_waterman_get_aligner LOC=UNKNOWN */
aligner_t *smith_waterman_get_aligner(sw_aligner_t *sw___0 ) ;
/* END FUNCTION-DECL smith_waterman_get_aligner LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_parityll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_parityll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fmod LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* END FUNCTION-DECL __builtin_fmod LOC=BUILTIN */

/* BEGIN TYPEDEF seq_buf_t LOC=libs/seq_file/seq_file.h:61 */
typedef struct __anonstruct_seq_buf_t_653462437 seq_buf_t;
/* END TYPEDEF seq_buf_t LOC=libs/seq_file/seq_file.h:61 */

/* BEGIN FUNCTION-DECL-EXTERN gzclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1631 */
extern int gzclose(gzFile file ) ;
/* END FUNCTION-DECL-EXTERN gzclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h:1631 */

/* BEGIN VARIABLE-DEF result LOC=UNKNOWN */
alignment_t *result  ;
/* END VARIABLE-DEF result LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* END FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_return_address LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_seq_buf_t_653462437 LOC=libs/seq_file/seq_file.h:61 */
struct __anonstruct_seq_buf_t_653462437 {
   char *b ;
   size_t___0 end ;
   size_t___0 size ;
};
/* END STRUCT __anonstruct_seq_buf_t_653462437 LOC=libs/seq_file/seq_file.h:61 */

/* BEGIN FUNCTION-DECL fskipline_buf LOC=UNKNOWN */
__inline static size_t___0 fskipline_buf(FILE *file , StreamBuffer *in ) ;
/* END FUNCTION-DECL fskipline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL strm_buf_alloc LOC=UNKNOWN */
__inline static StreamBuffer *strm_buf_alloc(StreamBuffer *b , size_t___0 s ) ;
/* END FUNCTION-DECL strm_buf_alloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_setup LOC=UNKNOWN */
__inline static char _seq_setup(seq_file_t *sf , _Bool use_zlib , size_t___0 buf_size ) ;
/* END FUNCTION-DECL _seq_setup LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floorl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_floorl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL sw_set_default_scoring LOC=UNKNOWN */
static void sw_set_default_scoring(void) ;
/* END FUNCTION-DECL sw_set_default_scoring LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL seq_close LOC=UNKNOWN */
__inline static void seq_close(seq_file_t *sf ) ;
/* END FUNCTION-DECL seq_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_expl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_expl LOC=BUILTIN */

/* BEGIN VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */
extern FILE *stderr ;
/* END VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */

/* BEGIN FUNCTION-DECL __builtin_log10l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* END FUNCTION-DECL __builtin_log10l LOC=BUILTIN */

/* BEGIN FUNCTION-DECL fskipline LOC=UNKNOWN */
__inline static size_t___0 fskipline(FILE *file ) ;
/* END FUNCTION-DECL fskipline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_popcount LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_popcount LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_plain_gz LOC=UNKNOWN */
__inline static int _seq_read_plain_gz(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_plain_gz LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */
extern int strcmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */

/* BEGIN FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* END FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _follow_hit LOC=UNKNOWN */
static char _follow_hit(sw_aligner_t *sw___0 , size_t___0 arr_index , alignment_t *result___0 ) ;
/* END FUNCTION-DECL _follow_hit LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL alignment_free LOC=UNKNOWN */
void alignment_free(alignment_t *result___0 ) ;
/* END FUNCTION-DECL alignment_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL print_usage LOC=UNKNOWN */
static  __attribute__((__noreturn__)) void print_usage(enum SeqAlignCmdType cmd_type ,
                                                       score_t *defaults , char const   *cmdstr ,
                                                       char const   *errfmt  , ...) ;
/* END FUNCTION-DECL print_usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_clz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_clz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL needleman_wunsch_free LOC=UNKNOWN */
void needleman_wunsch_free(nw_aligner_t *nw ) ;
/* END FUNCTION-DECL needleman_wunsch_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bzero LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bzero LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memset LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* END FUNCTION-DECL __builtin_memset LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nans LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nans LOC=BUILTIN */

/* BEGIN VARIABLE-DEF align_col_stop LOC=UNKNOWN */
char align_col_stop[5]  ;
/* END VARIABLE-DEF align_col_stop LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL cmdline_free LOC=UNKNOWN */
void cmdline_free(cmdline_t *cmd___0 ) ;
/* END FUNCTION-DECL cmdline_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_clzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_clzl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ceill LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* END FUNCTION-DECL __builtin_ceill LOC=BUILTIN */

/* BEGIN FUNCTION-DECL needleman_wunsch_align LOC=UNKNOWN */
void needleman_wunsch_align(char const   *a , char const   *b , scoring_t const   *scoring___0 ,
                            nw_aligner_t *nw , alignment_t *result___0 ) ;
/* END FUNCTION-DECL needleman_wunsch_align LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL alignment_reverse_move LOC=UNKNOWN */
void alignment_reverse_move(enum Matrix *curr_matrix , score_t *curr_score , size_t___0 *score_x ,
                            size_t___0 *score_y , size_t___0 *arr_index , aligner_t const   *aligner ) ;
/* END FUNCTION-DECL alignment_reverse_move LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* END FUNCTION-DECL __builtin_atan LOC=BUILTIN */

/* BEGIN TYPEDEF MatrixSort LOC=src/smith_waterman.c:64 */
typedef struct __anonstruct_MatrixSort_459211137 MatrixSort;
/* END TYPEDEF MatrixSort LOC=src/smith_waterman.c:64 */

/* BEGIN FUNCTION-DECL seq_read_alloc LOC=UNKNOWN */
__inline static read_t *seq_read_alloc(read_t *r ) ;
/* END FUNCTION-DECL seq_read_alloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_return LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* END FUNCTION-DECL __builtin_return LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_powif LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powif LOC=BUILTIN */

/* BEGIN VARIABLE-DEF file_list_length LOC=UNKNOWN */
int file_list_length  ;
/* END VARIABLE-DEF file_list_length LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF blosum80 LOC=UNKNOWN */
static int blosum80[576]  ;
/* END VARIABLE-DEF blosum80 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL freadline LOC=UNKNOWN */
__inline static size_t___0 freadline(FILE *file , char **buf , size_t___0 *len , size_t___0 *size ) ;
/* END FUNCTION-DECL freadline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL _scoring_check_wildcards LOC=UNKNOWN */
static char _scoring_check_wildcards(scoring_t const   *scoring___0 , char a , char b ,
                                     int *score ) ;
/* END FUNCTION-DECL _scoring_check_wildcards LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL align_pair_from_file LOC=UNKNOWN */
void align_pair_from_file(read_t *read1 , read_t *read2 ) ;
/* END FUNCTION-DECL align_pair_from_file LOC=UNKNOWN */

/* BEGIN TYPEDEF __isoc_va_list LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:18 */
typedef __builtin_va_list __isoc_va_list;
/* END TYPEDEF __isoc_va_list LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:18 */

/* BEGIN FUNCTION-DECL _ensure_history_capacity LOC=UNKNOWN */
static void _ensure_history_capacity(sw_history_t *hist , size_t___0 arr_size ) ;
/* END FUNCTION-DECL _ensure_history_capacity LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL _seq_read_unknown_f_buf LOC=UNKNOWN */
__inline static int _seq_read_unknown_f_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_unknown_f_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL smith_waterman_new LOC=UNKNOWN */
sw_aligner_t *smith_waterman_new(void) ;
/* END FUNCTION-DECL smith_waterman_new LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN calloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:41 */
extern void *calloc(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN calloc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:41 */

/* BEGIN FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */
extern int printf(char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */

/* BEGIN FUNCTION-DECL get_next_hit LOC=UNKNOWN */
static char get_next_hit(void) ;
/* END FUNCTION-DECL get_next_hit LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF align_col_mismatch LOC=UNKNOWN */
char align_col_mismatch[6]  ;
/* END VARIABLE-DEF align_col_mismatch LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_envp LOC=UNKNOWN */
char **_global_envp  ;
/* END VARIABLE-DEF _global_envp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL scoring_print LOC=UNKNOWN */
void scoring_print(scoring_t const   *scoring___0 ) ;
/* END FUNCTION-DECL scoring_print LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* END FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN vfprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:125 */
extern int vfprintf(FILE * __restrict   , char const   * __restrict   , __isoc_va_list  ) ;
/* END FUNCTION-DECL-EXTERN vfprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:125 */

/* BEGIN FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL gzgetc_buf LOC=UNKNOWN */
__inline static int gzgetc_buf(gzFile file , StreamBuffer *in ) ;
/* END FUNCTION-DECL gzgetc_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL gzskipline_buf LOC=UNKNOWN */
__inline static size_t___0 gzskipline_buf(gzFile file , StreamBuffer *in ) ;
/* END FUNCTION-DECL gzskipline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_clzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_clzll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN string_next_nonwhitespace LOC=libs/string_buffer/string_buffer.h:281 */
extern char *string_next_nonwhitespace(char *s ) ;
/* END FUNCTION-DECL-EXTERN string_next_nonwhitespace LOC=libs/string_buffer/string_buffer.h:281 */

/* BEGIN FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */
/* compiler builtin: 
   long long __builtin_bswap64(long long  ) ;  */
/* END FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */

/* BEGIN TYPEDEF va_list___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stdarg.h:22 */
typedef __builtin_va_list va_list___0;
/* END TYPEDEF va_list___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stdarg.h:22 */

/* BEGIN FUNCTION-DECL _seq_read_plain_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_plain_gz_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_plain_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_logl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_logl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_end LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_end LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* END FUNCTION-DECL __builtin_log LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtoul LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:33 */
extern unsigned long strtoul(char const   * __restrict   , char ** __restrict   ,
                             int  ) ;
/* END FUNCTION-DECL-EXTERN strtoul LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:33 */

/* BEGIN FUNCTION-DECL __builtin_cos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* END FUNCTION-DECL __builtin_cos LOC=BUILTIN */

/* BEGIN VARIABLE-DEF cmd LOC=UNKNOWN */
cmdline_t *cmd  ;
/* END VARIABLE-DEF cmd LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL sort_r LOC=UNKNOWN */
__inline static void sort_r(void *base , size_t___0 nel , size_t___0 width , int (*compar)(void const   *_a ,
                                                                                           void const   *_b ,
                                                                                           void *_arg ) ,
                            void *arg ) ;
/* END FUNCTION-DECL sort_r LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN free LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:43 */
extern void free(void * ) ;
/* END FUNCTION-DECL-EXTERN free LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h:43 */

/* BEGIN VARIABLE-DEF pam30 LOC=UNKNOWN */
static int pam30[576]  ;
/* END VARIABLE-DEF pam30 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) ;
/* END FUNCTION-DECL main LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_exp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* END FUNCTION-DECL __builtin_exp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */

/* BEGIN FUNCTION-DECL gzreadline_buf LOC=UNKNOWN */
__inline static size_t___0 gzreadline_buf(gzFile file , StreamBuffer *in , char **buf ,
                                          size_t___0 *len , size_t___0 *size ) ;
/* END FUNCTION-DECL gzreadline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL seq_guess_filetype_from_extension LOC=UNKNOWN */
__inline static seq_format seq_guess_filetype_from_extension(char const   *path ) ;
/* END FUNCTION-DECL seq_guess_filetype_from_extension LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL aligner_align LOC=UNKNOWN */
void aligner_align(aligner_t *aligner , char const   *seq_a , char const   *seq_b ,
                   size_t___0 len_a , size_t___0 len_b , scoring_t const   *scoring___0 ,
                   char is_sw ) ;
/* END FUNCTION-DECL aligner_align LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */
extern FILE *stdin ;
/* END VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */

/* BEGIN FUNCTION-DECL _seq_read_unknown_f LOC=UNKNOWN */
__inline static int _seq_read_unknown_f(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_unknown_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strbuf_reset_gzreadline LOC=libs/string_buffer/string_buffer.h:233 */
extern size_t___0 strbuf_reset_gzreadline(StrBuf *sb , gzFile gz_file ) ;
/* END FUNCTION-DECL-EXTERN strbuf_reset_gzreadline LOC=libs/string_buffer/string_buffer.h:233 */

/* BEGIN FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF file_paths2 LOC=UNKNOWN */
char **file_paths2  ;
/* END VARIABLE-DEF file_paths2 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF blosum62 LOC=UNKNOWN */
int blosum62[576]  ;
/* END VARIABLE-DEF blosum62 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL _seq_read_fasta_f_buf LOC=UNKNOWN */
__inline static int _seq_read_fasta_f_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fasta_f_buf LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF file_list_capacity LOC=UNKNOWN */
int file_list_capacity  ;
/* END VARIABLE-DEF file_list_capacity LOC=UNKNOWN */

/* BEGIN STRUCT read_struct LOC=libs/seq_file/seq_file.h:66 */
struct read_struct {
   seq_buf_t name ;
   seq_buf_t seq ;
   seq_buf_t qual ;
   void *bam ;
   read_t *next ;
   _Bool from_sam ;
};
/* END STRUCT read_struct LOC=libs/seq_file/seq_file.h:66 */

/* BEGIN FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* END FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_cosf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL align_scoring_load_matrix LOC=UNKNOWN */
void align_scoring_load_matrix(gzFile file , char const   *file_path , scoring_t *scoring___0 ,
                               char case_sensitive ) ;
/* END FUNCTION-DECL align_scoring_load_matrix LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* END FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF sub_matrix LOC=UNKNOWN */
static int sub_matrix[64]  ;
/* END VARIABLE-DEF sub_matrix LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL _seq_read_unknown_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_unknown_gz_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_unknown_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */

/* BEGIN FUNCTION-DECL alignment_create LOC=UNKNOWN */
alignment_t *alignment_create(size_t___0 capacity ) ;
/* END FUNCTION-DECL alignment_create LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL cmdline_get_file1 LOC=UNKNOWN */
char *cmdline_get_file1(cmdline_t *cmd___0 , size_t___0 i ) ;
/* END FUNCTION-DECL cmdline_get_file1 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_apply LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_apply LOC=BUILTIN */

/* BEGIN FUNCTION-DECL seq_read_free LOC=UNKNOWN */
__inline static void seq_read_free(read_t *r ) ;
/* END FUNCTION-DECL seq_read_free LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF scoring LOC=UNKNOWN */
scoring_t scoring  ;
/* END VARIABLE-DEF scoring LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL alignment_fill_matrices LOC=UNKNOWN */
static void alignment_fill_matrices(aligner_t *aligner , char is_sw ) ;
/* END FUNCTION-DECL alignment_fill_matrices LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_powi LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powi LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_StrBuf_483684869 LOC=libs/string_buffer/string_buffer.h:20 */
struct __anonstruct_StrBuf_483684869 {
   char *b ;
   size_t___0 end ;
   size_t___0 size ;
};
/* END STRUCT __anonstruct_StrBuf_483684869 LOC=libs/string_buffer/string_buffer.h:20 */

/* BEGIN FUNCTION-DECL __builtin_expect LOC=BUILTIN */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* END FUNCTION-DECL __builtin_expect LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_logf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* END FUNCTION-DECL __builtin_logf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_plain_f_buf LOC=UNKNOWN */
__inline static int _seq_read_plain_f_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_plain_f_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL scoring_system_PAM30 LOC=UNKNOWN */
void scoring_system_PAM30(scoring_t *scoring___0 ) ;
/* END FUNCTION-DECL scoring_system_PAM30 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_alloca LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_alloca LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _loading_error LOC=UNKNOWN */
static  __attribute__((__noreturn__)) void _loading_error(char const   *err_msg ,
                                                          char const   *file_path ,
                                                          int line_num , char is_matrix ) ;
/* END FUNCTION-DECL _loading_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL _seq_read_fastq_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_fastq_gz_buf(seq_file_t *sf , read_t *r ) ;
/* END FUNCTION-DECL _seq_read_fastq_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */
extern void *memset(void * , int  , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */

/* BEGIN FUNCTION-DECL __builtin_nan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_inf LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* END FUNCTION-DECL __builtin_inf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */

/* BEGIN FUNCTION-DECL seq_open LOC=UNKNOWN */
__inline static seq_file_t *seq_open(char const   *p ) ;
/* END FUNCTION-DECL seq_open LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_log10 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* END FUNCTION-DECL __builtin_log10 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL scoring_system_DNA_hybridization LOC=UNKNOWN */
void scoring_system_DNA_hybridization(scoring_t *scoring___0 ) ;
/* END FUNCTION-DECL scoring_system_DNA_hybridization LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL cbuf_capacity LOC=UNKNOWN */
__inline static void cbuf_capacity(char **buf , size_t___0 *sizeptr , size_t___0 len ) ;
/* END FUNCTION-DECL cbuf_capacity LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_modff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* END FUNCTION-DECL __builtin_modff LOC=BUILTIN */

/* BEGIN FUNCTION-DECL smith_waterman_fetch LOC=UNKNOWN */
int smith_waterman_fetch(sw_aligner_t *sw___0 , alignment_t *result___0 ) ;
/* END FUNCTION-DECL smith_waterman_fetch LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_read_reset LOC=UNKNOWN */
__inline static void seq_read_reset(read_t *r ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  unsigned int _1_seq_read_reset_next ;

  {
  {
  _1_seq_read_reset_next = 0U;
  }
  while (1) {
    switch (_1_seq_read_reset_next) {
    case 1: ;
    return;
    break;
    case 0: 
    tmp___0 = (size_t___0 )0;
    r->qual.end = tmp___0;
    tmp = tmp___0;
    r->seq.end = tmp;
    r->name.end = tmp;
    tmp___2 = (char )'\000';
    *(r->qual.b + 0) = tmp___2;
    tmp___1 = tmp___2;
    *(r->seq.b + 0) = tmp___1;
    *(r->name.b + 0) = tmp___1;
    r->from_sam = (_Bool)0;
    {
    _1_seq_read_reset_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_read_reset LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_plain_f_buf LOC=UNKNOWN */
__inline static int _seq_read_plain_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  unsigned int _1__seq_read_plain_f_buf_next ;

  {
  {
  _1__seq_read_plain_f_buf_next = 12U;
  }
  while (1) {
    switch (_1__seq_read_plain_f_buf_next) {
    case 12: 
    seq_read_reset(r);
    {
    _1__seq_read_plain_f_buf_next = 7U;
    }
    break;
    case 8: ;
    return (0);
    break;
    case 1: ;
    return (1);
    break;
    case 3: 
    fskipline_buf(sf->f_file, & sf->in);
    {
    _1__seq_read_plain_f_buf_next = 7U;
    }
    break;
    case 11: ;
    if (c == -1) {
      {
      _1__seq_read_plain_f_buf_next = 8U;
      }
    } else {
      {
      _1__seq_read_plain_f_buf_next = 13U;
      }
    }
    break;
    case 9: ;
    if (c != -1) {
      {
      _1__seq_read_plain_f_buf_next = 5U;
      }
    } else {
      {
      _1__seq_read_plain_f_buf_next = 11U;
      }
    }
    break;
    case 13: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    freadline_buf(sf->f_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_plain_f_buf_next = 1U;
    }
    break;
    case 6: ;
    if (! tmp) {
      {
      _1__seq_read_plain_f_buf_next = 11U;
      }
    } else {
      {
      _1__seq_read_plain_f_buf_next = 10U;
      }
    }
    break;
    case 5: 
    tmp = isspace(c);
    {
    _1__seq_read_plain_f_buf_next = 6U;
    }
    break;
    case 10: ;
    if (c != 10) {
      {
      _1__seq_read_plain_f_buf_next = 3U;
      }
    } else {
      {
      _1__seq_read_plain_f_buf_next = 7U;
      }
    }
    break;
    case 7: 
    c = fgetc_buf(sf->f_file, & sf->in);
    {
    _1__seq_read_plain_f_buf_next = 9U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_plain_f_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF needleman_wunsch_free LOC=UNKNOWN */
void needleman_wunsch_free(nw_aligner_t *nw ) 
{ 
  unsigned int _1_needleman_wunsch_free_next ;

  {
  {
  _1_needleman_wunsch_free_next = 1U;
  }
  while (1) {
    switch (_1_needleman_wunsch_free_next) {
    case 1: 
    aligner_destroy(nw);
    free((void *)nw);
    {
    _1_needleman_wunsch_free_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF needleman_wunsch_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_unknown_f_buf LOC=UNKNOWN */
__inline static int _seq_read_unknown_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1__seq_read_unknown_f_buf_next ;

  {
  {
  _1__seq_read_unknown_f_buf_next = 14U;
  }
  while (1) {
    switch (_1__seq_read_unknown_f_buf_next) {
    case 18: ;
    return (0);
    break;
    case 4: 
    ungetc_buf(c, & sf->in);
    tmp___0 = (*(sf->origreadfunc))(sf, r);
    {
    _1__seq_read_unknown_f_buf_next = 17U;
    }
    break;
    case 14: 
    seq_read_reset(r);
    {
    _1__seq_read_unknown_f_buf_next = 8U;
    }
    break;
    case 12: ;
    if (c == 64) {
      {
      _1__seq_read_unknown_f_buf_next = 1U;
      }
    } else {
      {
      _1__seq_read_unknown_f_buf_next = 9U;
      }
    }
    break;
    case 8: 
    c = fgetc_buf(sf->f_file, & sf->in);
    {
    _1__seq_read_unknown_f_buf_next = 13U;
    }
    break;
    case 1: 
    sf->format = (seq_format )4;
    sf->origreadfunc = & _seq_read_fastq_f_buf;
    {
    _1__seq_read_unknown_f_buf_next = 4U;
    }
    break;
    case 11: ;
    if (! tmp) {
      {
      _1__seq_read_unknown_f_buf_next = 6U;
      }
    } else {
      {
      _1__seq_read_unknown_f_buf_next = 7U;
      }
    }
    break;
    case 9: ;
    if (c == 62) {
      {
      _1__seq_read_unknown_f_buf_next = 2U;
      }
    } else {
      {
      _1__seq_read_unknown_f_buf_next = 0U;
      }
    }
    break;
    case 13: ;
    if (c != -1) {
      {
      _1__seq_read_unknown_f_buf_next = 5U;
      }
    } else {
      {
      _1__seq_read_unknown_f_buf_next = 6U;
      }
    }
    break;
    case 17: ;
    return (tmp___0);
    break;
    case 6: ;
    if (c == -1) {
      {
      _1__seq_read_unknown_f_buf_next = 18U;
      }
    } else {
      {
      _1__seq_read_unknown_f_buf_next = 12U;
      }
    }
    break;
    case 5: 
    tmp = isspace(c);
    {
    _1__seq_read_unknown_f_buf_next = 11U;
    }
    break;
    case 10: 
    fskipline(sf->f_file);
    {
    _1__seq_read_unknown_f_buf_next = 8U;
    }
    break;
    case 0: 
    sf->format = (seq_format )1;
    sf->origreadfunc = & _seq_read_plain_f_buf;
    {
    _1__seq_read_unknown_f_buf_next = 4U;
    }
    break;
    case 7: ;
    if (c != 10) {
      {
      _1__seq_read_unknown_f_buf_next = 10U;
      }
    } else {
      {
      _1__seq_read_unknown_f_buf_next = 8U;
      }
    }
    break;
    case 2: 
    sf->format = (seq_format )2;
    sf->origreadfunc = & _seq_read_fasta_f_buf;
    {
    _1__seq_read_unknown_f_buf_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_unknown_f_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_init LOC=UNKNOWN */
void scoring_init(scoring_t *scoring___0 , int match , int mismatch , int gap_open ,
                  int gap_extend , _Bool no_start_gap_penalty , _Bool no_end_gap_penalty ,
                  _Bool no_gaps_in_a , _Bool no_gaps_in_b , _Bool no_mismatches ,
                  _Bool case_sensitive ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int _1_scoring_init_next ;

  {
  {
  _1_scoring_init_next = 13U;
  }
  while (1) {
    switch (_1_scoring_init_next) {
    case 18: ;
    if (match >= mismatch) {
      {
      _1_scoring_init_next = 6U;
      }
    } else {
      {
      _1_scoring_init_next = 14U;
      }
    }
    break;
    case 4: 
    tmp = gap_open + gap_extend;
    {
    _1_scoring_init_next = 20U;
    }
    break;
    case 14: 
    scoring___0->max_penalty = mismatch;
    {
    _1_scoring_init_next = 3U;
    }
    break;
    case 15: ;
    if (scoring___0->max_penalty >= gap_open + gap_extend) {
      {
      _1_scoring_init_next = 2U;
      }
    } else {
      {
      _1_scoring_init_next = 24U;
      }
    }
    break;
    case 12: 
    _L: ;
    if (gap_open + gap_extend <= gap_extend) {
      {
      _1_scoring_init_next = 4U;
      }
    } else {
      {
      _1_scoring_init_next = 7U;
      }
    }
    break;
    case 1: 
    scoring___0->min_penalty = mismatch;
    {
    _1_scoring_init_next = 18U;
    }
    break;
    case 23: 
    scoring___0->min_penalty = scoring___0->min_penalty;
    {
    _1_scoring_init_next = 15U;
    }
    break;
    case 3: ;
    if (! no_gaps_in_a) {
      {
      _1_scoring_init_next = 26U;
      }
    } else {
      {
      _1_scoring_init_next = 10U;
      }
    }
    break;
    case 16: 
    scoring___0->min_penalty = match;
    {
    _1_scoring_init_next = 18U;
    }
    break;
    case 24: 
    _L___0: ;
    if (gap_open + gap_extend >= gap_extend) {
      {
      _1_scoring_init_next = 0U;
      }
    } else {
      {
      _1_scoring_init_next = 5U;
      }
    }
    break;
    case 21: ;
    return;
    break;
    case 26: 
    _L___1: ;
    if (scoring___0->min_penalty <= gap_open + gap_extend) {
      {
      _1_scoring_init_next = 9U;
      }
    } else {
      {
      _1_scoring_init_next = 12U;
      }
    }
    break;
    case 11: 
    scoring___0->max_penalty = scoring___0->max_penalty;
    {
    _1_scoring_init_next = 21U;
    }
    break;
    case 9: ;
    if (scoring___0->min_penalty <= gap_extend) {
      {
      _1_scoring_init_next = 23U;
      }
    } else {
      {
      _1_scoring_init_next = 12U;
      }
    }
    break;
    case 13: 
    scoring___0->gap_open = gap_open;
    scoring___0->gap_extend = gap_extend;
    scoring___0->no_start_gap_penalty = no_start_gap_penalty;
    scoring___0->no_end_gap_penalty = no_end_gap_penalty;
    scoring___0->no_gaps_in_a = no_gaps_in_a;
    scoring___0->no_gaps_in_b = no_gaps_in_b;
    scoring___0->no_mismatches = no_mismatches;
    scoring___0->use_match_mismatch = (_Bool)1;
    scoring___0->match = match;
    scoring___0->mismatch = mismatch;
    scoring___0->case_sensitive = case_sensitive;
    memset((void *)(scoring___0->wildcards), 0, sizeof(scoring___0->wildcards));
    memset((void *)(scoring___0->swap_set), 0, sizeof(scoring___0->swap_set));
    {
    _1_scoring_init_next = 22U;
    }
    break;
    case 19: 
    scoring___0->max_penalty = tmp___0;
    {
    _1_scoring_init_next = 21U;
    }
    break;
    case 6: 
    scoring___0->max_penalty = match;
    {
    _1_scoring_init_next = 3U;
    }
    break;
    case 22: ;
    if (match <= mismatch) {
      {
      _1_scoring_init_next = 16U;
      }
    } else {
      {
      _1_scoring_init_next = 1U;
      }
    }
    break;
    case 5: 
    tmp___0 = gap_extend;
    {
    _1_scoring_init_next = 19U;
    }
    break;
    case 10: ;
    if (! no_gaps_in_b) {
      {
      _1_scoring_init_next = 26U;
      }
    } else {
      {
      _1_scoring_init_next = 21U;
      }
    }
    break;
    case 0: 
    tmp___0 = gap_open + gap_extend;
    {
    _1_scoring_init_next = 19U;
    }
    break;
    case 7: 
    tmp = gap_extend;
    {
    _1_scoring_init_next = 20U;
    }
    break;
    case 2: ;
    if (scoring___0->max_penalty >= gap_extend) {
      {
      _1_scoring_init_next = 11U;
      }
    } else {
      {
      _1_scoring_init_next = 24U;
      }
    }
    break;
    case 20: 
    scoring___0->min_penalty = tmp;
    {
    _1_scoring_init_next = 15U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_init LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF sort_match_indices LOC=UNKNOWN */
int sort_match_indices(void const   *aa , void const   *bb , void *arg ) 
{ 
  size_t___0 const   *a ;
  size_t___0 const   *b ;
  MatrixSort const   *tmp ;
  score_t const   *match_scores ;
  size_t___0 score_width ;
  long diff ;
  int tmp___0 ;
  unsigned int _1_sort_match_indices_next ;

  {
  {
  _1_sort_match_indices_next = 0U;
  }
  while (1) {
    switch (_1_sort_match_indices_next) {
    case 4: ;
    return ((int )(*a % (unsigned long const   )score_width - *b % (unsigned long const   )score_width));
    break;
    case 1: ;
    if (diff == 0L) {
      {
      _1_sort_match_indices_next = 4U;
      }
    } else {
      {
      _1_sort_match_indices_next = 7U;
      }
    }
    break;
    case 3: 
    tmp___0 = 1;
    {
    _1_sort_match_indices_next = 2U;
    }
    break;
    case 6: 
    tmp___0 = -1;
    {
    _1_sort_match_indices_next = 2U;
    }
    break;
    case 0: 
    a = (size_t___0 const   *)aa;
    b = (size_t___0 const   *)bb;
    tmp = (MatrixSort const   *)arg;
    match_scores = (score_t const   *)tmp->match_scores;
    score_width = (size_t___0 )tmp->score_width;
    diff = (long )*(match_scores + *b) - (long )*(match_scores + *a);
    {
    _1_sort_match_indices_next = 1U;
    }
    break;
    case 7: ;
    if (diff > 0L) {
      {
      _1_sort_match_indices_next = 3U;
      }
    } else {
      {
      _1_sort_match_indices_next = 6U;
      }
    }
    break;
    case 2: ;
    return (tmp___0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF sort_match_indices LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fastq_gz LOC=UNKNOWN */
__inline static int _seq_read_fastq_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  size_t___0 tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  size_t___0 tmp___8 ;
  unsigned char *tmp___9 ;
  int tmp___10 ;
  unsigned int _1__seq_read_fastq_gz_next ;

  {
  {
  _1__seq_read_fastq_gz_next = 41U;
  }
  while (1) {
    switch (_1__seq_read_fastq_gz_next) {
    case 18: 
    tmp___7 = gzgetc(sf->gz_file);
    c = tmp___7;
    {
    _1__seq_read_fastq_gz_next = 45U;
    }
    break;
    case 49: 
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fastq_gz_next = 19U;
    }
    break;
    case 52: 
    c = tmp___1;
    {
    _1__seq_read_fastq_gz_next = 14U;
    }
    break;
    case 4: ;
    if (c != 13) {
      {
      _1__seq_read_fastq_gz_next = 32U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 19U;
      }
    }
    break;
    case 14: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_gz_next = 20U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 23U;
      }
    }
    break;
    case 15: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fastq_gz_next = 19U;
    }
    break;
    case 12: ;
    return (-1);
    break;
    case 45: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_gz_next = 22U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 0U;
      }
    }
    break;
    case 1: 
    tmp___8 = gzreadline(sf->gz_file, & r->qual.b, & r->qual.end, & r->qual.size);
    {
    _1__seq_read_fastq_gz_next = 24U;
    }
    break;
    case 23: ;
    if (c != 64) {
      {
      _1__seq_read_fastq_gz_next = 44U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 42U;
      }
    }
    break;
    case 3: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    tmp___1 = (int )*tmp;
    {
    _1__seq_read_fastq_gz_next = 52U;
    }
    break;
    case 16: 
    cbuf_chomp(r->qual.b, & r->qual.end);
    {
    _1__seq_read_fastq_gz_next = 10U;
    }
    break;
    case 24: ;
    if (tmp___8 > 0UL) {
      {
      _1__seq_read_fastq_gz_next = 16U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 39U;
      }
    }
    break;
    case 21: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_gz_next = 12U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 4U;
      }
    }
    break;
    case 26: ;
    if (tmp___2 == 0UL) {
      {
      _1__seq_read_fastq_gz_next = 9U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 15U;
      }
    }
    break;
    case 11: ;
    if (! (c != 43)) {
      {
      _1__seq_read_fastq_gz_next = 53U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 21U;
      }
    }
    break;
    case 9: ;
    return (-1);
    break;
    case 13: ;
    if (! (c != 64)) {
      {
      _1__seq_read_fastq_gz_next = 6U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 33U;
      }
    }
    break;
    case 51: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_gz_next = 13U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 6U;
      }
    }
    break;
    case 19: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_fastq_gz_next = 35U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 5U;
      }
    }
    break;
    case 32: ;
    if (c != 10) {
      {
      _1__seq_read_fastq_gz_next = 47U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 19U;
      }
    }
    break;
    case 6: 
    gzungetc(c, sf->gz_file);
    {
    _1__seq_read_fastq_gz_next = 37U;
    }
    break;
    case 34: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp___9 = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    c = (int )*tmp___9;
    {
    _1__seq_read_fastq_gz_next = 51U;
    }
    break;
    case 48: ;
    if (tmp___3 == 0UL) {
      {
      _1__seq_read_fastq_gz_next = 46U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 49U;
      }
    }
    break;
    case 22: ;
    if (! (c != 10)) {
      {
      _1__seq_read_fastq_gz_next = 0U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 53U;
      }
    }
    break;
    case 28: ;
    return (-1);
    break;
    case 53: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_fastq_gz_next = 43U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 18U;
      }
    }
    break;
    case 47: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___3 = gzreadline(sf->gz_file, & r->seq.b, & r->seq.end, & r->seq.size);
    {
    _1__seq_read_fastq_gz_next = 48U;
    }
    break;
    case 44: ;
    return (-1);
    break;
    case 5: 
    tmp___5 = gzgetc(sf->gz_file);
    c = tmp___5;
    {
    _1__seq_read_fastq_gz_next = 11U;
    }
    break;
    case 33: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_fastq_gz_next = 34U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 2U;
      }
    }
    break;
    case 37: ;
    return (1);
    break;
    case 41: 
    seq_read_reset(r);
    {
    _1__seq_read_fastq_gz_next = 7U;
    }
    break;
    case 10: ;
    if (! (r->qual.end < r->seq.end)) {
      {
      _1__seq_read_fastq_gz_next = 33U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 1U;
      }
    }
    break;
    case 42: 
    tmp___2 = gzreadline(sf->gz_file, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fastq_gz_next = 26U;
    }
    break;
    case 0: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_gz_next = 28U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 1U;
      }
    }
    break;
    case 46: ;
    return (-1);
    break;
    case 39: ;
    return (1);
    break;
    case 7: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_fastq_gz_next = 3U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_next = 29U;
      }
    }
    break;
    case 35: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp___4 = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    c = (int )*tmp___4;
    {
    _1__seq_read_fastq_gz_next = 11U;
    }
    break;
    case 29: 
    tmp___0 = gzgetc(sf->gz_file);
    tmp___1 = tmp___0;
    {
    _1__seq_read_fastq_gz_next = 52U;
    }
    break;
    case 43: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp___6 = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    c = (int )*tmp___6;
    {
    _1__seq_read_fastq_gz_next = 45U;
    }
    break;
    case 2: 
    tmp___10 = gzgetc(sf->gz_file);
    c = tmp___10;
    {
    _1__seq_read_fastq_gz_next = 51U;
    }
    break;
    case 20: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fastq_gz LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gzreadline_buf LOC=UNKNOWN */
__inline static size_t___0 gzreadline_buf(gzFile file , StreamBuffer *in , char **buf ,
                                          size_t___0 *len , size_t___0 *size ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 buffered ;
  size_t___0 total_read ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  unsigned int _1_gzreadline_buf_next ;

  {
  {
  _1_gzreadline_buf_next = 14U;
  }
  while (1) {
    switch (_1_gzreadline_buf_next) {
    case 18: 
    tmp___0 = offset;
    offset ++;
    {
    _1_gzreadline_buf_next = 3U;
    }
    break;
    case 4: 
    buffered = offset - in->begin;
    cbuf_capacity(buf, size, *len + buffered);
    memcpy((void */* __restrict  */)(*buf + *len), (void const   */* __restrict  */)(in->b + in->begin),
           buffered);
    *len += buffered;
    in->begin = offset;
    total_read += buffered;
    {
    _1_gzreadline_buf_next = 7U;
    }
    break;
    case 14: ;
    if (in->begin >= in->end) {
      {
      _1_gzreadline_buf_next = 12U;
      }
    } else {
      {
      _1_gzreadline_buf_next = 8U;
      }
    }
    break;
    case 12: 
    tmp = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
    in->end = 1UL + tmp;
    in->begin = (size_t___0 )1;
    {
    _1_gzreadline_buf_next = 8U;
    }
    break;
    case 8: 
    total_read = (size_t___0 )0;
    {
    _1_gzreadline_buf_next = 6U;
    }
    break;
    case 3: ;
    if (! ((int )*(in->b + tmp___0) != 10)) {
      {
      _1_gzreadline_buf_next = 4U;
      }
    } else {
      {
      _1_gzreadline_buf_next = 19U;
      }
    }
    break;
    case 11: ;
    return (total_read);
    break;
    case 9: 
    offset = in->begin;
    {
    _1_gzreadline_buf_next = 19U;
    }
    break;
    case 13: 
    tmp___1 = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
    in->end = 1UL + tmp___1;
    in->begin = (size_t___0 )1;
    {
    _1_gzreadline_buf_next = 6U;
    }
    break;
    case 19: ;
    if (offset < in->end) {
      {
      _1_gzreadline_buf_next = 18U;
      }
    } else {
      {
      _1_gzreadline_buf_next = 4U;
      }
    }
    break;
    case 17: 
    *(*buf + *len) = (char)0;
    {
    _1_gzreadline_buf_next = 11U;
    }
    break;
    case 6: ;
    if (in->end > in->begin) {
      {
      _1_gzreadline_buf_next = 9U;
      }
    } else {
      {
      _1_gzreadline_buf_next = 17U;
      }
    }
    break;
    case 7: ;
    if ((int )*(*buf + (*len - 1UL)) == 10) {
      {
      _1_gzreadline_buf_next = 17U;
      }
    } else {
      {
      _1_gzreadline_buf_next = 13U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gzreadline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF bitset_set_length LOC=UNKNOWN */
__inline static BitSet *bitset_set_length(BitSet *bs , size_t___0 l ) 
{ 
  size_t___0 ss ;
  void *tmp ;
  BitSet *tmp___0 ;
  unsigned int _1_bitset_set_length_next ;

  {
  {
  _1_bitset_set_length_next = 4U;
  }
  while (1) {
    switch (_1_bitset_set_length_next) {
    case 4: 
    ss = (l + 31UL) / 32UL;
    {
    _1_bitset_set_length_next = 0U;
    }
    break;
    case 1: 
    bs->l = l;
    {
    _1_bitset_set_length_next = 3U;
    }
    break;
    case 3: ;
    if (bs->b) {
      {
      _1_bitset_set_length_next = 7U;
      }
    } else {
      {
      _1_bitset_set_length_next = 5U;
      }
    }
    break;
    case 6: 
    tmp = realloc((void *)bs->b, ss * sizeof(*(bs->b + 0)));
    bs->b = (uint32_t *)tmp;
    memset((void *)(bs->b + bs->s), 0, (ss - bs->s) * sizeof(*(bs->b + 0)));
    bs->s = ss;
    {
    _1_bitset_set_length_next = 1U;
    }
    break;
    case 5: 
    tmp___0 = (BitSet *)((void *)0);
    {
    _1_bitset_set_length_next = 2U;
    }
    break;
    case 0: ;
    if (ss > bs->s) {
      {
      _1_bitset_set_length_next = 6U;
      }
    } else {
      {
      _1_bitset_set_length_next = 1U;
      }
    }
    break;
    case 7: 
    tmp___0 = bs;
    {
    _1_bitset_set_length_next = 2U;
    }
    break;
    case 2: ;
    return (tmp___0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF bitset_set_length LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF sw_set_default_scoring LOC=UNKNOWN */
static void sw_set_default_scoring(void) 
{ 
  unsigned int _1_sw_set_default_scoring_next ;

  {
  {
  _1_sw_set_default_scoring_next = 1U;
  }
  while (1) {
    switch (_1_sw_set_default_scoring_next) {
    case 1: 
    scoring_system_default(& scoring);
    scoring.match = 2;
    scoring.mismatch = -2;
    scoring.gap_open = -2;
    scoring.gap_extend = -1;
    {
    _1_sw_set_default_scoring_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF sw_set_default_scoring LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_guess_filetype_from_extension LOC=UNKNOWN */
__inline static seq_format seq_guess_filetype_from_extension(char const   *path ) 
{ 
  size_t___0 plen ;
  size_t___0 tmp ;
  char const   *exts[29] ;
  seq_format types[29] ;
  size_t___0 extlens[29] ;
  size_t___0 i ;
  int tmp___0 ;
  unsigned int _1_seq_guess_filetype_from_extension_next ;

  {
  {
  _1_seq_guess_filetype_from_extension_next = 4U;
  }
  while (1) {
    switch (_1_seq_guess_filetype_from_extension_next) {
    case 4: 
    tmp = strlen(path);
    plen = tmp;
    exts[0] = ".fa";
    exts[1] = ".fasta";
    exts[2] = ".fsa";
    exts[3] = ".fsa.gz";
    exts[4] = "fsa.gzip";
    exts[5] = ".faz";
    exts[6] = ".fagz";
    exts[7] = ".fa.gz";
    exts[8] = ".fa.gzip";
    exts[9] = ".fastaz";
    exts[10] = ".fasta.gzip";
    exts[11] = ".fq";
    exts[12] = ".fastq";
    exts[13] = ".fsq";
    exts[14] = ".fsq.gz";
    exts[15] = "fsq.gzip";
    exts[16] = ".fqz";
    exts[17] = ".fqgz";
    exts[18] = ".fq.gz";
    exts[19] = ".fq.gzip";
    exts[20] = ".fastqz";
    exts[21] = ".fastq.gzip";
    exts[22] = ".txt";
    exts[23] = ".txtgz";
    exts[24] = ".txt.gz";
    exts[25] = ".txt.gzip";
    exts[26] = ".sam";
    exts[27] = ".bam";
    exts[28] = ".cram";
    types[0] = (seq_format )2;
    types[1] = (seq_format )2;
    types[2] = (seq_format )2;
    types[3] = (seq_format )2;
    types[4] = (seq_format )2;
    types[5] = (seq_format )2;
    types[6] = (seq_format )2;
    types[7] = (seq_format )2;
    types[8] = (seq_format )2;
    types[9] = (seq_format )2;
    types[10] = (seq_format )2;
    types[11] = (seq_format )4;
    types[12] = (seq_format )4;
    types[13] = (seq_format )4;
    types[14] = (seq_format )4;
    types[15] = (seq_format )4;
    types[16] = (seq_format )4;
    types[17] = (seq_format )4;
    types[18] = (seq_format )4;
    types[19] = (seq_format )4;
    types[20] = (seq_format )4;
    types[21] = (seq_format )4;
    types[22] = (seq_format )1;
    types[23] = (seq_format )1;
    types[24] = (seq_format )1;
    types[25] = (seq_format )1;
    types[26] = (seq_format )8;
    types[27] = (seq_format )16;
    types[28] = (seq_format )16;
    i = (size_t___0 )0;
    {
    _1_seq_guess_filetype_from_extension_next = 12U;
    }
    break;
    case 14: 
    extlens[i] = strlen(exts[i]);
    i ++;
    {
    _1_seq_guess_filetype_from_extension_next = 12U;
    }
    break;
    case 12: ;
    if (i < 29UL) {
      {
      _1_seq_guess_filetype_from_extension_next = 14U;
      }
    } else {
      {
      _1_seq_guess_filetype_from_extension_next = 6U;
      }
    }
    break;
    case 8: ;
    return (types[i]);
    break;
    case 1: 
    tmp___0 = strcasecmp((path + plen) - extlens[i], exts[i]);
    {
    _1_seq_guess_filetype_from_extension_next = 9U;
    }
    break;
    case 11: 
    i ++;
    {
    _1_seq_guess_filetype_from_extension_next = 2U;
    }
    break;
    case 9: ;
    if (tmp___0 == 0) {
      {
      _1_seq_guess_filetype_from_extension_next = 8U;
      }
    } else {
      {
      _1_seq_guess_filetype_from_extension_next = 11U;
      }
    }
    break;
    case 13: ;
    return ((seq_format )0);
    break;
    case 6: 
    i = (size_t___0 )0;
    {
    _1_seq_guess_filetype_from_extension_next = 2U;
    }
    break;
    case 10: ;
    if (extlens[i] <= plen) {
      {
      _1_seq_guess_filetype_from_extension_next = 1U;
      }
    } else {
      {
      _1_seq_guess_filetype_from_extension_next = 11U;
      }
    }
    break;
    case 2: ;
    if (i < 29UL) {
      {
      _1_seq_guess_filetype_from_extension_next = 10U;
      }
    } else {
      {
      _1_seq_guess_filetype_from_extension_next = 13U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_guess_filetype_from_extension LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_read_alloc LOC=UNKNOWN */
__inline static read_t *seq_read_alloc(read_t *r ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  size_t___0 tmp___3 ;
  unsigned int _1_seq_read_alloc_next ;

  {
  {
  _1_seq_read_alloc_next = 3U;
  }
  while (1) {
    switch (_1_seq_read_alloc_next) {
    case 4: 
    seq_read_dealloc(r);
    {
    _1_seq_read_alloc_next = 5U;
    }
    break;
    case 8: ;
    if (! r->qual.b) {
      {
      _1_seq_read_alloc_next = 1U;
      }
    } else {
      {
      _1_seq_read_alloc_next = 0U;
      }
    }
    break;
    case 1: 
    seq_read_dealloc(r);
    {
    _1_seq_read_alloc_next = 6U;
    }
    break;
    case 3: 
    memset((void *)r, 0, sizeof(read_t ));
    tmp = malloc((size_t )256);
    r->name.b = (char *)tmp;
    tmp___0 = malloc((size_t )256);
    r->seq.b = (char *)tmp___0;
    tmp___1 = malloc((size_t )256);
    r->qual.b = (char *)tmp___1;
    tmp___3 = (size_t___0 )256;
    r->qual.size = tmp___3;
    tmp___2 = tmp___3;
    r->seq.size = tmp___2;
    r->name.size = tmp___2;
    {
    _1_seq_read_alloc_next = 2U;
    }
    break;
    case 9: 
    seq_read_dealloc(r);
    {
    _1_seq_read_alloc_next = 7U;
    }
    break;
    case 6: ;
    return ((read_t *)((void *)0));
    break;
    case 5: ;
    return ((read_t *)((void *)0));
    break;
    case 10: ;
    if (! r->seq.b) {
      {
      _1_seq_read_alloc_next = 9U;
      }
    } else {
      {
      _1_seq_read_alloc_next = 8U;
      }
    }
    break;
    case 0: ;
    return (r);
    break;
    case 7: ;
    return ((read_t *)((void *)0));
    break;
    case 2: ;
    if (! r->name.b) {
      {
      _1_seq_read_alloc_next = 4U;
      }
    } else {
      {
      _1_seq_read_alloc_next = 10U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_read_alloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gzskipline LOC=UNKNOWN */
__inline static size_t___0 gzskipline(gzFile file ) 
{ 
  int c ;
  size_t___0 skipped_bytes ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned int _1_gzskipline_next ;

  {
  {
  _1_gzskipline_next = 2U;
  }
  while (1) {
    switch (_1_gzskipline_next) {
    case 8: ;
    if (c == 10) {
      {
      _1_gzskipline_next = 10U;
      }
    } else {
      {
      _1_gzskipline_next = 3U;
      }
    }
    break;
    case 3: ;
    if (file->have) {
      {
      _1_gzskipline_next = 7U;
      }
    } else {
      {
      _1_gzskipline_next = 5U;
      }
    }
    break;
    case 6: ;
    if (! (c != -1)) {
      {
      _1_gzskipline_next = 10U;
      }
    } else {
      {
      _1_gzskipline_next = 0U;
      }
    }
    break;
    case 5: 
    tmp___0 = gzgetc(file);
    c = tmp___0;
    {
    _1_gzskipline_next = 6U;
    }
    break;
    case 10: ;
    return (skipped_bytes);
    break;
    case 0: 
    skipped_bytes ++;
    {
    _1_gzskipline_next = 8U;
    }
    break;
    case 7: 
    (file->have) --;
    (file->pos) ++;
    tmp = file->next;
    (file->next) ++;
    c = (int )*tmp;
    {
    _1_gzskipline_next = 6U;
    }
    break;
    case 2: 
    skipped_bytes = (size_t___0 )0;
    {
    _1_gzskipline_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gzskipline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gzread2 LOC=UNKNOWN */
__inline static size_t___0 gzread2(gzFile gz , void *ptr , size_t___0 len ) 
{ 
  size_t___0 nread ;
  size_t___0 n ;
  int s ;
  unsigned int _1_gzread2_next ;

  {
  {
  _1_gzread2_next = 9U;
  }
  while (1) {
    switch (_1_gzread2_next) {
    case 4: ;
    if (n > 4294967295UL) {
      {
      _1_gzread2_next = 10U;
      }
    } else {
      {
      _1_gzread2_next = 5U;
      }
    }
    break;
    case 1: 
    nread += (size_t___0 )s;
    {
    _1_gzread2_next = 11U;
    }
    break;
    case 3: 
    n = len - nread;
    {
    _1_gzread2_next = 4U;
    }
    break;
    case 11: ;
    if (nread < len) {
      {
      _1_gzread2_next = 3U;
      }
    } else {
      {
      _1_gzread2_next = 0U;
      }
    }
    break;
    case 9: 
    nread = (size_t___0 )0;
    {
    _1_gzread2_next = 11U;
    }
    break;
    case 5: 
    s = gzread(gz, (voidp )((char *)ptr + nread), (unsigned int )n);
    {
    _1_gzread2_next = 7U;
    }
    break;
    case 10: 
    n = (size_t___0 )4294967295U;
    {
    _1_gzread2_next = 5U;
    }
    break;
    case 0: ;
    return (nread);
    break;
    case 7: ;
    if (s <= 0) {
      {
      _1_gzread2_next = 0U;
      }
    } else {
      {
      _1_gzread2_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gzread2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF sort_r LOC=UNKNOWN */
__inline static void sort_r(void *base , size_t___0 nel , size_t___0 width , int (*compar)(void const   *_a ,
                                                                                           void const   *_b ,
                                                                                           void *_arg ) ,
                            void *arg ) 
{ 
  unsigned int _1_sort_r_next ;

  {
  {
  _1_sort_r_next = 0U;
  }
  while (1) {
    switch (_1_sort_r_next) {
    case 1: ;
    return;
    break;
    case 0: 
    sort_r_simple(base, nel, width, compar, arg);
    {
    _1_sort_r_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF sort_r LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cbuf_capacity LOC=UNKNOWN */
__inline static void cbuf_capacity(char **buf , size_t___0 *sizeptr , size_t___0 len ) 
{ 
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  unsigned int _1_cbuf_capacity_next ;

  {
  {
  _1_cbuf_capacity_next = 5U;
  }
  while (1) {
    switch (_1_cbuf_capacity_next) {
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Out of memory\n"));
    exit(1);

    break;
    case 1: 
    tmp = __builtin_clzl(len);
    *sizeptr = 1UL << (64 - tmp);
    tmp___1 = realloc((void *)*buf, *sizeptr);
    tmp___0 = (char *)tmp___1;
    *buf = tmp___0;
    {
    _1_cbuf_capacity_next = 3U;
    }
    break;
    case 3: ;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      _1_cbuf_capacity_next = 4U;
      }
    } else {
      {
      _1_cbuf_capacity_next = 2U;
      }
    }
    break;
    case 5: 
    len ++;
    {
    _1_cbuf_capacity_next = 0U;
    }
    break;
    case 0: ;
    if (*sizeptr < len) {
      {
      _1_cbuf_capacity_next = 1U;
      }
    } else {
      {
      _1_cbuf_capacity_next = 2U;
      }
    }
    break;
    case 2: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF cbuf_capacity LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _scoring_check_wildcards LOC=UNKNOWN */
static char _scoring_check_wildcards(scoring_t const   *scoring___0 , char a , char b ,
                                     int *score ) 
{ 
  int tmp_score ;
  unsigned int _1__scoring_check_wildcards_next ;

  {
  {
  _1__scoring_check_wildcards_next = 6U;
  }
  while (1) {
    switch (_1__scoring_check_wildcards_next) {
    case 4: ;
    if (tmp_score != 2147483647) {
      {
      _1__scoring_check_wildcards_next = 0U;
      }
    } else {
      {
      _1__scoring_check_wildcards_next = 2U;
      }
    }
    break;
    case 8: 
    tmp_score = tmp_score;
    {
    _1__scoring_check_wildcards_next = 4U;
    }
    break;
    case 1: ;
    return ((char)0);
    break;
    case 3: ;
    if ((scoring___0->wildcards[(int )a >> 5] >> ((int )a & 31)) & 1U) {
      {
      _1__scoring_check_wildcards_next = 5U;
      }
    } else {
      {
      _1__scoring_check_wildcards_next = 11U;
      }
    }
    break;
    case 11: ;
    if ((scoring___0->wildcards[(int )b >> 5] >> ((int )b & 31)) & 1U) {
      {
      _1__scoring_check_wildcards_next = 10U;
      }
    } else {
      {
      _1__scoring_check_wildcards_next = 4U;
      }
    }
    break;
    case 9: ;
    return ((char)1);
    break;
    case 6: 
    tmp_score = 2147483647;
    {
    _1__scoring_check_wildcards_next = 3U;
    }
    break;
    case 5: 
    tmp_score = scoring___0->wildscores[(size_t___0 )a];
    {
    _1__scoring_check_wildcards_next = 11U;
    }
    break;
    case 10: ;
    if (scoring___0->wildscores[(size_t___0 )b] <= tmp_score) {
      {
      _1__scoring_check_wildcards_next = 7U;
      }
    } else {
      {
      _1__scoring_check_wildcards_next = 8U;
      }
    }
    break;
    case 0: 
    *score = tmp_score;
    {
    _1__scoring_check_wildcards_next = 9U;
    }
    break;
    case 7: 
    tmp_score = scoring___0->wildscores[(size_t___0 )b];
    {
    _1__scoring_check_wildcards_next = 4U;
    }
    break;
    case 2: 
    *score = 0;
    {
    _1__scoring_check_wildcards_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _scoring_check_wildcards LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) 
{ 
  size_t___0 i ;
  size_t___0 num_of_file_pairs ;
  size_t___0 tmp ;
  char const   *file1 ;
  char *tmp___0 ;
  char const   *file2 ;
  char *tmp___1 ;
  int _BARRIER_0 ;
  unsigned int _1_main_next ;

  {
  {
  {
  {
  {
  goto wait_on_keystroke_i$nit_INLINE_wait_on_keystroke_i$nit;
  }
  wait_on_keystroke_i$nit_INLINE_wait_on_keystroke_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto alignment_index_i$nit_INLINE_alignment_index_i$nit;
  }
  alignment_index_i$nit_INLINE_alignment_index_i$nit: /* CIL Label */ ;
  }
  {
  {
  sub_matrix[0] = (int const   )2;
  sub_matrix[1] = (int const   )2;
  sub_matrix[2] = (int const   )-4;
  sub_matrix[3] = (int const   )-4;
  sub_matrix[4] = (int const   )-4;
  sub_matrix[5] = (int const   )-4;
  sub_matrix[6] = (int const   )-4;
  sub_matrix[7] = (int const   )-4;
  sub_matrix[8] = (int const   )2;
  sub_matrix[9] = (int const   )2;
  sub_matrix[10] = (int const   )-4;
  sub_matrix[11] = (int const   )-4;
  sub_matrix[12] = (int const   )-4;
  sub_matrix[13] = (int const   )-4;
  sub_matrix[14] = (int const   )-4;
  sub_matrix[15] = (int const   )-4;
  sub_matrix[16] = (int const   )-4;
  sub_matrix[17] = (int const   )-4;
  sub_matrix[18] = (int const   )5;
  sub_matrix[19] = (int const   )5;
  sub_matrix[20] = (int const   )-4;
  sub_matrix[21] = (int const   )-4;
  sub_matrix[22] = (int const   )-4;
  sub_matrix[23] = (int const   )-4;
  sub_matrix[24] = (int const   )-4;
  sub_matrix[25] = (int const   )-4;
  sub_matrix[26] = (int const   )5;
  sub_matrix[27] = (int const   )5;
  sub_matrix[28] = (int const   )-4;
  sub_matrix[29] = (int const   )-4;
  sub_matrix[30] = (int const   )-4;
  sub_matrix[31] = (int const   )-4;
  sub_matrix[32] = (int const   )-4;
  sub_matrix[33] = (int const   )-4;
  sub_matrix[34] = (int const   )-4;
  sub_matrix[35] = (int const   )-4;
  sub_matrix[36] = (int const   )5;
  sub_matrix[37] = (int const   )5;
  sub_matrix[38] = (int const   )-4;
  sub_matrix[39] = (int const   )-4;
  sub_matrix[40] = (int const   )-4;
  sub_matrix[41] = (int const   )-4;
  sub_matrix[42] = (int const   )-4;
  sub_matrix[43] = (int const   )-4;
  sub_matrix[44] = (int const   )5;
  sub_matrix[45] = (int const   )5;
  sub_matrix[46] = (int const   )-4;
  sub_matrix[47] = (int const   )-4;
  sub_matrix[48] = (int const   )-4;
  sub_matrix[49] = (int const   )-4;
  sub_matrix[50] = (int const   )-4;
  sub_matrix[51] = (int const   )-4;
  sub_matrix[52] = (int const   )-4;
  sub_matrix[53] = (int const   )-4;
  sub_matrix[54] = (int const   )2;
  sub_matrix[55] = (int const   )2;
  sub_matrix[56] = (int const   )-4;
  sub_matrix[57] = (int const   )-4;
  sub_matrix[58] = (int const   )-4;
  sub_matrix[59] = (int const   )-4;
  sub_matrix[60] = (int const   )-4;
  sub_matrix[61] = (int const   )-4;
  sub_matrix[62] = (int const   )2;
  sub_matrix[63] = (int const   )2;
  goto sub_matrix_i$nit_INLINE_sub_matrix_i$nit;
  }
  sub_matrix_i$nit_INLINE_sub_matrix_i$nit: /* CIL Label */ ;
  }
  {
  {
  dna_bases[0] = (char const   )'A';
  dna_bases[1] = (char const   )'a';
  dna_bases[2] = (char const   )'C';
  dna_bases[3] = (char const   )'c';
  dna_bases[4] = (char const   )'G';
  dna_bases[5] = (char const   )'g';
  dna_bases[6] = (char const   )'T';
  dna_bases[7] = (char const   )'t';
  dna_bases[8] = (char const   )'\000';
  goto dna_bases_i$nit_INLINE_dna_bases_i$nit;
  }
  dna_bases_i$nit_INLINE_dna_bases_i$nit: /* CIL Label */ ;
  }
  {
  {
  blosum62[0] = 4;
  blosum62[1] = -1;
  blosum62[2] = -2;
  blosum62[3] = -2;
  blosum62[4] = 0;
  blosum62[5] = -1;
  blosum62[6] = -1;
  blosum62[7] = 0;
  blosum62[8] = -2;
  blosum62[9] = -1;
  blosum62[10] = -1;
  blosum62[11] = -1;
  blosum62[12] = -1;
  blosum62[13] = -2;
  blosum62[14] = -1;
  blosum62[15] = 1;
  blosum62[16] = 0;
  blosum62[17] = -3;
  blosum62[18] = -2;
  blosum62[19] = 0;
  blosum62[20] = -2;
  blosum62[21] = -1;
  blosum62[22] = 0;
  blosum62[23] = -4;
  blosum62[24] = -1;
  blosum62[25] = 5;
  blosum62[26] = 0;
  blosum62[27] = -2;
  blosum62[28] = -3;
  blosum62[29] = 1;
  blosum62[30] = 0;
  blosum62[31] = -2;
  blosum62[32] = 0;
  blosum62[33] = -3;
  blosum62[34] = -2;
  blosum62[35] = 2;
  blosum62[36] = -1;
  blosum62[37] = -3;
  blosum62[38] = -2;
  blosum62[39] = -1;
  blosum62[40] = -1;
  blosum62[41] = -3;
  blosum62[42] = -2;
  blosum62[43] = -3;
  blosum62[44] = -1;
  blosum62[45] = 0;
  blosum62[46] = -1;
  blosum62[47] = -4;
  blosum62[48] = -2;
  blosum62[49] = 0;
  blosum62[50] = 6;
  blosum62[51] = 1;
  blosum62[52] = -3;
  blosum62[53] = 0;
  blosum62[54] = 0;
  blosum62[55] = 0;
  blosum62[56] = 1;
  blosum62[57] = -3;
  blosum62[58] = -3;
  blosum62[59] = 0;
  blosum62[60] = -2;
  blosum62[61] = -3;
  blosum62[62] = -2;
  blosum62[63] = 1;
  blosum62[64] = 0;
  blosum62[65] = -4;
  blosum62[66] = -2;
  blosum62[67] = -3;
  blosum62[68] = 3;
  blosum62[69] = 0;
  blosum62[70] = -1;
  blosum62[71] = -4;
  blosum62[72] = -2;
  blosum62[73] = -2;
  blosum62[74] = 1;
  blosum62[75] = 6;
  blosum62[76] = -3;
  blosum62[77] = 0;
  blosum62[78] = 2;
  blosum62[79] = -1;
  blosum62[80] = -1;
  blosum62[81] = -3;
  blosum62[82] = -4;
  blosum62[83] = -1;
  blosum62[84] = -3;
  blosum62[85] = -3;
  blosum62[86] = -1;
  blosum62[87] = 0;
  blosum62[88] = -1;
  blosum62[89] = -4;
  blosum62[90] = -3;
  blosum62[91] = -3;
  blosum62[92] = 4;
  blosum62[93] = 1;
  blosum62[94] = -1;
  blosum62[95] = -4;
  blosum62[96] = 0;
  blosum62[97] = -3;
  blosum62[98] = -3;
  blosum62[99] = -3;
  blosum62[100] = 9;
  blosum62[101] = -3;
  blosum62[102] = -4;
  blosum62[103] = -3;
  blosum62[104] = -3;
  blosum62[105] = -1;
  blosum62[106] = -1;
  blosum62[107] = -3;
  blosum62[108] = -1;
  blosum62[109] = -2;
  blosum62[110] = -3;
  blosum62[111] = -1;
  blosum62[112] = -1;
  blosum62[113] = -2;
  blosum62[114] = -2;
  blosum62[115] = -1;
  blosum62[116] = -3;
  blosum62[117] = -3;
  blosum62[118] = -2;
  blosum62[119] = -4;
  blosum62[120] = -1;
  blosum62[121] = 1;
  blosum62[122] = 0;
  blosum62[123] = 0;
  blosum62[124] = -3;
  blosum62[125] = 5;
  blosum62[126] = 2;
  blosum62[127] = -2;
  blosum62[128] = 0;
  blosum62[129] = -3;
  blosum62[130] = -2;
  blosum62[131] = 1;
  blosum62[132] = 0;
  blosum62[133] = -3;
  blosum62[134] = -1;
  blosum62[135] = 0;
  blosum62[136] = -1;
  blosum62[137] = -2;
  blosum62[138] = -1;
  blosum62[139] = -2;
  blosum62[140] = 0;
  blosum62[141] = 3;
  blosum62[142] = -1;
  blosum62[143] = -4;
  blosum62[144] = -1;
  blosum62[145] = 0;
  blosum62[146] = 0;
  blosum62[147] = 2;
  blosum62[148] = -4;
  blosum62[149] = 2;
  blosum62[150] = 5;
  blosum62[151] = -2;
  blosum62[152] = 0;
  blosum62[153] = -3;
  blosum62[154] = -3;
  blosum62[155] = 1;
  blosum62[156] = -2;
  blosum62[157] = -3;
  blosum62[158] = -1;
  blosum62[159] = 0;
  blosum62[160] = -1;
  blosum62[161] = -3;
  blosum62[162] = -2;
  blosum62[163] = -2;
  blosum62[164] = 1;
  blosum62[165] = 4;
  blosum62[166] = -1;
  blosum62[167] = -4;
  blosum62[168] = 0;
  blosum62[169] = -2;
  blosum62[170] = 0;
  blosum62[171] = -1;
  blosum62[172] = -3;
  blosum62[173] = -2;
  blosum62[174] = -2;
  blosum62[175] = 6;
  blosum62[176] = -2;
  blosum62[177] = -4;
  blosum62[178] = -4;
  blosum62[179] = -2;
  blosum62[180] = -3;
  blosum62[181] = -3;
  blosum62[182] = -2;
  blosum62[183] = 0;
  blosum62[184] = -2;
  blosum62[185] = -2;
  blosum62[186] = -3;
  blosum62[187] = -3;
  blosum62[188] = -1;
  blosum62[189] = -2;
  blosum62[190] = -1;
  blosum62[191] = -4;
  blosum62[192] = -2;
  blosum62[193] = 0;
  blosum62[194] = 1;
  blosum62[195] = -1;
  blosum62[196] = -3;
  blosum62[197] = 0;
  blosum62[198] = 0;
  blosum62[199] = -2;
  blosum62[200] = 8;
  blosum62[201] = -3;
  blosum62[202] = -3;
  blosum62[203] = -1;
  blosum62[204] = -2;
  blosum62[205] = -1;
  blosum62[206] = -2;
  blosum62[207] = -1;
  blosum62[208] = -2;
  blosum62[209] = -2;
  blosum62[210] = 2;
  blosum62[211] = -3;
  blosum62[212] = 0;
  blosum62[213] = 0;
  blosum62[214] = -1;
  blosum62[215] = -4;
  blosum62[216] = -1;
  blosum62[217] = -3;
  blosum62[218] = -3;
  blosum62[219] = -3;
  blosum62[220] = -1;
  blosum62[221] = -3;
  blosum62[222] = -3;
  blosum62[223] = -4;
  blosum62[224] = -3;
  blosum62[225] = 4;
  blosum62[226] = 2;
  blosum62[227] = -3;
  blosum62[228] = 1;
  blosum62[229] = 0;
  blosum62[230] = -3;
  blosum62[231] = -2;
  blosum62[232] = -1;
  blosum62[233] = -3;
  blosum62[234] = -1;
  blosum62[235] = 3;
  blosum62[236] = -3;
  blosum62[237] = -3;
  blosum62[238] = -1;
  blosum62[239] = -4;
  blosum62[240] = -1;
  blosum62[241] = -2;
  blosum62[242] = -3;
  blosum62[243] = -4;
  blosum62[244] = -1;
  blosum62[245] = -2;
  blosum62[246] = -3;
  blosum62[247] = -4;
  blosum62[248] = -3;
  blosum62[249] = 2;
  blosum62[250] = 4;
  blosum62[251] = -2;
  blosum62[252] = 2;
  blosum62[253] = 0;
  blosum62[254] = -3;
  blosum62[255] = -2;
  blosum62[256] = -1;
  blosum62[257] = -2;
  blosum62[258] = -1;
  blosum62[259] = 1;
  blosum62[260] = -4;
  blosum62[261] = -3;
  blosum62[262] = -1;
  blosum62[263] = -4;
  blosum62[264] = -1;
  blosum62[265] = 2;
  blosum62[266] = 0;
  blosum62[267] = -1;
  blosum62[268] = -3;
  blosum62[269] = 1;
  blosum62[270] = 1;
  blosum62[271] = -2;
  blosum62[272] = -1;
  blosum62[273] = -3;
  blosum62[274] = -2;
  blosum62[275] = 5;
  blosum62[276] = -1;
  blosum62[277] = -3;
  blosum62[278] = -1;
  blosum62[279] = 0;
  blosum62[280] = -1;
  blosum62[281] = -3;
  blosum62[282] = -2;
  blosum62[283] = -2;
  blosum62[284] = 0;
  blosum62[285] = 1;
  blosum62[286] = -1;
  blosum62[287] = -4;
  blosum62[288] = -1;
  blosum62[289] = -1;
  blosum62[290] = -2;
  blosum62[291] = -3;
  blosum62[292] = -1;
  blosum62[293] = 0;
  blosum62[294] = -2;
  blosum62[295] = -3;
  blosum62[296] = -2;
  blosum62[297] = 1;
  blosum62[298] = 2;
  blosum62[299] = -1;
  blosum62[300] = 5;
  blosum62[301] = 0;
  blosum62[302] = -2;
  blosum62[303] = -1;
  blosum62[304] = -1;
  blosum62[305] = -1;
  blosum62[306] = -1;
  blosum62[307] = 1;
  blosum62[308] = -3;
  blosum62[309] = -1;
  blosum62[310] = -1;
  blosum62[311] = -4;
  blosum62[312] = -2;
  blosum62[313] = -3;
  blosum62[314] = -3;
  blosum62[315] = -3;
  blosum62[316] = -2;
  blosum62[317] = -3;
  blosum62[318] = -3;
  blosum62[319] = -3;
  blosum62[320] = -1;
  blosum62[321] = 0;
  blosum62[322] = 0;
  blosum62[323] = -3;
  blosum62[324] = 0;
  blosum62[325] = 6;
  blosum62[326] = -4;
  blosum62[327] = -2;
  blosum62[328] = -2;
  blosum62[329] = 1;
  blosum62[330] = 3;
  blosum62[331] = -1;
  blosum62[332] = -3;
  blosum62[333] = -3;
  blosum62[334] = -1;
  blosum62[335] = -4;
  blosum62[336] = -1;
  blosum62[337] = -2;
  blosum62[338] = -2;
  blosum62[339] = -1;
  blosum62[340] = -3;
  blosum62[341] = -1;
  blosum62[342] = -1;
  blosum62[343] = -2;
  blosum62[344] = -2;
  blosum62[345] = -3;
  blosum62[346] = -3;
  blosum62[347] = -1;
  blosum62[348] = -2;
  blosum62[349] = -4;
  blosum62[350] = 7;
  blosum62[351] = -1;
  blosum62[352] = -1;
  blosum62[353] = -4;
  blosum62[354] = -3;
  blosum62[355] = -2;
  blosum62[356] = -2;
  blosum62[357] = -1;
  blosum62[358] = -2;
  blosum62[359] = -4;
  blosum62[360] = 1;
  blosum62[361] = -1;
  blosum62[362] = 1;
  blosum62[363] = 0;
  blosum62[364] = -1;
  blosum62[365] = 0;
  blosum62[366] = 0;
  blosum62[367] = 0;
  blosum62[368] = -1;
  blosum62[369] = -2;
  blosum62[370] = -2;
  blosum62[371] = 0;
  blosum62[372] = -1;
  blosum62[373] = -2;
  blosum62[374] = -1;
  blosum62[375] = 4;
  blosum62[376] = 1;
  blosum62[377] = -3;
  blosum62[378] = -2;
  blosum62[379] = -2;
  blosum62[380] = 0;
  blosum62[381] = 0;
  blosum62[382] = 0;
  blosum62[383] = -4;
  blosum62[384] = 0;
  blosum62[385] = -1;
  blosum62[386] = 0;
  blosum62[387] = -1;
  blosum62[388] = -1;
  blosum62[389] = -1;
  blosum62[390] = -1;
  blosum62[391] = -2;
  blosum62[392] = -2;
  blosum62[393] = -1;
  blosum62[394] = -1;
  blosum62[395] = -1;
  blosum62[396] = -1;
  blosum62[397] = -2;
  blosum62[398] = -1;
  blosum62[399] = 1;
  blosum62[400] = 5;
  blosum62[401] = -2;
  blosum62[402] = -2;
  blosum62[403] = 0;
  blosum62[404] = -1;
  blosum62[405] = -1;
  blosum62[406] = 0;
  blosum62[407] = -4;
  blosum62[408] = -3;
  blosum62[409] = -3;
  blosum62[410] = -4;
  blosum62[411] = -4;
  blosum62[412] = -2;
  blosum62[413] = -2;
  blosum62[414] = -3;
  blosum62[415] = -2;
  blosum62[416] = -2;
  blosum62[417] = -3;
  blosum62[418] = -2;
  blosum62[419] = -3;
  blosum62[420] = -1;
  blosum62[421] = 1;
  blosum62[422] = -4;
  blosum62[423] = -3;
  blosum62[424] = -2;
  blosum62[425] = 11;
  blosum62[426] = 2;
  blosum62[427] = -3;
  blosum62[428] = -4;
  blosum62[429] = -3;
  blosum62[430] = -2;
  blosum62[431] = -4;
  blosum62[432] = -2;
  blosum62[433] = -2;
  blosum62[434] = -2;
  blosum62[435] = -3;
  blosum62[436] = -2;
  blosum62[437] = -1;
  blosum62[438] = -2;
  blosum62[439] = -3;
  blosum62[440] = 2;
  blosum62[441] = -1;
  blosum62[442] = -1;
  blosum62[443] = -2;
  blosum62[444] = -1;
  blosum62[445] = 3;
  blosum62[446] = -3;
  blosum62[447] = -2;
  blosum62[448] = -2;
  blosum62[449] = 2;
  blosum62[450] = 7;
  blosum62[451] = -1;
  blosum62[452] = -3;
  blosum62[453] = -2;
  blosum62[454] = -1;
  blosum62[455] = -4;
  blosum62[456] = 0;
  blosum62[457] = -3;
  blosum62[458] = -3;
  blosum62[459] = -3;
  blosum62[460] = -1;
  blosum62[461] = -2;
  blosum62[462] = -2;
  blosum62[463] = -3;
  blosum62[464] = -3;
  blosum62[465] = 3;
  blosum62[466] = 1;
  blosum62[467] = -2;
  blosum62[468] = 1;
  blosum62[469] = -1;
  blosum62[470] = -2;
  blosum62[471] = -2;
  blosum62[472] = 0;
  blosum62[473] = -3;
  blosum62[474] = -1;
  blosum62[475] = 4;
  blosum62[476] = -3;
  blosum62[477] = -2;
  blosum62[478] = -1;
  blosum62[479] = -4;
  blosum62[480] = -2;
  blosum62[481] = -1;
  blosum62[482] = 3;
  blosum62[483] = 4;
  blosum62[484] = -3;
  blosum62[485] = 0;
  blosum62[486] = 1;
  blosum62[487] = -1;
  blosum62[488] = 0;
  blosum62[489] = -3;
  blosum62[490] = -4;
  blosum62[491] = 0;
  blosum62[492] = -3;
  blosum62[493] = -3;
  blosum62[494] = -2;
  blosum62[495] = 0;
  blosum62[496] = -1;
  blosum62[497] = -4;
  blosum62[498] = -3;
  blosum62[499] = -3;
  blosum62[500] = 4;
  blosum62[501] = 1;
  blosum62[502] = -1;
  blosum62[503] = -4;
  blosum62[504] = -1;
  blosum62[505] = 0;
  blosum62[506] = 0;
  blosum62[507] = 1;
  blosum62[508] = -3;
  blosum62[509] = 3;
  blosum62[510] = 4;
  blosum62[511] = -2;
  blosum62[512] = 0;
  blosum62[513] = -3;
  blosum62[514] = -3;
  blosum62[515] = 1;
  blosum62[516] = -1;
  blosum62[517] = -3;
  blosum62[518] = -1;
  blosum62[519] = 0;
  blosum62[520] = -1;
  blosum62[521] = -3;
  blosum62[522] = -2;
  blosum62[523] = -2;
  blosum62[524] = 1;
  blosum62[525] = 4;
  blosum62[526] = -1;
  blosum62[527] = -4;
  blosum62[528] = 0;
  blosum62[529] = -1;
  blosum62[530] = -1;
  blosum62[531] = -1;
  blosum62[532] = -2;
  blosum62[533] = -1;
  blosum62[534] = -1;
  blosum62[535] = -1;
  blosum62[536] = -1;
  blosum62[537] = -1;
  blosum62[538] = -1;
  blosum62[539] = -1;
  blosum62[540] = -1;
  blosum62[541] = -1;
  blosum62[542] = -2;
  blosum62[543] = 0;
  blosum62[544] = 0;
  blosum62[545] = -2;
  blosum62[546] = -1;
  blosum62[547] = -1;
  blosum62[548] = -1;
  blosum62[549] = -1;
  blosum62[550] = -1;
  blosum62[551] = -4;
  blosum62[552] = -4;
  blosum62[553] = -4;
  blosum62[554] = -4;
  blosum62[555] = -4;
  blosum62[556] = -4;
  blosum62[557] = -4;
  blosum62[558] = -4;
  blosum62[559] = -4;
  blosum62[560] = -4;
  blosum62[561] = -4;
  blosum62[562] = -4;
  blosum62[563] = -4;
  blosum62[564] = -4;
  blosum62[565] = -4;
  blosum62[566] = -4;
  blosum62[567] = -4;
  blosum62[568] = -4;
  blosum62[569] = -4;
  blosum62[570] = -4;
  blosum62[571] = -4;
  blosum62[572] = -4;
  blosum62[573] = -4;
  blosum62[574] = -4;
  blosum62[575] = 1;
  goto blosum62_i$nit_INLINE_blosum62_i$nit;
  }
  blosum62_i$nit_INLINE_blosum62_i$nit: /* CIL Label */ ;
  }
  {
  {
  blosum80[0] = (int const   )7;
  blosum80[1] = (int const   )-3;
  blosum80[2] = (int const   )-3;
  blosum80[3] = (int const   )-3;
  blosum80[4] = (int const   )-1;
  blosum80[5] = (int const   )-2;
  blosum80[6] = (int const   )-2;
  blosum80[7] = (int const   )0;
  blosum80[8] = (int const   )-3;
  blosum80[9] = (int const   )-3;
  blosum80[10] = (int const   )-3;
  blosum80[11] = (int const   )-1;
  blosum80[12] = (int const   )-2;
  blosum80[13] = (int const   )-4;
  blosum80[14] = (int const   )-1;
  blosum80[15] = (int const   )2;
  blosum80[16] = (int const   )0;
  blosum80[17] = (int const   )-5;
  blosum80[18] = (int const   )-4;
  blosum80[19] = (int const   )-1;
  blosum80[20] = (int const   )-3;
  blosum80[21] = (int const   )-2;
  blosum80[22] = (int const   )-1;
  blosum80[23] = (int const   )-8;
  blosum80[24] = (int const   )-3;
  blosum80[25] = (int const   )9;
  blosum80[26] = (int const   )-1;
  blosum80[27] = (int const   )-3;
  blosum80[28] = (int const   )-6;
  blosum80[29] = (int const   )1;
  blosum80[30] = (int const   )-1;
  blosum80[31] = (int const   )-4;
  blosum80[32] = (int const   )0;
  blosum80[33] = (int const   )-5;
  blosum80[34] = (int const   )-4;
  blosum80[35] = (int const   )3;
  blosum80[36] = (int const   )-3;
  blosum80[37] = (int const   )-5;
  blosum80[38] = (int const   )-3;
  blosum80[39] = (int const   )-2;
  blosum80[40] = (int const   )-2;
  blosum80[41] = (int const   )-5;
  blosum80[42] = (int const   )-4;
  blosum80[43] = (int const   )-4;
  blosum80[44] = (int const   )-2;
  blosum80[45] = (int const   )0;
  blosum80[46] = (int const   )-2;
  blosum80[47] = (int const   )-8;
  blosum80[48] = (int const   )-3;
  blosum80[49] = (int const   )-1;
  blosum80[50] = (int const   )9;
  blosum80[51] = (int const   )2;
  blosum80[52] = (int const   )-5;
  blosum80[53] = (int const   )0;
  blosum80[54] = (int const   )-1;
  blosum80[55] = (int const   )-1;
  blosum80[56] = (int const   )1;
  blosum80[57] = (int const   )-6;
  blosum80[58] = (int const   )-6;
  blosum80[59] = (int const   )0;
  blosum80[60] = (int const   )-4;
  blosum80[61] = (int const   )-6;
  blosum80[62] = (int const   )-4;
  blosum80[63] = (int const   )1;
  blosum80[64] = (int const   )0;
  blosum80[65] = (int const   )-7;
  blosum80[66] = (int const   )-4;
  blosum80[67] = (int const   )-5;
  blosum80[68] = (int const   )5;
  blosum80[69] = (int const   )-1;
  blosum80[70] = (int const   )-2;
  blosum80[71] = (int const   )-8;
  blosum80[72] = (int const   )-3;
  blosum80[73] = (int const   )-3;
  blosum80[74] = (int const   )2;
  blosum80[75] = (int const   )10;
  blosum80[76] = (int const   )-7;
  blosum80[77] = (int const   )-1;
  blosum80[78] = (int const   )2;
  blosum80[79] = (int const   )-3;
  blosum80[80] = (int const   )-2;
  blosum80[81] = (int const   )-7;
  blosum80[82] = (int const   )-7;
  blosum80[83] = (int const   )-2;
  blosum80[84] = (int const   )-6;
  blosum80[85] = (int const   )-6;
  blosum80[86] = (int const   )-3;
  blosum80[87] = (int const   )-1;
  blosum80[88] = (int const   )-2;
  blosum80[89] = (int const   )-8;
  blosum80[90] = (int const   )-6;
  blosum80[91] = (int const   )-6;
  blosum80[92] = (int const   )6;
  blosum80[93] = (int const   )1;
  blosum80[94] = (int const   )-3;
  blosum80[95] = (int const   )-8;
  blosum80[96] = (int const   )-1;
  blosum80[97] = (int const   )-6;
  blosum80[98] = (int const   )-5;
  blosum80[99] = (int const   )-7;
  blosum80[100] = (int const   )13;
  blosum80[101] = (int const   )-5;
  blosum80[102] = (int const   )-7;
  blosum80[103] = (int const   )-6;
  blosum80[104] = (int const   )-7;
  blosum80[105] = (int const   )-2;
  blosum80[106] = (int const   )-3;
  blosum80[107] = (int const   )-6;
  blosum80[108] = (int const   )-3;
  blosum80[109] = (int const   )-4;
  blosum80[110] = (int const   )-6;
  blosum80[111] = (int const   )-2;
  blosum80[112] = (int const   )-2;
  blosum80[113] = (int const   )-5;
  blosum80[114] = (int const   )-5;
  blosum80[115] = (int const   )-2;
  blosum80[116] = (int const   )-6;
  blosum80[117] = (int const   )-7;
  blosum80[118] = (int const   )-4;
  blosum80[119] = (int const   )-8;
  blosum80[120] = (int const   )-2;
  blosum80[121] = (int const   )1;
  blosum80[122] = (int const   )0;
  blosum80[123] = (int const   )-1;
  blosum80[124] = (int const   )-5;
  blosum80[125] = (int const   )9;
  blosum80[126] = (int const   )3;
  blosum80[127] = (int const   )-4;
  blosum80[128] = (int const   )1;
  blosum80[129] = (int const   )-5;
  blosum80[130] = (int const   )-4;
  blosum80[131] = (int const   )2;
  blosum80[132] = (int const   )-1;
  blosum80[133] = (int const   )-5;
  blosum80[134] = (int const   )-3;
  blosum80[135] = (int const   )-1;
  blosum80[136] = (int const   )-1;
  blosum80[137] = (int const   )-4;
  blosum80[138] = (int const   )-3;
  blosum80[139] = (int const   )-4;
  blosum80[140] = (int const   )-1;
  blosum80[141] = (int const   )5;
  blosum80[142] = (int const   )-2;
  blosum80[143] = (int const   )-8;
  blosum80[144] = (int const   )-2;
  blosum80[145] = (int const   )-1;
  blosum80[146] = (int const   )-1;
  blosum80[147] = (int const   )2;
  blosum80[148] = (int const   )-7;
  blosum80[149] = (int const   )3;
  blosum80[150] = (int const   )8;
  blosum80[151] = (int const   )-4;
  blosum80[152] = (int const   )0;
  blosum80[153] = (int const   )-6;
  blosum80[154] = (int const   )-6;
  blosum80[155] = (int const   )1;
  blosum80[156] = (int const   )-4;
  blosum80[157] = (int const   )-6;
  blosum80[158] = (int const   )-2;
  blosum80[159] = (int const   )-1;
  blosum80[160] = (int const   )-2;
  blosum80[161] = (int const   )-6;
  blosum80[162] = (int const   )-5;
  blosum80[163] = (int const   )-4;
  blosum80[164] = (int const   )1;
  blosum80[165] = (int const   )6;
  blosum80[166] = (int const   )-2;
  blosum80[167] = (int const   )-8;
  blosum80[168] = (int const   )0;
  blosum80[169] = (int const   )-4;
  blosum80[170] = (int const   )-1;
  blosum80[171] = (int const   )-3;
  blosum80[172] = (int const   )-6;
  blosum80[173] = (int const   )-4;
  blosum80[174] = (int const   )-4;
  blosum80[175] = (int const   )9;
  blosum80[176] = (int const   )-4;
  blosum80[177] = (int const   )-7;
  blosum80[178] = (int const   )-7;
  blosum80[179] = (int const   )-3;
  blosum80[180] = (int const   )-5;
  blosum80[181] = (int const   )-6;
  blosum80[182] = (int const   )-5;
  blosum80[183] = (int const   )-1;
  blosum80[184] = (int const   )-3;
  blosum80[185] = (int const   )-6;
  blosum80[186] = (int const   )-6;
  blosum80[187] = (int const   )-6;
  blosum80[188] = (int const   )-2;
  blosum80[189] = (int const   )-4;
  blosum80[190] = (int const   )-3;
  blosum80[191] = (int const   )-8;
  blosum80[192] = (int const   )-3;
  blosum80[193] = (int const   )0;
  blosum80[194] = (int const   )1;
  blosum80[195] = (int const   )-2;
  blosum80[196] = (int const   )-7;
  blosum80[197] = (int const   )1;
  blosum80[198] = (int const   )0;
  blosum80[199] = (int const   )-4;
  blosum80[200] = (int const   )12;
  blosum80[201] = (int const   )-6;
  blosum80[202] = (int const   )-5;
  blosum80[203] = (int const   )-1;
  blosum80[204] = (int const   )-4;
  blosum80[205] = (int const   )-2;
  blosum80[206] = (int const   )-4;
  blosum80[207] = (int const   )-2;
  blosum80[208] = (int const   )-3;
  blosum80[209] = (int const   )-4;
  blosum80[210] = (int const   )3;
  blosum80[211] = (int const   )-5;
  blosum80[212] = (int const   )-1;
  blosum80[213] = (int const   )0;
  blosum80[214] = (int const   )-2;
  blosum80[215] = (int const   )-8;
  blosum80[216] = (int const   )-3;
  blosum80[217] = (int const   )-5;
  blosum80[218] = (int const   )-6;
  blosum80[219] = (int const   )-7;
  blosum80[220] = (int const   )-2;
  blosum80[221] = (int const   )-5;
  blosum80[222] = (int const   )-6;
  blosum80[223] = (int const   )-7;
  blosum80[224] = (int const   )-6;
  blosum80[225] = (int const   )7;
  blosum80[226] = (int const   )2;
  blosum80[227] = (int const   )-5;
  blosum80[228] = (int const   )2;
  blosum80[229] = (int const   )-1;
  blosum80[230] = (int const   )-5;
  blosum80[231] = (int const   )-4;
  blosum80[232] = (int const   )-2;
  blosum80[233] = (int const   )-5;
  blosum80[234] = (int const   )-3;
  blosum80[235] = (int const   )4;
  blosum80[236] = (int const   )-6;
  blosum80[237] = (int const   )-6;
  blosum80[238] = (int const   )-2;
  blosum80[239] = (int const   )-8;
  blosum80[240] = (int const   )-3;
  blosum80[241] = (int const   )-4;
  blosum80[242] = (int const   )-6;
  blosum80[243] = (int const   )-7;
  blosum80[244] = (int const   )-3;
  blosum80[245] = (int const   )-4;
  blosum80[246] = (int const   )-6;
  blosum80[247] = (int const   )-7;
  blosum80[248] = (int const   )-5;
  blosum80[249] = (int const   )2;
  blosum80[250] = (int const   )6;
  blosum80[251] = (int const   )-4;
  blosum80[252] = (int const   )3;
  blosum80[253] = (int const   )0;
  blosum80[254] = (int const   )-5;
  blosum80[255] = (int const   )-4;
  blosum80[256] = (int const   )-3;
  blosum80[257] = (int const   )-4;
  blosum80[258] = (int const   )-2;
  blosum80[259] = (int const   )1;
  blosum80[260] = (int const   )-7;
  blosum80[261] = (int const   )-5;
  blosum80[262] = (int const   )-2;
  blosum80[263] = (int const   )-8;
  blosum80[264] = (int const   )-1;
  blosum80[265] = (int const   )3;
  blosum80[266] = (int const   )0;
  blosum80[267] = (int const   )-2;
  blosum80[268] = (int const   )-6;
  blosum80[269] = (int const   )2;
  blosum80[270] = (int const   )1;
  blosum80[271] = (int const   )-3;
  blosum80[272] = (int const   )-1;
  blosum80[273] = (int const   )-5;
  blosum80[274] = (int const   )-4;
  blosum80[275] = (int const   )8;
  blosum80[276] = (int const   )-3;
  blosum80[277] = (int const   )-5;
  blosum80[278] = (int const   )-2;
  blosum80[279] = (int const   )-1;
  blosum80[280] = (int const   )-1;
  blosum80[281] = (int const   )-6;
  blosum80[282] = (int const   )-4;
  blosum80[283] = (int const   )-4;
  blosum80[284] = (int const   )-1;
  blosum80[285] = (int const   )1;
  blosum80[286] = (int const   )-2;
  blosum80[287] = (int const   )-8;
  blosum80[288] = (int const   )-2;
  blosum80[289] = (int const   )-3;
  blosum80[290] = (int const   )-4;
  blosum80[291] = (int const   )-6;
  blosum80[292] = (int const   )-3;
  blosum80[293] = (int const   )-1;
  blosum80[294] = (int const   )-4;
  blosum80[295] = (int const   )-5;
  blosum80[296] = (int const   )-4;
  blosum80[297] = (int const   )2;
  blosum80[298] = (int const   )3;
  blosum80[299] = (int const   )-3;
  blosum80[300] = (int const   )9;
  blosum80[301] = (int const   )0;
  blosum80[302] = (int const   )-4;
  blosum80[303] = (int const   )-3;
  blosum80[304] = (int const   )-1;
  blosum80[305] = (int const   )-3;
  blosum80[306] = (int const   )-3;
  blosum80[307] = (int const   )1;
  blosum80[308] = (int const   )-5;
  blosum80[309] = (int const   )-3;
  blosum80[310] = (int const   )-2;
  blosum80[311] = (int const   )-8;
  blosum80[312] = (int const   )-4;
  blosum80[313] = (int const   )-5;
  blosum80[314] = (int const   )-6;
  blosum80[315] = (int const   )-6;
  blosum80[316] = (int const   )-4;
  blosum80[317] = (int const   )-5;
  blosum80[318] = (int const   )-6;
  blosum80[319] = (int const   )-6;
  blosum80[320] = (int const   )-2;
  blosum80[321] = (int const   )-1;
  blosum80[322] = (int const   )0;
  blosum80[323] = (int const   )-5;
  blosum80[324] = (int const   )0;
  blosum80[325] = (int const   )10;
  blosum80[326] = (int const   )-6;
  blosum80[327] = (int const   )-4;
  blosum80[328] = (int const   )-4;
  blosum80[329] = (int const   )0;
  blosum80[330] = (int const   )4;
  blosum80[331] = (int const   )-2;
  blosum80[332] = (int const   )-6;
  blosum80[333] = (int const   )-6;
  blosum80[334] = (int const   )-3;
  blosum80[335] = (int const   )-8;
  blosum80[336] = (int const   )-1;
  blosum80[337] = (int const   )-3;
  blosum80[338] = (int const   )-4;
  blosum80[339] = (int const   )-3;
  blosum80[340] = (int const   )-6;
  blosum80[341] = (int const   )-3;
  blosum80[342] = (int const   )-2;
  blosum80[343] = (int const   )-5;
  blosum80[344] = (int const   )-4;
  blosum80[345] = (int const   )-5;
  blosum80[346] = (int const   )-5;
  blosum80[347] = (int const   )-2;
  blosum80[348] = (int const   )-4;
  blosum80[349] = (int const   )-6;
  blosum80[350] = (int const   )12;
  blosum80[351] = (int const   )-2;
  blosum80[352] = (int const   )-3;
  blosum80[353] = (int const   )-7;
  blosum80[354] = (int const   )-6;
  blosum80[355] = (int const   )-4;
  blosum80[356] = (int const   )-4;
  blosum80[357] = (int const   )-2;
  blosum80[358] = (int const   )-3;
  blosum80[359] = (int const   )-8;
  blosum80[360] = (int const   )2;
  blosum80[361] = (int const   )-2;
  blosum80[362] = (int const   )1;
  blosum80[363] = (int const   )-1;
  blosum80[364] = (int const   )-2;
  blosum80[365] = (int const   )-1;
  blosum80[366] = (int const   )-1;
  blosum80[367] = (int const   )-1;
  blosum80[368] = (int const   )-2;
  blosum80[369] = (int const   )-4;
  blosum80[370] = (int const   )-4;
  blosum80[371] = (int const   )-1;
  blosum80[372] = (int const   )-3;
  blosum80[373] = (int const   )-4;
  blosum80[374] = (int const   )-2;
  blosum80[375] = (int const   )7;
  blosum80[376] = (int const   )2;
  blosum80[377] = (int const   )-6;
  blosum80[378] = (int const   )-3;
  blosum80[379] = (int const   )-3;
  blosum80[380] = (int const   )0;
  blosum80[381] = (int const   )-1;
  blosum80[382] = (int const   )-1;
  blosum80[383] = (int const   )-8;
  blosum80[384] = (int const   )0;
  blosum80[385] = (int const   )-2;
  blosum80[386] = (int const   )0;
  blosum80[387] = (int const   )-2;
  blosum80[388] = (int const   )-2;
  blosum80[389] = (int const   )-1;
  blosum80[390] = (int const   )-2;
  blosum80[391] = (int const   )-3;
  blosum80[392] = (int const   )-3;
  blosum80[393] = (int const   )-2;
  blosum80[394] = (int const   )-3;
  blosum80[395] = (int const   )-1;
  blosum80[396] = (int const   )-1;
  blosum80[397] = (int const   )-4;
  blosum80[398] = (int const   )-3;
  blosum80[399] = (int const   )2;
  blosum80[400] = (int const   )8;
  blosum80[401] = (int const   )-5;
  blosum80[402] = (int const   )-3;
  blosum80[403] = (int const   )0;
  blosum80[404] = (int const   )-1;
  blosum80[405] = (int const   )-2;
  blosum80[406] = (int const   )-1;
  blosum80[407] = (int const   )-8;
  blosum80[408] = (int const   )-5;
  blosum80[409] = (int const   )-5;
  blosum80[410] = (int const   )-7;
  blosum80[411] = (int const   )-8;
  blosum80[412] = (int const   )-5;
  blosum80[413] = (int const   )-4;
  blosum80[414] = (int const   )-6;
  blosum80[415] = (int const   )-6;
  blosum80[416] = (int const   )-4;
  blosum80[417] = (int const   )-5;
  blosum80[418] = (int const   )-4;
  blosum80[419] = (int const   )-6;
  blosum80[420] = (int const   )-3;
  blosum80[421] = (int const   )0;
  blosum80[422] = (int const   )-7;
  blosum80[423] = (int const   )-6;
  blosum80[424] = (int const   )-5;
  blosum80[425] = (int const   )16;
  blosum80[426] = (int const   )3;
  blosum80[427] = (int const   )-5;
  blosum80[428] = (int const   )-8;
  blosum80[429] = (int const   )-5;
  blosum80[430] = (int const   )-5;
  blosum80[431] = (int const   )-8;
  blosum80[432] = (int const   )-4;
  blosum80[433] = (int const   )-4;
  blosum80[434] = (int const   )-4;
  blosum80[435] = (int const   )-6;
  blosum80[436] = (int const   )-5;
  blosum80[437] = (int const   )-3;
  blosum80[438] = (int const   )-5;
  blosum80[439] = (int const   )-6;
  blosum80[440] = (int const   )3;
  blosum80[441] = (int const   )-3;
  blosum80[442] = (int const   )-2;
  blosum80[443] = (int const   )-4;
  blosum80[444] = (int const   )-3;
  blosum80[445] = (int const   )4;
  blosum80[446] = (int const   )-6;
  blosum80[447] = (int const   )-3;
  blosum80[448] = (int const   )-3;
  blosum80[449] = (int const   )3;
  blosum80[450] = (int const   )11;
  blosum80[451] = (int const   )-3;
  blosum80[452] = (int const   )-5;
  blosum80[453] = (int const   )-4;
  blosum80[454] = (int const   )-3;
  blosum80[455] = (int const   )-8;
  blosum80[456] = (int const   )-1;
  blosum80[457] = (int const   )-4;
  blosum80[458] = (int const   )-5;
  blosum80[459] = (int const   )-6;
  blosum80[460] = (int const   )-2;
  blosum80[461] = (int const   )-4;
  blosum80[462] = (int const   )-4;
  blosum80[463] = (int const   )-6;
  blosum80[464] = (int const   )-5;
  blosum80[465] = (int const   )4;
  blosum80[466] = (int const   )1;
  blosum80[467] = (int const   )-4;
  blosum80[468] = (int const   )1;
  blosum80[469] = (int const   )-2;
  blosum80[470] = (int const   )-4;
  blosum80[471] = (int const   )-3;
  blosum80[472] = (int const   )0;
  blosum80[473] = (int const   )-5;
  blosum80[474] = (int const   )-3;
  blosum80[475] = (int const   )7;
  blosum80[476] = (int const   )-6;
  blosum80[477] = (int const   )-4;
  blosum80[478] = (int const   )-2;
  blosum80[479] = (int const   )-8;
  blosum80[480] = (int const   )-3;
  blosum80[481] = (int const   )-2;
  blosum80[482] = (int const   )5;
  blosum80[483] = (int const   )6;
  blosum80[484] = (int const   )-6;
  blosum80[485] = (int const   )-1;
  blosum80[486] = (int const   )1;
  blosum80[487] = (int const   )-2;
  blosum80[488] = (int const   )-1;
  blosum80[489] = (int const   )-6;
  blosum80[490] = (int const   )-7;
  blosum80[491] = (int const   )-1;
  blosum80[492] = (int const   )-5;
  blosum80[493] = (int const   )-6;
  blosum80[494] = (int const   )-4;
  blosum80[495] = (int const   )0;
  blosum80[496] = (int const   )-1;
  blosum80[497] = (int const   )-8;
  blosum80[498] = (int const   )-5;
  blosum80[499] = (int const   )-6;
  blosum80[500] = (int const   )6;
  blosum80[501] = (int const   )0;
  blosum80[502] = (int const   )-3;
  blosum80[503] = (int const   )-8;
  blosum80[504] = (int const   )-2;
  blosum80[505] = (int const   )0;
  blosum80[506] = (int const   )-1;
  blosum80[507] = (int const   )1;
  blosum80[508] = (int const   )-7;
  blosum80[509] = (int const   )5;
  blosum80[510] = (int const   )6;
  blosum80[511] = (int const   )-4;
  blosum80[512] = (int const   )0;
  blosum80[513] = (int const   )-6;
  blosum80[514] = (int const   )-5;
  blosum80[515] = (int const   )1;
  blosum80[516] = (int const   )-3;
  blosum80[517] = (int const   )-6;
  blosum80[518] = (int const   )-2;
  blosum80[519] = (int const   )-1;
  blosum80[520] = (int const   )-2;
  blosum80[521] = (int const   )-5;
  blosum80[522] = (int const   )-4;
  blosum80[523] = (int const   )-4;
  blosum80[524] = (int const   )0;
  blosum80[525] = (int const   )6;
  blosum80[526] = (int const   )-1;
  blosum80[527] = (int const   )-8;
  blosum80[528] = (int const   )-1;
  blosum80[529] = (int const   )-2;
  blosum80[530] = (int const   )-2;
  blosum80[531] = (int const   )-3;
  blosum80[532] = (int const   )-4;
  blosum80[533] = (int const   )-2;
  blosum80[534] = (int const   )-2;
  blosum80[535] = (int const   )-3;
  blosum80[536] = (int const   )-2;
  blosum80[537] = (int const   )-2;
  blosum80[538] = (int const   )-2;
  blosum80[539] = (int const   )-2;
  blosum80[540] = (int const   )-2;
  blosum80[541] = (int const   )-3;
  blosum80[542] = (int const   )-3;
  blosum80[543] = (int const   )-1;
  blosum80[544] = (int const   )-1;
  blosum80[545] = (int const   )-5;
  blosum80[546] = (int const   )-3;
  blosum80[547] = (int const   )-2;
  blosum80[548] = (int const   )-3;
  blosum80[549] = (int const   )-1;
  blosum80[550] = (int const   )-2;
  blosum80[551] = (int const   )-8;
  blosum80[552] = (int const   )-8;
  blosum80[553] = (int const   )-8;
  blosum80[554] = (int const   )-8;
  blosum80[555] = (int const   )-8;
  blosum80[556] = (int const   )-8;
  blosum80[557] = (int const   )-8;
  blosum80[558] = (int const   )-8;
  blosum80[559] = (int const   )-8;
  blosum80[560] = (int const   )-8;
  blosum80[561] = (int const   )-8;
  blosum80[562] = (int const   )-8;
  blosum80[563] = (int const   )-8;
  blosum80[564] = (int const   )-8;
  blosum80[565] = (int const   )-8;
  blosum80[566] = (int const   )-8;
  blosum80[567] = (int const   )-8;
  blosum80[568] = (int const   )-8;
  blosum80[569] = (int const   )-8;
  blosum80[570] = (int const   )-8;
  blosum80[571] = (int const   )-8;
  blosum80[572] = (int const   )-8;
  blosum80[573] = (int const   )-8;
  blosum80[574] = (int const   )-8;
  blosum80[575] = (int const   )1;
  goto blosum80_i$nit_INLINE_blosum80_i$nit;
  }
  blosum80_i$nit_INLINE_blosum80_i$nit: /* CIL Label */ ;
  }
  {
  {
  pam70[0] = (int const   )5;
  pam70[1] = (int const   )-4;
  pam70[2] = (int const   )-2;
  pam70[3] = (int const   )-1;
  pam70[4] = (int const   )-4;
  pam70[5] = (int const   )-2;
  pam70[6] = (int const   )-1;
  pam70[7] = (int const   )0;
  pam70[8] = (int const   )-4;
  pam70[9] = (int const   )-2;
  pam70[10] = (int const   )-4;
  pam70[11] = (int const   )-4;
  pam70[12] = (int const   )-3;
  pam70[13] = (int const   )-6;
  pam70[14] = (int const   )0;
  pam70[15] = (int const   )1;
  pam70[16] = (int const   )1;
  pam70[17] = (int const   )-9;
  pam70[18] = (int const   )-5;
  pam70[19] = (int const   )-1;
  pam70[20] = (int const   )-1;
  pam70[21] = (int const   )-1;
  pam70[22] = (int const   )-2;
  pam70[23] = (int const   )-11;
  pam70[24] = (int const   )-4;
  pam70[25] = (int const   )8;
  pam70[26] = (int const   )-3;
  pam70[27] = (int const   )-6;
  pam70[28] = (int const   )-5;
  pam70[29] = (int const   )0;
  pam70[30] = (int const   )-5;
  pam70[31] = (int const   )-6;
  pam70[32] = (int const   )0;
  pam70[33] = (int const   )-3;
  pam70[34] = (int const   )-6;
  pam70[35] = (int const   )2;
  pam70[36] = (int const   )-2;
  pam70[37] = (int const   )-7;
  pam70[38] = (int const   )-2;
  pam70[39] = (int const   )-1;
  pam70[40] = (int const   )-4;
  pam70[41] = (int const   )0;
  pam70[42] = (int const   )-7;
  pam70[43] = (int const   )-5;
  pam70[44] = (int const   )-4;
  pam70[45] = (int const   )-2;
  pam70[46] = (int const   )-3;
  pam70[47] = (int const   )-11;
  pam70[48] = (int const   )-2;
  pam70[49] = (int const   )-3;
  pam70[50] = (int const   )6;
  pam70[51] = (int const   )3;
  pam70[52] = (int const   )-7;
  pam70[53] = (int const   )-1;
  pam70[54] = (int const   )0;
  pam70[55] = (int const   )-1;
  pam70[56] = (int const   )1;
  pam70[57] = (int const   )-3;
  pam70[58] = (int const   )-5;
  pam70[59] = (int const   )0;
  pam70[60] = (int const   )-5;
  pam70[61] = (int const   )-6;
  pam70[62] = (int const   )-3;
  pam70[63] = (int const   )1;
  pam70[64] = (int const   )0;
  pam70[65] = (int const   )-6;
  pam70[66] = (int const   )-3;
  pam70[67] = (int const   )-5;
  pam70[68] = (int const   )5;
  pam70[69] = (int const   )-1;
  pam70[70] = (int const   )-2;
  pam70[71] = (int const   )-11;
  pam70[72] = (int const   )-1;
  pam70[73] = (int const   )-6;
  pam70[74] = (int const   )3;
  pam70[75] = (int const   )6;
  pam70[76] = (int const   )-9;
  pam70[77] = (int const   )0;
  pam70[78] = (int const   )3;
  pam70[79] = (int const   )-1;
  pam70[80] = (int const   )-1;
  pam70[81] = (int const   )-5;
  pam70[82] = (int const   )-8;
  pam70[83] = (int const   )-2;
  pam70[84] = (int const   )-7;
  pam70[85] = (int const   )-10;
  pam70[86] = (int const   )-4;
  pam70[87] = (int const   )-1;
  pam70[88] = (int const   )-2;
  pam70[89] = (int const   )-10;
  pam70[90] = (int const   )-7;
  pam70[91] = (int const   )-5;
  pam70[92] = (int const   )5;
  pam70[93] = (int const   )2;
  pam70[94] = (int const   )-3;
  pam70[95] = (int const   )-11;
  pam70[96] = (int const   )-4;
  pam70[97] = (int const   )-5;
  pam70[98] = (int const   )-7;
  pam70[99] = (int const   )-9;
  pam70[100] = (int const   )9;
  pam70[101] = (int const   )-9;
  pam70[102] = (int const   )-9;
  pam70[103] = (int const   )-6;
  pam70[104] = (int const   )-5;
  pam70[105] = (int const   )-4;
  pam70[106] = (int const   )-10;
  pam70[107] = (int const   )-9;
  pam70[108] = (int const   )-9;
  pam70[109] = (int const   )-8;
  pam70[110] = (int const   )-5;
  pam70[111] = (int const   )-1;
  pam70[112] = (int const   )-5;
  pam70[113] = (int const   )-11;
  pam70[114] = (int const   )-2;
  pam70[115] = (int const   )-4;
  pam70[116] = (int const   )-8;
  pam70[117] = (int const   )-9;
  pam70[118] = (int const   )-6;
  pam70[119] = (int const   )-11;
  pam70[120] = (int const   )-2;
  pam70[121] = (int const   )0;
  pam70[122] = (int const   )-1;
  pam70[123] = (int const   )0;
  pam70[124] = (int const   )-9;
  pam70[125] = (int const   )7;
  pam70[126] = (int const   )2;
  pam70[127] = (int const   )-4;
  pam70[128] = (int const   )2;
  pam70[129] = (int const   )-5;
  pam70[130] = (int const   )-3;
  pam70[131] = (int const   )-1;
  pam70[132] = (int const   )-2;
  pam70[133] = (int const   )-9;
  pam70[134] = (int const   )-1;
  pam70[135] = (int const   )-3;
  pam70[136] = (int const   )-3;
  pam70[137] = (int const   )-8;
  pam70[138] = (int const   )-8;
  pam70[139] = (int const   )-4;
  pam70[140] = (int const   )-1;
  pam70[141] = (int const   )5;
  pam70[142] = (int const   )-2;
  pam70[143] = (int const   )-11;
  pam70[144] = (int const   )-1;
  pam70[145] = (int const   )-5;
  pam70[146] = (int const   )0;
  pam70[147] = (int const   )3;
  pam70[148] = (int const   )-9;
  pam70[149] = (int const   )2;
  pam70[150] = (int const   )6;
  pam70[151] = (int const   )-2;
  pam70[152] = (int const   )-2;
  pam70[153] = (int const   )-4;
  pam70[154] = (int const   )-6;
  pam70[155] = (int const   )-2;
  pam70[156] = (int const   )-4;
  pam70[157] = (int const   )-9;
  pam70[158] = (int const   )-3;
  pam70[159] = (int const   )-2;
  pam70[160] = (int const   )-3;
  pam70[161] = (int const   )-11;
  pam70[162] = (int const   )-6;
  pam70[163] = (int const   )-4;
  pam70[164] = (int const   )2;
  pam70[165] = (int const   )5;
  pam70[166] = (int const   )-3;
  pam70[167] = (int const   )-11;
  pam70[168] = (int const   )0;
  pam70[169] = (int const   )-6;
  pam70[170] = (int const   )-1;
  pam70[171] = (int const   )-1;
  pam70[172] = (int const   )-6;
  pam70[173] = (int const   )-4;
  pam70[174] = (int const   )-2;
  pam70[175] = (int const   )6;
  pam70[176] = (int const   )-6;
  pam70[177] = (int const   )-6;
  pam70[178] = (int const   )-7;
  pam70[179] = (int const   )-5;
  pam70[180] = (int const   )-6;
  pam70[181] = (int const   )-7;
  pam70[182] = (int const   )-3;
  pam70[183] = (int const   )0;
  pam70[184] = (int const   )-3;
  pam70[185] = (int const   )-10;
  pam70[186] = (int const   )-9;
  pam70[187] = (int const   )-3;
  pam70[188] = (int const   )-1;
  pam70[189] = (int const   )-3;
  pam70[190] = (int const   )-3;
  pam70[191] = (int const   )-11;
  pam70[192] = (int const   )-4;
  pam70[193] = (int const   )0;
  pam70[194] = (int const   )1;
  pam70[195] = (int const   )-1;
  pam70[196] = (int const   )-5;
  pam70[197] = (int const   )2;
  pam70[198] = (int const   )-2;
  pam70[199] = (int const   )-6;
  pam70[200] = (int const   )8;
  pam70[201] = (int const   )-6;
  pam70[202] = (int const   )-4;
  pam70[203] = (int const   )-3;
  pam70[204] = (int const   )-6;
  pam70[205] = (int const   )-4;
  pam70[206] = (int const   )-2;
  pam70[207] = (int const   )-3;
  pam70[208] = (int const   )-4;
  pam70[209] = (int const   )-5;
  pam70[210] = (int const   )-1;
  pam70[211] = (int const   )-4;
  pam70[212] = (int const   )0;
  pam70[213] = (int const   )1;
  pam70[214] = (int const   )-3;
  pam70[215] = (int const   )-11;
  pam70[216] = (int const   )-2;
  pam70[217] = (int const   )-3;
  pam70[218] = (int const   )-3;
  pam70[219] = (int const   )-5;
  pam70[220] = (int const   )-4;
  pam70[221] = (int const   )-5;
  pam70[222] = (int const   )-4;
  pam70[223] = (int const   )-6;
  pam70[224] = (int const   )-6;
  pam70[225] = (int const   )7;
  pam70[226] = (int const   )1;
  pam70[227] = (int const   )-4;
  pam70[228] = (int const   )1;
  pam70[229] = (int const   )0;
  pam70[230] = (int const   )-5;
  pam70[231] = (int const   )-4;
  pam70[232] = (int const   )-1;
  pam70[233] = (int const   )-9;
  pam70[234] = (int const   )-4;
  pam70[235] = (int const   )3;
  pam70[236] = (int const   )-4;
  pam70[237] = (int const   )-4;
  pam70[238] = (int const   )-3;
  pam70[239] = (int const   )-11;
  pam70[240] = (int const   )-4;
  pam70[241] = (int const   )-6;
  pam70[242] = (int const   )-5;
  pam70[243] = (int const   )-8;
  pam70[244] = (int const   )-10;
  pam70[245] = (int const   )-3;
  pam70[246] = (int const   )-6;
  pam70[247] = (int const   )-7;
  pam70[248] = (int const   )-4;
  pam70[249] = (int const   )1;
  pam70[250] = (int const   )6;
  pam70[251] = (int const   )-5;
  pam70[252] = (int const   )2;
  pam70[253] = (int const   )-1;
  pam70[254] = (int const   )-5;
  pam70[255] = (int const   )-6;
  pam70[256] = (int const   )-4;
  pam70[257] = (int const   )-4;
  pam70[258] = (int const   )-4;
  pam70[259] = (int const   )0;
  pam70[260] = (int const   )-6;
  pam70[261] = (int const   )-4;
  pam70[262] = (int const   )-4;
  pam70[263] = (int const   )-11;
  pam70[264] = (int const   )-4;
  pam70[265] = (int const   )2;
  pam70[266] = (int const   )0;
  pam70[267] = (int const   )-2;
  pam70[268] = (int const   )-9;
  pam70[269] = (int const   )-1;
  pam70[270] = (int const   )-2;
  pam70[271] = (int const   )-5;
  pam70[272] = (int const   )-3;
  pam70[273] = (int const   )-4;
  pam70[274] = (int const   )-5;
  pam70[275] = (int const   )6;
  pam70[276] = (int const   )0;
  pam70[277] = (int const   )-9;
  pam70[278] = (int const   )-4;
  pam70[279] = (int const   )-2;
  pam70[280] = (int const   )-1;
  pam70[281] = (int const   )-7;
  pam70[282] = (int const   )-7;
  pam70[283] = (int const   )-6;
  pam70[284] = (int const   )-1;
  pam70[285] = (int const   )-2;
  pam70[286] = (int const   )-3;
  pam70[287] = (int const   )-11;
  pam70[288] = (int const   )-3;
  pam70[289] = (int const   )-2;
  pam70[290] = (int const   )-5;
  pam70[291] = (int const   )-7;
  pam70[292] = (int const   )-9;
  pam70[293] = (int const   )-2;
  pam70[294] = (int const   )-4;
  pam70[295] = (int const   )-6;
  pam70[296] = (int const   )-6;
  pam70[297] = (int const   )1;
  pam70[298] = (int const   )2;
  pam70[299] = (int const   )0;
  pam70[300] = (int const   )10;
  pam70[301] = (int const   )-2;
  pam70[302] = (int const   )-5;
  pam70[303] = (int const   )-3;
  pam70[304] = (int const   )-2;
  pam70[305] = (int const   )-8;
  pam70[306] = (int const   )-7;
  pam70[307] = (int const   )0;
  pam70[308] = (int const   )-6;
  pam70[309] = (int const   )-3;
  pam70[310] = (int const   )-3;
  pam70[311] = (int const   )-11;
  pam70[312] = (int const   )-6;
  pam70[313] = (int const   )-7;
  pam70[314] = (int const   )-6;
  pam70[315] = (int const   )-10;
  pam70[316] = (int const   )-8;
  pam70[317] = (int const   )-9;
  pam70[318] = (int const   )-9;
  pam70[319] = (int const   )-7;
  pam70[320] = (int const   )-4;
  pam70[321] = (int const   )0;
  pam70[322] = (int const   )-1;
  pam70[323] = (int const   )-9;
  pam70[324] = (int const   )-2;
  pam70[325] = (int const   )8;
  pam70[326] = (int const   )-7;
  pam70[327] = (int const   )-4;
  pam70[328] = (int const   )-6;
  pam70[329] = (int const   )-2;
  pam70[330] = (int const   )4;
  pam70[331] = (int const   )-5;
  pam70[332] = (int const   )-7;
  pam70[333] = (int const   )-9;
  pam70[334] = (int const   )-5;
  pam70[335] = (int const   )-11;
  pam70[336] = (int const   )0;
  pam70[337] = (int const   )-2;
  pam70[338] = (int const   )-3;
  pam70[339] = (int const   )-4;
  pam70[340] = (int const   )-5;
  pam70[341] = (int const   )-1;
  pam70[342] = (int const   )-3;
  pam70[343] = (int const   )-3;
  pam70[344] = (int const   )-2;
  pam70[345] = (int const   )-5;
  pam70[346] = (int const   )-5;
  pam70[347] = (int const   )-4;
  pam70[348] = (int const   )-5;
  pam70[349] = (int const   )-7;
  pam70[350] = (int const   )7;
  pam70[351] = (int const   )0;
  pam70[352] = (int const   )-2;
  pam70[353] = (int const   )-9;
  pam70[354] = (int const   )-9;
  pam70[355] = (int const   )-3;
  pam70[356] = (int const   )-4;
  pam70[357] = (int const   )-2;
  pam70[358] = (int const   )-3;
  pam70[359] = (int const   )-11;
  pam70[360] = (int const   )1;
  pam70[361] = (int const   )-1;
  pam70[362] = (int const   )1;
  pam70[363] = (int const   )-1;
  pam70[364] = (int const   )-1;
  pam70[365] = (int const   )-3;
  pam70[366] = (int const   )-2;
  pam70[367] = (int const   )0;
  pam70[368] = (int const   )-3;
  pam70[369] = (int const   )-4;
  pam70[370] = (int const   )-6;
  pam70[371] = (int const   )-2;
  pam70[372] = (int const   )-3;
  pam70[373] = (int const   )-4;
  pam70[374] = (int const   )0;
  pam70[375] = (int const   )5;
  pam70[376] = (int const   )2;
  pam70[377] = (int const   )-3;
  pam70[378] = (int const   )-5;
  pam70[379] = (int const   )-3;
  pam70[380] = (int const   )0;
  pam70[381] = (int const   )-2;
  pam70[382] = (int const   )-1;
  pam70[383] = (int const   )-11;
  pam70[384] = (int const   )1;
  pam70[385] = (int const   )-4;
  pam70[386] = (int const   )0;
  pam70[387] = (int const   )-2;
  pam70[388] = (int const   )-5;
  pam70[389] = (int const   )-3;
  pam70[390] = (int const   )-3;
  pam70[391] = (int const   )-3;
  pam70[392] = (int const   )-4;
  pam70[393] = (int const   )-1;
  pam70[394] = (int const   )-4;
  pam70[395] = (int const   )-1;
  pam70[396] = (int const   )-2;
  pam70[397] = (int const   )-6;
  pam70[398] = (int const   )-2;
  pam70[399] = (int const   )2;
  pam70[400] = (int const   )6;
  pam70[401] = (int const   )-8;
  pam70[402] = (int const   )-4;
  pam70[403] = (int const   )-1;
  pam70[404] = (int const   )-1;
  pam70[405] = (int const   )-3;
  pam70[406] = (int const   )-2;
  pam70[407] = (int const   )-11;
  pam70[408] = (int const   )-9;
  pam70[409] = (int const   )0;
  pam70[410] = (int const   )-6;
  pam70[411] = (int const   )-10;
  pam70[412] = (int const   )-11;
  pam70[413] = (int const   )-8;
  pam70[414] = (int const   )-11;
  pam70[415] = (int const   )-10;
  pam70[416] = (int const   )-5;
  pam70[417] = (int const   )-9;
  pam70[418] = (int const   )-4;
  pam70[419] = (int const   )-7;
  pam70[420] = (int const   )-8;
  pam70[421] = (int const   )-2;
  pam70[422] = (int const   )-9;
  pam70[423] = (int const   )-3;
  pam70[424] = (int const   )-8;
  pam70[425] = (int const   )13;
  pam70[426] = (int const   )-3;
  pam70[427] = (int const   )-10;
  pam70[428] = (int const   )-7;
  pam70[429] = (int const   )-10;
  pam70[430] = (int const   )-7;
  pam70[431] = (int const   )-11;
  pam70[432] = (int const   )-5;
  pam70[433] = (int const   )-7;
  pam70[434] = (int const   )-3;
  pam70[435] = (int const   )-7;
  pam70[436] = (int const   )-2;
  pam70[437] = (int const   )-8;
  pam70[438] = (int const   )-6;
  pam70[439] = (int const   )-9;
  pam70[440] = (int const   )-1;
  pam70[441] = (int const   )-4;
  pam70[442] = (int const   )-4;
  pam70[443] = (int const   )-7;
  pam70[444] = (int const   )-7;
  pam70[445] = (int const   )4;
  pam70[446] = (int const   )-9;
  pam70[447] = (int const   )-5;
  pam70[448] = (int const   )-4;
  pam70[449] = (int const   )-3;
  pam70[450] = (int const   )9;
  pam70[451] = (int const   )-5;
  pam70[452] = (int const   )-4;
  pam70[453] = (int const   )-7;
  pam70[454] = (int const   )-5;
  pam70[455] = (int const   )-11;
  pam70[456] = (int const   )-1;
  pam70[457] = (int const   )-5;
  pam70[458] = (int const   )-5;
  pam70[459] = (int const   )-5;
  pam70[460] = (int const   )-4;
  pam70[461] = (int const   )-4;
  pam70[462] = (int const   )-4;
  pam70[463] = (int const   )-3;
  pam70[464] = (int const   )-4;
  pam70[465] = (int const   )3;
  pam70[466] = (int const   )0;
  pam70[467] = (int const   )-6;
  pam70[468] = (int const   )0;
  pam70[469] = (int const   )-5;
  pam70[470] = (int const   )-3;
  pam70[471] = (int const   )-3;
  pam70[472] = (int const   )-1;
  pam70[473] = (int const   )-10;
  pam70[474] = (int const   )-5;
  pam70[475] = (int const   )6;
  pam70[476] = (int const   )-5;
  pam70[477] = (int const   )-4;
  pam70[478] = (int const   )-2;
  pam70[479] = (int const   )-11;
  pam70[480] = (int const   )-1;
  pam70[481] = (int const   )-4;
  pam70[482] = (int const   )5;
  pam70[483] = (int const   )5;
  pam70[484] = (int const   )-8;
  pam70[485] = (int const   )-1;
  pam70[486] = (int const   )2;
  pam70[487] = (int const   )-1;
  pam70[488] = (int const   )0;
  pam70[489] = (int const   )-4;
  pam70[490] = (int const   )-6;
  pam70[491] = (int const   )-1;
  pam70[492] = (int const   )-6;
  pam70[493] = (int const   )-7;
  pam70[494] = (int const   )-4;
  pam70[495] = (int const   )0;
  pam70[496] = (int const   )-1;
  pam70[497] = (int const   )-7;
  pam70[498] = (int const   )-4;
  pam70[499] = (int const   )-5;
  pam70[500] = (int const   )5;
  pam70[501] = (int const   )1;
  pam70[502] = (int const   )-2;
  pam70[503] = (int const   )-11;
  pam70[504] = (int const   )-1;
  pam70[505] = (int const   )-2;
  pam70[506] = (int const   )-1;
  pam70[507] = (int const   )2;
  pam70[508] = (int const   )-9;
  pam70[509] = (int const   )5;
  pam70[510] = (int const   )5;
  pam70[511] = (int const   )-3;
  pam70[512] = (int const   )1;
  pam70[513] = (int const   )-4;
  pam70[514] = (int const   )-4;
  pam70[515] = (int const   )-2;
  pam70[516] = (int const   )-3;
  pam70[517] = (int const   )-9;
  pam70[518] = (int const   )-2;
  pam70[519] = (int const   )-2;
  pam70[520] = (int const   )-3;
  pam70[521] = (int const   )-10;
  pam70[522] = (int const   )-7;
  pam70[523] = (int const   )-4;
  pam70[524] = (int const   )1;
  pam70[525] = (int const   )5;
  pam70[526] = (int const   )-3;
  pam70[527] = (int const   )-11;
  pam70[528] = (int const   )-2;
  pam70[529] = (int const   )-3;
  pam70[530] = (int const   )-2;
  pam70[531] = (int const   )-3;
  pam70[532] = (int const   )-6;
  pam70[533] = (int const   )-2;
  pam70[534] = (int const   )-3;
  pam70[535] = (int const   )-3;
  pam70[536] = (int const   )-3;
  pam70[537] = (int const   )-3;
  pam70[538] = (int const   )-4;
  pam70[539] = (int const   )-3;
  pam70[540] = (int const   )-3;
  pam70[541] = (int const   )-5;
  pam70[542] = (int const   )-3;
  pam70[543] = (int const   )-1;
  pam70[544] = (int const   )-2;
  pam70[545] = (int const   )-7;
  pam70[546] = (int const   )-5;
  pam70[547] = (int const   )-2;
  pam70[548] = (int const   )-2;
  pam70[549] = (int const   )-3;
  pam70[550] = (int const   )-3;
  pam70[551] = (int const   )-11;
  pam70[552] = (int const   )-11;
  pam70[553] = (int const   )-11;
  pam70[554] = (int const   )-11;
  pam70[555] = (int const   )-11;
  pam70[556] = (int const   )-11;
  pam70[557] = (int const   )-11;
  pam70[558] = (int const   )-11;
  pam70[559] = (int const   )-11;
  pam70[560] = (int const   )-11;
  pam70[561] = (int const   )-11;
  pam70[562] = (int const   )-11;
  pam70[563] = (int const   )-11;
  pam70[564] = (int const   )-11;
  pam70[565] = (int const   )-11;
  pam70[566] = (int const   )-11;
  pam70[567] = (int const   )-11;
  pam70[568] = (int const   )-11;
  pam70[569] = (int const   )-11;
  pam70[570] = (int const   )-11;
  pam70[571] = (int const   )-11;
  pam70[572] = (int const   )-11;
  pam70[573] = (int const   )-11;
  pam70[574] = (int const   )-11;
  pam70[575] = (int const   )1;
  goto pam70_i$nit_INLINE_pam70_i$nit;
  }
  pam70_i$nit_INLINE_pam70_i$nit: /* CIL Label */ ;
  }
  {
  {
  pam30[0] = (int const   )6;
  pam30[1] = (int const   )-7;
  pam30[2] = (int const   )-4;
  pam30[3] = (int const   )-3;
  pam30[4] = (int const   )-6;
  pam30[5] = (int const   )-4;
  pam30[6] = (int const   )-2;
  pam30[7] = (int const   )-2;
  pam30[8] = (int const   )-7;
  pam30[9] = (int const   )-5;
  pam30[10] = (int const   )-6;
  pam30[11] = (int const   )-7;
  pam30[12] = (int const   )-5;
  pam30[13] = (int const   )-8;
  pam30[14] = (int const   )-2;
  pam30[15] = (int const   )0;
  pam30[16] = (int const   )-1;
  pam30[17] = (int const   )-13;
  pam30[18] = (int const   )-8;
  pam30[19] = (int const   )-2;
  pam30[20] = (int const   )-3;
  pam30[21] = (int const   )-3;
  pam30[22] = (int const   )-3;
  pam30[23] = (int const   )-17;
  pam30[24] = (int const   )-7;
  pam30[25] = (int const   )8;
  pam30[26] = (int const   )-6;
  pam30[27] = (int const   )-10;
  pam30[28] = (int const   )-8;
  pam30[29] = (int const   )-2;
  pam30[30] = (int const   )-9;
  pam30[31] = (int const   )-9;
  pam30[32] = (int const   )-2;
  pam30[33] = (int const   )-5;
  pam30[34] = (int const   )-8;
  pam30[35] = (int const   )0;
  pam30[36] = (int const   )-4;
  pam30[37] = (int const   )-9;
  pam30[38] = (int const   )-4;
  pam30[39] = (int const   )-3;
  pam30[40] = (int const   )-6;
  pam30[41] = (int const   )-2;
  pam30[42] = (int const   )-10;
  pam30[43] = (int const   )-8;
  pam30[44] = (int const   )-7;
  pam30[45] = (int const   )-4;
  pam30[46] = (int const   )-6;
  pam30[47] = (int const   )-17;
  pam30[48] = (int const   )-4;
  pam30[49] = (int const   )-6;
  pam30[50] = (int const   )8;
  pam30[51] = (int const   )2;
  pam30[52] = (int const   )-11;
  pam30[53] = (int const   )-3;
  pam30[54] = (int const   )-2;
  pam30[55] = (int const   )-3;
  pam30[56] = (int const   )0;
  pam30[57] = (int const   )-5;
  pam30[58] = (int const   )-7;
  pam30[59] = (int const   )-1;
  pam30[60] = (int const   )-9;
  pam30[61] = (int const   )-9;
  pam30[62] = (int const   )-6;
  pam30[63] = (int const   )0;
  pam30[64] = (int const   )-2;
  pam30[65] = (int const   )-8;
  pam30[66] = (int const   )-4;
  pam30[67] = (int const   )-8;
  pam30[68] = (int const   )6;
  pam30[69] = (int const   )-3;
  pam30[70] = (int const   )-3;
  pam30[71] = (int const   )-17;
  pam30[72] = (int const   )-3;
  pam30[73] = (int const   )-10;
  pam30[74] = (int const   )2;
  pam30[75] = (int const   )8;
  pam30[76] = (int const   )-14;
  pam30[77] = (int const   )-2;
  pam30[78] = (int const   )2;
  pam30[79] = (int const   )-3;
  pam30[80] = (int const   )-4;
  pam30[81] = (int const   )-7;
  pam30[82] = (int const   )-12;
  pam30[83] = (int const   )-4;
  pam30[84] = (int const   )-11;
  pam30[85] = (int const   )-15;
  pam30[86] = (int const   )-8;
  pam30[87] = (int const   )-4;
  pam30[88] = (int const   )-5;
  pam30[89] = (int const   )-15;
  pam30[90] = (int const   )-11;
  pam30[91] = (int const   )-8;
  pam30[92] = (int const   )6;
  pam30[93] = (int const   )1;
  pam30[94] = (int const   )-5;
  pam30[95] = (int const   )-17;
  pam30[96] = (int const   )-6;
  pam30[97] = (int const   )-8;
  pam30[98] = (int const   )-11;
  pam30[99] = (int const   )-14;
  pam30[100] = (int const   )10;
  pam30[101] = (int const   )-14;
  pam30[102] = (int const   )-14;
  pam30[103] = (int const   )-9;
  pam30[104] = (int const   )-7;
  pam30[105] = (int const   )-6;
  pam30[106] = (int const   )-15;
  pam30[107] = (int const   )-14;
  pam30[108] = (int const   )-13;
  pam30[109] = (int const   )-13;
  pam30[110] = (int const   )-8;
  pam30[111] = (int const   )-3;
  pam30[112] = (int const   )-8;
  pam30[113] = (int const   )-15;
  pam30[114] = (int const   )-4;
  pam30[115] = (int const   )-6;
  pam30[116] = (int const   )-12;
  pam30[117] = (int const   )-14;
  pam30[118] = (int const   )-9;
  pam30[119] = (int const   )-17;
  pam30[120] = (int const   )-4;
  pam30[121] = (int const   )-2;
  pam30[122] = (int const   )-3;
  pam30[123] = (int const   )-2;
  pam30[124] = (int const   )-14;
  pam30[125] = (int const   )8;
  pam30[126] = (int const   )1;
  pam30[127] = (int const   )-7;
  pam30[128] = (int const   )1;
  pam30[129] = (int const   )-8;
  pam30[130] = (int const   )-5;
  pam30[131] = (int const   )-3;
  pam30[132] = (int const   )-4;
  pam30[133] = (int const   )-13;
  pam30[134] = (int const   )-3;
  pam30[135] = (int const   )-5;
  pam30[136] = (int const   )-5;
  pam30[137] = (int const   )-13;
  pam30[138] = (int const   )-12;
  pam30[139] = (int const   )-7;
  pam30[140] = (int const   )-3;
  pam30[141] = (int const   )6;
  pam30[142] = (int const   )-5;
  pam30[143] = (int const   )-17;
  pam30[144] = (int const   )-2;
  pam30[145] = (int const   )-9;
  pam30[146] = (int const   )-2;
  pam30[147] = (int const   )2;
  pam30[148] = (int const   )-14;
  pam30[149] = (int const   )1;
  pam30[150] = (int const   )8;
  pam30[151] = (int const   )-4;
  pam30[152] = (int const   )-5;
  pam30[153] = (int const   )-5;
  pam30[154] = (int const   )-9;
  pam30[155] = (int const   )-4;
  pam30[156] = (int const   )-7;
  pam30[157] = (int const   )-14;
  pam30[158] = (int const   )-5;
  pam30[159] = (int const   )-4;
  pam30[160] = (int const   )-6;
  pam30[161] = (int const   )-17;
  pam30[162] = (int const   )-8;
  pam30[163] = (int const   )-6;
  pam30[164] = (int const   )1;
  pam30[165] = (int const   )6;
  pam30[166] = (int const   )-5;
  pam30[167] = (int const   )-17;
  pam30[168] = (int const   )-2;
  pam30[169] = (int const   )-9;
  pam30[170] = (int const   )-3;
  pam30[171] = (int const   )-3;
  pam30[172] = (int const   )-9;
  pam30[173] = (int const   )-7;
  pam30[174] = (int const   )-4;
  pam30[175] = (int const   )6;
  pam30[176] = (int const   )-9;
  pam30[177] = (int const   )-11;
  pam30[178] = (int const   )-10;
  pam30[179] = (int const   )-7;
  pam30[180] = (int const   )-8;
  pam30[181] = (int const   )-9;
  pam30[182] = (int const   )-6;
  pam30[183] = (int const   )-2;
  pam30[184] = (int const   )-6;
  pam30[185] = (int const   )-15;
  pam30[186] = (int const   )-14;
  pam30[187] = (int const   )-5;
  pam30[188] = (int const   )-3;
  pam30[189] = (int const   )-5;
  pam30[190] = (int const   )-5;
  pam30[191] = (int const   )-17;
  pam30[192] = (int const   )-7;
  pam30[193] = (int const   )-2;
  pam30[194] = (int const   )0;
  pam30[195] = (int const   )-4;
  pam30[196] = (int const   )-7;
  pam30[197] = (int const   )1;
  pam30[198] = (int const   )-5;
  pam30[199] = (int const   )-9;
  pam30[200] = (int const   )9;
  pam30[201] = (int const   )-9;
  pam30[202] = (int const   )-6;
  pam30[203] = (int const   )-6;
  pam30[204] = (int const   )-10;
  pam30[205] = (int const   )-6;
  pam30[206] = (int const   )-4;
  pam30[207] = (int const   )-6;
  pam30[208] = (int const   )-7;
  pam30[209] = (int const   )-7;
  pam30[210] = (int const   )-3;
  pam30[211] = (int const   )-6;
  pam30[212] = (int const   )-1;
  pam30[213] = (int const   )-1;
  pam30[214] = (int const   )-5;
  pam30[215] = (int const   )-17;
  pam30[216] = (int const   )-5;
  pam30[217] = (int const   )-5;
  pam30[218] = (int const   )-5;
  pam30[219] = (int const   )-7;
  pam30[220] = (int const   )-6;
  pam30[221] = (int const   )-8;
  pam30[222] = (int const   )-5;
  pam30[223] = (int const   )-11;
  pam30[224] = (int const   )-9;
  pam30[225] = (int const   )8;
  pam30[226] = (int const   )-1;
  pam30[227] = (int const   )-6;
  pam30[228] = (int const   )-1;
  pam30[229] = (int const   )-2;
  pam30[230] = (int const   )-8;
  pam30[231] = (int const   )-7;
  pam30[232] = (int const   )-2;
  pam30[233] = (int const   )-14;
  pam30[234] = (int const   )-6;
  pam30[235] = (int const   )2;
  pam30[236] = (int const   )-6;
  pam30[237] = (int const   )-6;
  pam30[238] = (int const   )-5;
  pam30[239] = (int const   )-17;
  pam30[240] = (int const   )-6;
  pam30[241] = (int const   )-8;
  pam30[242] = (int const   )-7;
  pam30[243] = (int const   )-12;
  pam30[244] = (int const   )-15;
  pam30[245] = (int const   )-5;
  pam30[246] = (int const   )-9;
  pam30[247] = (int const   )-10;
  pam30[248] = (int const   )-6;
  pam30[249] = (int const   )-1;
  pam30[250] = (int const   )7;
  pam30[251] = (int const   )-8;
  pam30[252] = (int const   )1;
  pam30[253] = (int const   )-3;
  pam30[254] = (int const   )-7;
  pam30[255] = (int const   )-8;
  pam30[256] = (int const   )-7;
  pam30[257] = (int const   )-6;
  pam30[258] = (int const   )-7;
  pam30[259] = (int const   )-2;
  pam30[260] = (int const   )-9;
  pam30[261] = (int const   )-7;
  pam30[262] = (int const   )-6;
  pam30[263] = (int const   )-17;
  pam30[264] = (int const   )-7;
  pam30[265] = (int const   )0;
  pam30[266] = (int const   )-1;
  pam30[267] = (int const   )-4;
  pam30[268] = (int const   )-14;
  pam30[269] = (int const   )-3;
  pam30[270] = (int const   )-4;
  pam30[271] = (int const   )-7;
  pam30[272] = (int const   )-6;
  pam30[273] = (int const   )-6;
  pam30[274] = (int const   )-8;
  pam30[275] = (int const   )7;
  pam30[276] = (int const   )-2;
  pam30[277] = (int const   )-14;
  pam30[278] = (int const   )-6;
  pam30[279] = (int const   )-4;
  pam30[280] = (int const   )-3;
  pam30[281] = (int const   )-12;
  pam30[282] = (int const   )-9;
  pam30[283] = (int const   )-9;
  pam30[284] = (int const   )-2;
  pam30[285] = (int const   )-4;
  pam30[286] = (int const   )-5;
  pam30[287] = (int const   )-17;
  pam30[288] = (int const   )-5;
  pam30[289] = (int const   )-4;
  pam30[290] = (int const   )-9;
  pam30[291] = (int const   )-11;
  pam30[292] = (int const   )-13;
  pam30[293] = (int const   )-4;
  pam30[294] = (int const   )-7;
  pam30[295] = (int const   )-8;
  pam30[296] = (int const   )-10;
  pam30[297] = (int const   )-1;
  pam30[298] = (int const   )1;
  pam30[299] = (int const   )-2;
  pam30[300] = (int const   )11;
  pam30[301] = (int const   )-4;
  pam30[302] = (int const   )-8;
  pam30[303] = (int const   )-5;
  pam30[304] = (int const   )-4;
  pam30[305] = (int const   )-13;
  pam30[306] = (int const   )-11;
  pam30[307] = (int const   )-1;
  pam30[308] = (int const   )-10;
  pam30[309] = (int const   )-5;
  pam30[310] = (int const   )-5;
  pam30[311] = (int const   )-17;
  pam30[312] = (int const   )-8;
  pam30[313] = (int const   )-9;
  pam30[314] = (int const   )-9;
  pam30[315] = (int const   )-15;
  pam30[316] = (int const   )-13;
  pam30[317] = (int const   )-13;
  pam30[318] = (int const   )-14;
  pam30[319] = (int const   )-9;
  pam30[320] = (int const   )-6;
  pam30[321] = (int const   )-2;
  pam30[322] = (int const   )-3;
  pam30[323] = (int const   )-14;
  pam30[324] = (int const   )-4;
  pam30[325] = (int const   )9;
  pam30[326] = (int const   )-10;
  pam30[327] = (int const   )-6;
  pam30[328] = (int const   )-9;
  pam30[329] = (int const   )-4;
  pam30[330] = (int const   )2;
  pam30[331] = (int const   )-8;
  pam30[332] = (int const   )-10;
  pam30[333] = (int const   )-13;
  pam30[334] = (int const   )-8;
  pam30[335] = (int const   )-17;
  pam30[336] = (int const   )-2;
  pam30[337] = (int const   )-4;
  pam30[338] = (int const   )-6;
  pam30[339] = (int const   )-8;
  pam30[340] = (int const   )-8;
  pam30[341] = (int const   )-3;
  pam30[342] = (int const   )-5;
  pam30[343] = (int const   )-6;
  pam30[344] = (int const   )-4;
  pam30[345] = (int const   )-8;
  pam30[346] = (int const   )-7;
  pam30[347] = (int const   )-6;
  pam30[348] = (int const   )-8;
  pam30[349] = (int const   )-10;
  pam30[350] = (int const   )8;
  pam30[351] = (int const   )-2;
  pam30[352] = (int const   )-4;
  pam30[353] = (int const   )-14;
  pam30[354] = (int const   )-13;
  pam30[355] = (int const   )-6;
  pam30[356] = (int const   )-7;
  pam30[357] = (int const   )-4;
  pam30[358] = (int const   )-5;
  pam30[359] = (int const   )-17;
  pam30[360] = (int const   )0;
  pam30[361] = (int const   )-3;
  pam30[362] = (int const   )0;
  pam30[363] = (int const   )-4;
  pam30[364] = (int const   )-3;
  pam30[365] = (int const   )-5;
  pam30[366] = (int const   )-4;
  pam30[367] = (int const   )-2;
  pam30[368] = (int const   )-6;
  pam30[369] = (int const   )-7;
  pam30[370] = (int const   )-8;
  pam30[371] = (int const   )-4;
  pam30[372] = (int const   )-5;
  pam30[373] = (int const   )-6;
  pam30[374] = (int const   )-2;
  pam30[375] = (int const   )6;
  pam30[376] = (int const   )0;
  pam30[377] = (int const   )-5;
  pam30[378] = (int const   )-7;
  pam30[379] = (int const   )-6;
  pam30[380] = (int const   )-1;
  pam30[381] = (int const   )-5;
  pam30[382] = (int const   )-3;
  pam30[383] = (int const   )-17;
  pam30[384] = (int const   )-1;
  pam30[385] = (int const   )-6;
  pam30[386] = (int const   )-2;
  pam30[387] = (int const   )-5;
  pam30[388] = (int const   )-8;
  pam30[389] = (int const   )-5;
  pam30[390] = (int const   )-6;
  pam30[391] = (int const   )-6;
  pam30[392] = (int const   )-7;
  pam30[393] = (int const   )-2;
  pam30[394] = (int const   )-7;
  pam30[395] = (int const   )-3;
  pam30[396] = (int const   )-4;
  pam30[397] = (int const   )-9;
  pam30[398] = (int const   )-4;
  pam30[399] = (int const   )0;
  pam30[400] = (int const   )7;
  pam30[401] = (int const   )-13;
  pam30[402] = (int const   )-6;
  pam30[403] = (int const   )-3;
  pam30[404] = (int const   )-3;
  pam30[405] = (int const   )-6;
  pam30[406] = (int const   )-4;
  pam30[407] = (int const   )-17;
  pam30[408] = (int const   )-13;
  pam30[409] = (int const   )-2;
  pam30[410] = (int const   )-8;
  pam30[411] = (int const   )-15;
  pam30[412] = (int const   )-15;
  pam30[413] = (int const   )-13;
  pam30[414] = (int const   )-17;
  pam30[415] = (int const   )-15;
  pam30[416] = (int const   )-7;
  pam30[417] = (int const   )-14;
  pam30[418] = (int const   )-6;
  pam30[419] = (int const   )-12;
  pam30[420] = (int const   )-13;
  pam30[421] = (int const   )-4;
  pam30[422] = (int const   )-14;
  pam30[423] = (int const   )-5;
  pam30[424] = (int const   )-13;
  pam30[425] = (int const   )13;
  pam30[426] = (int const   )-5;
  pam30[427] = (int const   )-15;
  pam30[428] = (int const   )-10;
  pam30[429] = (int const   )-14;
  pam30[430] = (int const   )-11;
  pam30[431] = (int const   )-17;
  pam30[432] = (int const   )-8;
  pam30[433] = (int const   )-10;
  pam30[434] = (int const   )-4;
  pam30[435] = (int const   )-11;
  pam30[436] = (int const   )-4;
  pam30[437] = (int const   )-12;
  pam30[438] = (int const   )-8;
  pam30[439] = (int const   )-14;
  pam30[440] = (int const   )-3;
  pam30[441] = (int const   )-6;
  pam30[442] = (int const   )-7;
  pam30[443] = (int const   )-9;
  pam30[444] = (int const   )-11;
  pam30[445] = (int const   )2;
  pam30[446] = (int const   )-13;
  pam30[447] = (int const   )-7;
  pam30[448] = (int const   )-6;
  pam30[449] = (int const   )-5;
  pam30[450] = (int const   )10;
  pam30[451] = (int const   )-7;
  pam30[452] = (int const   )-6;
  pam30[453] = (int const   )-9;
  pam30[454] = (int const   )-7;
  pam30[455] = (int const   )-17;
  pam30[456] = (int const   )-2;
  pam30[457] = (int const   )-8;
  pam30[458] = (int const   )-8;
  pam30[459] = (int const   )-8;
  pam30[460] = (int const   )-6;
  pam30[461] = (int const   )-7;
  pam30[462] = (int const   )-6;
  pam30[463] = (int const   )-5;
  pam30[464] = (int const   )-6;
  pam30[465] = (int const   )2;
  pam30[466] = (int const   )-2;
  pam30[467] = (int const   )-9;
  pam30[468] = (int const   )-1;
  pam30[469] = (int const   )-8;
  pam30[470] = (int const   )-6;
  pam30[471] = (int const   )-6;
  pam30[472] = (int const   )-3;
  pam30[473] = (int const   )-15;
  pam30[474] = (int const   )-7;
  pam30[475] = (int const   )7;
  pam30[476] = (int const   )-8;
  pam30[477] = (int const   )-6;
  pam30[478] = (int const   )-5;
  pam30[479] = (int const   )-17;
  pam30[480] = (int const   )-3;
  pam30[481] = (int const   )-7;
  pam30[482] = (int const   )6;
  pam30[483] = (int const   )6;
  pam30[484] = (int const   )-12;
  pam30[485] = (int const   )-3;
  pam30[486] = (int const   )1;
  pam30[487] = (int const   )-3;
  pam30[488] = (int const   )-1;
  pam30[489] = (int const   )-6;
  pam30[490] = (int const   )-9;
  pam30[491] = (int const   )-2;
  pam30[492] = (int const   )-10;
  pam30[493] = (int const   )-10;
  pam30[494] = (int const   )-7;
  pam30[495] = (int const   )-1;
  pam30[496] = (int const   )-3;
  pam30[497] = (int const   )-10;
  pam30[498] = (int const   )-6;
  pam30[499] = (int const   )-8;
  pam30[500] = (int const   )6;
  pam30[501] = (int const   )0;
  pam30[502] = (int const   )-5;
  pam30[503] = (int const   )-17;
  pam30[504] = (int const   )-3;
  pam30[505] = (int const   )-4;
  pam30[506] = (int const   )-3;
  pam30[507] = (int const   )1;
  pam30[508] = (int const   )-14;
  pam30[509] = (int const   )6;
  pam30[510] = (int const   )6;
  pam30[511] = (int const   )-5;
  pam30[512] = (int const   )-1;
  pam30[513] = (int const   )-6;
  pam30[514] = (int const   )-7;
  pam30[515] = (int const   )-4;
  pam30[516] = (int const   )-5;
  pam30[517] = (int const   )-13;
  pam30[518] = (int const   )-4;
  pam30[519] = (int const   )-5;
  pam30[520] = (int const   )-6;
  pam30[521] = (int const   )-14;
  pam30[522] = (int const   )-9;
  pam30[523] = (int const   )-6;
  pam30[524] = (int const   )0;
  pam30[525] = (int const   )6;
  pam30[526] = (int const   )-5;
  pam30[527] = (int const   )-17;
  pam30[528] = (int const   )-3;
  pam30[529] = (int const   )-6;
  pam30[530] = (int const   )-3;
  pam30[531] = (int const   )-5;
  pam30[532] = (int const   )-9;
  pam30[533] = (int const   )-5;
  pam30[534] = (int const   )-5;
  pam30[535] = (int const   )-5;
  pam30[536] = (int const   )-5;
  pam30[537] = (int const   )-5;
  pam30[538] = (int const   )-6;
  pam30[539] = (int const   )-5;
  pam30[540] = (int const   )-5;
  pam30[541] = (int const   )-8;
  pam30[542] = (int const   )-5;
  pam30[543] = (int const   )-3;
  pam30[544] = (int const   )-4;
  pam30[545] = (int const   )-11;
  pam30[546] = (int const   )-7;
  pam30[547] = (int const   )-5;
  pam30[548] = (int const   )-5;
  pam30[549] = (int const   )-5;
  pam30[550] = (int const   )-5;
  pam30[551] = (int const   )-17;
  pam30[552] = (int const   )-17;
  pam30[553] = (int const   )-17;
  pam30[554] = (int const   )-17;
  pam30[555] = (int const   )-17;
  pam30[556] = (int const   )-17;
  pam30[557] = (int const   )-17;
  pam30[558] = (int const   )-17;
  pam30[559] = (int const   )-17;
  pam30[560] = (int const   )-17;
  pam30[561] = (int const   )-17;
  pam30[562] = (int const   )-17;
  pam30[563] = (int const   )-17;
  pam30[564] = (int const   )-17;
  pam30[565] = (int const   )-17;
  pam30[566] = (int const   )-17;
  pam30[567] = (int const   )-17;
  pam30[568] = (int const   )-17;
  pam30[569] = (int const   )-17;
  pam30[570] = (int const   )-17;
  pam30[571] = (int const   )-17;
  pam30[572] = (int const   )-17;
  pam30[573] = (int const   )-17;
  pam30[574] = (int const   )-17;
  pam30[575] = (int const   )1;
  goto pam30_i$nit_INLINE_pam30_i$nit;
  }
  pam30_i$nit_INLINE_pam30_i$nit: /* CIL Label */ ;
  }
  {
  {
  amino_acids[0] = (char )'A';
  amino_acids[1] = (char )'R';
  amino_acids[2] = (char )'N';
  amino_acids[3] = (char )'D';
  amino_acids[4] = (char )'C';
  amino_acids[5] = (char )'Q';
  amino_acids[6] = (char )'E';
  amino_acids[7] = (char )'G';
  amino_acids[8] = (char )'H';
  amino_acids[9] = (char )'I';
  amino_acids[10] = (char )'L';
  amino_acids[11] = (char )'K';
  amino_acids[12] = (char )'M';
  amino_acids[13] = (char )'F';
  amino_acids[14] = (char )'P';
  amino_acids[15] = (char )'S';
  amino_acids[16] = (char )'T';
  amino_acids[17] = (char )'W';
  amino_acids[18] = (char )'Y';
  amino_acids[19] = (char )'V';
  amino_acids[20] = (char )'B';
  amino_acids[21] = (char )'Z';
  amino_acids[22] = (char )'X';
  amino_acids[23] = (char )'*';
  amino_acids[24] = (char )'\000';
  goto amino_acids_i$nit_INLINE_amino_acids_i$nit;
  }
  amino_acids_i$nit_INLINE_amino_acids_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto file_paths2_i$nit_INLINE_file_paths2_i$nit;
  }
  file_paths2_i$nit_INLINE_file_paths2_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto file_paths1_i$nit_INLINE_file_paths1_i$nit;
  }
  file_paths1_i$nit_INLINE_file_paths1_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto file_list_capacity_i$nit_INLINE_file_list_capacity_i$nit;
  }
  file_list_capacity_i$nit_INLINE_file_list_capacity_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto file_list_length_i$nit_INLINE_file_list_length_i$nit;
  }
  file_list_length_i$nit_INLINE_file_list_length_i$nit: /* CIL Label */ ;
  }
  {
  {
  align_col_stop[0] = (char const   )'\033';
  align_col_stop[1] = (char const   )'[';
  align_col_stop[2] = (char const   )'0';
  align_col_stop[3] = (char const   )'m';
  align_col_stop[4] = (char const   )'\000';
  goto align_col_stop_i$nit_INLINE_align_col_stop_i$nit;
  }
  align_col_stop_i$nit_INLINE_align_col_stop_i$nit: /* CIL Label */ ;
  }
  {
  {
  align_col_context[0] = (char const   )'\033';
  align_col_context[1] = (char const   )'[';
  align_col_context[2] = (char const   )'9';
  align_col_context[3] = (char const   )'5';
  align_col_context[4] = (char const   )'m';
  align_col_context[5] = (char const   )'\000';
  goto align_col_context_i$nit_INLINE_align_col_context_i$nit;
  }
  align_col_context_i$nit_INLINE_align_col_context_i$nit: /* CIL Label */ ;
  }
  {
  {
  align_col_indel[0] = (char const   )'\033';
  align_col_indel[1] = (char const   )'[';
  align_col_indel[2] = (char const   )'9';
  align_col_indel[3] = (char const   )'1';
  align_col_indel[4] = (char const   )'m';
  align_col_indel[5] = (char const   )'\000';
  goto align_col_indel_i$nit_INLINE_align_col_indel_i$nit;
  }
  align_col_indel_i$nit_INLINE_align_col_indel_i$nit: /* CIL Label */ ;
  }
  {
  {
  align_col_mismatch[0] = (char const   )'\033';
  align_col_mismatch[1] = (char const   )'[';
  align_col_mismatch[2] = (char const   )'9';
  align_col_mismatch[3] = (char const   )'2';
  align_col_mismatch[4] = (char const   )'m';
  align_col_mismatch[5] = (char const   )'\000';
  goto align_col_mismatch_i$nit_INLINE_align_col_mismatch_i$nit;
  }
  align_col_mismatch_i$nit_INLINE_align_col_mismatch_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_envp_i$nit_INLINE__global_envp_i$nit;
  }
  _global_envp_i$nit_INLINE__global_envp_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argv_i$nit_INLINE__global_argv_i$nit;
  }
  _global_argv_i$nit_INLINE__global_argv_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argc_i$nit_INLINE__global_argc_i$nit;
  }
  _global_argc_i$nit_INLINE__global_argc_i$nit: /* CIL Label */ ;
  }
  goto megaInit_INLINE_megaInit;
  }
  megaInit_INLINE_megaInit: /* CIL Label */ ;
  }
  _global_argc = argc;
  _global_argv = argv;
  _global_envp = _formal_envp;
  _BARRIER_0 = 1;
  {
  _1_main_next = 8U;
  }
  while (1) {
    switch (_1_main_next) {
    case 4: ;
    if ((unsigned long )file2 == (unsigned long )((void *)0)) {
      {
      _1_main_next = 7U;
      }
    } else {
      {
      _1_main_next = 6U;
      }
    }
    break;
    case 14: ;
    if ((unsigned long )cmd->seq1 != (unsigned long )((void *)0)) {
      {
      _1_main_next = 2U;
      }
    } else {
      {
      _1_main_next = 13U;
      }
    }
    break;
    case 12: ;
    return (0);
    break;
    case 8: 
    sw_set_default_scoring();
    cmd = cmdline_new(argc, argv, & scoring, (enum SeqAlignCmdType )0);
    sw = smith_waterman_new();
    result = alignment_create((size_t___0 )256);
    {
    _1_main_next = 14U;
    }
    break;
    case 1: 
    tmp___0 = cmdline_get_file1(cmd, i);
    file1 = (char const   *)tmp___0;
    tmp___1 = cmdline_get_file2(cmd, i);
    file2 = (char const   *)tmp___1;
    {
    _1_main_next = 9U;
    }
    break;
    case 3: ;
    if (i < num_of_file_pairs) {
      {
      _1_main_next = 1U;
      }
    } else {
      {
      _1_main_next = 10U;
      }
    }
    break;
    case 9: ;
    if ((unsigned long )file1 != (unsigned long )((void *)0)) {
      {
      _1_main_next = 0U;
      }
    } else {
      {
      _1_main_next = 6U;
      }
    }
    break;
    case 13: 
    tmp = cmdline_get_num_of_file_pairs(cmd);
    num_of_file_pairs = tmp;
    i = (size_t___0 )0;
    {
    _1_main_next = 3U;
    }
    break;
    case 6: 
    align_from_file(file1, file2, & align_pair_from_file, (_Bool )(! cmd->interactive));
    i ++;
    {
    _1_main_next = 3U;
    }
    break;
    case 10: 
    smith_waterman_free(sw);
    alignment_free(result);
    cmdline_free(cmd);
    {
    _1_main_next = 12U;
    }
    break;
    case 0: ;
    if ((int const   )*file1 == 0) {
      {
      _1_main_next = 4U;
      }
    } else {
      {
      _1_main_next = 6U;
      }
    }
    break;
    case 7: 
    wait_on_keystroke = (_Bool)1;
    file1 = "-";
    {
    _1_main_next = 6U;
    }
    break;
    case 2: 
    align(cmd->seq1, cmd->seq2, (char const   *)((void *)0), (char const   *)((void *)0));
    {
    _1_main_next = 13U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF main LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF strbuf_free LOC=UNKNOWN */
__inline static void strbuf_free(StrBuf *sb ) 
{ 
  unsigned int _1_strbuf_free_next ;

  {
  {
  _1_strbuf_free_next = 0U;
  }
  while (1) {
    switch (_1_strbuf_free_next) {
    case 1: ;
    return;
    break;
    case 0: 
    free((void *)sb->b);
    free((void *)sb);
    {
    _1_strbuf_free_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF strbuf_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_plain_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_plain_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  unsigned int _1__seq_read_plain_gz_buf_next ;

  {
  {
  _1__seq_read_plain_gz_buf_next = 5U;
  }
  while (1) {
    switch (_1__seq_read_plain_gz_buf_next) {
    case 4: ;
    return (0);
    break;
    case 12: 
    c = gzgetc_buf(sf->gz_file, & sf->in);
    {
    _1__seq_read_plain_gz_buf_next = 11U;
    }
    break;
    case 3: ;
    if (! tmp) {
      {
      _1__seq_read_plain_gz_buf_next = 9U;
      }
    } else {
      {
      _1__seq_read_plain_gz_buf_next = 7U;
      }
    }
    break;
    case 11: ;
    if (c != -1) {
      {
      _1__seq_read_plain_gz_buf_next = 13U;
      }
    } else {
      {
      _1__seq_read_plain_gz_buf_next = 9U;
      }
    }
    break;
    case 9: ;
    if (c == -1) {
      {
      _1__seq_read_plain_gz_buf_next = 4U;
      }
    } else {
      {
      _1__seq_read_plain_gz_buf_next = 10U;
      }
    }
    break;
    case 13: 
    tmp = isspace(c);
    {
    _1__seq_read_plain_gz_buf_next = 3U;
    }
    break;
    case 5: 
    seq_read_reset(r);
    {
    _1__seq_read_plain_gz_buf_next = 12U;
    }
    break;
    case 10: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    gzreadline_buf(sf->gz_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_plain_gz_buf_next = 0U;
    }
    break;
    case 0: ;
    return (1);
    break;
    case 7: ;
    if (c != 10) {
      {
      _1__seq_read_plain_gz_buf_next = 2U;
      }
    } else {
      {
      _1__seq_read_plain_gz_buf_next = 12U;
      }
    }
    break;
    case 2: 
    gzskipline_buf(sf->gz_file, & sf->in);
    {
    _1__seq_read_plain_gz_buf_next = 12U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_plain_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _rndup2pow64___0 LOC=UNKNOWN */
__inline static size_t___0 _rndup2pow64___0(unsigned long long x ) 
{ 
  unsigned int _1__rndup2pow64___0_next ;

  {
  {
  _1__rndup2pow64___0_next = 0U;
  }
  while (1) {
    switch (_1__rndup2pow64___0_next) {
    case 1: ;
    return ((size_t___0 )x);
    break;
    case 0: 
    x --;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;
    x ++;
    {
    _1__rndup2pow64___0_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _rndup2pow64___0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmdline_get_file1 LOC=UNKNOWN */
char *cmdline_get_file1(cmdline_t *cmd___0 , size_t___0 i ) 
{ 
  unsigned int _1_cmdline_get_file1_next ;

  {
  {
  _1_cmdline_get_file1_next = 0U;
  }
  while (1) {
    switch (_1_cmdline_get_file1_next) {
    case 0: ;
    return (*(cmd___0->file_paths1 + i));
    break;
    }
  }
}
}
/* END FUNCTION-DEF cmdline_get_file1 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fastq_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_fastq_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  size_t___0 tmp___2 ;
  unsigned int _1__seq_read_fastq_gz_buf_next ;

  {
  {
  _1__seq_read_fastq_gz_buf_next = 35U;
  }
  while (1) {
    switch (_1__seq_read_fastq_gz_buf_next) {
    case 18: 
    cbuf_chomp(r->qual.b, & r->qual.end);
    {
    _1__seq_read_fastq_gz_buf_next = 6U;
    }
    break;
    case 4: ;
    return (-1);
    break;
    case 30: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_gz_buf_next = 26U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 15U;
      }
    }
    break;
    case 14: ;
    if (tmp___2 > 0UL) {
      {
      _1__seq_read_fastq_gz_buf_next = 18U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 39U;
      }
    }
    break;
    case 15: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_gz_buf_next = 28U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 1U;
      }
    }
    break;
    case 31: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fastq_gz_buf_next = 19U;
    }
    break;
    case 8: ;
    if (c != 64) {
      {
      _1__seq_read_fastq_gz_buf_next = 29U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 16U;
      }
    }
    break;
    case 1: 
    tmp___2 = gzreadline_buf(sf->gz_file, & sf->in, & r->qual.b, & r->qual.end, & r->qual.size);
    {
    _1__seq_read_fastq_gz_buf_next = 14U;
    }
    break;
    case 3: ;
    if (tmp___0 == 0UL) {
      {
      _1__seq_read_fastq_gz_buf_next = 4U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 31U;
      }
    }
    break;
    case 16: 
    tmp___0 = gzreadline_buf(sf->gz_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fastq_gz_buf_next = 3U;
    }
    break;
    case 21: 
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fastq_gz_buf_next = 19U;
    }
    break;
    case 36: ;
    if (tmp___1 == 0UL) {
      {
      _1__seq_read_fastq_gz_buf_next = 20U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 21U;
      }
    }
    break;
    case 26: ;
    if (! (c != 10)) {
      {
      _1__seq_read_fastq_gz_buf_next = 15U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 11U;
      }
    }
    break;
    case 11: 
    c = gzgetc_buf(sf->gz_file, & sf->in);
    {
    _1__seq_read_fastq_gz_buf_next = 30U;
    }
    break;
    case 9: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_gz_buf_next = 33U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 8U;
      }
    }
    break;
    case 19: 
    c = gzgetc_buf(sf->gz_file, & sf->in);
    {
    _1__seq_read_fastq_gz_buf_next = 41U;
    }
    break;
    case 17: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___1 = gzreadline_buf(sf->gz_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
    {
    _1__seq_read_fastq_gz_buf_next = 36U;
    }
    break;
    case 6: ;
    if (! (r->qual.end < r->seq.end)) {
      {
      _1__seq_read_fastq_gz_buf_next = 22U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 1U;
      }
    }
    break;
    case 27: 
    ungetc_buf(c, & sf->in);
    {
    _1__seq_read_fastq_gz_buf_next = 38U;
    }
    break;
    case 38: ;
    return (1);
    break;
    case 34: ;
    return (-1);
    break;
    case 22: 
    c = gzgetc_buf(sf->gz_file, & sf->in);
    {
    _1__seq_read_fastq_gz_buf_next = 2U;
    }
    break;
    case 28: ;
    return (-1);
    break;
    case 5: ;
    if (c != 10) {
      {
      _1__seq_read_fastq_gz_buf_next = 17U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 19U;
      }
    }
    break;
    case 33: ;
    return (0);
    break;
    case 41: ;
    if (! (c != 43)) {
      {
      _1__seq_read_fastq_gz_buf_next = 11U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 10U;
      }
    }
    break;
    case 10: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_gz_buf_next = 34U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 0U;
      }
    }
    break;
    case 42: ;
    if (! (c != 64)) {
      {
      _1__seq_read_fastq_gz_buf_next = 27U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 22U;
      }
    }
    break;
    case 0: ;
    if (c != 13) {
      {
      _1__seq_read_fastq_gz_buf_next = 5U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 19U;
      }
    }
    break;
    case 39: ;
    return (1);
    break;
    case 35: 
    seq_read_reset(r);
    tmp = gzgetc_buf(sf->gz_file, & sf->in);
    c = tmp;
    {
    _1__seq_read_fastq_gz_buf_next = 9U;
    }
    break;
    case 29: ;
    return (-1);
    break;
    case 2: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_gz_buf_next = 42U;
      }
    } else {
      {
      _1__seq_read_fastq_gz_buf_next = 27U;
      }
    }
    break;
    case 20: ;
    return (-1);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fastq_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmdline_get_file2 LOC=UNKNOWN */
char *cmdline_get_file2(cmdline_t *cmd___0 , size_t___0 i ) 
{ 
  unsigned int _1_cmdline_get_file2_next ;

  {
  {
  _1_cmdline_get_file2_next = 0U;
  }
  while (1) {
    switch (_1_cmdline_get_file2_next) {
    case 0: ;
    return (*(cmd___0->file_paths2 + i));
    break;
    }
  }
}
}
/* END FUNCTION-DEF cmdline_get_file2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF aligner_destroy LOC=UNKNOWN */
void aligner_destroy(aligner_t *aligner ) 
{ 
  unsigned int _1_aligner_destroy_next ;

  {
  {
  _1_aligner_destroy_next = 2U;
  }
  while (1) {
    switch (_1_aligner_destroy_next) {
    case 1: 
    free((void *)aligner->match_scores);
    free((void *)aligner->gap_a_scores);
    free((void *)aligner->gap_b_scores);
    {
    _1_aligner_destroy_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    case 2: ;
    if (aligner->capacity > 0UL) {
      {
      _1_aligner_destroy_next = 1U;
      }
    } else {
      {
      _1_aligner_destroy_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF aligner_destroy LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fastq_f_buf LOC=UNKNOWN */
__inline static int _seq_read_fastq_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  size_t___0 tmp___2 ;
  unsigned int _1__seq_read_fastq_f_buf_next ;

  {
  {
  _1__seq_read_fastq_f_buf_next = 23U;
  }
  while (1) {
    switch (_1__seq_read_fastq_f_buf_next) {
    case 25: 
    cbuf_chomp(r->qual.b, & r->qual.end);
    {
    _1__seq_read_fastq_f_buf_next = 32U;
    }
    break;
    case 15: ;
    return (-1);
    break;
    case 31: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___1 = freadline_buf(sf->f_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
    {
    _1__seq_read_fastq_f_buf_next = 0U;
    }
    break;
    case 12: 
    ungetc_buf(c, & sf->in);
    {
    _1__seq_read_fastq_f_buf_next = 38U;
    }
    break;
    case 8: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_f_buf_next = 40U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 12U;
      }
    }
    break;
    case 1: 
    c = fgetc_buf(sf->f_file, & sf->in);
    {
    _1__seq_read_fastq_f_buf_next = 9U;
    }
    break;
    case 23: 
    seq_read_reset(r);
    tmp = fgetc_buf(sf->f_file, & sf->in);
    c = tmp;
    {
    _1__seq_read_fastq_f_buf_next = 13U;
    }
    break;
    case 3: ;
    if (c != 13) {
      {
      _1__seq_read_fastq_f_buf_next = 28U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 37U;
      }
    }
    break;
    case 24: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fastq_f_buf_next = 37U;
    }
    break;
    case 21: ;
    return (-1);
    break;
    case 26: ;
    return (-1);
    break;
    case 9: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_f_buf_next = 7U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 27U;
      }
    }
    break;
    case 13: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_f_buf_next = 20U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 22U;
      }
    }
    break;
    case 19: ;
    return (-1);
    break;
    case 32: ;
    if (! (r->qual.end < r->seq.end)) {
      {
      _1__seq_read_fastq_f_buf_next = 6U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 34U;
      }
    }
    break;
    case 17: ;
    if (tmp___2 > 0UL) {
      {
      _1__seq_read_fastq_f_buf_next = 25U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 41U;
      }
    }
    break;
    case 40: ;
    if (! (c != 64)) {
      {
      _1__seq_read_fastq_f_buf_next = 12U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 6U;
      }
    }
    break;
    case 6: 
    c = fgetc_buf(sf->f_file, & sf->in);
    {
    _1__seq_read_fastq_f_buf_next = 8U;
    }
    break;
    case 27: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_f_buf_next = 10U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 34U;
      }
    }
    break;
    case 38: ;
    return (1);
    break;
    case 34: 
    tmp___2 = freadline_buf(sf->f_file, & sf->in, & r->qual.b, & r->qual.end, & r->qual.size);
    {
    _1__seq_read_fastq_f_buf_next = 17U;
    }
    break;
    case 22: ;
    if (c != 64) {
      {
      _1__seq_read_fastq_f_buf_next = 26U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 35U;
      }
    }
    break;
    case 28: ;
    if (c != 10) {
      {
      _1__seq_read_fastq_f_buf_next = 31U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 37U;
      }
    }
    break;
    case 33: 
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fastq_f_buf_next = 37U;
    }
    break;
    case 37: 
    c = fgetc_buf(sf->f_file, & sf->in);
    {
    _1__seq_read_fastq_f_buf_next = 42U;
    }
    break;
    case 41: ;
    return (1);
    break;
    case 10: ;
    return (-1);
    break;
    case 42: ;
    if (! (c != 43)) {
      {
      _1__seq_read_fastq_f_buf_next = 1U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 39U;
      }
    }
    break;
    case 0: ;
    if (tmp___1 == 0UL) {
      {
      _1__seq_read_fastq_f_buf_next = 19U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 33U;
      }
    }
    break;
    case 39: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_f_buf_next = 15U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 3U;
      }
    }
    break;
    case 7: ;
    if (! (c != 10)) {
      {
      _1__seq_read_fastq_f_buf_next = 27U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 1U;
      }
    }
    break;
    case 35: 
    tmp___0 = freadline_buf(sf->f_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fastq_f_buf_next = 43U;
    }
    break;
    case 43: ;
    if (tmp___0 == 0UL) {
      {
      _1__seq_read_fastq_f_buf_next = 21U;
      }
    } else {
      {
      _1__seq_read_fastq_f_buf_next = 24U;
      }
    }
    break;
    case 20: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fastq_f_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF bitset_alloc LOC=UNKNOWN */
__inline static BitSet *bitset_alloc(BitSet *bs , size_t___0 l ) 
{ 
  void *tmp ;
  BitSet *tmp___0 ;
  unsigned int _1_bitset_alloc_next ;

  {
  {
  _1_bitset_alloc_next = 1U;
  }
  while (1) {
    switch (_1_bitset_alloc_next) {
    case 4: ;
    if (bs->b) {
      {
      _1_bitset_alloc_next = 0U;
      }
    } else {
      {
      _1_bitset_alloc_next = 2U;
      }
    }
    break;
    case 1: 
    bs->s = (l + 31UL) / 32UL;
    bs->l = l;
    tmp = calloc(sizeof(*(bs->b + 0)), bs->s);
    bs->b = (uint32_t *)tmp;
    {
    _1_bitset_alloc_next = 4U;
    }
    break;
    case 3: ;
    return (tmp___0);
    break;
    case 0: 
    tmp___0 = bs;
    {
    _1_bitset_alloc_next = 3U;
    }
    break;
    case 2: 
    tmp___0 = (BitSet *)((void *)0);
    {
    _1_bitset_alloc_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF bitset_alloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF aligner_align LOC=UNKNOWN */
void aligner_align(aligner_t *aligner , char const   *seq_a , char const   *seq_b ,
                   size_t___0 len_a , size_t___0 len_b , scoring_t const   *scoring___0 ,
                   char is_sw ) 
{ 
  size_t___0 new_capacity ;
  size_t___0 mem ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int _1_aligner_align_next ;

  {
  {
  _1_aligner_align_next = 4U;
  }
  while (1) {
    switch (_1_aligner_align_next) {
    case 4: 
    aligner->scoring = scoring___0;
    aligner->seq_a = seq_a;
    aligner->seq_b = seq_b;
    aligner->score_width = len_a + 1UL;
    aligner->score_height = len_b + 1UL;
    new_capacity = aligner->score_width * aligner->score_height;
    {
    _1_aligner_align_next = 3U;
    }
    break;
    case 1: ;
    return;
    break;
    case 3: ;
    if (aligner->capacity < new_capacity) {
      {
      _1_aligner_align_next = 2U;
      }
    } else {
      {
      _1_aligner_align_next = 0U;
      }
    }
    break;
    case 0: 
    alignment_fill_matrices(aligner, is_sw);
    {
    _1_aligner_align_next = 1U;
    }
    break;
    case 2: 
    aligner->capacity = _rndup2pow64((unsigned long long )new_capacity);
    mem = sizeof(score_t ) * aligner->capacity;
    tmp = realloc((void *)aligner->match_scores, mem);
    aligner->match_scores = (score_t *)tmp;
    tmp___0 = realloc((void *)aligner->gap_a_scores, mem);
    aligner->gap_a_scores = (score_t *)tmp___0;
    tmp___1 = realloc((void *)aligner->gap_b_scores, mem);
    aligner->gap_b_scores = (score_t *)tmp___1;
    {
    _1_aligner_align_next = 0U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF aligner_align LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF sort_r_cmpswap LOC=UNKNOWN */
__inline static int sort_r_cmpswap(char * __restrict  a , char * __restrict  b , size_t___0 w ,
                                   int (*compar)(void const   *_a , void const   *_b ,
                                                 void *_arg ) , void *arg ) 
{ 
  char tmp ;
  char *end ;
  int tmp___0 ;
  unsigned int _1_sort_r_cmpswap_next ;

  {
  {
  _1_sort_r_cmpswap_next = 3U;
  }
  while (1) {
    switch (_1_sort_r_cmpswap_next) {
    case 1: ;
    return (0);
    break;
    case 3: 
    end = (char *)(a + w);
    tmp___0 = (*compar)((void const   *)a, (void const   *)b, arg);
    {
    _1_sort_r_cmpswap_next = 2U;
    }
    break;
    case 6: ;
    if ((unsigned long )a < (unsigned long )end) {
      {
      _1_sort_r_cmpswap_next = 7U;
      }
    } else {
      {
      _1_sort_r_cmpswap_next = 0U;
      }
    }
    break;
    case 0: ;
    return (1);
    break;
    case 7: 
    tmp = *a;
    *a = *b;
    *b = tmp;
    a ++;
    b ++;
    {
    _1_sort_r_cmpswap_next = 6U;
    }
    break;
    case 2: ;
    if (tmp___0 > 0) {
      {
      _1_sort_r_cmpswap_next = 6U;
      }
    } else {
      {
      _1_sort_r_cmpswap_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF sort_r_cmpswap LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_unknown_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_unknown_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1__seq_read_unknown_gz_buf_next ;

  {
  {
  _1__seq_read_unknown_gz_buf_next = 1U;
  }
  while (1) {
    switch (_1__seq_read_unknown_gz_buf_next) {
    case 18: ;
    return (tmp___0);
    break;
    case 4: 
    gzskipline(sf->gz_file);
    {
    _1__seq_read_unknown_gz_buf_next = 9U;
    }
    break;
    case 14: 
    tmp = isspace(c);
    {
    _1__seq_read_unknown_gz_buf_next = 6U;
    }
    break;
    case 15: ;
    return (0);
    break;
    case 12: 
    sf->format = (seq_format )1;
    sf->origreadfunc = & _seq_read_plain_gz_buf;
    {
    _1__seq_read_unknown_gz_buf_next = 5U;
    }
    break;
    case 8: ;
    if (c == 62) {
      {
      _1__seq_read_unknown_gz_buf_next = 17U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_buf_next = 12U;
      }
    }
    break;
    case 1: 
    seq_read_reset(r);
    {
    _1__seq_read_unknown_gz_buf_next = 9U;
    }
    break;
    case 3: ;
    if (c != 10) {
      {
      _1__seq_read_unknown_gz_buf_next = 4U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_buf_next = 9U;
      }
    }
    break;
    case 16: ;
    if (c != -1) {
      {
      _1__seq_read_unknown_gz_buf_next = 14U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_buf_next = 10U;
      }
    }
    break;
    case 9: 
    c = gzgetc_buf(sf->gz_file, & sf->in);
    {
    _1__seq_read_unknown_gz_buf_next = 16U;
    }
    break;
    case 13: ;
    if (c == 64) {
      {
      _1__seq_read_unknown_gz_buf_next = 0U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_buf_next = 8U;
      }
    }
    break;
    case 17: 
    sf->format = (seq_format )2;
    sf->origreadfunc = & _seq_read_fasta_gz_buf;
    {
    _1__seq_read_unknown_gz_buf_next = 5U;
    }
    break;
    case 6: ;
    if (! tmp) {
      {
      _1__seq_read_unknown_gz_buf_next = 10U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_buf_next = 3U;
      }
    }
    break;
    case 5: 
    ungetc_buf(c, & sf->in);
    tmp___0 = (*(sf->origreadfunc))(sf, r);
    {
    _1__seq_read_unknown_gz_buf_next = 18U;
    }
    break;
    case 10: ;
    if (c == -1) {
      {
      _1__seq_read_unknown_gz_buf_next = 15U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_buf_next = 13U;
      }
    }
    break;
    case 0: 
    sf->format = (seq_format )4;
    sf->origreadfunc = & _seq_read_fastq_gz_buf;
    {
    _1__seq_read_unknown_gz_buf_next = 5U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_unknown_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF print_usage LOC=UNKNOWN */
static  __attribute__((__noreturn__)) void print_usage(enum SeqAlignCmdType cmd_type ,
                                                       score_t *defaults , char const   *cmdstr ,
                                                       char const   *errfmt  , ...) ;
static void print_usage(enum SeqAlignCmdType cmd_type , score_t *defaults , char const   *cmdstr ,
                        char const   *errfmt  , ...) 
{ 
  va_list___0 argptr ;
  size_t___0 tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int _1_print_usage_next ;

  {
  {
  _1_print_usage_next = 7U;
  }
  while (1) {
    switch (_1_print_usage_next) {
    case 18: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"\n    --freestartgap       No penalty for gap at start of alignment\n    --freeendgap         No penalty for gap at end of alignment\n\n    --printscores        Print optimal alignment scores\n    --zam                A funky type of output\n"));
    {
    _1_print_usage_next = 0U;
    }
    break;
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"  %s optimal %s alignment (maximises score).  \n  Takes a pair of sequences on the command line, or can read from a\n  file and from sequence piped in.  Can read gzip files, FASTA and FASTQ.\n\n"),
            tmp___1, tmp___0);
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"  OPTIONS:\n    --file <file>        Sequence file reading with gzip support - read two\n                         sequences at a time and align them\n    --files <f1> <f2>    Read one sequence from each file to align at one time\n    --stdin              Read from STDIN (same as \'--file -\')\n\n    --case_sensitive     Use case sensitive character comparison [default: off]\n\n    --match <score>      [default: %i]\n    --mismatch <score>   [default: %i]\n    --gapopen <score>    [default: %i]\n    --gapextend <score>  [default: %i]\n\n    --scoring <PAM30|PAM70|BLOSUM80|BLOSUM62>\n    --substitution_matrix <file>  see details for formatting\n    --substitution_pairs <file>   see details for formatting\n\n    --wildcard <w> <s>   Character <w> matches all characters with score <s>\n\n"),
            *(defaults + 0), *(defaults + 1), *(defaults + 2), *(defaults + 3));
    {
    _1_print_usage_next = 3U;
    }
    break;
    case 14: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"    --minscore <score>   Minimum required score\n                         [default: match * MAX(0.2 * length, 2)]\n    --maxhits <hits>     Maximum number of results per alignment\n                         [default: no limit]\n\n    --context <n>        Print <n> bases of context\n    --printseq           Print sequences before local alignments\n"));
    {
    _1_print_usage_next = 0U;
    }
    break;
    case 15: 
    tmp___1 = (char *)"Needleman-Wunsch";
    {
    _1_print_usage_next = 4U;
    }
    break;
    case 12: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"\n"));
    {
    _1_print_usage_next = 2U;
    }
    break;
    case 8: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"    --nomismatches       No mismatches allowed%s\n"),
            tmp___2);
    printf((char const   *)((char const   */* __restrict  */)"\n DETAILS:\n  * For help choosing scoring, see the README file. \n  * Gap (of length N) penalty is: (open+N*extend)\n  * To do alignment without affine gap penalty, set \'--gapopen 0\'.\n  * Scoring files should be matrices, with entries separated by a single\n    character or whitespace. See files in the \'scores\' directory for examples.\n\n  turner.isaac@gmail.com  (compiled: %s %s)\n"),
           "Apr 19 2023", "21:51:25");
    exit(1);

    break;
    case 1: 
    tmp___2 = (char *)"";
    {
    _1_print_usage_next = 8U;
    }
    break;
    case 3: ;
    if ((unsigned int )cmd_type == 0U) {
      {
      _1_print_usage_next = 14U;
      }
    } else {
      {
      _1_print_usage_next = 18U;
      }
    }
    break;
    case 16: 
    tmp___1 = (char *)"Smith-Waterman";
    {
    _1_print_usage_next = 4U;
    }
    break;
    case 11: 
    tmp___0 = (char *)"local";
    {
    _1_print_usage_next = 9U;
    }
    break;
    case 9: ;
    if ((unsigned int )cmd_type == 0U) {
      {
      _1_print_usage_next = 16U;
      }
    } else {
      {
      _1_print_usage_next = 15U;
      }
    }
    break;
    case 13: 
    tmp___0 = (char *)"global";
    {
    _1_print_usage_next = 9U;
    }
    break;
    case 19: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error: "));
    __builtin_va_start(argptr, errfmt);
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)errfmt,
             argptr);
    __builtin_va_end(argptr);
    tmp = strlen(errfmt);
    {
    _1_print_usage_next = 20U;
    }
    break;
    case 17: ;
    if ((unsigned int )cmd_type == 0U) {
      {
      _1_print_usage_next = 11U;
      }
    } else {
      {
      _1_print_usage_next = 13U;
      }
    }
    break;
    case 5: 
    tmp___2 = (char *)" (cannot be used with --nogaps..)";
    {
    _1_print_usage_next = 8U;
    }
    break;
    case 10: ;
    if ((unsigned int )cmd_type == 0U) {
      {
      _1_print_usage_next = 1U;
      }
    } else {
      {
      _1_print_usage_next = 5U;
      }
    }
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"    --printmatrices      Print dynamic programming matrices\n    --printfasta         Print fasta header lines\n    --pretty             Print with a descriptor line\n    --colour             Print with colour\n\n  Experimental Options:\n    --nogapsin1          No gaps allowed within the first sequence\n    --nogapsin2          No gaps allowed within the second sequence\n    --nogaps             No gaps allowed in either sequence\n"));
    {
    _1_print_usage_next = 10U;
    }
    break;
    case 7: ;
    if ((unsigned long )errfmt != (unsigned long )((void *)0)) {
      {
      _1_print_usage_next = 19U;
      }
    } else {
      {
      _1_print_usage_next = 2U;
      }
    }
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"usage: %s [OPTIONS] [seq1 seq2]\n"),
            cmdstr);
    {
    _1_print_usage_next = 17U;
    }
    break;
    case 20: ;
    if ((int const   )*(errfmt + (tmp - 1UL)) != 10) {
      {
      _1_print_usage_next = 12U;
      }
    } else {
      {
      _1_print_usage_next = 2U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF print_usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _follow_hit LOC=UNKNOWN */
static char _follow_hit(sw_aligner_t *sw___0 , size_t___0 arr_index , alignment_t *result___0 ) 
{ 
  aligner_t const   *aligner ;
  sw_history_t const   *hist ;
  size_t___0 score_x ;
  size_t___0 score_y ;
  enum Matrix curr_matrix ;
  score_t curr_score ;
  size_t___0 end_arr_index ;
  size_t___0 end_score_x ;
  size_t___0 end_score_y ;
  score_t end_score ;
  size_t___0 length ;
  unsigned int i ;
  unsigned int _1__follow_hit_next ;

  {
  {
  _1__follow_hit_next = 13U;
  }
  while (1) {
    switch (_1__follow_hit_next) {
    case 18: ;
    if ((*(hist->match_scores_mask.b + (arr_index >> 5)) >> (arr_index & 31UL)) & 1U) {
      {
      _1__follow_hit_next = 22U;
      }
    } else {
      {
      _1__follow_hit_next = 5U;
      }
    }
    break;
    case 4: ;
    switch ((unsigned int )curr_matrix) {
    case 0U: 
    {
    _1__follow_hit_next = 0U;
    }
    break;
    case 1U: 
    {
    _1__follow_hit_next = 6U;
    }
    break;
    case 2U: 
    {
    _1__follow_hit_next = 15U;
    }
    break;
    default: 
    {
    _1__follow_hit_next = 11U;
    }
    break;
    }
    break;
    case 15: 
    *(result___0->result_a + i) = (char )*(aligner->seq_a + (score_x - 1UL));
    *(result___0->result_b + i) = (char )'-';
    {
    _1__follow_hit_next = 21U;
    }
    break;
    case 12: 
    alignment_reverse_move(& curr_matrix, & curr_score, & score_x, & score_y, & arr_index,
                           aligner);
    length ++;
    {
    _1__follow_hit_next = 18U;
    }
    break;
    case 8: 
    result___0->length = length;
    alignment_ensure_capacity(result___0, length);
    arr_index = end_arr_index;
    score_x = end_score_x;
    score_y = end_score_y;
    curr_matrix = (enum Matrix )0;
    curr_score = end_score;
    i = (unsigned int )(length - 1UL);
    {
    _1__follow_hit_next = 9U;
    }
    break;
    case 1: ;
    return ((char)1);
    break;
    case 3: 
    *(result___0->result_a + length) = (char )'\000';
    *(result___0->result_b + length) = (char )'\000';
    result___0->score = end_score;
    result___0->pos_a = score_x;
    result___0->pos_b = score_y;
    result___0->len_a = end_score_x - score_x;
    result___0->len_b = end_score_y - score_y;
    {
    _1__follow_hit_next = 1U;
    }
    break;
    case 21: 
    alignment_reverse_move(& curr_matrix, & curr_score, & score_x, & score_y, & arr_index,
                           aligner);
    i --;
    {
    _1__follow_hit_next = 9U;
    }
    break;
    case 11: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Program error: invalid matrix in _follow_hit()\n"));
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Please submit a bug report to: turner.isaac@gmail.com\n"));
    exit(1);

    break;
    case 9: ;
    if (curr_score > 0) {
      {
      _1__follow_hit_next = 4U;
      }
    } else {
      {
      _1__follow_hit_next = 3U;
      }
    }
    break;
    case 13: 
    aligner = (aligner_t const   *)(& sw___0->aligner);
    hist = (sw_history_t const   *)(& sw___0->history);
    score_x = arr_index % (unsigned long )aligner->score_width;
    score_y = arr_index / (size_t___0 )aligner->score_width;
    curr_matrix = (enum Matrix )0;
    curr_score = *(aligner->match_scores + arr_index);
    end_arr_index = arr_index;
    end_score_x = score_x;
    end_score_y = score_y;
    end_score = curr_score;
    length = (size_t___0 )0;
    {
    _1__follow_hit_next = 18U;
    }
    break;
    case 17: ;
    if (curr_score == 0) {
      {
      _1__follow_hit_next = 8U;
      }
    } else {
      {
      _1__follow_hit_next = 12U;
      }
    }
    break;
    case 6: 
    *(result___0->result_a + i) = (char )'-';
    *(result___0->result_b + i) = (char )*(aligner->seq_b + (score_y - 1UL));
    {
    _1__follow_hit_next = 21U;
    }
    break;
    case 22: ;
    return ((char)0);
    break;
    case 5: 
    *(hist->match_scores_mask.b + (arr_index >> 5)) |= (unsigned int )(1 << (arr_index & 31UL));
    {
    _1__follow_hit_next = 17U;
    }
    break;
    case 0: 
    *(result___0->result_a + i) = (char )*(aligner->seq_a + (score_x - 1UL));
    *(result___0->result_b + i) = (char )*(aligner->seq_b + (score_y - 1UL));
    {
    _1__follow_hit_next = 21U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _follow_hit LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_print_spacer LOC=UNKNOWN */
void alignment_print_spacer(char const   *alignment_a , char const   *alignment_b ,
                            scoring_t const   *scoring___0 ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1_alignment_print_spacer_next ;

  {
  {
  _1_alignment_print_spacer_next = 17U;
  }
  while (1) {
    switch (_1_alignment_print_spacer_next) {
    case 4: ;
    if (tmp == tmp___0) {
      {
      _1_alignment_print_spacer_next = 3U;
      }
    } else {
      {
      _1_alignment_print_spacer_next = 11U;
      }
    }
    break;
    case 14: 
    tmp = tolower((int )*(alignment_a + i));
    tmp___0 = tolower((int )*(alignment_b + i));
    {
    _1_alignment_print_spacer_next = 4U;
    }
    break;
    case 15: ;
    if (! scoring___0->case_sensitive) {
      {
      _1_alignment_print_spacer_next = 14U;
      }
    } else {
      {
      _1_alignment_print_spacer_next = 1U;
      }
    }
    break;
    case 8: ;
    return;
    break;
    case 1: 
    putc('*', stdout);
    {
    _1_alignment_print_spacer_next = 6U;
    }
    break;
    case 3: 
    putc('|', stdout);
    {
    _1_alignment_print_spacer_next = 6U;
    }
    break;
    case 16: ;
    if ((int const   )*(alignment_a + i) != 0) {
      {
      _1_alignment_print_spacer_next = 13U;
      }
    } else {
      {
      _1_alignment_print_spacer_next = 8U;
      }
    }
    break;
    case 11: 
    putc('*', stdout);
    {
    _1_alignment_print_spacer_next = 6U;
    }
    break;
    case 9: 
    putc(' ', stdout);
    {
    _1_alignment_print_spacer_next = 6U;
    }
    break;
    case 13: ;
    if ((int const   )*(alignment_a + i) == 45) {
      {
      _1_alignment_print_spacer_next = 9U;
      }
    } else {
      {
      _1_alignment_print_spacer_next = 10U;
      }
    }
    break;
    case 17: 
    i = 0;
    {
    _1_alignment_print_spacer_next = 16U;
    }
    break;
    case 6: 
    i ++;
    {
    _1_alignment_print_spacer_next = 16U;
    }
    break;
    case 5: 
    putc('|', stdout);
    {
    _1_alignment_print_spacer_next = 6U;
    }
    break;
    case 10: ;
    if ((int const   )*(alignment_b + i) == 45) {
      {
      _1_alignment_print_spacer_next = 0U;
      }
    } else {
      {
      _1_alignment_print_spacer_next = 2U;
      }
    }
    break;
    case 0: 
    putc(' ', stdout);
    {
    _1_alignment_print_spacer_next = 6U;
    }
    break;
    case 2: ;
    if ((int const   )*(alignment_a + i) == (int const   )*(alignment_b + i)) {
      {
      _1_alignment_print_spacer_next = 5U;
      }
    } else {
      {
      _1_alignment_print_spacer_next = 15U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_print_spacer LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF sort_r_simple LOC=UNKNOWN */
__inline static void sort_r_simple(void *base , size_t___0 nel , size_t___0 w , int (*compar)(void const   *_a ,
                                                                                              void const   *_b ,
                                                                                              void *_arg ) ,
                                   void *arg ) 
{ 
  char *b ;
  char *end ;
  char *pi ;
  char *pj ;
  int tmp ;
  char *x ;
  char *y ;
  char *xend ;
  char ch ;
  char *pl ;
  char *pr ;
  char *last ;
  char *tmp___0 ;
  char *l[3] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int _1_sort_r_simple_next ;

  {
  {
  _1_sort_r_simple_next = 39U;
  }
  while (1) {
    switch (_1_sort_r_simple_next) {
    case 18: 
    last = b + w * (nel - 1UL);
    l[0] = b;
    l[1] = b + w * (nel / 2UL);
    l[2] = last;
    tmp___1 = (*compar)((void const   *)l[0], (void const   *)l[1], arg);
    {
    _1_sort_r_simple_next = 33U;
    }
    break;
    case 4: 
    tmp___0 = l[0];
    l[0] = l[1];
    l[1] = tmp___0;
    {
    _1_sort_r_simple_next = 45U;
    }
    break;
    case 14: 
    pl = b;
    pr = last;
    {
    _1_sort_r_simple_next = 31U;
    }
    break;
    case 15: ;
    if ((unsigned long )pl < (unsigned long )pr) {
      {
      _1_sort_r_simple_next = 36U;
      }
    } else {
      {
      _1_sort_r_simple_next = 31U;
      }
    }
    break;
    case 31: ;
    if ((unsigned long )pl < (unsigned long )pr) {
      {
      _1_sort_r_simple_next = 8U;
      }
    } else {
      {
      _1_sort_r_simple_next = 16U;
      }
    }
    break;
    case 12: ;
    if ((unsigned long )pi < (unsigned long )end) {
      {
      _1_sort_r_simple_next = 34U;
      }
    } else {
      {
      _1_sort_r_simple_next = 32U;
      }
    }
    break;
    case 8: ;
    if ((unsigned long )pl < (unsigned long )pr) {
      {
      _1_sort_r_simple_next = 28U;
      }
    } else {
      {
      _1_sort_r_simple_next = 15U;
      }
    }
    break;
    case 45: 
    x = l[1];
    y = last;
    xend = x + w;
    {
    _1_sort_r_simple_next = 26U;
    }
    break;
    case 1: 
    ch = *x;
    *x = *y;
    *y = ch;
    x ++;
    y ++;
    {
    _1_sort_r_simple_next = 26U;
    }
    break;
    case 23: ;
    if (tmp___3 > 0) {
      {
      _1_sort_r_simple_next = 13U;
      }
    } else {
      {
      _1_sort_r_simple_next = 45U;
      }
    }
    break;
    case 3: 
    pj -= w;
    {
    _1_sort_r_simple_next = 6U;
    }
    break;
    case 16: 
    sort_r_simple((void *)b, (size_t___0 )(pl - b) / w, w, compar, arg);
    sort_r_simple((void *)(pl + w), (size_t___0 )(end - (pl + w)) / w, w, compar,
                  arg);
    {
    _1_sort_r_simple_next = 32U;
    }
    break;
    case 21: ;
    if (tmp___4) {
      {
      _1_sort_r_simple_next = 38U;
      }
    } else {
      {
      _1_sort_r_simple_next = 29U;
      }
    }
    break;
    case 36: 
    tmp___5 = sort_r_cmpswap((char */* __restrict  */)pl, (char */* __restrict  */)pr,
                             w, compar, arg);
    {
    _1_sort_r_simple_next = 48U;
    }
    break;
    case 26: ;
    if ((unsigned long )x < (unsigned long )xend) {
      {
      _1_sort_r_simple_next = 1U;
      }
    } else {
      {
      _1_sort_r_simple_next = 14U;
      }
    }
    break;
    case 9: ;
    if (! tmp) {
      {
      _1_sort_r_simple_next = 46U;
      }
    } else {
      {
      _1_sort_r_simple_next = 3U;
      }
    }
    break;
    case 13: 
    tmp___0 = l[1];
    l[1] = l[2];
    l[2] = tmp___0;
    tmp___2 = (*compar)((void const   *)l[0], (void const   *)l[1], arg);
    {
    _1_sort_r_simple_next = 10U;
    }
    break;
    case 32: ;
    return;
    break;
    case 40: ;
    if (nel < 7UL) {
      {
      _1_sort_r_simple_next = 37U;
      }
    } else {
      {
      _1_sort_r_simple_next = 18U;
      }
    }
    break;
    case 6: ;
    if ((unsigned long )pj > (unsigned long )b) {
      {
      _1_sort_r_simple_next = 0U;
      }
    } else {
      {
      _1_sort_r_simple_next = 46U;
      }
    }
    break;
    case 38: 
    pr -= w;
    {
    _1_sort_r_simple_next = 15U;
    }
    break;
    case 34: 
    pj = pi;
    {
    _1_sort_r_simple_next = 6U;
    }
    break;
    case 48: ;
    if (tmp___5) {
      {
      _1_sort_r_simple_next = 2U;
      }
    } else {
      {
      _1_sort_r_simple_next = 22U;
      }
    }
    break;
    case 22: 
    pr -= w;
    {
    _1_sort_r_simple_next = 15U;
    }
    break;
    case 28: 
    tmp___4 = sort_r_cmpswap((char */* __restrict  */)pl, (char */* __restrict  */)pr,
                             w, compar, arg);
    {
    _1_sort_r_simple_next = 21U;
    }
    break;
    case 47: 
    tmp___0 = l[0];
    l[0] = l[1];
    l[1] = tmp___0;
    {
    _1_sort_r_simple_next = 35U;
    }
    break;
    case 33: ;
    if (tmp___1 > 0) {
      {
      _1_sort_r_simple_next = 47U;
      }
    } else {
      {
      _1_sort_r_simple_next = 35U;
      }
    }
    break;
    case 37: 
    pi = b + w;
    {
    _1_sort_r_simple_next = 12U;
    }
    break;
    case 10: ;
    if (tmp___2 > 0) {
      {
      _1_sort_r_simple_next = 4U;
      }
    } else {
      {
      _1_sort_r_simple_next = 45U;
      }
    }
    break;
    case 0: 
    tmp = sort_r_cmpswap((char */* __restrict  */)(pj - w), (char */* __restrict  */)pj,
                         w, compar, arg);
    {
    _1_sort_r_simple_next = 9U;
    }
    break;
    case 46: 
    pi += w;
    {
    _1_sort_r_simple_next = 12U;
    }
    break;
    case 39: 
    b = (char *)base;
    end = b + nel * w;
    {
    _1_sort_r_simple_next = 40U;
    }
    break;
    case 35: 
    tmp___3 = (*compar)((void const   *)l[1], (void const   *)l[2], arg);
    {
    _1_sort_r_simple_next = 23U;
    }
    break;
    case 29: 
    pl += w;
    {
    _1_sort_r_simple_next = 8U;
    }
    break;
    case 2: 
    pl += w;
    {
    _1_sort_r_simple_next = 31U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF sort_r_simple LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cbuf_chomp LOC=UNKNOWN */
__inline static void cbuf_chomp(char *buf , size_t___0 *lenptr ) 
{ 
  unsigned int _1_cbuf_chomp_next ;

  {
  {
  _1_cbuf_chomp_next = 3U;
  }
  while (1) {
    switch (_1_cbuf_chomp_next) {
    case 4: ;
    if (*lenptr) {
      {
      _1_cbuf_chomp_next = 2U;
      }
    } else {
      {
      _1_cbuf_chomp_next = 5U;
      }
    }
    break;
    case 8: ;
    if (! ((int )*(buf + (*lenptr - 1UL)) == 13)) {
      {
      _1_cbuf_chomp_next = 5U;
      }
    } else {
      {
      _1_cbuf_chomp_next = 7U;
      }
    }
    break;
    case 1: ;
    return;
    break;
    case 3: ;
    {
    _1_cbuf_chomp_next = 4U;
    }
    break;
    case 5: 
    *(buf + *lenptr) = (char )'\000';
    {
    _1_cbuf_chomp_next = 1U;
    }
    break;
    case 7: 
    (*lenptr) --;
    {
    _1_cbuf_chomp_next = 4U;
    }
    break;
    case 2: ;
    if (! ((int )*(buf + (*lenptr - 1UL)) == 10)) {
      {
      _1_cbuf_chomp_next = 8U;
      }
    } else {
      {
      _1_cbuf_chomp_next = 7U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cbuf_chomp LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cbuf_append_char LOC=UNKNOWN */
__inline static void cbuf_append_char(char **buf , size_t___0 *lenptr , size_t___0 *sizeptr ,
                                      char c ) 
{ 
  size_t___0 tmp ;
  unsigned int _1_cbuf_append_char_next ;

  {
  {
  _1_cbuf_append_char_next = 1U;
  }
  while (1) {
    switch (_1_cbuf_append_char_next) {
    case 1: 
    cbuf_capacity(buf, sizeptr, *lenptr + 1UL);
    tmp = *lenptr;
    (*lenptr) ++;
    *(*buf + tmp) = c;
    *(*buf + *lenptr) = (char )'\000';
    {
    _1_cbuf_append_char_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF cbuf_append_char LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fasta_gz_buf LOC=UNKNOWN */
__inline static int _seq_read_fasta_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  long nread ;
  size_t___0 tmp___1 ;
  unsigned int _1__seq_read_fasta_gz_buf_next ;

  {
  {
  _1__seq_read_fasta_gz_buf_next = 6U;
  }
  while (1) {
    switch (_1__seq_read_fasta_gz_buf_next) {
    case 18: ;
    return (-1);
    break;
    case 4: ;
    if (c != 13) {
      {
      _1__seq_read_fasta_gz_buf_next = 10U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 7U;
      }
    }
    break;
    case 14: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_gz_buf_next = 19U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 4U;
      }
    }
    break;
    case 15: 
    tmp___0 = gzreadline_buf(sf->gz_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fasta_gz_buf_next = 11U;
    }
    break;
    case 12: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___1 = gzreadline_buf(sf->gz_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
    nread = (long )tmp___1;
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fasta_gz_buf_next = 0U;
    }
    break;
    case 8: 
    ungetc_buf(c, & sf->in);
    {
    _1__seq_read_fasta_gz_buf_next = 13U;
    }
    break;
    case 3: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fasta_gz_buf_next = 7U;
    }
    break;
    case 16: ;
    return (0);
    break;
    case 21: ;
    return (-1);
    break;
    case 11: ;
    if (tmp___0 == 0UL) {
      {
      _1__seq_read_fasta_gz_buf_next = 21U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 3U;
      }
    }
    break;
    case 9: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_gz_buf_next = 16U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 5U;
      }
    }
    break;
    case 13: ;
    return (1);
    break;
    case 19: ;
    return (1);
    break;
    case 17: ;
    if (! (c != 62)) {
      {
      _1__seq_read_fasta_gz_buf_next = 8U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 14U;
      }
    }
    break;
    case 6: 
    seq_read_reset(r);
    tmp = gzgetc_buf(sf->gz_file, & sf->in);
    c = tmp;
    {
    _1__seq_read_fasta_gz_buf_next = 9U;
    }
    break;
    case 5: ;
    if (c != 62) {
      {
      _1__seq_read_fasta_gz_buf_next = 18U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 15U;
      }
    }
    break;
    case 10: ;
    if (c != 10) {
      {
      _1__seq_read_fasta_gz_buf_next = 12U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 7U;
      }
    }
    break;
    case 0: ;
    if (nread <= 0L) {
      {
      _1__seq_read_fasta_gz_buf_next = 2U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_buf_next = 7U;
      }
    }
    break;
    case 7: 
    c = gzgetc_buf(sf->gz_file, & sf->in);
    {
    _1__seq_read_fasta_gz_buf_next = 17U;
    }
    break;
    case 2: ;
    return (1);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fasta_gz_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF needleman_wunsch_align LOC=UNKNOWN */
void needleman_wunsch_align(char const   *a , char const   *b , scoring_t const   *scoring___0 ,
                            nw_aligner_t *nw , alignment_t *result___0 ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  unsigned int _1_needleman_wunsch_align_next ;

  {
  {
  _1_needleman_wunsch_align_next = 1U;
  }
  while (1) {
    switch (_1_needleman_wunsch_align_next) {
    case 1: 
    tmp = strlen(b);
    tmp___0 = strlen(a);
    needleman_wunsch_align2(a, b, tmp___0, tmp, scoring___0, nw, result___0);
    {
    _1_needleman_wunsch_align_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF needleman_wunsch_align LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_unknown_f LOC=UNKNOWN */
__inline static int _seq_read_unknown_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1__seq_read_unknown_f_next ;

  {
  {
  _1__seq_read_unknown_f_next = 14U;
  }
  while (1) {
    switch (_1__seq_read_unknown_f_next) {
    case 18: 
    sf->format = (seq_format )4;
    sf->origreadfunc = & _seq_read_fastq_f;
    {
    _1__seq_read_unknown_f_next = 5U;
    }
    break;
    case 4: ;
    if (c == 62) {
      {
      _1__seq_read_unknown_f_next = 16U;
      }
    } else {
      {
      _1__seq_read_unknown_f_next = 12U;
      }
    }
    break;
    case 14: 
    seq_read_reset(r);
    {
    _1__seq_read_unknown_f_next = 3U;
    }
    break;
    case 15: 
    tmp = isspace(c);
    {
    _1__seq_read_unknown_f_next = 13U;
    }
    break;
    case 12: 
    sf->format = (seq_format )1;
    sf->origreadfunc = & _seq_read_plain_f;
    {
    _1__seq_read_unknown_f_next = 5U;
    }
    break;
    case 8: ;
    if (c == 64) {
      {
      _1__seq_read_unknown_f_next = 18U;
      }
    } else {
      {
      _1__seq_read_unknown_f_next = 4U;
      }
    }
    break;
    case 3: 
    c = fgetc(sf->f_file);
    {
    _1__seq_read_unknown_f_next = 10U;
    }
    break;
    case 16: 
    sf->format = (seq_format )2;
    sf->origreadfunc = & _seq_read_fasta_f;
    {
    _1__seq_read_unknown_f_next = 5U;
    }
    break;
    case 11: ;
    if (c == -1) {
      {
      _1__seq_read_unknown_f_next = 7U;
      }
    } else {
      {
      _1__seq_read_unknown_f_next = 8U;
      }
    }
    break;
    case 13: ;
    if (! tmp) {
      {
      _1__seq_read_unknown_f_next = 11U;
      }
    } else {
      {
      _1__seq_read_unknown_f_next = 17U;
      }
    }
    break;
    case 17: ;
    if (c != 10) {
      {
      _1__seq_read_unknown_f_next = 6U;
      }
    } else {
      {
      _1__seq_read_unknown_f_next = 3U;
      }
    }
    break;
    case 6: 
    fskipline(sf->f_file);
    {
    _1__seq_read_unknown_f_next = 3U;
    }
    break;
    case 5: 
    ungetc(c, sf->f_file);
    tmp___0 = (*(sf->origreadfunc))(sf, r);
    {
    _1__seq_read_unknown_f_next = 0U;
    }
    break;
    case 10: ;
    if (c != -1) {
      {
      _1__seq_read_unknown_f_next = 15U;
      }
    } else {
      {
      _1__seq_read_unknown_f_next = 11U;
      }
    }
    break;
    case 0: ;
    return (tmp___0);
    break;
    case 7: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_unknown_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmdline_new LOC=UNKNOWN */
cmdline_t *cmdline_new(int argc , char **argv , scoring_t *scoring___0 , enum SeqAlignCmdType cmd_type ) 
{ 
  cmdline_t *cmd___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  score_t defaults[4] ;
  char scoring_set ;
  char substitutions_set ;
  char match_set ;
  char mismatch_set ;
  int argi ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  gzFile sub_matrix_file ;
  gzFile tmp___13 ;
  gzFile sub_pairs_file ;
  gzFile tmp___14 ;
  char tmp___15 ;
  char tmp___16 ;
  char tmp___17 ;
  char tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  char tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int wildscore ;
  size_t___0 tmp___24 ;
  char tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  unsigned int _1_cmdline_new_next ;

  {
  {
  _1_cmdline_new_next = 195U;
  }
  while (1) {
    switch (_1_cmdline_new_next) {
    case 182: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--nogaps.. --nomismatches cannot be used at together");

    break;
    case 18: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--zam only valid with Needleman-Wunsch");

    break;
    case 129: ;
    if (argc == 1) {
      {
      _1_cmdline_new_next = 145U;
      }
    } else {
      {
      _1_cmdline_new_next = 216U;
      }
    }
    break;
    case 50: ;
    if (tmp___3 == 0) {
      {
      _1_cmdline_new_next = 198U;
      }
    } else {
      {
      _1_cmdline_new_next = 35U;
      }
    }
    break;
    case 80: ;
    if (! tmp___21) {
      {
      _1_cmdline_new_next = 203U;
      }
    } else {
      {
      _1_cmdline_new_next = 229U;
      }
    }
    break;
    case 108: 
    tmp___19 = parse_entire_int(*(argv + (argi + 1)), & scoring___0->mismatch);
    {
    _1_cmdline_new_next = 110U;
    }
    break;
    case 166: 
    tmp___16 = parse_entire_uint(*(argv + (argi + 1)), & cmd___0->max_hits_per_alignment);
    {
    _1_cmdline_new_next = 10U;
    }
    break;
    case 104: 
    tmp___8 = strcasecmp((char const   *)*(argv + argi), "--scoring");
    {
    _1_cmdline_new_next = 207U;
    }
    break;
    case 130: 
    tmp___20 = parse_entire_int(*(argv + (argi + 1)), & scoring___0->gap_open);
    {
    _1_cmdline_new_next = 164U;
    }
    break;
    case 25: ;
    if (tmp___27 == 0) {
      {
      _1_cmdline_new_next = 59U;
      }
    } else {
      {
      _1_cmdline_new_next = 189U;
      }
    }
    break;
    case 49: ;
    if (tmp___35 == 0) {
      {
      _1_cmdline_new_next = 202U;
      }
    } else {
      {
      _1_cmdline_new_next = 175U;
      }
    }
    break;
    case 188: 
    tmp___18 = parse_entire_int(*(argv + (argi + 1)), & scoring___0->match);
    {
    _1_cmdline_new_next = 14U;
    }
    break;
    case 4: 
    tmp___44 = strcasecmp((char const   *)*(argv + argi), "--printscores");
    {
    _1_cmdline_new_next = 150U;
    }
    break;
    case 200: ;
    if ((unsigned long )sub_matrix_file == (unsigned long )((void *)0)) {
      {
      _1_cmdline_new_next = 212U;
      }
    } else {
      {
      _1_cmdline_new_next = 123U;
      }
    }
    break;
    case 219: ;
    if (! tmp___15) {
      {
      _1_cmdline_new_next = 96U;
      }
    } else {
      {
      _1_cmdline_new_next = 209U;
      }
    }
    break;
    case 30: 
    cmdline_add_files(cmd___0, *(argv + (argi + 1)), *(argv + (argi + 2)));
    {
    _1_cmdline_new_next = 165U;
    }
    break;
    case 62: 
    match_set = (char)1;
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 103: 
    tmp___24 = strlen((char const   *)*(argv + (argi + 1)));
    {
    _1_cmdline_new_next = 178U;
    }
    break;
    case 185: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--wildcard <w> <s> takes a single character and a number");

    break;
    case 189: 
    tmp___26 = strcasecmp((char const   *)*(argv + argi), "--wildcard");
    {
    _1_cmdline_new_next = 8U;
    }
    break;
    case 102: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Invalid --context <c> argument (must be >= 0)");

    break;
    case 106: ;
    if (! mismatch_set) {
      {
      _1_cmdline_new_next = 190U;
      }
    } else {
      {
      _1_cmdline_new_next = 143U;
      }
    }
    break;
    case 206: ;
    if (scoring___0->use_match_mismatch) {
      {
      _1_cmdline_new_next = 48U;
      }
    } else {
      {
      _1_cmdline_new_next = 65U;
      }
    }
    break;
    case 14: ;
    if (! tmp___18) {
      {
      _1_cmdline_new_next = 75U;
      }
    } else {
      {
      _1_cmdline_new_next = 62U;
      }
    }
    break;
    case 111: 
    mismatch_set = (char)1;
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 145: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), (char const   *)((void *)0));

    break;
    case 15: ;
    if (tmp___34 == 0) {
      {
      _1_cmdline_new_next = 142U;
      }
    } else {
      {
      _1_cmdline_new_next = 37U;
      }
    }
    break;
    case 82: 
    tmp___45 = strcasecmp((char const   *)*(argv + argi), "--printmatrices");
    {
    _1_cmdline_new_next = 7U;
    }
    break;
    case 133: 
    cmdline_add_files(cmd___0, *(argv + (argi + 1)), *(argv + (argi + 2)));
    {
    _1_cmdline_new_next = 165U;
    }
    break;
    case 89: 
    scoring___0->no_gaps_in_a = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 221: 
    cmd___0->print_seq = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 180: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--context only valid with Smith-Waterman");

    break;
    case 56: 
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 79: ;
    if (tmp___30 == 0) {
      {
      _1_cmdline_new_next = 130U;
      }
    } else {
      {
      _1_cmdline_new_next = 170U;
      }
    }
    break;
    case 217: 
    cmd___0->seq1 = (char const   *)*(argv + argi);
    cmd___0->seq2 = (char const   *)*(argv + (argi + 1));
    {
    _1_cmdline_new_next = 186U;
    }
    break;
    case 164: ;
    if (! tmp___20) {
      {
      _1_cmdline_new_next = 57U;
      }
    } else {
      {
      _1_cmdline_new_next = 55U;
      }
    }
    break;
    case 31: 
    tmp___11 = strcasecmp((char const   *)*(argv + argi), "-help");
    {
    _1_cmdline_new_next = 94U;
    }
    break;
    case 121: ;
    if (cmd___0->print_pretty) {
      {
      _1_cmdline_new_next = 26U;
      }
    } else {
      {
      _1_cmdline_new_next = 215U;
      }
    }
    break;
    case 12: 
    tmp___36 = strcasecmp((char const   *)*(argv + argi), "--substitution_pairs");
    {
    _1_cmdline_new_next = 162U;
    }
    break;
    case 141: ;
    if (tmp___52 == 0) {
      {
      _1_cmdline_new_next = 211U;
      }
    } else {
      {
      _1_cmdline_new_next = 20U;
      }
    }
    break;
    case 216: 
    scoring_set = (char)0;
    substitutions_set = (char)0;
    match_set = (char)0;
    mismatch_set = (char)0;
    argi = 1;
    {
    _1_cmdline_new_next = 230U;
    }
    break;
    case 101: ;
    if ((unsigned int )cmd_type != 1U) {
      {
      _1_cmdline_new_next = 115U;
      }
    } else {
      {
      _1_cmdline_new_next = 74U;
      }
    }
    break;
    case 168: ;
    if ((int )*(*(argv + argi) + 0) == 45) {
      {
      _1_cmdline_new_next = 81U;
      }
    } else {
      {
      _1_cmdline_new_next = 64U;
      }
    }
    break;
    case 209: 
    cmd___0->min_score_set = (_Bool)1;
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 69: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Invalid --mismatch argument (\'%s\') must be an int",
                *(argv + (argi + 1)));

    break;
    case 152: 
    tmp___3 = strcasecmp((char const   *)*(argv + (argi + 1)), "DNA_HYBRIDIZATION");
    {
    _1_cmdline_new_next = 50U;
    }
    break;
    case 205: ;
    if (argi == argc - 2) {
      {
      _1_cmdline_new_next = 11U;
      }
    } else {
      {
      _1_cmdline_new_next = 103U;
      }
    }
    break;
    case 8: ;
    if (tmp___26 == 0) {
      {
      _1_cmdline_new_next = 76U;
      }
    } else {
      {
      _1_cmdline_new_next = 157U;
      }
    }
    break;
    case 160: 
    scoring___0->no_mismatches = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 204: 
    cmdline_add_files(cmd___0, *(argv + (argi + 1)), (char *)((void *)0));
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 203: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Invalid --gapextend argument (\'%s\') must be an int",
                *(argv + (argi + 1)));

    break;
    case 96: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Invalid --minscore <score> argument (must be a +ve int)");

    break;
    case 195: 
    tmp = calloc((size_t )1, sizeof(cmdline_t ));
    cmd___0 = (cmdline_t *)tmp;
    cmd___0->file_list_length = (size_t___0 )0;
    cmd___0->file_list_capacity = (size_t___0 )256;
    tmp___0 = malloc(sizeof(char *) * cmd___0->file_list_capacity);
    cmd___0->file_paths1 = (char **)tmp___0;
    tmp___1 = malloc(sizeof(char *) * cmd___0->file_list_capacity);
    cmd___0->file_paths2 = (char **)tmp___1;
    tmp___2 = (char const   *)((void *)0);
    cmd___0->seq2 = tmp___2;
    cmd___0->seq1 = tmp___2;
    defaults[0] = scoring___0->match;
    defaults[1] = scoring___0->mismatch;
    defaults[2] = scoring___0->gap_open;
    defaults[3] = scoring___0->gap_extend;
    {
    _1_cmdline_new_next = 129U;
    }
    break;
    case 45: ;
    if (tmp___5 == 0) {
      {
      _1_cmdline_new_next = 158U;
      }
    } else {
      {
      _1_cmdline_new_next = 208U;
      }
    }
    break;
    case 54: 
    tmp___48 = strcasecmp((char const   *)*(argv + argi), "--nomismatches");
    {
    _1_cmdline_new_next = 112U;
    }
    break;
    case 78: 
    tmp___38 = strcasecmp((char const   *)*(argv + argi), "--scoring");
    {
    _1_cmdline_new_next = 136U;
    }
    break;
    case 124: ;
    if (tmp___46 == 0) {
      {
      _1_cmdline_new_next = 88U;
      }
    } else {
      {
      _1_cmdline_new_next = 82U;
      }
    }
    break;
    case 118: ;
    if (tmp___42 == 0) {
      {
      _1_cmdline_new_next = 153U;
      }
    } else {
      {
      _1_cmdline_new_next = 119U;
      }
    }
    break;
    case 140: 
    cmd___0->case_sensitive = (_Bool)1;
    {
    _1_cmdline_new_next = 39U;
    }
    break;
    case 1: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Unknown argument without parameter: %s",
                *(argv + argi));

    break;
    case 81: 
    tmp___53 = strcasecmp((char const   *)*(argv + argi), "--freestartgap");
    {
    _1_cmdline_new_next = 137U;
    }
    break;
    case 128: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Cannot use --printscore, --printfasta, --pretty or --colour with --zam");

    break;
    case 23: ;
    if (tmp___51 == 0) {
      {
      _1_cmdline_new_next = 107U;
      }
    } else {
      {
      _1_cmdline_new_next = 199U;
      }
    }
    break;
    case 77: ;
    if (tmp___40 == 0) {
      {
      _1_cmdline_new_next = 151U;
      }
    } else {
      {
      _1_cmdline_new_next = 95U;
      }
    }
    break;
    case 70: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), (char const   *)((void *)0));

    break;
    case 159: 
    cmd___0->max_hits_per_alignment_set = (_Bool)1;
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 3: ;
    if ((unsigned int )cmd_type != 1U) {
      {
      _1_cmdline_new_next = 232U;
      }
    } else {
      {
      _1_cmdline_new_next = 167U;
      }
    }
    break;
    case 134: 
    tmp___5 = strcasecmp((char const   *)*(argv + (argi + 1)), "BLOSUM80");
    {
    _1_cmdline_new_next = 45U;
    }
    break;
    case 16: ;
    if (scoring___0->no_mismatches) {
      {
      _1_cmdline_new_next = 220U;
      }
    } else {
      {
      _1_cmdline_new_next = 97U;
      }
    }
    break;
    case 24: 
    cmd___0->print_fasta = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 21: 
    cmd___0->print_matrices = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 94: ;
    if (tmp___11 == 0) {
      {
      _1_cmdline_new_next = 70U;
      }
    } else {
      {
      _1_cmdline_new_next = 179U;
      }
    }
    break;
    case 109: 
    tmp___37 = strcasecmp((char const   *)*(argv + argi), "--substitution_matrix");
    {
    _1_cmdline_new_next = 181U;
    }
    break;
    case 190: ;
    if (! scoring___0->no_mismatches) {
      {
      _1_cmdline_new_next = 147U;
      }
    } else {
      {
      _1_cmdline_new_next = 143U;
      }
    }
    break;
    case 167: 
    cmd___0->print_scores = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 36: 
    cmd___0->zam_stle_output = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 76: 
    wildscore = 0;
    {
    _1_cmdline_new_next = 205U;
    }
    break;
    case 131: 
    cmdline_add_files(cmd___0, (char *)"", (char *)((void *)0));
    cmd___0->interactive = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 197: ;
    if (tmp___23 == 0) {
      {
      _1_cmdline_new_next = 60U;
      }
    } else {
      {
      _1_cmdline_new_next = 133U;
      }
    }
    break;
    case 231: 
    tmp___42 = strcasecmp((char const   *)*(argv + argi), "--pretty");
    {
    _1_cmdline_new_next = 118U;
    }
    break;
    case 57: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Invalid --gapopen argument (\'%s\') must be an int",
                *(argv + (argi + 1)));

    break;
    case 68: 
    tmp___31 = strcasecmp((char const   *)*(argv + argi), "--mismatch");
    {
    _1_cmdline_new_next = 177U;
    }
    break;
    case 156: 
    tmp___25 = parse_entire_int(*(argv + (argi + 2)), & wildscore);
    {
    _1_cmdline_new_next = 86U;
    }
    break;
    case 213: ;
    if (cmd___0->zam_stle_output) {
      {
      _1_cmdline_new_next = 121U;
      }
    } else {
      {
      _1_cmdline_new_next = 38U;
      }
    }
    break;
    case 122: ;
    if (cmd___0->print_fasta) {
      {
      _1_cmdline_new_next = 128U;
      }
    } else {
      {
      _1_cmdline_new_next = 38U;
      }
    }
    break;
    case 181: ;
    if (tmp___37 == 0) {
      {
      _1_cmdline_new_next = 46U;
      }
    } else {
      {
      _1_cmdline_new_next = 12U;
      }
    }
    break;
    case 85: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--freeendgap only valid with Needleman-Wunsch");

    break;
    case 100: ;
    if (tmp___12 == 0) {
      {
      _1_cmdline_new_next = 27U;
      }
    } else {
      {
      _1_cmdline_new_next = 32U;
      }
    }
    break;
    case 26: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Cannot use --printscore, --printfasta, --pretty or --colour with --zam");

    break;
    case 98: ;
    if (! (tmp___47 == 0)) {
      {
      _1_cmdline_new_next = 0U;
      }
    } else {
      {
      _1_cmdline_new_next = 71U;
      }
    }
    break;
    case 105: 
    tmp___6 = strcasecmp((char const   *)*(argv + (argi + 1)), "PAM70");
    {
    _1_cmdline_new_next = 87U;
    }
    break;
    case 214: ;
    if (tmp___22 == 0) {
      {
      _1_cmdline_new_next = 196U;
      }
    } else {
      {
      _1_cmdline_new_next = 30U;
      }
    }
    break;
    case 11: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--wildcard <w> <s> takes a single character and a number");

    break;
    case 202: ;
    if ((unsigned int )cmd_type != 0U) {
      {
      _1_cmdline_new_next = 218U;
      }
    } else {
      {
      _1_cmdline_new_next = 43U;
      }
    }
    break;
    case 9: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), (char const   *)((void *)0));

    break;
    case 225: 
    tmp___30 = strcasecmp((char const   *)*(argv + argi), "--gapopen");
    {
    _1_cmdline_new_next = 79U;
    }
    break;
    case 135: ;
    if (tmp___41 == 0) {
      {
      _1_cmdline_new_next = 154U;
      }
    } else {
      {
      _1_cmdline_new_next = 172U;
      }
    }
    break;
    case 13: 
    scoring_system_BLOSUM62(scoring___0);
    {
    _1_cmdline_new_next = 176U;
    }
    break;
    case 63: 
    tmp___22 = strcmp((char const   *)*(argv + (argi + 1)), "-");
    {
    _1_cmdline_new_next = 214U;
    }
    break;
    case 220: ;
    if (scoring___0->no_gaps_in_a) {
      {
      _1_cmdline_new_next = 53U;
      }
    } else {
      {
      _1_cmdline_new_next = 90U;
      }
    }
    break;
    case 176: 
    scoring_set = (char)1;
    argi ++;
    {
    _1_cmdline_new_next = 39U;
    }
    break;
    case 186: ;
    if ((unsigned long )cmd___0->seq1 == (unsigned long )((void *)0)) {
      {
      _1_cmdline_new_next = 2U;
      }
    } else {
      {
      _1_cmdline_new_next = 213U;
      }
    }
    break;
    case 51: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Invalid --maxhits <hits> argument (must be a +ve int)");

    break;
    case 107: 
    scoring___0->no_gaps_in_a = (_Bool)1;
    scoring___0->no_gaps_in_b = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 146: 
    scoring_add_wildcard(scoring___0, *(*(argv + (argi + 1)) + 0), wildscore);
    argi += 2;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 211: ;
    if ((unsigned int )cmd_type != 1U) {
      {
      _1_cmdline_new_next = 85U;
      }
    } else {
      {
      _1_cmdline_new_next = 67U;
      }
    }
    break;
    case 125: ;
    if ((unsigned long )sub_pairs_file == (unsigned long )((void *)0)) {
      {
      _1_cmdline_new_next = 174U;
      }
    } else {
      {
      _1_cmdline_new_next = 47U;
      }
    }
    break;
    case 143: 
    _L___1: ;
    if (! match_set) {
      {
      _1_cmdline_new_next = 233U;
      }
    } else {
      {
      _1_cmdline_new_next = 183U;
      }
    }
    break;
    case 19: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--files option takes 2 arguments");

    break;
    case 32: 
    tmp___9 = strcasecmp((char const   *)*(argv + argi), "--case_sensitive");
    {
    _1_cmdline_new_next = 73U;
    }
    break;
    case 227: 
    tmp___7 = strcasecmp((char const   *)*(argv + (argi + 1)), "PAM30");
    {
    _1_cmdline_new_next = 34U;
    }
    break;
    case 17: 
    scoring___0->no_gaps_in_b = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 90: ;
    if (scoring___0->no_gaps_in_b) {
      {
      _1_cmdline_new_next = 182U;
      }
    } else {
      {
      _1_cmdline_new_next = 97U;
      }
    }
    break;
    case 172: 
    tmp___40 = strcasecmp((char const   *)*(argv + argi), "--zam");
    {
    _1_cmdline_new_next = 77U;
    }
    break;
    case 228: 
    tmp___49 = strcasecmp((char const   *)*(argv + argi), "--nogapsin2");
    {
    _1_cmdline_new_next = 132U;
    }
    break;
    case 226: 
    tmp___10 = strcasecmp((char const   *)*(argv + argi), "--help");
    {
    _1_cmdline_new_next = 139U;
    }
    break;
    case 40: ;
    if (argi < argc) {
      {
      _1_cmdline_new_next = 168U;
      }
    } else {
      {
      _1_cmdline_new_next = 127U;
      }
    }
    break;
    case 199: 
    tmp___50 = strcasecmp((char const   *)*(argv + argi), "--nogapsin1");
    {
    _1_cmdline_new_next = 210U;
    }
    break;
    case 210: ;
    if (tmp___50 == 0) {
      {
      _1_cmdline_new_next = 89U;
      }
    } else {
      {
      _1_cmdline_new_next = 228U;
      }
    }
    break;
    case 67: 
    scoring___0->no_end_gap_penalty = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 55: 
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 132: ;
    if (tmp___49 == 0) {
      {
      _1_cmdline_new_next = 17U;
      }
    } else {
      {
      _1_cmdline_new_next = 54U;
      }
    }
    break;
    case 110: ;
    if (! tmp___19) {
      {
      _1_cmdline_new_next = 69U;
      }
    } else {
      {
      _1_cmdline_new_next = 111U;
      }
    }
    break;
    case 208: 
    tmp___4 = strcasecmp((char const   *)*(argv + (argi + 1)), "BLOSUM62");
    {
    _1_cmdline_new_next = 33U;
    }
    break;
    case 60: 
    cmdline_add_files(cmd___0, *(argv + (argi + 1)), (char *)((void *)0));
    {
    _1_cmdline_new_next = 165U;
    }
    break;
    case 150: ;
    if (tmp___44 == 0) {
      {
      _1_cmdline_new_next = 3U;
      }
    } else {
      {
      _1_cmdline_new_next = 169U;
      }
    }
    break;
    case 59: ;
    if (argi >= argc - 2) {
      {
      _1_cmdline_new_next = 19U;
      }
    } else {
      {
      _1_cmdline_new_next = 63U;
      }
    }
    break;
    case 165: 
    argi += 2;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 187: 
    scoring_system_PAM30(scoring___0);
    {
    _1_cmdline_new_next = 176U;
    }
    break;
    case 161: 
    tmp___27 = strcasecmp((char const   *)*(argv + argi), "--files");
    {
    _1_cmdline_new_next = 25U;
    }
    break;
    case 196: 
    tmp___23 = strcmp((char const   *)*(argv + (argi + 2)), "-");
    {
    _1_cmdline_new_next = 197U;
    }
    break;
    case 223: 
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 6: 
    scoring___0->use_match_mismatch = (_Bool)0;
    {
    _1_cmdline_new_next = 206U;
    }
    break;
    case 155: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Match value should not be less than mismatch penalty");

    break;
    case 142: ;
    if ((unsigned int )cmd_type != 0U) {
      {
      _1_cmdline_new_next = 41U;
      }
    } else {
      {
      _1_cmdline_new_next = 166U;
      }
    }
    break;
    case 116: 
    tmp___52 = strcasecmp((char const   *)*(argv + argi), "--freeendgap");
    {
    _1_cmdline_new_next = 141U;
    }
    break;
    case 137: ;
    if (tmp___53 == 0) {
      {
      _1_cmdline_new_next = 101U;
      }
    } else {
      {
      _1_cmdline_new_next = 116U;
      }
    }
    break;
    case 27: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), (char const   *)((void *)0));

    break;
    case 154: 
    cmd___0->print_colour = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 151: ;
    if ((unsigned int )cmd_type != 1U) {
      {
      _1_cmdline_new_next = 18U;
      }
    } else {
      {
      _1_cmdline_new_next = 36U;
      }
    }
    break;
    case 157: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Unknown argument \'%s\'",
                *(argv + argi));

    break;
    case 194: 
    tmp___28 = strcasecmp((char const   *)*(argv + argi), "--file");
    {
    _1_cmdline_new_next = 83U;
    }
    break;
    case 38: ;
    return (cmd___0);
    break;
    case 61: ;
    if ((unsigned int )cmd_type != 0U) {
      {
      _1_cmdline_new_next = 180U;
      }
    } else {
      {
      _1_cmdline_new_next = 113U;
      }
    }
    break;
    case 158: 
    scoring_system_BLOSUM80(scoring___0);
    {
    _1_cmdline_new_next = 176U;
    }
    break;
    case 212: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Couldn\'t read: %s",
                *(argv + (argi + 1)));

    break;
    case 87: ;
    if (tmp___6 == 0) {
      {
      _1_cmdline_new_next = 28U;
      }
    } else {
      {
      _1_cmdline_new_next = 134U;
      }
    }
    break;
    case 113: 
    tmp___17 = parse_entire_uint(*(argv + (argi + 1)), & cmd___0->print_context);
    {
    _1_cmdline_new_next = 171U;
    }
    break;
    case 138: 
    tmp___21 = parse_entire_int(*(argv + (argi + 1)), & scoring___0->gap_extend);
    {
    _1_cmdline_new_next = 80U;
    }
    break;
    case 58: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--printseq only valid with Smith-Waterman");

    break;
    case 84: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Unknown options: \'%s\'",
                *(argv + argi));

    break;
    case 170: 
    tmp___29 = strcasecmp((char const   *)*(argv + argi), "--gapextend");
    {
    _1_cmdline_new_next = 5U;
    }
    break;
    case 183: 
    _L: ;
    if (substitutions_set) {
      {
      _1_cmdline_new_next = 93U;
      }
    } else {
      {
      _1_cmdline_new_next = 206U;
      }
    }
    break;
    case 171: ;
    if (! tmp___17) {
      {
      _1_cmdline_new_next = 102U;
      }
    } else {
      {
      _1_cmdline_new_next = 56U;
      }
    }
    break;
    case 34: ;
    if (tmp___7 == 0) {
      {
      _1_cmdline_new_next = 187U;
      }
    } else {
      {
      _1_cmdline_new_next = 105U;
      }
    }
    break;
    case 74: 
    scoring___0->no_start_gap_penalty = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 112: ;
    if (tmp___48 == 0) {
      {
      _1_cmdline_new_next = 160U;
      }
    } else {
      {
      _1_cmdline_new_next = 92U;
      }
    }
    break;
    case 178: ;
    if (tmp___24 != 1UL) {
      {
      _1_cmdline_new_next = 185U;
      }
    } else {
      {
      _1_cmdline_new_next = 156U;
      }
    }
    break;
    case 75: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Invalid --match argument (\'%s\') must be an int",
                *(argv + (argi + 1)));

    break;
    case 123: 
    align_scoring_load_matrix(sub_matrix_file, (char const   *)*(argv + (argi + 1)),
                              scoring___0, (char )cmd___0->case_sensitive);
    gzclose(sub_matrix_file);
    substitutions_set = (char)1;
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 48: ;
    if (scoring___0->match < scoring___0->mismatch) {
      {
      _1_cmdline_new_next = 155U;
      }
    } else {
      {
      _1_cmdline_new_next = 65U;
      }
    }
    break;
    case 169: 
    tmp___43 = strcasecmp((char const   *)*(argv + argi), "--printfasta");
    {
    _1_cmdline_new_next = 22U;
    }
    break;
    case 127: ;
    if (match_set) {
      {
      _1_cmdline_new_next = 106U;
      }
    } else {
      {
      _1_cmdline_new_next = 143U;
      }
    }
    break;
    case 139: ;
    if (tmp___10 == 0) {
      {
      _1_cmdline_new_next = 9U;
      }
    } else {
      {
      _1_cmdline_new_next = 31U;
      }
    }
    break;
    case 147: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--match --mismatch must both be set or neither set");

    break;
    case 71: 
    argi ++;
    {
    _1_cmdline_new_next = 40U;
    }
    break;
    case 22: ;
    if (tmp___43 == 0) {
      {
      _1_cmdline_new_next = 24U;
      }
    } else {
      {
      _1_cmdline_new_next = 231U;
      }
    }
    break;
    case 173: ;
    if (scoring_set) {
      {
      _1_cmdline_new_next = 91U;
      }
    } else {
      {
      _1_cmdline_new_next = 227U;
      }
    }
    break;
    case 215: ;
    if (cmd___0->print_scores) {
      {
      _1_cmdline_new_next = 66U;
      }
    } else {
      {
      _1_cmdline_new_next = 44U;
      }
    }
    break;
    case 222: ;
    if (argi == argc - 1) {
      {
      _1_cmdline_new_next = 1U;
      }
    } else {
      {
      _1_cmdline_new_next = 78U;
      }
    }
    break;
    case 28: 
    scoring_system_PAM70(scoring___0);
    {
    _1_cmdline_new_next = 176U;
    }
    break;
    case 53: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--nogaps.. --nomismatches cannot be used at together");

    break;
    case 65: ;
    if ((unsigned int )cmd_type == 1U) {
      {
      _1_cmdline_new_next = 16U;
      }
    } else {
      {
      _1_cmdline_new_next = 97U;
      }
    }
    break;
    case 191: 
    argi = 1;
    {
    _1_cmdline_new_next = 40U;
    }
    break;
    case 218: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--minscore only valid with Smith-Waterman");

    break;
    case 47: 
    align_scoring_load_pairwise(sub_pairs_file, (char const   *)*(argv + (argi + 1)),
                                scoring___0, (char )cmd___0->case_sensitive);
    gzclose(sub_pairs_file);
    substitutions_set = (char)1;
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 73: ;
    if (tmp___9 == 0) {
      {
      _1_cmdline_new_next = 140U;
      }
    } else {
      {
      _1_cmdline_new_next = 104U;
      }
    }
    break;
    case 44: ;
    if (cmd___0->print_colour) {
      {
      _1_cmdline_new_next = 149U;
      }
    } else {
      {
      _1_cmdline_new_next = 122U;
      }
    }
    break;
    case 5: ;
    if (tmp___29 == 0) {
      {
      _1_cmdline_new_next = 138U;
      }
    } else {
      {
      _1_cmdline_new_next = 194U;
      }
    }
    break;
    case 91: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "More than one scoring system specified - not permitted");

    break;
    case 120: ;
    if (tmp___33 == 0) {
      {
      _1_cmdline_new_next = 61U;
      }
    } else {
      {
      _1_cmdline_new_next = 126U;
      }
    }
    break;
    case 184: ;
    if (tmp___32 == 0) {
      {
      _1_cmdline_new_next = 188U;
      }
    } else {
      {
      _1_cmdline_new_next = 68U;
      }
    }
    break;
    case 97: ;
    if (argi < argc) {
      {
      _1_cmdline_new_next = 217U;
      }
    } else {
      {
      _1_cmdline_new_next = 186U;
      }
    }
    break;
    case 162: ;
    if (tmp___36 == 0) {
      {
      _1_cmdline_new_next = 163U;
      }
    } else {
      {
      _1_cmdline_new_next = 29U;
      }
    }
    break;
    case 163: 
    tmp___14 = gzopen((char const   *)*(argv + (argi + 1)), "r");
    sub_pairs_file = tmp___14;
    {
    _1_cmdline_new_next = 125U;
    }
    break;
    case 230: ;
    if (argi < argc) {
      {
      _1_cmdline_new_next = 226U;
      }
    } else {
      {
      _1_cmdline_new_next = 191U;
      }
    }
    break;
    case 72: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--match --mismatch must both be set or neither set");

    break;
    case 99: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--wildcard <w> <s> takes a single character and a number");

    break;
    case 114: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "No input specified");

    break;
    case 33: ;
    if (tmp___4 == 0) {
      {
      _1_cmdline_new_next = 13U;
      }
    } else {
      {
      _1_cmdline_new_next = 152U;
      }
    }
    break;
    case 37: 
    tmp___33 = strcasecmp((char const   *)*(argv + argi), "--context");
    {
    _1_cmdline_new_next = 120U;
    }
    break;
    case 64: ;
    if (argc - argi != 2) {
      {
      _1_cmdline_new_next = 84U;
      }
    } else {
      {
      _1_cmdline_new_next = 127U;
      }
    }
    break;
    case 93: ;
    if (! match_set) {
      {
      _1_cmdline_new_next = 6U;
      }
    } else {
      {
      _1_cmdline_new_next = 206U;
      }
    }
    break;
    case 119: 
    tmp___41 = strcasecmp((char const   *)*(argv + argi), "--colour");
    {
    _1_cmdline_new_next = 135U;
    }
    break;
    case 175: 
    tmp___34 = strcasecmp((char const   *)*(argv + argi), "--maxhits");
    {
    _1_cmdline_new_next = 15U;
    }
    break;
    case 41: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--maxhits only valid with Smith-Waterman");

    break;
    case 233: ;
    if (mismatch_set) {
      {
      _1_cmdline_new_next = 72U;
      }
    } else {
      {
      _1_cmdline_new_next = 183U;
      }
    }
    break;
    case 95: 
    tmp___39 = strcasecmp((char const   *)*(argv + argi), "--stdin");
    {
    _1_cmdline_new_next = 42U;
    }
    break;
    case 149: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Cannot use --printscore, --printfasta, --pretty or --colour with --zam");

    break;
    case 198: 
    scoring_system_DNA_hybridization(scoring___0);
    {
    _1_cmdline_new_next = 176U;
    }
    break;
    case 232: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--printscores only valid with Needleman-Wunsch");

    break;
    case 92: 
    tmp___47 = strcasecmp((char const   *)*(argv + argi), "--case_sensitive");
    {
    _1_cmdline_new_next = 98U;
    }
    break;
    case 115: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "--freestartgap only valid with Needleman-Wunsch");

    break;
    case 10: ;
    if (! tmp___16) {
      {
      _1_cmdline_new_next = 51U;
      }
    } else {
      {
      _1_cmdline_new_next = 159U;
      }
    }
    break;
    case 42: ;
    if (tmp___39 == 0) {
      {
      _1_cmdline_new_next = 131U;
      }
    } else {
      {
      _1_cmdline_new_next = 222U;
      }
    }
    break;
    case 0: 
    tmp___46 = strcasecmp((char const   *)*(argv + argi), "--printseq");
    {
    _1_cmdline_new_next = 124U;
    }
    break;
    case 136: ;
    if (tmp___38 == 0) {
      {
      _1_cmdline_new_next = 223U;
      }
    } else {
      {
      _1_cmdline_new_next = 109U;
      }
    }
    break;
    case 229: 
    argi ++;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 46: 
    tmp___13 = gzopen((char const   *)*(argv + (argi + 1)), "r");
    sub_matrix_file = tmp___13;
    {
    _1_cmdline_new_next = 200U;
    }
    break;
    case 153: 
    cmd___0->print_pretty = (_Bool)1;
    {
    _1_cmdline_new_next = 71U;
    }
    break;
    case 177: ;
    if (tmp___31 == 0) {
      {
      _1_cmdline_new_next = 108U;
      }
    } else {
      {
      _1_cmdline_new_next = 225U;
      }
    }
    break;
    case 39: 
    argi ++;
    {
    _1_cmdline_new_next = 230U;
    }
    break;
    case 66: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Cannot use --printscore, --printfasta, --pretty or --colour with --zam");

    break;
    case 83: ;
    if (tmp___28 == 0) {
      {
      _1_cmdline_new_next = 204U;
      }
    } else {
      {
      _1_cmdline_new_next = 161U;
      }
    }
    break;
    case 207: ;
    if (tmp___8 == 0) {
      {
      _1_cmdline_new_next = 173U;
      }
    } else {
      {
      _1_cmdline_new_next = 39U;
      }
    }
    break;
    case 7: ;
    if (tmp___45 == 0) {
      {
      _1_cmdline_new_next = 21U;
      }
    } else {
      {
      _1_cmdline_new_next = 4U;
      }
    }
    break;
    case 88: ;
    if ((unsigned int )cmd_type != 0U) {
      {
      _1_cmdline_new_next = 58U;
      }
    } else {
      {
      _1_cmdline_new_next = 221U;
      }
    }
    break;
    case 35: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Unknown --scoring choice, not one of PAM30|PAM70|BLOSUM80|BLOSUM62");

    break;
    case 174: 
    print_usage(cmd_type, defaults, (char const   *)*(argv + 0), "Couldn\'t read: %s",
                *(argv + (argi + 1)));

    break;
    case 29: 
    tmp___35 = strcasecmp((char const   *)*(argv + argi), "--minscore");
    {
    _1_cmdline_new_next = 49U;
    }
    break;
    case 126: 
    tmp___32 = strcasecmp((char const   *)*(argv + argi), "--match");
    {
    _1_cmdline_new_next = 184U;
    }
    break;
    case 179: 
    tmp___12 = strcasecmp((char const   *)*(argv + argi), "-h");
    {
    _1_cmdline_new_next = 100U;
    }
    break;
    case 43: 
    tmp___15 = parse_entire_int(*(argv + (argi + 1)), & cmd___0->min_score);
    {
    _1_cmdline_new_next = 219U;
    }
    break;
    case 86: ;
    if (! tmp___25) {
      {
      _1_cmdline_new_next = 99U;
      }
    } else {
      {
      _1_cmdline_new_next = 146U;
      }
    }
    break;
    case 2: ;
    if (cmd___0->file_list_length == 0UL) {
      {
      _1_cmdline_new_next = 114U;
      }
    } else {
      {
      _1_cmdline_new_next = 213U;
      }
    }
    break;
    case 20: 
    tmp___51 = strcasecmp((char const   *)*(argv + argi), "--nogaps");
    {
    _1_cmdline_new_next = 23U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cmdline_new LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_system_DNA_hybridization LOC=UNKNOWN */
void scoring_system_DNA_hybridization(scoring_t *scoring___0 ) 
{ 
  unsigned int _1_scoring_system_DNA_hybridization_next ;

  {
  {
  _1_scoring_system_DNA_hybridization_next = 0U;
  }
  while (1) {
    switch (_1_scoring_system_DNA_hybridization_next) {
    case 1: ;
    return;
    break;
    case 0: 
    scoring_init(scoring___0, 0, 0, -10, -10, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                 (_Bool)0, (_Bool)0);
    scoring_add_mutations(scoring___0, dna_bases, sub_matrix, (char)0);
    {
    _1_scoring_system_DNA_hybridization_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_system_DNA_hybridization LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_dopen LOC=UNKNOWN */
__inline static seq_file_t *seq_dopen(int fd , char ishts , _Bool use_zlib , size_t___0 buf_size ) 
{ 
  seq_file_t *sf ;
  void *tmp ;
  FILE *tmp___0 ;
  gzFile tmp___1 ;
  char tmp___2 ;
  unsigned int _1_seq_dopen_next ;

  {
  {
  _1_seq_dopen_next = 11U;
  }
  while (1) {
    switch (_1_seq_dopen_next) {
    case 4: ;
    if (! tmp___2) {
      {
      _1_seq_dopen_next = 9U;
      }
    } else {
      {
      _1_seq_dopen_next = 15U;
      }
    }
    break;
    case 14: ;
    return ((seq_file_t *)((void *)0));
    break;
    case 15: ;
    return (sf);
    break;
    case 12: 
    _L: ;
    if (use_zlib) {
      {
      _1_seq_dopen_next = 1U;
      }
    } else {
      {
      _1_seq_dopen_next = 2U;
      }
    }
    break;
    case 8: ;
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      _1_seq_dopen_next = 5U;
      }
    } else {
      {
      _1_seq_dopen_next = 2U;
      }
    }
    break;
    case 1: 
    tmp___1 = gzdopen(fd, "r");
    sf->gz_file = tmp___1;
    {
    _1_seq_dopen_next = 8U;
    }
    break;
    case 3: 
    seq_close(sf);
    {
    _1_seq_dopen_next = 14U;
    }
    break;
    case 16: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"[%s:%i] Error: not compiled with sam/bam support\n"),
            "libs/seq_file/seq_file.h", 555);
    exit(1);

    break;
    case 11: 
    tmp = calloc((size_t )1, sizeof(seq_file_t ));
    sf = (seq_file_t *)tmp;
    sf->path = strdup("-");
    {
    _1_seq_dopen_next = 0U;
    }
    break;
    case 9: ;
    return ((seq_file_t *)((void *)0));
    break;
    case 13: 
    tmp___0 = fdopen(fd, "r");
    sf->f_file = tmp___0;
    {
    _1_seq_dopen_next = 17U;
    }
    break;
    case 17: ;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      _1_seq_dopen_next = 3U;
      }
    } else {
      {
      _1_seq_dopen_next = 12U;
      }
    }
    break;
    case 6: ;
    return ((seq_file_t *)((void *)0));
    break;
    case 5: 
    seq_close(sf);
    {
    _1_seq_dopen_next = 6U;
    }
    break;
    case 10: ;
    if (! use_zlib) {
      {
      _1_seq_dopen_next = 13U;
      }
    } else {
      {
      _1_seq_dopen_next = 12U;
      }
    }
    break;
    case 0: ;
    if (ishts) {
      {
      _1_seq_dopen_next = 16U;
      }
    } else {
      {
      _1_seq_dopen_next = 10U;
      }
    }
    break;
    case 2: 
    tmp___2 = _seq_setup(sf, use_zlib, buf_size);
    {
    _1_seq_dopen_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_dopen LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF align_scoring_load_pairwise LOC=UNKNOWN */
void align_scoring_load_pairwise(gzFile file , char const   *file_path , scoring_t *scoring___0 ,
                                 char case_sensitive ) 
{ 
  StrBuf *sbuf ;
  StrBuf *tmp ;
  size_t___0 read_length ;
  int line_num ;
  char a ;
  char b ;
  int score ;
  int num_pairs_added ;
  size_t___0 char2_pos ;
  int tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char tmp___7 ;
  unsigned int _1_align_scoring_load_pairwise_next ;

  {
  {
  _1_align_scoring_load_pairwise_next = 7U;
  }
  while (1) {
    switch (_1_align_scoring_load_pairwise_next) {
    case 18: 
    scoring_add_mutation(scoring___0, a, b, score);
    num_pairs_added ++;
    {
    _1_align_scoring_load_pairwise_next = 35U;
    }
    break;
    case 25: ;
    if (! tmp___0) {
      {
      _1_align_scoring_load_pairwise_next = 13U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 31U;
      }
    }
    break;
    case 4: 
    tmp___1 = isspace((int )*(sbuf->b + (char2_pos + 1UL)));
    {
    _1_align_scoring_load_pairwise_next = 38U;
    }
    break;
    case 30: ;
    if (num_pairs_added == 0) {
      {
      _1_align_scoring_load_pairwise_next = 27U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 3U;
      }
    }
    break;
    case 15: 
    tmp___7 = string_is_all_whitespace((char const   *)sbuf->b);
    {
    _1_align_scoring_load_pairwise_next = 22U;
    }
    break;
    case 31: 
    char2_pos ++;
    {
    _1_align_scoring_load_pairwise_next = 42U;
    }
    break;
    case 12: 
    a = *(sbuf->b + 0);
    b = *(sbuf->b + 2);
    tmp___3 = parse_entire_int(sbuf->b + 4, & score);
    {
    _1_align_scoring_load_pairwise_next = 9U;
    }
    break;
    case 8: 
    strbuf_chomp(sbuf);
    {
    _1_align_scoring_load_pairwise_next = 21U;
    }
    break;
    case 1: ;
    if ((int )*(sbuf->b + 1) != (int )*(sbuf->b + 3)) {
      {
      _1_align_scoring_load_pairwise_next = 5U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 12U;
      }
    }
    break;
    case 23: 
    read_length = strbuf_reset_gzreadline(sbuf, file);
    {
    _1_align_scoring_load_pairwise_next = 36U;
    }
    break;
    case 3: ;
    return;
    break;
    case 24: 
    _loading_error("Line too short", file_path, line_num, (char)0);

    break;
    case 21: ;
    if (sbuf->end > 0UL) {
      {
      _1_align_scoring_load_pairwise_next = 41U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 35U;
      }
    }
    break;
    case 36: ;
    if (! (read_length > 0UL)) {
      {
      _1_align_scoring_load_pairwise_next = 11U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 8U;
      }
    }
    break;
    case 26: ;
    if (! case_sensitive) {
      {
      _1_align_scoring_load_pairwise_next = 40U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 18U;
      }
    }
    break;
    case 11: 
    strbuf_free(sbuf);
    {
    _1_align_scoring_load_pairwise_next = 30U;
    }
    break;
    case 9: ;
    if (! tmp___3) {
      {
      _1_align_scoring_load_pairwise_next = 37U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 26U;
      }
    }
    break;
    case 13: ;
    if (char2_pos + 2UL >= sbuf->end) {
      {
      _1_align_scoring_load_pairwise_next = 28U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 4U;
      }
    }
    break;
    case 19: 
    a = *(sbuf->b + 0);
    char2_pos = (size_t___0 )1;
    {
    _1_align_scoring_load_pairwise_next = 42U;
    }
    break;
    case 17: 
    _loading_error("Too few column headings", file_path, line_num, (char)0);

    break;
    case 40: 
    tmp___5 = tolower((int )a);
    a = (char )tmp___5;
    tmp___6 = tolower((int )b);
    b = (char )tmp___6;
    {
    _1_align_scoring_load_pairwise_next = 18U;
    }
    break;
    case 6: 
    tmp___0 = isspace((int )*(sbuf->b + char2_pos));
    {
    _1_align_scoring_load_pairwise_next = 25U;
    }
    break;
    case 27: 
    _loading_error("No pairs added from file (file empty?)", file_path, line_num,
                   (char)0);

    break;
    case 38: ;
    if (! tmp___1) {
      {
      _1_align_scoring_load_pairwise_next = 24U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 10U;
      }
    }
    break;
    case 34: ;
    if (! tmp___2) {
      {
      _1_align_scoring_load_pairwise_next = 20U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 26U;
      }
    }
    break;
    case 22: ;
    if (! tmp___7) {
      {
      _1_align_scoring_load_pairwise_next = 39U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 35U;
      }
    }
    break;
    case 28: 
    _loading_error("Line too short", file_path, line_num, (char)0);

    break;
    case 5: 
    _loading_error("Inconsistent separators used", file_path, line_num, (char)0);

    break;
    case 37: 
    _loading_error("Invalid number", file_path, line_num, (char)0);

    break;
    case 41: ;
    if ((int )*(sbuf->b + 0) != 35) {
      {
      _1_align_scoring_load_pairwise_next = 15U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 35U;
      }
    }
    break;
    case 10: 
    b = *(sbuf->b + char2_pos);
    tmp___2 = parse_entire_int((sbuf->b + char2_pos) + 2, & score);
    {
    _1_align_scoring_load_pairwise_next = 34U;
    }
    break;
    case 42: ;
    if ((int )*(sbuf->b + char2_pos) != 0) {
      {
      _1_align_scoring_load_pairwise_next = 6U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 13U;
      }
    }
    break;
    case 39: ;
    if (read_length < 5UL) {
      {
      _1_align_scoring_load_pairwise_next = 17U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 29U;
      }
    }
    break;
    case 7: 
    tmp = strbuf_new((size_t___0 )200);
    sbuf = tmp;
    line_num = 0;
    num_pairs_added = 0;
    {
    _1_align_scoring_load_pairwise_next = 23U;
    }
    break;
    case 35: 
    line_num ++;
    {
    _1_align_scoring_load_pairwise_next = 23U;
    }
    break;
    case 29: 
    tmp___4 = isspace((int )*(sbuf->b + 1));
    {
    _1_align_scoring_load_pairwise_next = 2U;
    }
    break;
    case 2: ;
    if (tmp___4) {
      {
      _1_align_scoring_load_pairwise_next = 19U;
      }
    } else {
      {
      _1_align_scoring_load_pairwise_next = 1U;
      }
    }
    break;
    case 20: 
    _loading_error("Invalid number", file_path, line_num, (char)0);

    break;
    }
  }
}
}
/* END FUNCTION-DEF align_scoring_load_pairwise LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF strm_buf_dealloc LOC=UNKNOWN */
__inline static void strm_buf_dealloc(StreamBuffer *b ) 
{ 
  unsigned int _1_strm_buf_dealloc_next ;

  {
  {
  _1_strm_buf_dealloc_next = 0U;
  }
  while (1) {
    switch (_1_strm_buf_dealloc_next) {
    case 1: ;
    return;
    break;
    case 0: 
    free((void *)b->b);
    memset((void *)b, 0, sizeof(StreamBuffer ));
    {
    _1_strm_buf_dealloc_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF strm_buf_dealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fgetc_buf LOC=UNKNOWN */
__inline static int fgetc_buf(FILE *file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  unsigned int _1_fgetc_buf_next ;

  {
  {
  _1_fgetc_buf_next = 3U;
  }
  while (1) {
    switch (_1_fgetc_buf_next) {
    case 8: ;
    return ((int )*(in->b + tmp___2));
    break;
    case 1: ;
    if (in->begin >= in->end) {
      {
      _1_fgetc_buf_next = 0U;
      }
    } else {
      {
      _1_fgetc_buf_next = 2U;
      }
    }
    break;
    case 3: ;
    if (in->begin >= in->end) {
      {
      _1_fgetc_buf_next = 6U;
      }
    } else {
      {
      _1_fgetc_buf_next = 7U;
      }
    }
    break;
    case 9: ;
    return (tmp___1);
    break;
    case 6: 
    tmp = fread((void */* __restrict  */)(in->b + 1), (size_t___0 )1, in->size - 1UL,
                (FILE */* __restrict  */)file);
    in->end = 1UL + tmp;
    in->begin = (size_t___0 )1;
    {
    _1_fgetc_buf_next = 1U;
    }
    break;
    case 0: 
    tmp___1 = -1;
    {
    _1_fgetc_buf_next = 9U;
    }
    break;
    case 7: 
    tmp___2 = in->begin;
    (in->begin) ++;
    {
    _1_fgetc_buf_next = 8U;
    }
    break;
    case 2: 
    tmp___0 = in->begin;
    (in->begin) ++;
    tmp___1 = (int )*(in->b + tmp___0);
    {
    _1_fgetc_buf_next = 9U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF fgetc_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fasta_f LOC=UNKNOWN */
__inline static int _seq_read_fasta_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  long nread ;
  size_t___0 tmp___1 ;
  unsigned int _1__seq_read_fasta_f_next ;

  {
  {
  _1__seq_read_fasta_f_next = 3U;
  }
  while (1) {
    switch (_1__seq_read_fasta_f_next) {
    case 18: ;
    return (1);
    break;
    case 4: ;
    return (-1);
    break;
    case 14: ;
    if (c != 62) {
      {
      _1__seq_read_fasta_f_next = 12U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 6U;
      }
    }
    break;
    case 15: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_f_next = 20U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 14U;
      }
    }
    break;
    case 12: ;
    return (-1);
    break;
    case 8: 
    c = fgetc(sf->f_file);
    {
    _1__seq_read_fasta_f_next = 13U;
    }
    break;
    case 3: 
    seq_read_reset(r);
    tmp = fgetc(sf->f_file);
    c = tmp;
    {
    _1__seq_read_fasta_f_next = 15U;
    }
    break;
    case 16: ;
    return (1);
    break;
    case 21: ;
    return (1);
    break;
    case 11: ;
    if (c != 10) {
      {
      _1__seq_read_fasta_f_next = 0U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 8U;
      }
    }
    break;
    case 9: 
    ungetc(c, sf->f_file);
    {
    _1__seq_read_fasta_f_next = 16U;
    }
    break;
    case 13: ;
    if (! (c != 62)) {
      {
      _1__seq_read_fasta_f_next = 9U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 19U;
      }
    }
    break;
    case 19: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_f_next = 21U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 5U;
      }
    }
    break;
    case 17: ;
    if (nread <= 0L) {
      {
      _1__seq_read_fasta_f_next = 18U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 8U;
      }
    }
    break;
    case 6: 
    tmp___0 = freadline(sf->f_file, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fasta_f_next = 10U;
    }
    break;
    case 5: ;
    if (c != 13) {
      {
      _1__seq_read_fasta_f_next = 11U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 8U;
      }
    }
    break;
    case 10: ;
    if (tmp___0 == 0UL) {
      {
      _1__seq_read_fasta_f_next = 4U;
      }
    } else {
      {
      _1__seq_read_fasta_f_next = 7U;
      }
    }
    break;
    case 0: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___1 = freadline(sf->f_file, & r->seq.b, & r->seq.end, & r->seq.size);
    nread = (long )tmp___1;
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fasta_f_next = 17U;
    }
    break;
    case 7: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fasta_f_next = 8U;
    }
    break;
    case 20: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fasta_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF needleman_wunsch_new LOC=UNKNOWN */
nw_aligner_t *needleman_wunsch_new(void) 
{ 
  nw_aligner_t *nw ;
  void *tmp ;
  unsigned int _1_needleman_wunsch_new_next ;

  {
  {
  _1_needleman_wunsch_new_next = 1U;
  }
  while (1) {
    switch (_1_needleman_wunsch_new_next) {
    case 1: 
    tmp = calloc((size_t )1, sizeof(nw_aligner_t ));
    nw = (nw_aligner_t *)tmp;
    {
    _1_needleman_wunsch_new_next = 0U;
    }
    break;
    case 0: ;
    return (nw);
    break;
    }
  }
}
}
/* END FUNCTION-DEF needleman_wunsch_new LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _init_history LOC=UNKNOWN */
static void _init_history(sw_history_t *hist ) 
{ 
  size_t___0 mem ;
  void *tmp ;
  unsigned int _1__init_history_next ;

  {
  {
  _1__init_history_next = 0U;
  }
  while (1) {
    switch (_1__init_history_next) {
    case 1: ;
    return;
    break;
    case 0: 
    bitset_alloc(& hist->match_scores_mask, (size_t___0 )256);
    hist->hits_capacity = (size_t___0 )256;
    mem = hist->hits_capacity * sizeof(*(hist->sorted_match_indices));
    tmp = malloc(mem);
    hist->sorted_match_indices = (size_t___0 *)tmp;
    {
    _1__init_history_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _init_history LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF smith_waterman_free LOC=UNKNOWN */
void smith_waterman_free(sw_aligner_t *sw___0 ) 
{ 
  unsigned int _1_smith_waterman_free_next ;

  {
  {
  _1_smith_waterman_free_next = 1U;
  }
  while (1) {
    switch (_1_smith_waterman_free_next) {
    case 1: 
    aligner_destroy(& sw___0->aligner);
    bitset_dealloc(& sw___0->history.match_scores_mask);
    free((void *)sw___0->history.sorted_match_indices);
    free((void *)sw___0);
    {
    _1_smith_waterman_free_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF smith_waterman_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_add_mutation LOC=UNKNOWN */
void scoring_add_mutation(scoring_t *scoring___0 , char a , char b , int score ) 
{ 
  unsigned int _1_scoring_add_mutation_next ;

  {
  {
  _1_scoring_add_mutation_next = 5U;
  }
  while (1) {
    switch (_1_scoring_add_mutation_next) {
    case 4: 
    scoring___0->min_penalty = scoring___0->min_penalty;
    {
    _1_scoring_add_mutation_next = 6U;
    }
    break;
    case 1: 
    scoring___0->max_penalty = score;
    {
    _1_scoring_add_mutation_next = 0U;
    }
    break;
    case 3: ;
    if (scoring___0->min_penalty <= score) {
      {
      _1_scoring_add_mutation_next = 4U;
      }
    } else {
      {
      _1_scoring_add_mutation_next = 2U;
      }
    }
    break;
    case 6: ;
    if (scoring___0->max_penalty >= score) {
      {
      _1_scoring_add_mutation_next = 7U;
      }
    } else {
      {
      _1_scoring_add_mutation_next = 1U;
      }
    }
    break;
    case 5: 
    scoring___0->swap_scores[(size_t___0 )a][(size_t___0 )b] = score;
    scoring___0->swap_set[(size_t___0 )a][(int )b >> 5] |= (unsigned int )(1 << ((int )b & 31));
    {
    _1_scoring_add_mutation_next = 3U;
    }
    break;
    case 0: ;
    return;
    break;
    case 7: 
    scoring___0->max_penalty = scoring___0->max_penalty;
    {
    _1_scoring_add_mutation_next = 0U;
    }
    break;
    case 2: 
    scoring___0->min_penalty = score;
    {
    _1_scoring_add_mutation_next = 6U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_add_mutation LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_system_BLOSUM62 LOC=UNKNOWN */
void scoring_system_BLOSUM62(scoring_t *scoring___0 ) 
{ 
  unsigned int _1_scoring_system_BLOSUM62_next ;

  {
  {
  _1_scoring_system_BLOSUM62_next = 1U;
  }
  while (1) {
    switch (_1_scoring_system_BLOSUM62_next) {
    case 1: 
    scoring_init(scoring___0, 1, -4, -10, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                 (_Bool)0, (_Bool)0);
    scoring_add_mutations(scoring___0, (char const   *)(amino_acids), (int const   *)(blosum62),
                          (char)1);
    {
    _1_scoring_system_BLOSUM62_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_system_BLOSUM62 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF freadline_buf LOC=UNKNOWN */
__inline static size_t___0 freadline_buf(FILE *file , StreamBuffer *in , char **buf ,
                                         size_t___0 *len , size_t___0 *size ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 buffered ;
  size_t___0 total_read ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  unsigned int _1_freadline_buf_next ;

  {
  {
  _1_freadline_buf_next = 8U;
  }
  while (1) {
    switch (_1_freadline_buf_next) {
    case 14: 
    offset = in->begin;
    {
    _1_freadline_buf_next = 10U;
    }
    break;
    case 15: ;
    if ((int )*(*buf + (*len - 1UL)) == 10) {
      {
      _1_freadline_buf_next = 6U;
      }
    } else {
      {
      _1_freadline_buf_next = 0U;
      }
    }
    break;
    case 12: ;
    if (! ((int )*(in->b + tmp___0) != 10)) {
      {
      _1_freadline_buf_next = 9U;
      }
    } else {
      {
      _1_freadline_buf_next = 10U;
      }
    }
    break;
    case 8: ;
    if (in->begin >= in->end) {
      {
      _1_freadline_buf_next = 5U;
      }
    } else {
      {
      _1_freadline_buf_next = 1U;
      }
    }
    break;
    case 1: 
    total_read = (size_t___0 )0;
    {
    _1_freadline_buf_next = 21U;
    }
    break;
    case 21: ;
    if (in->end > in->begin) {
      {
      _1_freadline_buf_next = 14U;
      }
    } else {
      {
      _1_freadline_buf_next = 6U;
      }
    }
    break;
    case 11: ;
    return (total_read);
    break;
    case 9: 
    buffered = offset - in->begin;
    cbuf_capacity(buf, size, *len + buffered);
    memcpy((void */* __restrict  */)(*buf + *len), (void const   */* __restrict  */)(in->b + in->begin),
           buffered);
    *len += buffered;
    in->begin = offset;
    total_read += buffered;
    {
    _1_freadline_buf_next = 15U;
    }
    break;
    case 6: 
    *(*buf + *len) = (char)0;
    {
    _1_freadline_buf_next = 11U;
    }
    break;
    case 5: 
    tmp = fread((void */* __restrict  */)(in->b + 1), (size_t___0 )1, in->size - 1UL,
                (FILE */* __restrict  */)file);
    in->end = 1UL + tmp;
    in->begin = (size_t___0 )1;
    {
    _1_freadline_buf_next = 1U;
    }
    break;
    case 10: ;
    if (offset < in->end) {
      {
      _1_freadline_buf_next = 20U;
      }
    } else {
      {
      _1_freadline_buf_next = 9U;
      }
    }
    break;
    case 0: 
    tmp___1 = fread((void */* __restrict  */)(in->b + 1), (size_t___0 )1, in->size - 1UL,
                    (FILE */* __restrict  */)file);
    in->end = 1UL + tmp___1;
    in->begin = (size_t___0 )1;
    {
    _1_freadline_buf_next = 21U;
    }
    break;
    case 20: 
    tmp___0 = offset;
    offset ++;
    {
    _1_freadline_buf_next = 12U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF freadline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_close LOC=UNKNOWN */
__inline static void seq_close(seq_file_t *sf ) 
{ 
  int e ;
  read_t *r ;
  read_t *tmpr ;
  unsigned int _1_seq_close_next ;

  {
  {
  _1_seq_close_next = 9U;
  }
  while (1) {
    switch (_1_seq_close_next) {
    case 4: 
    memset((void *)sf, 0, sizeof(*sf));
    free((void *)sf);
    {
    _1_seq_close_next = 10U;
    }
    break;
    case 14: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"[%s:%i] Error closing gzfile: %s [%i]\n"),
            "libs/seq_file/seq_file.h", 610, sf->path, e);
    {
    _1_seq_close_next = 8U;
    }
    break;
    case 12: ;
    if (e != 0) {
      {
      _1_seq_close_next = 14U;
      }
    } else {
      {
      _1_seq_close_next = 8U;
      }
    }
    break;
    case 8: 
    strm_buf_dealloc(& sf->in);
    free((void *)sf->path);
    r = sf->rhead;
    {
    _1_seq_close_next = 6U;
    }
    break;
    case 3: ;
    if ((unsigned long )sf->gz_file != (unsigned long )((void *)0)) {
      {
      _1_seq_close_next = 7U;
      }
    } else {
      {
      _1_seq_close_next = 8U;
      }
    }
    break;
    case 11: 
    tmpr = r->next;
    seq_read_free(r);
    r = tmpr;
    {
    _1_seq_close_next = 6U;
    }
    break;
    case 9: ;
    if ((unsigned long )sf->f_file != (unsigned long )((void *)0)) {
      {
      _1_seq_close_next = 5U;
      }
    } else {
      {
      _1_seq_close_next = 3U;
      }
    }
    break;
    case 13: ;
    if (e != 0) {
      {
      _1_seq_close_next = 2U;
      }
    } else {
      {
      _1_seq_close_next = 3U;
      }
    }
    break;
    case 6: ;
    if ((unsigned long )r != (unsigned long )((void *)0)) {
      {
      _1_seq_close_next = 11U;
      }
    } else {
      {
      _1_seq_close_next = 4U;
      }
    }
    break;
    case 5: 
    e = fclose(sf->f_file);
    {
    _1_seq_close_next = 13U;
    }
    break;
    case 10: ;
    return;
    break;
    case 7: 
    e = gzclose(sf->gz_file);
    {
    _1_seq_close_next = 12U;
    }
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"[%s:%i] Error closing file: %s [%i]\n"),
            "libs/seq_file/seq_file.h", 606, sf->path, e);
    {
    _1_seq_close_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fasta_f_buf LOC=UNKNOWN */
__inline static int _seq_read_fasta_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  long nread ;
  size_t___0 tmp___1 ;
  unsigned int _1__seq_read_fasta_f_buf_next ;

  {
  {
  _1__seq_read_fasta_f_buf_next = 0U;
  }
  while (1) {
    switch (_1__seq_read_fasta_f_buf_next) {
    case 18: ;
    return (1);
    break;
    case 4: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fasta_f_buf_next = 15U;
    }
    break;
    case 14: 
    tmp___0 = freadline_buf(sf->f_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fasta_f_buf_next = 20U;
    }
    break;
    case 15: 
    c = fgetc_buf(sf->f_file, & sf->in);
    {
    _1__seq_read_fasta_f_buf_next = 21U;
    }
    break;
    case 12: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_f_buf_next = 5U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 9U;
      }
    }
    break;
    case 8: ;
    if (c != 10) {
      {
      _1__seq_read_fasta_f_buf_next = 17U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 15U;
      }
    }
    break;
    case 1: ;
    return (1);
    break;
    case 3: ;
    return (1);
    break;
    case 16: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_f_buf_next = 1U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 10U;
      }
    }
    break;
    case 21: ;
    if (! (c != 62)) {
      {
      _1__seq_read_fasta_f_buf_next = 19U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 16U;
      }
    }
    break;
    case 9: ;
    if (c != 62) {
      {
      _1__seq_read_fasta_f_buf_next = 13U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 14U;
      }
    }
    break;
    case 13: ;
    return (-1);
    break;
    case 19: 
    ungetc_buf(c, & sf->in);
    {
    _1__seq_read_fasta_f_buf_next = 3U;
    }
    break;
    case 17: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___1 = freadline_buf(sf->f_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
    nread = (long )tmp___1;
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fasta_f_buf_next = 2U;
    }
    break;
    case 5: ;
    return (0);
    break;
    case 10: ;
    if (c != 13) {
      {
      _1__seq_read_fasta_f_buf_next = 8U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 15U;
      }
    }
    break;
    case 0: 
    seq_read_reset(r);
    tmp = fgetc_buf(sf->f_file, & sf->in);
    c = tmp;
    {
    _1__seq_read_fasta_f_buf_next = 12U;
    }
    break;
    case 7: ;
    return (-1);
    break;
    case 2: ;
    if (nread <= 0L) {
      {
      _1__seq_read_fasta_f_buf_next = 18U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 15U;
      }
    }
    break;
    case 20: ;
    if (tmp___0 == 0UL) {
      {
      _1__seq_read_fasta_f_buf_next = 7U;
      }
    } else {
      {
      _1__seq_read_fasta_f_buf_next = 4U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fasta_f_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF get_next_hit LOC=UNKNOWN */
static char get_next_hit(void) 
{ 
  int r ;
  char response ;
  char next_hit ;
  unsigned int _1_get_next_hit_next ;

  {
  {
  _1_get_next_hit_next = 15U;
  }
  while (1) {
    switch (_1_get_next_hit_next) {
    case 18: 
    printf((char const   *)((char const   */* __restrict  */)"next [h]it or [a]lignment: "));
    fflush(stdout);
    {
    _1_get_next_hit_next = 1U;
    }
    break;
    case 4: 
    r = 0;
    response = (char)0;
    next_hit = (char)0;
    {
    _1_get_next_hit_next = 7U;
    }
    break;
    case 15: ;
    if (! wait_on_keystroke) {
      {
      _1_get_next_hit_next = 23U;
      }
    } else {
      {
      _1_get_next_hit_next = 4U;
      }
    }
    break;
    case 12: 
    putc('\n', stdout);
    exit(0);

    break;
    case 1: 
    r = getc(stdin);
    {
    _1_get_next_hit_next = 13U;
    }
    break;
    case 23: ;
    return ((char)1);
    break;
    case 16: 
    next_hit = (char)0;
    response = (char)1;
    {
    _1_get_next_hit_next = 1U;
    }
    break;
    case 24: ;
    if (r == -1) {
      {
      _1_get_next_hit_next = 12U;
      }
    } else {
      {
      _1_get_next_hit_next = 7U;
      }
    }
    break;
    case 21: 
    next_hit = (char)1;
    response = (char)1;
    {
    _1_get_next_hit_next = 1U;
    }
    break;
    case 11: ;
    if (r != 10) {
      {
      _1_get_next_hit_next = 9U;
      }
    } else {
      {
      _1_get_next_hit_next = 24U;
      }
    }
    break;
    case 9: ;
    if (! (r != 13)) {
      {
      _1_get_next_hit_next = 24U;
      }
    } else {
      {
      _1_get_next_hit_next = 5U;
      }
    }
    break;
    case 13: ;
    if (r != -1) {
      {
      _1_get_next_hit_next = 11U;
      }
    } else {
      {
      _1_get_next_hit_next = 24U;
      }
    }
    break;
    case 19: ;
    if (r == 72) {
      {
      _1_get_next_hit_next = 21U;
      }
    } else {
      {
      _1_get_next_hit_next = 17U;
      }
    }
    break;
    case 17: ;
    if (r == 97) {
      {
      _1_get_next_hit_next = 22U;
      }
    } else {
      {
      _1_get_next_hit_next = 20U;
      }
    }
    break;
    case 6: 
    next_hit = (char)1;
    response = (char)1;
    {
    _1_get_next_hit_next = 1U;
    }
    break;
    case 22: 
    next_hit = (char)0;
    response = (char)1;
    {
    _1_get_next_hit_next = 1U;
    }
    break;
    case 5: ;
    if (r == 104) {
      {
      _1_get_next_hit_next = 6U;
      }
    } else {
      {
      _1_get_next_hit_next = 19U;
      }
    }
    break;
    case 0: ;
    return (next_hit);
    break;
    case 7: ;
    if (! response) {
      {
      _1_get_next_hit_next = 18U;
      }
    } else {
      {
      _1_get_next_hit_next = 0U;
      }
    }
    break;
    case 20: ;
    if (r == 65) {
      {
      _1_get_next_hit_next = 16U;
      }
    } else {
      {
      _1_get_next_hit_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF get_next_hit LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _rndup2pow64 LOC=UNKNOWN */
__inline static size_t___0 _rndup2pow64(unsigned long long x ) 
{ 
  unsigned int _1__rndup2pow64_next ;

  {
  {
  _1__rndup2pow64_next = 1U;
  }
  while (1) {
    switch (_1__rndup2pow64_next) {
    case 1: 
    x --;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;
    x ++;
    {
    _1__rndup2pow64_next = 0U;
    }
    break;
    case 0: ;
    return ((size_t___0 )x);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _rndup2pow64 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_system_default LOC=UNKNOWN */
void scoring_system_default(scoring_t *scoring___0 ) 
{ 
  int match_default ;
  int mismatch_default ;
  int gap_open_default ;
  int gap_extend_default ;
  unsigned int _1_scoring_system_default_next ;

  {
  {
  _1_scoring_system_default_next = 1U;
  }
  while (1) {
    switch (_1_scoring_system_default_next) {
    case 1: 
    match_default = 1;
    mismatch_default = -2;
    gap_open_default = -4;
    gap_extend_default = -1;
    scoring_init(scoring___0, match_default, mismatch_default, gap_open_default, gap_extend_default,
                 (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0);
    {
    _1_scoring_system_default_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_system_default LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ungetc_buf LOC=UNKNOWN */
__inline static int ungetc_buf(int c , StreamBuffer *in ) 
{ 
  unsigned int _1_ungetc_buf_next ;

  {
  {
  _1_ungetc_buf_next = 4U;
  }
  while (1) {
    switch (_1_ungetc_buf_next) {
    case 4: ;
    if (in->begin == 0UL) {
      {
      _1_ungetc_buf_next = 5U;
      }
    } else {
      {
      _1_ungetc_buf_next = 6U;
      }
    }
    break;
    case 1: 
    *(in->b + 0) = (char )c;
    in->end = (size_t___0 )1;
    {
    _1_ungetc_buf_next = 0U;
    }
    break;
    case 3: ;
    return (c);
    break;
    case 6: 
    (in->begin) --;
    *(in->b + in->begin) = (char )c;
    {
    _1_ungetc_buf_next = 3U;
    }
    break;
    case 5: ;
    if (in->end == 0UL) {
      {
      _1_ungetc_buf_next = 1U;
      }
    } else {
      {
      _1_ungetc_buf_next = 2U;
      }
    }
    break;
    case 0: ;
    return (c);
    break;
    case 2: ;
    return (-1);
    break;
    }
  }
}
}
/* END FUNCTION-DEF ungetc_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF smith_waterman_align2 LOC=UNKNOWN */
void smith_waterman_align2(char const   *a , char const   *b , size_t___0 len_a ,
                           size_t___0 len_b , scoring_t const   *scoring___0 , sw_aligner_t *sw___0 ) 
{ 
  aligner_t *aligner ;
  sw_history_t *hist ;
  size_t___0 arr_size ;
  size_t___0 tmp ;
  size_t___0 pos ;
  size_t___0 tmp___0 ;
  MatrixSort tmp_struct ;
  unsigned int _1_smith_waterman_align2_next ;

  {
  {
  _1_smith_waterman_align2_next = 0U;
  }
  while (1) {
    switch (_1_smith_waterman_align2_next) {
    case 4: 
    pos ++;
    {
    _1_smith_waterman_align2_next = 2U;
    }
    break;
    case 8: 
    tmp___0 = hist->num_of_hits;
    (hist->num_of_hits) ++;
    *(hist->sorted_match_indices + tmp___0) = pos;
    {
    _1_smith_waterman_align2_next = 4U;
    }
    break;
    case 1: ;
    if (*(aligner->match_scores + pos) > 0) {
      {
      _1_smith_waterman_align2_next = 8U;
      }
    } else {
      {
      _1_smith_waterman_align2_next = 4U;
      }
    }
    break;
    case 6: ;
    return;
    break;
    case 0: 
    aligner = & sw___0->aligner;
    hist = & sw___0->history;
    aligner_align(aligner, a, b, len_a, len_b, scoring___0, (char)1);
    arr_size = aligner->score_width * aligner->score_height;
    _ensure_history_capacity(hist, arr_size);
    memset((void *)hist->match_scores_mask.b, 0, (hist->match_scores_mask.l + 31UL) / 32UL);
    tmp = (size_t___0 )0;
    hist->next_hit = tmp;
    hist->num_of_hits = tmp;
    pos = (size_t___0 )0;
    {
    _1_smith_waterman_align2_next = 2U;
    }
    break;
    case 7: 
    tmp_struct.match_scores = aligner->match_scores;
    tmp_struct.score_width = (unsigned int )aligner->score_width;
    sort_r((void *)hist->sorted_match_indices, hist->num_of_hits, sizeof(size_t___0 ),
           & sort_match_indices, (void *)(& tmp_struct));
    {
    _1_smith_waterman_align2_next = 6U;
    }
    break;
    case 2: ;
    if (pos < arr_size) {
      {
      _1_smith_waterman_align2_next = 1U;
      }
    } else {
      {
      _1_smith_waterman_align2_next = 7U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF smith_waterman_align2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fastq_f LOC=UNKNOWN */
__inline static int _seq_read_fastq_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  size_t___0 tmp___2 ;
  unsigned int _1__seq_read_fastq_f_next ;

  {
  {
  _1__seq_read_fastq_f_next = 15U;
  }
  while (1) {
    switch (_1__seq_read_fastq_f_next) {
    case 25: ;
    if (! (r->qual.end < r->seq.end)) {
      {
      _1__seq_read_fastq_f_next = 29U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 2U;
      }
    }
    break;
    case 4: 
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fastq_f_next = 5U;
    }
    break;
    case 14: ;
    if (! (c != 43)) {
      {
      _1__seq_read_fastq_f_next = 20U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 32U;
      }
    }
    break;
    case 15: 
    seq_read_reset(r);
    tmp = fgetc(sf->f_file);
    c = tmp;
    {
    _1__seq_read_fastq_f_next = 28U;
    }
    break;
    case 8: 
    tmp___0 = freadline(sf->f_file, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fastq_f_next = 22U;
    }
    break;
    case 23: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_f_next = 19U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 17U;
      }
    }
    break;
    case 3: ;
    return (1);
    break;
    case 16: ;
    return (-1);
    break;
    case 24: ;
    return (1);
    break;
    case 21: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___1 = freadline(sf->f_file, & r->seq.b, & r->seq.end, & r->seq.size);
    {
    _1__seq_read_fastq_f_next = 13U;
    }
    break;
    case 36: ;
    return (-1);
    break;
    case 26: ;
    return (-1);
    break;
    case 11: ;
    return (0);
    break;
    case 9: ;
    if (! (c != 64)) {
      {
      _1__seq_read_fastq_f_next = 34U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 29U;
      }
    }
    break;
    case 13: ;
    if (tmp___1 == 0UL) {
      {
      _1__seq_read_fastq_f_next = 7U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 4U;
      }
    }
    break;
    case 19: ;
    if (! (c != 10)) {
      {
      _1__seq_read_fastq_f_next = 17U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 20U;
      }
    }
    break;
    case 32: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_f_next = 26U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 37U;
      }
    }
    break;
    case 17: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_f_next = 39U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 2U;
      }
    }
    break;
    case 40: ;
    if (c != 64) {
      {
      _1__seq_read_fastq_f_next = 36U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 8U;
      }
    }
    break;
    case 6: ;
    if (tmp___2 > 0UL) {
      {
      _1__seq_read_fastq_f_next = 42U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 3U;
      }
    }
    break;
    case 38: ;
    if (c != -1) {
      {
      _1__seq_read_fastq_f_next = 9U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 34U;
      }
    }
    break;
    case 34: 
    ungetc(c, sf->f_file);
    {
    _1__seq_read_fastq_f_next = 24U;
    }
    break;
    case 22: ;
    if (tmp___0 == 0UL) {
      {
      _1__seq_read_fastq_f_next = 16U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 0U;
      }
    }
    break;
    case 28: ;
    if (c == -1) {
      {
      _1__seq_read_fastq_f_next = 11U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 40U;
      }
    }
    break;
    case 5: 
    c = fgetc(sf->f_file);
    {
    _1__seq_read_fastq_f_next = 14U;
    }
    break;
    case 37: ;
    if (c != 13) {
      {
      _1__seq_read_fastq_f_next = 10U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 5U;
      }
    }
    break;
    case 10: ;
    if (c != 10) {
      {
      _1__seq_read_fastq_f_next = 21U;
      }
    } else {
      {
      _1__seq_read_fastq_f_next = 5U;
      }
    }
    break;
    case 42: 
    cbuf_chomp(r->qual.b, & r->qual.end);
    {
    _1__seq_read_fastq_f_next = 25U;
    }
    break;
    case 0: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fastq_f_next = 5U;
    }
    break;
    case 39: ;
    return (-1);
    break;
    case 7: ;
    return (-1);
    break;
    case 29: 
    c = fgetc(sf->f_file);
    {
    _1__seq_read_fastq_f_next = 38U;
    }
    break;
    case 2: 
    tmp___2 = freadline(sf->f_file, & r->qual.b, & r->qual.end, & r->qual.size);
    {
    _1__seq_read_fastq_f_next = 6U;
    }
    break;
    case 20: 
    c = fgetc(sf->f_file);
    {
    _1__seq_read_fastq_f_next = 23U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fastq_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_read_free LOC=UNKNOWN */
__inline static void seq_read_free(read_t *r ) 
{ 
  unsigned int _1_seq_read_free_next ;

  {
  {
  _1_seq_read_free_next = 1U;
  }
  while (1) {
    switch (_1_seq_read_free_next) {
    case 1: 
    seq_read_dealloc(r);
    free((void *)r);
    {
    _1_seq_read_free_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_read_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF smith_waterman_get_aligner LOC=UNKNOWN */
aligner_t *smith_waterman_get_aligner(sw_aligner_t *sw___0 ) 
{ 
  unsigned int _1_smith_waterman_get_aligner_next ;

  {
  {
  _1_smith_waterman_get_aligner_next = 0U;
  }
  while (1) {
    switch (_1_smith_waterman_get_aligner_next) {
    case 0: ;
    return (& sw___0->aligner);
    break;
    }
  }
}
}
/* END FUNCTION-DEF smith_waterman_get_aligner LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF align_pair_from_file LOC=UNKNOWN */
void align_pair_from_file(read_t *read1 , read_t *read2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int _1_align_pair_from_file_next ;

  {
  {
  _1_align_pair_from_file_next = 4U;
  }
  while (1) {
    switch (_1_align_pair_from_file_next) {
    case 4: ;
    if (read2->name.end == 0UL) {
      {
      _1_align_pair_from_file_next = 0U;
      }
    } else {
      {
      _1_align_pair_from_file_next = 6U;
      }
    }
    break;
    case 1: 
    tmp___0 = read1->name.b;
    {
    _1_align_pair_from_file_next = 5U;
    }
    break;
    case 3: 
    tmp___0 = (char *)((void *)0);
    {
    _1_align_pair_from_file_next = 5U;
    }
    break;
    case 6: 
    tmp = read2->name.b;
    {
    _1_align_pair_from_file_next = 2U;
    }
    break;
    case 5: 
    align((char const   *)read1->seq.b, (char const   *)read2->seq.b, (char const   *)tmp___0,
          (char const   *)tmp);
    {
    _1_align_pair_from_file_next = 7U;
    }
    break;
    case 0: 
    tmp = (char *)((void *)0);
    {
    _1_align_pair_from_file_next = 2U;
    }
    break;
    case 7: ;
    return;
    break;
    case 2: ;
    if (read1->name.end == 0UL) {
      {
      _1_align_pair_from_file_next = 3U;
      }
    } else {
      {
      _1_align_pair_from_file_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF align_pair_from_file LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF smith_waterman_align LOC=UNKNOWN */
void smith_waterman_align(char const   *a , char const   *b , scoring_t const   *scoring___0 ,
                          sw_aligner_t *sw___0 ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  unsigned int _1_smith_waterman_align_next ;

  {
  {
  _1_smith_waterman_align_next = 0U;
  }
  while (1) {
    switch (_1_smith_waterman_align_next) {
    case 1: ;
    return;
    break;
    case 0: 
    tmp = strlen(b);
    tmp___0 = strlen(a);
    smith_waterman_align2(a, b, tmp___0, tmp, scoring___0, sw___0);
    {
    _1_smith_waterman_align_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF smith_waterman_align LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_fasta_gz LOC=UNKNOWN */
__inline static int _seq_read_fasta_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  long nread ;
  size_t___0 tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned int _1__seq_read_fasta_gz_next ;

  {
  {
  _1__seq_read_fasta_gz_next = 25U;
  }
  while (1) {
    switch (_1__seq_read_fasta_gz_next) {
    case 18: ;
    if (nread <= 0L) {
      {
      _1__seq_read_fasta_gz_next = 20U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 14U;
      }
    }
    break;
    case 25: 
    seq_read_reset(r);
    {
    _1__seq_read_fasta_gz_next = 26U;
    }
    break;
    case 4: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp___4 = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    c = (int )*tmp___4;
    {
    _1__seq_read_fasta_gz_next = 3U;
    }
    break;
    case 14: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_fasta_gz_next = 4U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 7U;
      }
    }
    break;
    case 15: 
    c = tmp___1;
    {
    _1__seq_read_fasta_gz_next = 11U;
    }
    break;
    case 12: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    tmp___1 = (int )*tmp;
    {
    _1__seq_read_fasta_gz_next = 15U;
    }
    break;
    case 8: ;
    return (-1);
    break;
    case 1: 
    tmp___2 = gzreadline(sf->gz_file, & r->name.b, & r->name.end, & r->name.size);
    {
    _1__seq_read_fasta_gz_next = 9U;
    }
    break;
    case 23: 
    cbuf_chomp(r->name.b, & r->name.end);
    {
    _1__seq_read_fasta_gz_next = 14U;
    }
    break;
    case 3: ;
    if (! (c != 62)) {
      {
      _1__seq_read_fasta_gz_next = 6U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 5U;
      }
    }
    break;
    case 16: ;
    return (1);
    break;
    case 24: 
    tmp___0 = gzgetc(sf->gz_file);
    tmp___1 = tmp___0;
    {
    _1__seq_read_fasta_gz_next = 15U;
    }
    break;
    case 21: ;
    return (-1);
    break;
    case 26: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_fasta_gz_next = 12U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 24U;
      }
    }
    break;
    case 11: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_gz_next = 19U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 2U;
      }
    }
    break;
    case 9: ;
    if (tmp___2 == 0UL) {
      {
      _1__seq_read_fasta_gz_next = 8U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 23U;
      }
    }
    break;
    case 13: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    tmp___3 = gzreadline(sf->gz_file, & r->seq.b, & r->seq.end, & r->seq.size);
    nread = (long )tmp___3;
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_fasta_gz_next = 18U;
    }
    break;
    case 19: ;
    return (0);
    break;
    case 17: ;
    if (c != 13) {
      {
      _1__seq_read_fasta_gz_next = 27U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 14U;
      }
    }
    break;
    case 6: 
    gzungetc(c, sf->gz_file);
    {
    _1__seq_read_fasta_gz_next = 16U;
    }
    break;
    case 27: ;
    if (c != 10) {
      {
      _1__seq_read_fasta_gz_next = 13U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 14U;
      }
    }
    break;
    case 5: ;
    if (c == -1) {
      {
      _1__seq_read_fasta_gz_next = 10U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 17U;
      }
    }
    break;
    case 10: ;
    return (1);
    break;
    case 7: 
    tmp___5 = gzgetc(sf->gz_file);
    c = tmp___5;
    {
    _1__seq_read_fasta_gz_next = 3U;
    }
    break;
    case 2: ;
    if (c != 62) {
      {
      _1__seq_read_fasta_gz_next = 21U;
      }
    } else {
      {
      _1__seq_read_fasta_gz_next = 1U;
      }
    }
    break;
    case 20: ;
    return (1);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_fasta_gz LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_open LOC=UNKNOWN */
__inline static seq_file_t *seq_open(char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  seq_file_t *tmp___1 ;
  int tmp___2 ;
  seq_format fmt ;
  seq_format tmp___3 ;
  _Bool ishts ;
  int tmp___4 ;
  seq_file_t *tmp___5 ;
  unsigned int _1_seq_open_next ;

  {
  {
  _1_seq_open_next = 7U;
  }
  while (1) {
    switch (_1_seq_open_next) {
    case 4: 
    tmp___4 = 1;
    {
    _1_seq_open_next = 12U;
    }
    break;
    case 14: ;
    return (tmp___5);
    break;
    case 15: ;
    return (tmp___1);
    break;
    case 12: 
    ishts = (_Bool )tmp___4;
    tmp___5 = seq_open2(p, ishts, (_Bool)1, (size_t___0 )(1 << 20));
    {
    _1_seq_open_next = 14U;
    }
    break;
    case 8: ;
    if (tmp___2 == 0) {
      {
      _1_seq_open_next = 13U;
      }
    } else {
      {
      _1_seq_open_next = 0U;
      }
    }
    break;
    case 1: 
    tmp___4 = 1;
    {
    _1_seq_open_next = 12U;
    }
    break;
    case 3: 
    tmp = 1;
    {
    _1_seq_open_next = 16U;
    }
    break;
    case 16: 
    tmp___2 = strcmp(p, "-");
    {
    _1_seq_open_next = 8U;
    }
    break;
    case 11: 
    __assert_fail("p != NULL", "libs/seq_file/seq_file.h", 575, "seq_open");
    tmp = 0;

    break;
    case 9: 
    tmp___4 = 1;
    {
    _1_seq_open_next = 12U;
    }
    break;
    case 13: 
    tmp___0 = fileno(stdin);
    tmp___1 = seq_dopen(tmp___0, (char)0, (_Bool)1, (size_t___0 )0);
    {
    _1_seq_open_next = 15U;
    }
    break;
    case 6: ;
    if ((unsigned int )fmt == 16U) {
      {
      _1_seq_open_next = 9U;
      }
    } else {
      {
      _1_seq_open_next = 10U;
      }
    }
    break;
    case 5: 
    tmp___4 = 0;
    {
    _1_seq_open_next = 12U;
    }
    break;
    case 10: ;
    if ((unsigned int )fmt == 16U) {
      {
      _1_seq_open_next = 1U;
      }
    } else {
      {
      _1_seq_open_next = 5U;
      }
    }
    break;
    case 0: 
    tmp___3 = seq_guess_filetype_from_extension(p);
    fmt = tmp___3;
    {
    _1_seq_open_next = 2U;
    }
    break;
    case 7: ;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      _1_seq_open_next = 3U;
      }
    } else {
      {
      _1_seq_open_next = 11U;
      }
    }
    break;
    case 2: ;
    if ((unsigned int )fmt == 8U) {
      {
      _1_seq_open_next = 4U;
      }
    } else {
      {
      _1_seq_open_next = 6U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_open LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF align LOC=UNKNOWN */
void align(char const   *seq_a , char const   *seq_b , char const   *seq_a_name ,
           char const   *seq_b_name ) 
{ 
  aligner_t *aligner ;
  aligner_t *tmp ;
  size_t___0 len_a ;
  size_t___0 len_b ;
  size_t___0 tmp___1 ;
  double tmp___2 ;
  size_t___0 tmp___3 ;
  size_t___0 hit_index ;
  size_t___0 context_left ;
  size_t___0 context_right ;
  size_t___0 left_spaces_a ;
  size_t___0 left_spaces_b ;
  size_t___0 right_spaces_a ;
  size_t___0 right_spaces_b ;
  size_t___0 tmp___4 ;
  size_t___0 rem_a ;
  size_t___0 rem_b ;
  size_t___0 max_left_spaces ;
  size_t___0 tmp___5 ;
  size_t___0 max_right_spaces ;
  size_t___0 tmp___6 ;
  size_t___0 spacer ;
  char tmp___7 ;
  int tmp___8 ;
  unsigned int _1_align_next ;

  {
  {
  _1_align_next = 9U;
  }
  while (1) {
    switch (_1_align_next) {
    case 18: ;
    if (result->pos_a >= result->pos_b) {
      {
      _1_align_next = 93U;
      }
    } else {
      {
      _1_align_next = 21U;
      }
    }
    break;
    case 50: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error: Interactive input takes seq only (no FASTA/FASTQ) \'%s:%s\'\n"),
            seq_a_name, seq_b_name);
    fflush(stderr);
    exit(1);

    break;
    case 80: 
    fputs((char const   *)((char const   */* __restrict  */)seq_a_name), (FILE *)((FILE */* __restrict  */)stdout));
    putc('\n', stdout);
    {
    _1_align_next = 78U;
    }
    break;
    case 108: 
    putc('.', stdout);
    spacer ++;
    {
    _1_align_next = 33U;
    }
    break;
    case 104: 
    tmp___3 = len_b;
    {
    _1_align_next = 103U;
    }
    break;
    case 25: 
    fputs((char const   *)((char const   */* __restrict  */)"==\n"), (FILE *)((FILE */* __restrict  */)stdout));
    fflush(stdout);
    alignment_index ++;
    {
    _1_align_next = 77U;
    }
    break;
    case 49: 
    print_alignment_part((char const   *)result->result_a, (char const   *)result->result_b,
                         result->pos_a, result->len_a, seq_a, left_spaces_a, right_spaces_a,
                         context_left - left_spaces_a, context_right - right_spaces_a);
    {
    _1_align_next = 10U;
    }
    break;
    case 52: ;
    if (cmd->print_fasta) {
      {
      _1_align_next = 67U;
      }
    } else {
      {
      _1_align_next = 0U;
      }
    }
    break;
    case 4: 
    tmp___2 = 0.2 * (double )tmp___1;
    {
    _1_align_next = 85U;
    }
    break;
    case 30: 
    context_left = context_left;
    {
    _1_align_next = 63U;
    }
    break;
    case 62: ;
    if ((unsigned long )seq_a_name != (unsigned long )((void *)0)) {
      {
      _1_align_next = 80U;
      }
    } else {
      {
      _1_align_next = 78U;
      }
    }
    break;
    case 103: ;
    if (0.2 * (double )tmp___3 >= (double )2) {
      {
      _1_align_next = 1U;
      }
    } else {
      {
      _1_align_next = 66U;
      }
    }
    break;
    case 102: 
    left_spaces_b = context_left - result->pos_b;
    {
    _1_align_next = 40U;
    }
    break;
    case 106: ;
    if (cmd->print_context) {
      {
      _1_align_next = 18U;
      }
    } else {
      {
      _1_align_next = 49U;
      }
    }
    break;
    case 14: ;
    if (context_left <= (size_t___0 )cmd->print_context) {
      {
      _1_align_next = 30U;
      }
    } else {
      {
      _1_align_next = 35U;
      }
    }
    break;
    case 111: 
    tmp___5 = left_spaces_b;
    {
    _1_align_next = 115U;
    }
    break;
    case 15: 
    putc(' ', stdout);
    spacer ++;
    {
    _1_align_next = 99U;
    }
    break;
    case 82: 
    putc(' ', stdout);
    spacer ++;
    {
    _1_align_next = 16U;
    }
    break;
    case 89: ;
    if (context_left > result->pos_b) {
      {
      _1_align_next = 102U;
      }
    } else {
      {
      _1_align_next = 57U;
      }
    }
    break;
    case 56: 
    fflush(stdout);
    hit_index = (size_t___0 )0;
    context_left = (size_t___0 )0;
    context_right = (size_t___0 )0;
    left_spaces_a = (size_t___0 )0;
    left_spaces_b = (size_t___0 )0;
    right_spaces_a = (size_t___0 )0;
    right_spaces_b = (size_t___0 )0;
    {
    _1_align_next = 58U;
    }
    break;
    case 79: 
    context_right = context_right;
    {
    _1_align_next = 91U;
    }
    break;
    case 31: ;
    if ((unsigned long )seq_a_name != (unsigned long )((void *)0)) {
      {
      _1_align_next = 55U;
      }
    } else {
      {
      _1_align_next = 61U;
      }
    }
    break;
    case 101: 
    fputs((char const   *)((char const   */* __restrict  */)seq_b), (FILE *)((FILE */* __restrict  */)stdout));
    putc('\n', stdout);
    {
    _1_align_next = 8U;
    }
    break;
    case 69: 
    cmd->min_score = 0;
    {
    _1_align_next = 56U;
    }
    break;
    case 8: 
    putc('\n', stdout);
    {
    _1_align_next = 107U;
    }
    break;
    case 96: 
    fputs((char const   *)((char const   */* __restrict  */)seq_b_name), (FILE *)((FILE */* __restrict  */)stdout));
    putc('\n', stdout);
    {
    _1_align_next = 0U;
    }
    break;
    case 54: 
    tmp___1 = len_b;
    {
    _1_align_next = 4U;
    }
    break;
    case 78: ;
    if (cmd->print_seq) {
      {
      _1_align_next = 26U;
      }
    } else {
      {
      _1_align_next = 52U;
      }
    }
    break;
    case 1: ;
    if (len_a <= len_b) {
      {
      _1_align_next = 68U;
      }
    } else {
      {
      _1_align_next = 54U;
      }
    }
    break;
    case 81: 
    tmp___3 = len_a;
    {
    _1_align_next = 103U;
    }
    break;
    case 77: ;
    return;
    break;
    case 3: 
    putc('\n', stdout);
    {
    _1_align_next = 71U;
    }
    break;
    case 16: ;
    if (spacer < max_left_spaces) {
      {
      _1_align_next = 82U;
      }
    } else {
      {
      _1_align_next = 32U;
      }
    }
    break;
    case 24: 
    context_right = rem_a;
    {
    _1_align_next = 48U;
    }
    break;
    case 21: 
    context_left = result->pos_b;
    {
    _1_align_next = 14U;
    }
    break;
    case 94: 
    tmp___5 = left_spaces_a;
    {
    _1_align_next = 115U;
    }
    break;
    case 109: 
    context_right = rem_b;
    {
    _1_align_next = 48U;
    }
    break;
    case 76: 
    right_spaces_a = context_right - rem_a;
    {
    _1_align_next = 2U;
    }
    break;
    case 57: 
    left_spaces_b = (size_t___0 )0;
    {
    _1_align_next = 40U;
    }
    break;
    case 68: 
    tmp___1 = len_a;
    {
    _1_align_next = 4U;
    }
    break;
    case 85: 
    cmd->min_score = (score_t )((double )scoring.match * tmp___2);
    {
    _1_align_next = 56U;
    }
    break;
    case 26: 
    fputs((char const   *)((char const   */* __restrict  */)seq_a), (FILE *)((FILE */* __restrict  */)stdout));
    putc('\n', stdout);
    {
    _1_align_next = 52U;
    }
    break;
    case 98: 
    max_right_spaces = tmp___6;
    spacer = (size_t___0 )0;
    {
    _1_align_next = 16U;
    }
    break;
    case 105: ;
    if (tmp___8) {
      {
      _1_align_next = 38U;
      }
    } else {
      {
      _1_align_next = 25U;
      }
    }
    break;
    case 11: ;
    if (spacer < context_right - max_right_spaces) {
      {
      _1_align_next = 46U;
      }
    } else {
      {
      _1_align_next = 83U;
      }
    }
    break;
    case 9: ;
    if ((unsigned long )seq_a_name != (unsigned long )((void *)0)) {
      {
      _1_align_next = 19U;
      }
    } else {
      {
      _1_align_next = 5U;
      }
    }
    break;
    case 13: ;
    if (! (hit_index < (size_t___0 )cmd->max_hits_per_alignment)) {
      {
      _1_align_next = 25U;
      }
    } else {
      {
      _1_align_next = 97U;
      }
    }
    break;
    case 63: 
    rem_a = len_a - (result->pos_a + result->len_a);
    rem_b = len_b - (result->pos_b + result->len_b);
    {
    _1_align_next = 75U;
    }
    break;
    case 51: ;
    if ((int const   )*(seq_a + 0) == 0) {
      {
      _1_align_next = 28U;
      }
    } else {
      {
      _1_align_next = 73U;
      }
    }
    break;
    case 107: ;
    if (! cmd->min_score_set) {
      {
      _1_align_next = 84U;
      }
    } else {
      {
      _1_align_next = 56U;
      }
    }
    break;
    case 19: 
    _L: ;
    if (wait_on_keystroke) {
      {
      _1_align_next = 50U;
      }
    } else {
      {
      _1_align_next = 51U;
      }
    }
    break;
    case 32: 
    spacer = (size_t___0 )0;
    {
    _1_align_next = 33U;
    }
    break;
    case 17: 
    right_spaces_b = (size_t___0 )0;
    {
    _1_align_next = 49U;
    }
    break;
    case 40: ;
    if (context_right > rem_a) {
      {
      _1_align_next = 76U;
      }
    } else {
      {
      _1_align_next = 60U;
      }
    }
    break;
    case 67: ;
    if ((unsigned long )seq_b_name != (unsigned long )((void *)0)) {
      {
      _1_align_next = 96U;
      }
    } else {
      {
      _1_align_next = 0U;
      }
    }
    break;
    case 55: ;
    if ((unsigned long )seq_b_name != (unsigned long )((void *)0)) {
      {
      _1_align_next = 95U;
      }
    } else {
      {
      _1_align_next = 61U;
      }
    }
    break;
    case 60: 
    right_spaces_a = (size_t___0 )0;
    {
    _1_align_next = 2U;
    }
    break;
    case 59: ;
    if (len_a <= len_b) {
      {
      _1_align_next = 81U;
      }
    } else {
      {
      _1_align_next = 104U;
      }
    }
    break;
    case 6: 
    alignment_print_spacer((char const   *)result->result_a, (char const   *)result->result_b,
                           (scoring_t const   *)(& scoring));
    spacer = (size_t___0 )0;
    {
    _1_align_next = 11U;
    }
    break;
    case 27: 
    right_spaces_b = context_right - rem_b;
    {
    _1_align_next = 49U;
    }
    break;
    case 38: ;
    if (result->score >= cmd->min_score) {
      {
      _1_align_next = 113U;
      }
    } else {
      {
      _1_align_next = 25U;
      }
    }
    break;
    case 61: 
    fflush(stderr);
    {
    _1_align_next = 39U;
    }
    break;
    case 87: ;
    if (cmd->print_matrices) {
      {
      _1_align_next = 29U;
      }
    } else {
      {
      _1_align_next = 41U;
      }
    }
    break;
    case 113: ;
    if (! (! cmd->max_hits_per_alignment_set)) {
      {
      _1_align_next = 13U;
      }
    } else {
      {
      _1_align_next = 97U;
      }
    }
    break;
    case 58: 
    tmp___7 = get_next_hit();
    {
    _1_align_next = 47U;
    }
    break;
    case 84: ;
    if (wait_on_keystroke) {
      {
      _1_align_next = 69U;
      }
    } else {
      {
      _1_align_next = 59U;
      }
    }
    break;
    case 112: ;
    if (cmd->print_fasta) {
      {
      _1_align_next = 31U;
      }
    } else {
      {
      _1_align_next = 61U;
      }
    }
    break;
    case 75: ;
    if (rem_a >= rem_b) {
      {
      _1_align_next = 24U;
      }
    } else {
      {
      _1_align_next = 109U;
      }
    }
    break;
    case 48: ;
    if (context_right <= (size_t___0 )cmd->print_context) {
      {
      _1_align_next = 79U;
      }
    } else {
      {
      _1_align_next = 37U;
      }
    }
    break;
    case 71: 
    print_alignment_part((char const   *)result->result_b, (char const   *)result->result_a,
                         result->pos_b, result->len_b, seq_b, left_spaces_b, right_spaces_b,
                         context_left - left_spaces_b, context_right - right_spaces_b);
    printf((char const   *)((char const   */* __restrict  */)"\n"));
    fflush(stdout);
    {
    _1_align_next = 58U;
    }
    break;
    case 22: ;
    if (right_spaces_a >= right_spaces_b) {
      {
      _1_align_next = 42U;
      }
    } else {
      {
      _1_align_next = 72U;
      }
    }
    break;
    case 28: 
    _L___0: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error: Sequences must have length > 0\n"));
    fflush(stderr);
    {
    _1_align_next = 112U;
    }
    break;
    case 53: 
    tmp___8 = smith_waterman_fetch(sw, result);
    {
    _1_align_next = 105U;
    }
    break;
    case 47: ;
    if (tmp___7) {
      {
      _1_align_next = 53U;
      }
    } else {
      {
      _1_align_next = 25U;
      }
    }
    break;
    case 73: ;
    if ((int const   )*(seq_b + 0) == 0) {
      {
      _1_align_next = 28U;
      }
    } else {
      {
      _1_align_next = 114U;
      }
    }
    break;
    case 5: ;
    if ((unsigned long )seq_b_name != (unsigned long )((void *)0)) {
      {
      _1_align_next = 19U;
      }
    } else {
      {
      _1_align_next = 51U;
      }
    }
    break;
    case 91: ;
    if (context_left > result->pos_a) {
      {
      _1_align_next = 92U;
      }
    } else {
      {
      _1_align_next = 88U;
      }
    }
    break;
    case 97: 
    tmp___4 = hit_index;
    hit_index ++;
    printf((char const   *)((char const   */* __restrict  */)"hit %zu.%zu score: %i\n"),
           alignment_index, tmp___4, result->score);
    {
    _1_align_next = 106U;
    }
    break;
    case 72: 
    tmp___6 = right_spaces_b;
    {
    _1_align_next = 98U;
    }
    break;
    case 99: ;
    if (spacer < max_right_spaces) {
      {
      _1_align_next = 15U;
      }
    } else {
      {
      _1_align_next = 3U;
      }
    }
    break;
    case 114: 
    smith_waterman_align(seq_a, seq_b, (scoring_t const   *)(& scoring), sw);
    tmp = smith_waterman_get_aligner(sw);
    aligner = tmp;
    len_a = aligner->score_width - 1UL;
    len_b = aligner->score_height - 1UL;
    printf((char const   *)((char const   */* __restrict  */)"== Alignment %zu lengths (%lu, %lu):\n"),
           alignment_index, len_a, len_b);
    {
    _1_align_next = 87U;
    }
    break;
    case 33: ;
    if (spacer < context_left - max_left_spaces) {
      {
      _1_align_next = 108U;
      }
    } else {
      {
      _1_align_next = 6U;
      }
    }
    break;
    case 37: 
    context_right = (size_t___0 )cmd->print_context;
    {
    _1_align_next = 91U;
    }
    break;
    case 93: 
    context_left = result->pos_a;
    {
    _1_align_next = 14U;
    }
    break;
    case 41: ;
    if (cmd->print_fasta) {
      {
      _1_align_next = 62U;
      }
    } else {
      {
      _1_align_next = 78U;
      }
    }
    break;
    case 95: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"%s\n%s\n"),
            seq_a_name, seq_b_name);
    {
    _1_align_next = 61U;
    }
    break;
    case 92: 
    left_spaces_a = context_left - result->pos_a;
    {
    _1_align_next = 89U;
    }
    break;
    case 115: 
    max_left_spaces = tmp___5;
    {
    _1_align_next = 22U;
    }
    break;
    case 10: ;
    if (cmd->print_pretty) {
      {
      _1_align_next = 43U;
      }
    } else {
      {
      _1_align_next = 71U;
      }
    }
    break;
    case 42: 
    tmp___6 = right_spaces_a;
    {
    _1_align_next = 98U;
    }
    break;
    case 0: ;
    if (cmd->print_seq) {
      {
      _1_align_next = 101U;
      }
    } else {
      {
      _1_align_next = 8U;
      }
    }
    break;
    case 46: 
    putc('.', stdout);
    spacer ++;
    {
    _1_align_next = 11U;
    }
    break;
    case 39: ;
    return;
    break;
    case 66: 
    tmp___2 = (double )2;
    {
    _1_align_next = 85U;
    }
    break;
    case 83: 
    spacer = (size_t___0 )0;
    {
    _1_align_next = 99U;
    }
    break;
    case 88: 
    left_spaces_a = (size_t___0 )0;
    {
    _1_align_next = 89U;
    }
    break;
    case 35: 
    context_left = (size_t___0 )cmd->print_context;
    {
    _1_align_next = 63U;
    }
    break;
    case 29: 
    alignment_print_matrices((aligner_t const   *)aligner);
    {
    _1_align_next = 41U;
    }
    break;
    case 43: 
    fputs((char const   *)((char const   */* __restrict  */)"  "), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_align_next = 86U;
    }
    break;
    case 86: ;
    if (left_spaces_a >= left_spaces_b) {
      {
      _1_align_next = 94U;
      }
    } else {
      {
      _1_align_next = 111U;
      }
    }
    break;
    case 2: ;
    if (context_right > rem_b) {
      {
      _1_align_next = 27U;
      }
    } else {
      {
      _1_align_next = 17U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF align LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_colour_print_against LOC=UNKNOWN */
void alignment_colour_print_against(char const   *alignment_a , char const   *alignment_b ,
                                    char case_sensitive ) 
{ 
  int i ;
  char red ;
  char green ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1_alignment_colour_print_against_next ;

  {
  {
  _1_alignment_colour_print_against_next = 2U;
  }
  while (1) {
    switch (_1_alignment_colour_print_against_next) {
    case 18: ;
    if (green) {
      {
      _1_alignment_colour_print_against_next = 30U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 6U;
      }
    }
    break;
    case 25: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_mismatch)),
          (FILE *)((FILE */* __restrict  */)stdout));
    green = (char)1;
    {
    _1_alignment_colour_print_against_next = 5U;
    }
    break;
    case 4: ;
    if ((int const   )*(alignment_b + i) == 45) {
      {
      _1_alignment_colour_print_against_next = 19U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 23U;
      }
    }
    break;
    case 30: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_stop)), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_alignment_colour_print_against_next = 1U;
    }
    break;
    case 14: 
    green = (char)0;
    fputs((char const   *)((char const   */* __restrict  */)(align_col_stop)), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_alignment_colour_print_against_next = 5U;
    }
    break;
    case 1: ;
    return;
    break;
    case 23: ;
    if (red) {
      {
      _1_alignment_colour_print_against_next = 22U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 13U;
      }
    }
    break;
    case 3: ;
    if ((int const   )*(alignment_a + i) != (int const   )*(alignment_b + i)) {
      {
      _1_alignment_colour_print_against_next = 9U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 0U;
      }
    }
    break;
    case 16: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_stop)), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_alignment_colour_print_against_next = 1U;
    }
    break;
    case 24: ;
    if (tmp != tmp___0) {
      {
      _1_alignment_colour_print_against_next = 9U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 11U;
      }
    }
    break;
    case 26: ;
    if (! green) {
      {
      _1_alignment_colour_print_against_next = 25U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 5U;
      }
    }
    break;
    case 11: 
    _L___2: ;
    if (green) {
      {
      _1_alignment_colour_print_against_next = 14U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 5U;
      }
    }
    break;
    case 9: 
    _L___1: ;
    if ((int const   )*(alignment_a + i) != 45) {
      {
      _1_alignment_colour_print_against_next = 29U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 11U;
      }
    }
    break;
    case 13: ;
    if (case_sensitive) {
      {
      _1_alignment_colour_print_against_next = 3U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 0U;
      }
    }
    break;
    case 19: ;
    if (! red) {
      {
      _1_alignment_colour_print_against_next = 27U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 13U;
      }
    }
    break;
    case 6: ;
    if (red) {
      {
      _1_alignment_colour_print_against_next = 16U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 1U;
      }
    }
    break;
    case 27: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_indel)), (FILE *)((FILE */* __restrict  */)stdout));
    red = (char)1;
    {
    _1_alignment_colour_print_against_next = 13U;
    }
    break;
    case 22: 
    red = (char)0;
    fputs((char const   *)((char const   */* __restrict  */)(align_col_stop)), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_alignment_colour_print_against_next = 13U;
    }
    break;
    case 28: ;
    if ((int const   )*(alignment_a + i) != 0) {
      {
      _1_alignment_colour_print_against_next = 4U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 18U;
      }
    }
    break;
    case 5: 
    putc((int )*(alignment_a + i), stdout);
    i ++;
    {
    _1_alignment_colour_print_against_next = 28U;
    }
    break;
    case 10: 
    tmp = tolower((int )*(alignment_a + i));
    tmp___0 = tolower((int )*(alignment_b + i));
    {
    _1_alignment_colour_print_against_next = 24U;
    }
    break;
    case 0: 
    _L___3: ;
    if (! case_sensitive) {
      {
      _1_alignment_colour_print_against_next = 10U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 11U;
      }
    }
    break;
    case 29: ;
    if ((int const   )*(alignment_b + i) != 45) {
      {
      _1_alignment_colour_print_against_next = 26U;
      }
    } else {
      {
      _1_alignment_colour_print_against_next = 11U;
      }
    }
    break;
    case 2: 
    red = (char)0;
    green = (char)0;
    i = 0;
    {
    _1_alignment_colour_print_against_next = 28U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_colour_print_against LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_fill_matrices LOC=UNKNOWN */
static void alignment_fill_matrices(aligner_t *aligner , char is_sw ) 
{ 
  score_t *match_scores ;
  score_t *gap_a_scores ;
  score_t *gap_b_scores ;
  scoring_t const   *scoring___0 ;
  size_t___0 score_width ;
  size_t___0 score_height ;
  size_t___0 i ;
  size_t___0 j ;
  int gap_open_penalty ;
  int gap_extend_penalty ;
  score_t min ;
  int tmp ;
  int tmp___0 ;
  size_t___0 seq_i ;
  size_t___0 seq_j ;
  size_t___0 len_i ;
  size_t___0 len_j ;
  size_t___0 index___0 ;
  size_t___0 index_left ;
  size_t___0 index_up ;
  size_t___0 index_upleft ;
  score_t tmp___1 ;
  score_t tmp___2 ;
  score_t tmp___3 ;
  score_t tmp___4 ;
  _Bool is_match ;
  int substitution_penalty ;
  score_t tmp___7 ;
  score_t tmp___8 ;
  score_t tmp___9 ;
  score_t tmp___10 ;
  score_t tmp___11 ;
  score_t tmp___14 ;
  score_t tmp___15 ;
  score_t tmp___16 ;
  score_t tmp___17 ;
  score_t tmp___18 ;
  score_t tmp___21 ;
  score_t tmp___22 ;
  score_t tmp___23 ;
  score_t tmp___24 ;
  unsigned int _1_alignment_fill_matrices_next ;

  {
  {
  _1_alignment_fill_matrices_next = 34U;
  }
  while (1) {
    switch (_1_alignment_fill_matrices_next) {
    case 18: 
    _L___9: ;
    if (*(gap_a_scores + index_left) >= *(gap_b_scores + index_left)) {
      {
      _1_alignment_fill_matrices_next = 25U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 49U;
      }
    }
    break;
    case 80: ;
    if (*(match_scores + index_up) + gap_open_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
      {
      _1_alignment_fill_matrices_next = 102U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 44U;
      }
    }
    break;
    case 108: 
    tmp___10 = tmp___9;
    {
    _1_alignment_fill_matrices_next = 127U;
    }
    break;
    case 104: 
    tmp___22 = tmp___21;
    {
    _1_alignment_fill_matrices_next = 89U;
    }
    break;
    case 130: 
    *(gap_b_scores + i) = 0;
    {
    _1_alignment_fill_matrices_next = 54U;
    }
    break;
    case 25: 
    tmp___18 = *(gap_a_scores + index_left);
    {
    _1_alignment_fill_matrices_next = 11U;
    }
    break;
    case 49: 
    tmp___18 = *(gap_b_scores + index_left);
    {
    _1_alignment_fill_matrices_next = 11U;
    }
    break;
    case 52: 
    *(gap_b_scores + index___0) = min;
    {
    _1_alignment_fill_matrices_next = 112U;
    }
    break;
    case 4: 
    index_upleft = (size_t___0 )0;
    index_up = (size_t___0 )1;
    index_left = score_width;
    index___0 = score_width + 1UL;
    seq_j = (size_t___0 )0;
    {
    _1_alignment_fill_matrices_next = 30U;
    }
    break;
    case 30: ;
    if (seq_j < len_j) {
      {
      _1_alignment_fill_matrices_next = 41U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 110U;
      }
    }
    break;
    case 62: 
    *(gap_a_scores + index___0) = tmp___15;
    {
    _1_alignment_fill_matrices_next = 26U;
    }
    break;
    case 103: ;
    if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
      {
      _1_alignment_fill_matrices_next = 60U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 64U;
      }
    }
    break;
    case 102: 
    tmp___15 = *(match_scores + index_up) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 62U;
    }
    break;
    case 106: 
    _L___2: ;
    if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_a_scores + index_upleft) + substitution_penalty) {
      {
      _1_alignment_fill_matrices_next = 103U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 64U;
      }
    }
    break;
    case 14: 
    *(gap_a_scores + index___0) = *(match_scores + index_up);
    {
    _1_alignment_fill_matrices_next = 26U;
    }
    break;
    case 111: 
    *(match_scores + index___0) = min;
    {
    _1_alignment_fill_matrices_next = 92U;
    }
    break;
    case 15: 
    _L___8: ;
    if (! scoring___0->no_gaps_in_a) {
      {
      _1_alignment_fill_matrices_next = 61U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 87U;
      }
    }
    break;
    case 133: ;
    if (seq_j == len_j - 1UL) {
      {
      _1_alignment_fill_matrices_next = 128U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 114U;
      }
    }
    break;
    case 89: 
    *(gap_b_scores + index___0) = tmp___22;
    {
    _1_alignment_fill_matrices_next = 112U;
    }
    break;
    case 56: ;
    if (*(match_scores + index_left) + gap_open_penalty >= *(gap_a_scores + index_left) + gap_open_penalty) {
      {
      _1_alignment_fill_matrices_next = 16U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 39U;
      }
    }
    break;
    case 79: 
    *(gap_b_scores + i) = (score_t )(scoring___0->gap_open + (int const   )((int )i * (int )scoring___0->gap_extend));
    {
    _1_alignment_fill_matrices_next = 54U;
    }
    break;
    case 31: 
    tmp___9 = *(gap_a_scores + index_upleft) + substitution_penalty;
    {
    _1_alignment_fill_matrices_next = 108U;
    }
    break;
    case 12: ;
    if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_a_scores + index_upleft) + substitution_penalty) {
      {
      _1_alignment_fill_matrices_next = 28U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 135U;
      }
    }
    break;
    case 101: 
    *(gap_a_scores + index___0) = 0;
    {
    _1_alignment_fill_matrices_next = 96U;
    }
    break;
    case 96: 
    *(gap_b_scores + index___0) = min;
    j ++;
    index___0 += score_width;
    {
    _1_alignment_fill_matrices_next = 71U;
    }
    break;
    case 54: 
    i ++;
    {
    _1_alignment_fill_matrices_next = 40U;
    }
    break;
    case 124: ;
    if (tmp___24 >= min) {
      {
      _1_alignment_fill_matrices_next = 56U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 52U;
      }
    }
    break;
    case 1: 
    tmp___24 = *(match_scores + index_left) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 124U;
    }
    break;
    case 81: 
    tmp___14 = *(gap_b_scores + index_up) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 93U;
    }
    break;
    case 128: 
    _L___13: ;
    if (*(match_scores + index_left) + gap_open_penalty >= *(gap_a_scores + index_left) + gap_open_penalty) {
      {
      _1_alignment_fill_matrices_next = 21U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 97U;
      }
    }
    break;
    case 23: 
    tmp___24 = tmp___23;
    {
    _1_alignment_fill_matrices_next = 124U;
    }
    break;
    case 77: 
    tmp___21 = *(gap_a_scores + index_left) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 104U;
    }
    break;
    case 70: ;
    if (*(match_scores + index_left) >= *(gap_a_scores + index_left)) {
      {
      _1_alignment_fill_matrices_next = 134U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 18U;
      }
    }
    break;
    case 3: 
    tmp___2 = 0;
    *(gap_b_scores + i) = tmp___2;
    tmp___1 = tmp___2;
    *(gap_a_scores + i) = tmp___1;
    *(match_scores + i) = tmp___1;
    i ++;
    {
    _1_alignment_fill_matrices_next = 125U;
    }
    break;
    case 134: ;
    if (*(match_scores + index_left) >= *(gap_b_scores + index_left)) {
      {
      _1_alignment_fill_matrices_next = 123U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 18U;
      }
    }
    break;
    case 16: ;
    if (*(match_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
      {
      _1_alignment_fill_matrices_next = 27U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 39U;
      }
    }
    break;
    case 24: 
    tmp___7 = *(gap_b_scores + index_upleft) + substitution_penalty;
    {
    _1_alignment_fill_matrices_next = 120U;
    }
    break;
    case 21: ;
    if (*(match_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
      {
      _1_alignment_fill_matrices_next = 1U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 97U;
      }
    }
    break;
    case 94: 
    index___0 ++;
    index_left ++;
    index_up ++;
    index_upleft ++;
    seq_j ++;
    {
    _1_alignment_fill_matrices_next = 30U;
    }
    break;
    case 109: 
    tmp___17 = tmp___16;
    {
    _1_alignment_fill_matrices_next = 131U;
    }
    break;
    case 131: ;
    if (tmp___17 >= min) {
      {
      _1_alignment_fill_matrices_next = 88U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 32U;
      }
    }
    break;
    case 57: ;
    if (*(match_scores + index_up) >= *(gap_b_scores + index_up)) {
      {
      _1_alignment_fill_matrices_next = 14U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 100U;
      }
    }
    break;
    case 68: 
    *(match_scores + index___0) = tmp___8;
    {
    _1_alignment_fill_matrices_next = 92U;
    }
    break;
    case 122: 
    scoring_lookup(scoring___0, (char )*(aligner->seq_a + seq_i), (char )*(aligner->seq_b + seq_j),
                   & substitution_penalty, & is_match);
    {
    _1_alignment_fill_matrices_next = 83U;
    }
    break;
    case 85: 
    tmp = abs((int )scoring___0->min_penalty);
    tmp___0 = (-0x7FFFFFFF-1) + tmp;
    {
    _1_alignment_fill_matrices_next = 119U;
    }
    break;
    case 100: 
    _L___3: ;
    if (*(gap_a_scores + index_up) >= *(gap_b_scores + index_up)) {
      {
      _1_alignment_fill_matrices_next = 42U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 75U;
      }
    }
    break;
    case 26: ;
    if (seq_j == len_j - 1UL) {
      {
      _1_alignment_fill_matrices_next = 51U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 6U;
      }
    }
    break;
    case 98: 
    i = (size_t___0 )1;
    {
    _1_alignment_fill_matrices_next = 125U;
    }
    break;
    case 105: ;
    if (! is_match) {
      {
      _1_alignment_fill_matrices_next = 35U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 106U;
      }
    }
    break;
    case 11: 
    *(gap_b_scores + index___0) = tmp___18;
    {
    _1_alignment_fill_matrices_next = 112U;
    }
    break;
    case 135: 
    _L___0: ;
    if (*(gap_a_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
      {
      _1_alignment_fill_matrices_next = 116U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 24U;
      }
    }
    break;
    case 13: 
    *(match_scores + index___0) = min;
    {
    _1_alignment_fill_matrices_next = 55U;
    }
    break;
    case 63: 
    tmp___4 = min;
    *(gap_b_scores + index___0) = tmp___4;
    tmp___3 = tmp___4;
    *(gap_a_scores + index___0) = tmp___3;
    *(match_scores + index___0) = tmp___3;
    j ++;
    index___0 += score_width;
    {
    _1_alignment_fill_matrices_next = 59U;
    }
    break;
    case 51: ;
    if (scoring___0->no_end_gap_penalty) {
      {
      _1_alignment_fill_matrices_next = 70U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 6U;
      }
    }
    break;
    case 125: ;
    if (i < score_width) {
      {
      _1_alignment_fill_matrices_next = 3U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 95U;
      }
    }
    break;
    case 32: 
    *(gap_a_scores + index___0) = min;
    {
    _1_alignment_fill_matrices_next = 26U;
    }
    break;
    case 17: 
    tmp___17 = *(match_scores + index_up) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 131U;
    }
    break;
    case 90: 
    j = (size_t___0 )1;
    index___0 = score_width;
    {
    _1_alignment_fill_matrices_next = 71U;
    }
    break;
    case 40: ;
    if (i < score_width) {
      {
      _1_alignment_fill_matrices_next = 72U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 90U;
      }
    }
    break;
    case 55: ;
    if (scoring___0->no_start_gap_penalty) {
      {
      _1_alignment_fill_matrices_next = 101U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 126U;
      }
    }
    break;
    case 132: 
    *(gap_a_scores + index___0) = tmp___11;
    {
    _1_alignment_fill_matrices_next = 26U;
    }
    break;
    case 110: ;
    return;
    break;
    case 60: 
    tmp___10 = *(match_scores + index_upleft) + substitution_penalty;
    {
    _1_alignment_fill_matrices_next = 127U;
    }
    break;
    case 59: ;
    if (j < score_height) {
      {
      _1_alignment_fill_matrices_next = 63U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 4U;
      }
    }
    break;
    case 6: 
    _L___14: ;
    if (! scoring___0->no_gaps_in_b) {
      {
      _1_alignment_fill_matrices_next = 128U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 133U;
      }
    }
    break;
    case 116: 
    tmp___7 = *(gap_a_scores + index_upleft) + substitution_penalty;
    {
    _1_alignment_fill_matrices_next = 120U;
    }
    break;
    case 27: 
    tmp___22 = *(match_scores + index_left) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 89U;
    }
    break;
    case 38: ;
    if (*(match_scores + index_up) >= *(gap_a_scores + index_up)) {
      {
      _1_alignment_fill_matrices_next = 57U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 100U;
      }
    }
    break;
    case 61: 
    _L___7: ;
    if (*(match_scores + index_up) + gap_open_penalty >= *(gap_a_scores + index_up) + gap_extend_penalty) {
      {
      _1_alignment_fill_matrices_next = 43U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 10U;
      }
    }
    break;
    case 87: ;
    if (seq_i == len_i - 1UL) {
      {
      _1_alignment_fill_matrices_next = 61U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 0U;
      }
    }
    break;
    case 113: ;
    if (is_sw) {
      {
      _1_alignment_fill_matrices_next = 66U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 85U;
      }
    }
    break;
    case 34: 
    match_scores = aligner->match_scores;
    gap_a_scores = aligner->gap_a_scores;
    gap_b_scores = aligner->gap_b_scores;
    scoring___0 = aligner->scoring;
    score_width = aligner->score_width;
    score_height = aligner->score_height;
    gap_open_penalty = (int )(scoring___0->gap_extend + scoring___0->gap_open);
    gap_extend_penalty = (int )scoring___0->gap_extend;
    {
    _1_alignment_fill_matrices_next = 113U;
    }
    break;
    case 74: ;
    if (is_sw) {
      {
      _1_alignment_fill_matrices_next = 98U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 5U;
      }
    }
    break;
    case 112: 
    index___0 ++;
    index_left ++;
    index_up ++;
    index_upleft ++;
    seq_i ++;
    {
    _1_alignment_fill_matrices_next = 99U;
    }
    break;
    case 75: 
    tmp___11 = *(gap_b_scores + index_up);
    {
    _1_alignment_fill_matrices_next = 132U;
    }
    break;
    case 123: 
    *(gap_b_scores + index___0) = *(match_scores + index_left);
    {
    _1_alignment_fill_matrices_next = 112U;
    }
    break;
    case 127: ;
    if (tmp___10 >= min) {
      {
      _1_alignment_fill_matrices_next = 12U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 111U;
      }
    }
    break;
    case 71: ;
    if (j < score_height) {
      {
      _1_alignment_fill_matrices_next = 13U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 4U;
      }
    }
    break;
    case 22: 
    tmp___23 = *(gap_a_scores + index_left) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 23U;
    }
    break;
    case 28: ;
    if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
      {
      _1_alignment_fill_matrices_next = 29U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 135U;
      }
    }
    break;
    case 65: 
    tmp___21 = *(gap_b_scores + index_left) + gap_extend_penalty;
    {
    _1_alignment_fill_matrices_next = 104U;
    }
    break;
    case 47: 
    tmp___9 = *(gap_b_scores + index_upleft) + substitution_penalty;
    {
    _1_alignment_fill_matrices_next = 108U;
    }
    break;
    case 44: 
    _L___5: ;
    if (*(gap_a_scores + index_up) + gap_extend_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
      {
      _1_alignment_fill_matrices_next = 33U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 81U;
      }
    }
    break;
    case 5: 
    i = (size_t___0 )1;
    {
    _1_alignment_fill_matrices_next = 40U;
    }
    break;
    case 91: 
    tmp___23 = *(gap_b_scores + index_left) + gap_extend_penalty;
    {
    _1_alignment_fill_matrices_next = 23U;
    }
    break;
    case 120: 
    tmp___8 = tmp___7;
    {
    _1_alignment_fill_matrices_next = 68U;
    }
    break;
    case 97: 
    _L___12: ;
    if (*(gap_a_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
      {
      _1_alignment_fill_matrices_next = 22U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 91U;
      }
    }
    break;
    case 72: 
    *(match_scores + i) = min;
    *(gap_a_scores + i) = min;
    {
    _1_alignment_fill_matrices_next = 115U;
    }
    break;
    case 99: ;
    if (seq_i < len_i) {
      {
      _1_alignment_fill_matrices_next = 122U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 94U;
      }
    }
    break;
    case 114: 
    *(gap_b_scores + index___0) = min;
    {
    _1_alignment_fill_matrices_next = 112U;
    }
    break;
    case 33: 
    tmp___14 = *(gap_a_scores + index_up) + gap_extend_penalty;
    {
    _1_alignment_fill_matrices_next = 93U;
    }
    break;
    case 37: ;
    if (scoring___0->no_end_gap_penalty) {
      {
      _1_alignment_fill_matrices_next = 38U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 15U;
      }
    }
    break;
    case 64: 
    _L___1: ;
    if (*(gap_a_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
      {
      _1_alignment_fill_matrices_next = 31U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 47U;
      }
    }
    break;
    case 93: 
    tmp___15 = tmp___14;
    {
    _1_alignment_fill_matrices_next = 62U;
    }
    break;
    case 119: 
    min = tmp___0;
    len_i = score_width - 1UL;
    len_j = score_height - 1UL;
    *(match_scores + 0) = 0;
    *(gap_a_scores + 0) = 0;
    *(gap_b_scores + 0) = 0;
    {
    _1_alignment_fill_matrices_next = 74U;
    }
    break;
    case 41: 
    seq_i = (size_t___0 )0;
    {
    _1_alignment_fill_matrices_next = 99U;
    }
    break;
    case 95: 
    j = (size_t___0 )1;
    index___0 = score_width;
    {
    _1_alignment_fill_matrices_next = 59U;
    }
    break;
    case 92: ;
    if (seq_i == len_i - 1UL) {
      {
      _1_alignment_fill_matrices_next = 37U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 15U;
      }
    }
    break;
    case 115: ;
    if (scoring___0->no_start_gap_penalty) {
      {
      _1_alignment_fill_matrices_next = 130U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 79U;
      }
    }
    break;
    case 10: 
    _L___6: ;
    if (*(gap_a_scores + index_up) + gap_extend_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
      {
      _1_alignment_fill_matrices_next = 136U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 7U;
      }
    }
    break;
    case 42: 
    tmp___11 = *(gap_a_scores + index_up);
    {
    _1_alignment_fill_matrices_next = 132U;
    }
    break;
    case 0: 
    *(gap_a_scores + index___0) = min;
    {
    _1_alignment_fill_matrices_next = 26U;
    }
    break;
    case 136: 
    tmp___16 = *(gap_a_scores + index_up) + gap_extend_penalty;
    {
    _1_alignment_fill_matrices_next = 109U;
    }
    break;
    case 39: 
    _L___11: ;
    if (*(gap_a_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
      {
      _1_alignment_fill_matrices_next = 77U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 65U;
      }
    }
    break;
    case 66: 
    tmp___0 = 0;
    {
    _1_alignment_fill_matrices_next = 119U;
    }
    break;
    case 83: ;
    if (scoring___0->no_mismatches) {
      {
      _1_alignment_fill_matrices_next = 105U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 106U;
      }
    }
    break;
    case 7: 
    tmp___16 = *(gap_b_scores + index_up) + gap_open_penalty;
    {
    _1_alignment_fill_matrices_next = 109U;
    }
    break;
    case 88: ;
    if (*(match_scores + index_up) + gap_open_penalty >= *(gap_a_scores + index_up) + gap_extend_penalty) {
      {
      _1_alignment_fill_matrices_next = 80U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 44U;
      }
    }
    break;
    case 35: 
    *(match_scores + index___0) = min;
    {
    _1_alignment_fill_matrices_next = 92U;
    }
    break;
    case 29: 
    tmp___8 = *(match_scores + index_upleft) + substitution_penalty;
    {
    _1_alignment_fill_matrices_next = 68U;
    }
    break;
    case 126: 
    *(gap_a_scores + index___0) = (score_t )(scoring___0->gap_open + (int const   )((int )j * (int )scoring___0->gap_extend));
    {
    _1_alignment_fill_matrices_next = 96U;
    }
    break;
    case 43: ;
    if (*(match_scores + index_up) + gap_open_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
      {
      _1_alignment_fill_matrices_next = 17U;
      }
    } else {
      {
      _1_alignment_fill_matrices_next = 10U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_fill_matrices LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF smith_waterman_new LOC=UNKNOWN */
sw_aligner_t *smith_waterman_new(void) 
{ 
  sw_aligner_t *sw___0 ;
  void *tmp ;
  unsigned int _1_smith_waterman_new_next ;

  {
  {
  _1_smith_waterman_new_next = 1U;
  }
  while (1) {
    switch (_1_smith_waterman_new_next) {
    case 1: 
    tmp = calloc((size_t )1, sizeof(sw_aligner_t ));
    sw___0 = (sw_aligner_t *)tmp;
    _init_history(& sw___0->history);
    {
    _1_smith_waterman_new_next = 0U;
    }
    break;
    case 0: ;
    return (sw___0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF smith_waterman_new LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_system_PAM30 LOC=UNKNOWN */
void scoring_system_PAM30(scoring_t *scoring___0 ) 
{ 
  unsigned int _1_scoring_system_PAM30_next ;

  {
  {
  _1_scoring_system_PAM30_next = 0U;
  }
  while (1) {
    switch (_1_scoring_system_PAM30_next) {
    case 1: ;
    return;
    break;
    case 0: 
    scoring_init(scoring___0, 1, -17, -9, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                 (_Bool)0, (_Bool)0);
    scoring_add_mutations(scoring___0, (char const   *)(amino_acids), pam30, (char)1);
    {
    _1_scoring_system_PAM30_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_system_PAM30 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_read_dealloc LOC=UNKNOWN */
__inline static void seq_read_dealloc(read_t *r ) 
{ 
  unsigned int _1_seq_read_dealloc_next ;

  {
  {
  _1_seq_read_dealloc_next = 0U;
  }
  while (1) {
    switch (_1_seq_read_dealloc_next) {
    case 1: ;
    return;
    break;
    case 0: 
    free((void *)r->name.b);
    free((void *)r->seq.b);
    free((void *)r->qual.b);
    memset((void *)r, 0, sizeof(read_t ));
    {
    _1_seq_read_dealloc_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_read_dealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_print_matrices LOC=UNKNOWN */
void alignment_print_matrices(aligner_t const   *aligner ) 
{ 
  score_t const   *match_scores ;
  score_t const   *gap_a_scores ;
  score_t const   *gap_b_scores ;
  size_t___0 i ;
  size_t___0 j ;
  unsigned int _1_alignment_print_matrices_next ;

  {
  {
  _1_alignment_print_matrices_next = 6U;
  }
  while (1) {
    switch (_1_alignment_print_matrices_next) {
    case 18: ;
    if (j < (size_t___0 )aligner->score_height) {
      {
      _1_alignment_print_matrices_next = 11U;
      }
    } else {
      {
      _1_alignment_print_matrices_next = 25U;
      }
    }
    break;
    case 25: 
    printf((char const   *)((char const   */* __restrict  */)"match: %i mismatch: %i gapopen: %i gapexend: %i\n"),
           (aligner->scoring)->match, (aligner->scoring)->mismatch, (aligner->scoring)->gap_open,
           (aligner->scoring)->gap_extend);
    printf((char const   *)((char const   */* __restrict  */)"\n"));
    {
    _1_alignment_print_matrices_next = 30U;
    }
    break;
    case 4: ;
    if (i < (size_t___0 )aligner->score_width) {
      {
      _1_alignment_print_matrices_next = 26U;
      }
    } else {
      {
      _1_alignment_print_matrices_next = 3U;
      }
    }
    break;
    case 30: ;
    return;
    break;
    case 14: ;
    if (j < (size_t___0 )aligner->score_height) {
      {
      _1_alignment_print_matrices_next = 5U;
      }
    } else {
      {
      _1_alignment_print_matrices_next = 20U;
      }
    }
    break;
    case 8: ;
    if (i < (size_t___0 )aligner->score_width) {
      {
      _1_alignment_print_matrices_next = 9U;
      }
    } else {
      {
      _1_alignment_print_matrices_next = 28U;
      }
    }
    break;
    case 3: 
    putc('\n', stdout);
    j ++;
    {
    _1_alignment_print_matrices_next = 14U;
    }
    break;
    case 16: ;
    if (j < (size_t___0 )aligner->score_height) {
      {
      _1_alignment_print_matrices_next = 29U;
      }
    } else {
      {
      _1_alignment_print_matrices_next = 2U;
      }
    }
    break;
    case 21: ;
    if (i < (size_t___0 )aligner->score_width) {
      {
      _1_alignment_print_matrices_next = 22U;
      }
    } else {
      {
      _1_alignment_print_matrices_next = 17U;
      }
    }
    break;
    case 26: 
    printf((char const   *)((char const   */* __restrict  */)"\t%3i"), (int )*(gap_a_scores + (j * (unsigned long )aligner->score_width + i)));
    i ++;
    {
    _1_alignment_print_matrices_next = 4U;
    }
    break;
    case 11: 
    printf((char const   *)((char const   */* __restrict  */)"%3i:"), (int )j);
    i = (size_t___0 )0;
    {
    _1_alignment_print_matrices_next = 21U;
    }
    break;
    case 9: 
    printf((char const   *)((char const   */* __restrict  */)"\t%3i"), (int )*(match_scores + (j * (unsigned long )aligner->score_width + i)));
    i ++;
    {
    _1_alignment_print_matrices_next = 8U;
    }
    break;
    case 17: 
    putc('\n', stdout);
    j ++;
    {
    _1_alignment_print_matrices_next = 18U;
    }
    break;
    case 6: 
    match_scores = (score_t const   *)aligner->match_scores;
    gap_a_scores = (score_t const   *)aligner->gap_a_scores;
    gap_b_scores = (score_t const   *)aligner->gap_b_scores;
    printf((char const   *)((char const   */* __restrict  */)"seq_a: %.*s\nseq_b: %.*s\n"),
           (int )aligner->score_width - 1, aligner->seq_a, (int )aligner->score_height - 1,
           aligner->seq_b);
    printf((char const   *)((char const   */* __restrict  */)"match_scores:\n"));
    j = (size_t___0 )0;
    {
    _1_alignment_print_matrices_next = 16U;
    }
    break;
    case 22: 
    printf((char const   *)((char const   */* __restrict  */)"\t%3i"), (int )*(gap_b_scores + (j * (unsigned long )aligner->score_width + i)));
    i ++;
    {
    _1_alignment_print_matrices_next = 21U;
    }
    break;
    case 28: 
    putc('\n', stdout);
    j ++;
    {
    _1_alignment_print_matrices_next = 16U;
    }
    break;
    case 5: 
    printf((char const   *)((char const   */* __restrict  */)"%3i:"), (int )j);
    i = (size_t___0 )0;
    {
    _1_alignment_print_matrices_next = 4U;
    }
    break;
    case 29: 
    printf((char const   *)((char const   */* __restrict  */)"%3i:"), (int )j);
    i = (size_t___0 )0;
    {
    _1_alignment_print_matrices_next = 8U;
    }
    break;
    case 2: 
    printf((char const   *)((char const   */* __restrict  */)"gap_a_scores:\n"));
    j = (size_t___0 )0;
    {
    _1_alignment_print_matrices_next = 14U;
    }
    break;
    case 20: 
    printf((char const   *)((char const   */* __restrict  */)"gap_b_scores:\n"));
    j = (size_t___0 )0;
    {
    _1_alignment_print_matrices_next = 18U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_print_matrices LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF align_from_file LOC=UNKNOWN */
void align_from_file(char const   *path1 , char const   *path2 , void (*align___0)(read_t *r1 ,
                                                                                   read_t *r2 ) ,
                     _Bool use_zlib ) 
{ 
  seq_file_t *sf1 ;
  seq_file_t *sf2 ;
  read_t read1 ;
  read_t read2 ;
  unsigned long alignments ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1_align_from_file_next ;

  {
  {
  _1_align_from_file_next = 20U;
  }
  while (1) {
    switch (_1_align_from_file_next) {
    case 18: 
    seq_close(sf2);
    {
    _1_align_from_file_next = 22U;
    }
    break;
    case 4: ;
    return;
    break;
    case 14: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Alignment Error: Odd number of sequences - I read in pairs!\n"));
    fflush(stderr);
    {
    _1_align_from_file_next = 12U;
    }
    break;
    case 15: ;
    if ((unsigned long )sf1 == (unsigned long )((void *)0)) {
      {
      _1_align_from_file_next = 23U;
      }
    } else {
      {
      _1_align_from_file_next = 6U;
      }
    }
    break;
    case 12: ;
    if (alignments == 0UL) {
      {
      _1_align_from_file_next = 1U;
      }
    } else {
      {
      _1_align_from_file_next = 17U;
      }
    }
    break;
    case 8: ;
    if (tmp <= 0) {
      {
      _1_align_from_file_next = 14U;
      }
    } else {
      {
      _1_align_from_file_next = 3U;
      }
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Alignment Warning: empty input\n"));
    fflush(stderr);
    {
    _1_align_from_file_next = 17U;
    }
    break;
    case 23: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Alignment Error: couldn\'t open file %s\n"),
            path1);
    fflush(stderr);
    {
    _1_align_from_file_next = 4U;
    }
    break;
    case 3: 
    (*align___0)(& read1, & read2);
    alignments ++;
    {
    _1_align_from_file_next = 9U;
    }
    break;
    case 16: 
    sf2 = sf1;
    {
    _1_align_from_file_next = 10U;
    }
    break;
    case 24: 
    tmp = (*(sf2->readfunc))(sf2, & read2);
    {
    _1_align_from_file_next = 8U;
    }
    break;
    case 26: ;
    if ((unsigned long )sf2 == (unsigned long )((void *)0)) {
      {
      _1_align_from_file_next = 2U;
      }
    } else {
      {
      _1_align_from_file_next = 10U;
      }
    }
    break;
    case 9: 
    tmp___0 = (*(sf1->readfunc))(sf1, & read1);
    {
    _1_align_from_file_next = 19U;
    }
    break;
    case 13: ;
    return;
    break;
    case 19: ;
    if (! (tmp___0 > 0)) {
      {
      _1_align_from_file_next = 12U;
      }
    } else {
      {
      _1_align_from_file_next = 24U;
      }
    }
    break;
    case 17: 
    seq_close(sf1);
    {
    _1_align_from_file_next = 0U;
    }
    break;
    case 6: ;
    if ((unsigned long )path2 == (unsigned long )((void *)0)) {
      {
      _1_align_from_file_next = 16U;
      }
    } else {
      {
      _1_align_from_file_next = 5U;
      }
    }
    break;
    case 22: 
    seq_read_dealloc(& read1);
    seq_read_dealloc(& read2);
    {
    _1_align_from_file_next = 7U;
    }
    break;
    case 5: 
    sf2 = open_seq_file(path2, use_zlib);
    {
    _1_align_from_file_next = 26U;
    }
    break;
    case 10: 
    seq_read_alloc(& read1);
    seq_read_alloc(& read2);
    alignments = 0UL;
    {
    _1_align_from_file_next = 9U;
    }
    break;
    case 0: ;
    if ((unsigned long )path2 != (unsigned long )((void *)0)) {
      {
      _1_align_from_file_next = 18U;
      }
    } else {
      {
      _1_align_from_file_next = 22U;
      }
    }
    break;
    case 7: ;
    return;
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Alignment Error: couldn\'t open file %s\n"),
            path1);
    fflush(stderr);
    {
    _1_align_from_file_next = 13U;
    }
    break;
    case 20: 
    sf1 = open_seq_file(path1, use_zlib);
    {
    _1_align_from_file_next = 15U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF align_from_file LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_reverse_move LOC=UNKNOWN */
void alignment_reverse_move(enum Matrix *curr_matrix , score_t *curr_score , size_t___0 *score_x ,
                            size_t___0 *score_y , size_t___0 *arr_index , aligner_t const   *aligner ) 
{ 
  size_t___0 seq_x ;
  size_t___0 seq_y ;
  size_t___0 len_i ;
  size_t___0 len_j ;
  _Bool is_match ;
  int match_penalty ;
  scoring_t const   *scoring___0 ;
  int gap_a_open_penalty ;
  int gap_b_open_penalty ;
  int gap_a_extend_penalty ;
  int gap_b_extend_penalty ;
  int prev_match_penalty ;
  int prev_gap_a_penalty ;
  int prev_gap_b_penalty ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int _1_alignment_reverse_move_next ;

  {
  {
  _1_alignment_reverse_move_next = 44U;
  }
  while (1) {
    switch (_1_alignment_reverse_move_next) {
    case 18: ;
    if ((unsigned int )*curr_matrix == 1U) {
      {
      _1_alignment_reverse_move_next = 5U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 42U;
      }
    }
    break;
    case 25: 
    prev_match_penalty = gap_b_open_penalty;
    prev_gap_a_penalty = gap_b_open_penalty;
    prev_gap_b_penalty = gap_b_extend_penalty;
    (*score_x) --;
    (*arr_index) --;
    {
    _1_alignment_reverse_move_next = 17U;
    }
    break;
    case 4: 
    _L___0: ;
    if (*(aligner->gap_b_scores + *arr_index) + prev_gap_b_penalty == *curr_score) {
      {
      _1_alignment_reverse_move_next = 29U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 45U;
      }
    }
    break;
    case 30: 
    gap_b_extend_penalty = 0;
    gap_b_open_penalty = gap_b_extend_penalty;
    {
    _1_alignment_reverse_move_next = 8U;
    }
    break;
    case 14: 
    *curr_matrix = (enum Matrix )0;
    *curr_score = *(aligner->match_scores + *arr_index);
    {
    _1_alignment_reverse_move_next = 34U;
    }
    break;
    case 31: 
    gap_b_extend_penalty = 0;
    gap_b_open_penalty = gap_b_extend_penalty;
    {
    _1_alignment_reverse_move_next = 13U;
    }
    break;
    case 12: ;
    if (*score_y == 0UL) {
      {
      _1_alignment_reverse_move_next = 30U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 8U;
      }
    }
    break;
    case 8: ;
    switch ((unsigned int )*curr_matrix) {
    case 0U: 
    {
    _1_alignment_reverse_move_next = 36U;
    }
    break;
    case 1U: 
    {
    _1_alignment_reverse_move_next = 9U;
    }
    break;
    case 2U: 
    {
    _1_alignment_reverse_move_next = 25U;
    }
    break;
    default: 
    {
    _1_alignment_reverse_move_next = 16U;
    }
    break;
    }
    break;
    case 45: 
    _L: ;
    if (*(aligner->match_scores + *arr_index) + prev_match_penalty == *curr_score) {
      {
      _1_alignment_reverse_move_next = 14U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 39U;
      }
    }
    break;
    case 1: 
    tmp___0 = (char *)"MATCH";
    {
    _1_alignment_reverse_move_next = 26U;
    }
    break;
    case 23: ;
    if (*score_x == 0UL) {
      {
      _1_alignment_reverse_move_next = 10U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 12U;
      }
    }
    break;
    case 16: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Program error: invalid matrix in get_reverse_move()\n"));
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Please submit a bug report to: turner.isaac@gmail.com\n"));
    exit(1);

    break;
    case 24: 
    tmp___0 = tmp;
    {
    _1_alignment_reverse_move_next = 26U;
    }
    break;
    case 36: 
    prev_match_penalty = match_penalty;
    prev_gap_a_penalty = match_penalty;
    prev_gap_b_penalty = match_penalty;
    (*score_x) --;
    (*score_y) --;
    *arr_index -= (size_t___0 )(aligner->score_width + 1UL);
    {
    _1_alignment_reverse_move_next = 17U;
    }
    break;
    case 26: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"[%s:%zu,%zu]: %i [ismatch: %i] \'%c\' \'%c\'\n"),
            tmp___0, *score_x, *score_y, *curr_score, (int )is_match, (int const   )*(aligner->seq_a + seq_x),
            (int const   )*(aligner->seq_b + seq_y));
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)" Penalties match: %i gap_open: %i gap_extend: %i\n"),
            prev_match_penalty, prev_gap_a_penalty, prev_gap_b_penalty);
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)" Expected MATCH: %i GAP_A: %i GAP_B: %i\n"),
            *(aligner->match_scores + *arr_index), *(aligner->gap_a_scores + *arr_index),
            *(aligner->gap_b_scores + *arr_index));
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Program error: traceback fail (get_reverse_move)\nThis may be due to an integer overflow if your sequences are long or scores\nare large. If this is the case using smaller scores or shorter sequences may\nwork around this problem.  \n  If you think this is a bug, please report it to: turner.isaac@gmail.com\n"));
    exit(1);

    break;
    case 11: 
    gap_a_extend_penalty = 0;
    gap_a_open_penalty = gap_a_extend_penalty;
    {
    _1_alignment_reverse_move_next = 27U;
    }
    break;
    case 9: 
    prev_match_penalty = gap_a_open_penalty;
    prev_gap_a_penalty = gap_a_extend_penalty;
    prev_gap_b_penalty = gap_a_open_penalty;
    (*score_y) --;
    *arr_index -= (size_t___0 )aligner->score_width;
    {
    _1_alignment_reverse_move_next = 17U;
    }
    break;
    case 13: ;
    if (scoring___0->no_start_gap_penalty) {
      {
      _1_alignment_reverse_move_next = 23U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 8U;
      }
    }
    break;
    case 17: ;
    if (! scoring___0->no_gaps_in_a) {
      {
      _1_alignment_reverse_move_next = 38U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 37U;
      }
    }
    break;
    case 40: ;
    if (*score_y == 0UL) {
      {
      _1_alignment_reverse_move_next = 4U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 41U;
      }
    }
    break;
    case 6: 
    _L___1: ;
    if (! scoring___0->no_gaps_in_b) {
      {
      _1_alignment_reverse_move_next = 4U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 40U;
      }
    }
    break;
    case 27: ;
    if (*score_y == len_j) {
      {
      _1_alignment_reverse_move_next = 31U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 13U;
      }
    }
    break;
    case 38: 
    _L___2: ;
    if (*(aligner->gap_a_scores + *arr_index) + prev_gap_a_penalty == *curr_score) {
      {
      _1_alignment_reverse_move_next = 33U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 6U;
      }
    }
    break;
    case 34: ;
    return;
    break;
    case 22: ;
    if ((unsigned int )*curr_matrix == 0U) {
      {
      _1_alignment_reverse_move_next = 1U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 18U;
      }
    }
    break;
    case 44: 
    seq_x = *score_x - 1UL;
    seq_y = *score_y - 1UL;
    len_i = (size_t___0 )(aligner->score_width - 1UL);
    len_j = (size_t___0 )(aligner->score_height - 1UL);
    scoring___0 = (scoring_t const   *)aligner->scoring;
    scoring_lookup(scoring___0, (char )*(aligner->seq_a + seq_x), (char )*(aligner->seq_b + seq_y),
                   & match_penalty, & is_match);
    gap_b_open_penalty = (int )(scoring___0->gap_extend + scoring___0->gap_open);
    gap_a_open_penalty = gap_b_open_penalty;
    gap_b_extend_penalty = (int )scoring___0->gap_extend;
    gap_a_extend_penalty = gap_b_extend_penalty;
    {
    _1_alignment_reverse_move_next = 2U;
    }
    break;
    case 5: 
    tmp = (char *)"GAP_A";
    {
    _1_alignment_reverse_move_next = 24U;
    }
    break;
    case 33: 
    *curr_matrix = (enum Matrix )1;
    *curr_score = *(aligner->gap_a_scores + *arr_index);
    {
    _1_alignment_reverse_move_next = 34U;
    }
    break;
    case 37: ;
    if (*score_x == 0UL) {
      {
      _1_alignment_reverse_move_next = 38U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 35U;
      }
    }
    break;
    case 41: ;
    if (*score_y == len_j) {
      {
      _1_alignment_reverse_move_next = 4U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 45U;
      }
    }
    break;
    case 10: 
    gap_a_extend_penalty = 0;
    gap_a_open_penalty = gap_a_extend_penalty;
    {
    _1_alignment_reverse_move_next = 12U;
    }
    break;
    case 42: 
    tmp = (char *)"GAP_B";
    {
    _1_alignment_reverse_move_next = 24U;
    }
    break;
    case 39: 
    alignment_print_matrices(aligner);
    {
    _1_alignment_reverse_move_next = 22U;
    }
    break;
    case 7: ;
    if (*score_x == len_i) {
      {
      _1_alignment_reverse_move_next = 11U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 27U;
      }
    }
    break;
    case 35: ;
    if (*score_x == len_i) {
      {
      _1_alignment_reverse_move_next = 38U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 6U;
      }
    }
    break;
    case 29: 
    *curr_matrix = (enum Matrix )2;
    *curr_score = *(aligner->gap_b_scores + *arr_index);
    {
    _1_alignment_reverse_move_next = 34U;
    }
    break;
    case 2: ;
    if (scoring___0->no_end_gap_penalty) {
      {
      _1_alignment_reverse_move_next = 7U;
      }
    } else {
      {
      _1_alignment_reverse_move_next = 13U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_reverse_move LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_plain_f LOC=UNKNOWN */
__inline static int _seq_read_plain_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  unsigned int _1__seq_read_plain_f_next ;

  {
  {
  _1__seq_read_plain_f_next = 1U;
  }
  while (1) {
    switch (_1__seq_read_plain_f_next) {
    case 4: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    freadline(sf->f_file, & r->seq.b, & r->seq.end, & r->seq.size);
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_plain_f_next = 6U;
    }
    break;
    case 1: 
    seq_read_reset(r);
    {
    _1__seq_read_plain_f_next = 0U;
    }
    break;
    case 3: ;
    return (0);
    break;
    case 11: 
    fskipline(sf->f_file);
    {
    _1__seq_read_plain_f_next = 0U;
    }
    break;
    case 13: 
    tmp = isspace(c);
    {
    _1__seq_read_plain_f_next = 10U;
    }
    break;
    case 6: ;
    return (1);
    break;
    case 5: ;
    if (c != 10) {
      {
      _1__seq_read_plain_f_next = 11U;
      }
    } else {
      {
      _1__seq_read_plain_f_next = 0U;
      }
    }
    break;
    case 10: ;
    if (! tmp) {
      {
      _1__seq_read_plain_f_next = 2U;
      }
    } else {
      {
      _1__seq_read_plain_f_next = 5U;
      }
    }
    break;
    case 0: 
    c = fgetc(sf->f_file);
    {
    _1__seq_read_plain_f_next = 7U;
    }
    break;
    case 7: ;
    if (c != -1) {
      {
      _1__seq_read_plain_f_next = 13U;
      }
    } else {
      {
      _1__seq_read_plain_f_next = 2U;
      }
    }
    break;
    case 2: ;
    if (c == -1) {
      {
      _1__seq_read_plain_f_next = 3U;
      }
    } else {
      {
      _1__seq_read_plain_f_next = 4U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_plain_f LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_add_wildcard LOC=UNKNOWN */
void scoring_add_wildcard(scoring_t *scoring___0 , char c , int score ) 
{ 
  int tmp ;
  unsigned int _1_scoring_add_wildcard_next ;

  {
  {
  _1_scoring_add_wildcard_next = 2U;
  }
  while (1) {
    switch (_1_scoring_add_wildcard_next) {
    case 4: 
    scoring___0->max_penalty = scoring___0->max_penalty;
    {
    _1_scoring_add_wildcard_next = 6U;
    }
    break;
    case 8: 
    scoring___0->wildcards[(int )c >> 5] |= (unsigned int )(1 << ((int )c & 31));
    scoring___0->wildscores[(size_t___0 )c] = score;
    {
    _1_scoring_add_wildcard_next = 7U;
    }
    break;
    case 1: 
    scoring___0->min_penalty = scoring___0->min_penalty;
    {
    _1_scoring_add_wildcard_next = 5U;
    }
    break;
    case 3: 
    tmp = tolower((int )c);
    c = (char )tmp;
    {
    _1_scoring_add_wildcard_next = 8U;
    }
    break;
    case 9: 
    scoring___0->max_penalty = score;
    {
    _1_scoring_add_wildcard_next = 6U;
    }
    break;
    case 6: ;
    return;
    break;
    case 5: ;
    if (scoring___0->max_penalty >= score) {
      {
      _1_scoring_add_wildcard_next = 4U;
      }
    } else {
      {
      _1_scoring_add_wildcard_next = 9U;
      }
    }
    break;
    case 0: 
    scoring___0->min_penalty = score;
    {
    _1_scoring_add_wildcard_next = 5U;
    }
    break;
    case 7: ;
    if (scoring___0->min_penalty <= score) {
      {
      _1_scoring_add_wildcard_next = 1U;
      }
    } else {
      {
      _1_scoring_add_wildcard_next = 0U;
      }
    }
    break;
    case 2: ;
    if (! scoring___0->case_sensitive) {
      {
      _1_scoring_add_wildcard_next = 3U;
      }
    } else {
      {
      _1_scoring_add_wildcard_next = 8U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_add_wildcard LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF parse_entire_int LOC=UNKNOWN */
char parse_entire_int(char *str , int *result___0 ) 
{ 
  size_t___0 len ;
  size_t___0 tmp ;
  char *strtol_last_char_ptr ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int _1_parse_entire_int_next ;

  {
  {
  _1_parse_entire_int_next = 1U;
  }
  while (1) {
    switch (_1_parse_entire_int_next) {
    case 4: ;
    return ((char)1);
    break;
    case 8: ;
    if (tmp___0 < (-0x7FFFFFFF-1)) {
      {
      _1_parse_entire_int_next = 0U;
      }
    } else {
      {
      _1_parse_entire_int_next = 3U;
      }
    }
    break;
    case 1: 
    tmp = strlen((char const   *)str);
    len = tmp;
    strtol_last_char_ptr = str;
    tmp___1 = strtol((char const   *)((char const   */* __restrict  */)str), (char **)((char **/* __restrict  */)(& strtol_last_char_ptr)),
                     10);
    tmp___0 = tmp___1;
    {
    _1_parse_entire_int_next = 5U;
    }
    break;
    case 3: ;
    if ((unsigned long )strtol_last_char_ptr != (unsigned long )(str + len)) {
      {
      _1_parse_entire_int_next = 9U;
      }
    } else {
      {
      _1_parse_entire_int_next = 7U;
      }
    }
    break;
    case 9: ;
    return ((char)0);
    break;
    case 5: ;
    if (tmp___0 > 2147483647L) {
      {
      _1_parse_entire_int_next = 2U;
      }
    } else {
      {
      _1_parse_entire_int_next = 8U;
      }
    }
    break;
    case 0: ;
    return ((char)0);
    break;
    case 7: 
    *result___0 = (int )tmp___0;
    {
    _1_parse_entire_int_next = 4U;
    }
    break;
    case 2: ;
    return ((char)0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF parse_entire_int LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF print_alignment_part LOC=UNKNOWN */
void print_alignment_part(char const   *seq1 , char const   *seq2 , size_t___0 pos ,
                          size_t___0 len , char const   *context_str , size_t___0 spaces_left ,
                          size_t___0 spaces_right , size_t___0 context_left , size_t___0 context_right ) 
{ 
  size_t___0 i ;
  unsigned int _1_print_alignment_part_next ;

  {
  {
  _1_print_alignment_part_next = 1U;
  }
  while (1) {
    switch (_1_print_alignment_part_next) {
    case 18: 
    printf((char const   *)((char const   */* __restrict  */)"  [pos: %li; len: %lu]\n"),
           pos, len);
    {
    _1_print_alignment_part_next = 23U;
    }
    break;
    case 25: ;
    if (cmd->print_colour) {
      {
      _1_print_alignment_part_next = 12U;
      }
    } else {
      {
      _1_print_alignment_part_next = 11U;
      }
    }
    break;
    case 4: ;
    if (cmd->print_colour) {
      {
      _1_print_alignment_part_next = 24U;
      }
    } else {
      {
      _1_print_alignment_part_next = 20U;
      }
    }
    break;
    case 14: 
    alignment_colour_print_against(seq1, seq2, (char )scoring.case_sensitive);
    {
    _1_print_alignment_part_next = 22U;
    }
    break;
    case 15: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_context)),
          (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_print_alignment_part_next = 21U;
    }
    break;
    case 12: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_stop)), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_print_alignment_part_next = 11U;
    }
    break;
    case 1: 
    printf((char const   *)((char const   */* __restrict  */)"  "));
    i = (size_t___0 )0;
    {
    _1_print_alignment_part_next = 9U;
    }
    break;
    case 23: ;
    return;
    break;
    case 3: ;
    if (context_left > 0UL) {
      {
      _1_print_alignment_part_next = 4U;
      }
    } else {
      {
      _1_print_alignment_part_next = 11U;
      }
    }
    break;
    case 24: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_context)),
          (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_print_alignment_part_next = 20U;
    }
    break;
    case 21: 
    printf((char const   *)((char const   */* __restrict  */)"%.*s"), (int )context_right,
           (context_str + pos) + len);
    {
    _1_print_alignment_part_next = 13U;
    }
    break;
    case 11: ;
    if (cmd->print_colour) {
      {
      _1_print_alignment_part_next = 14U;
      }
    } else {
      {
      _1_print_alignment_part_next = 0U;
      }
    }
    break;
    case 9: ;
    if (i < spaces_left) {
      {
      _1_print_alignment_part_next = 2U;
      }
    } else {
      {
      _1_print_alignment_part_next = 3U;
      }
    }
    break;
    case 13: ;
    if (cmd->print_colour) {
      {
      _1_print_alignment_part_next = 5U;
      }
    } else {
      {
      _1_print_alignment_part_next = 6U;
      }
    }
    break;
    case 19: ;
    if (cmd->print_colour) {
      {
      _1_print_alignment_part_next = 15U;
      }
    } else {
      {
      _1_print_alignment_part_next = 21U;
      }
    }
    break;
    case 17: ;
    if (i < spaces_right) {
      {
      _1_print_alignment_part_next = 10U;
      }
    } else {
      {
      _1_print_alignment_part_next = 18U;
      }
    }
    break;
    case 6: 
    i = (size_t___0 )0;
    {
    _1_print_alignment_part_next = 17U;
    }
    break;
    case 22: ;
    if (context_right > 0UL) {
      {
      _1_print_alignment_part_next = 19U;
      }
    } else {
      {
      _1_print_alignment_part_next = 6U;
      }
    }
    break;
    case 5: 
    fputs((char const   *)((char const   */* __restrict  */)(align_col_stop)), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_print_alignment_part_next = 6U;
    }
    break;
    case 10: 
    putc(' ', stdout);
    i ++;
    {
    _1_print_alignment_part_next = 17U;
    }
    break;
    case 0: 
    fputs((char const   *)((char const   */* __restrict  */)seq1), (FILE *)((FILE */* __restrict  */)stdout));
    {
    _1_print_alignment_part_next = 22U;
    }
    break;
    case 2: 
    printf((char const   *)((char const   */* __restrict  */)" "));
    i ++;
    {
    _1_print_alignment_part_next = 9U;
    }
    break;
    case 20: 
    printf((char const   *)((char const   */* __restrict  */)"%.*s"), (int )context_left,
           (context_str + pos) - context_left);
    {
    _1_print_alignment_part_next = 25U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF print_alignment_part LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gzskipline_buf LOC=UNKNOWN */
__inline static size_t___0 gzskipline_buf(gzFile file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 skipped_bytes ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  unsigned int _1_gzskipline_buf_next ;

  {
  {
  _1_gzskipline_buf_next = 18U;
  }
  while (1) {
    switch (_1_gzskipline_buf_next) {
    case 18: ;
    if (in->begin >= in->end) {
      {
      _1_gzskipline_buf_next = 17U;
      }
    } else {
      {
      _1_gzskipline_buf_next = 6U;
      }
    }
    break;
    case 8: ;
    if ((int )*(in->b + (offset - 1UL)) == 10) {
      {
      _1_gzskipline_buf_next = 11U;
      }
    } else {
      {
      _1_gzskipline_buf_next = 10U;
      }
    }
    break;
    case 1: 
    skipped_bytes += offset - in->begin;
    {
    _1_gzskipline_buf_next = 19U;
    }
    break;
    case 21: ;
    if (! ((int )*(in->b + tmp___0) != 10)) {
      {
      _1_gzskipline_buf_next = 0U;
      }
    } else {
      {
      _1_gzskipline_buf_next = 1U;
      }
    }
    break;
    case 11: ;
    return (skipped_bytes);
    break;
    case 13: 
    offset = in->begin;
    {
    _1_gzskipline_buf_next = 19U;
    }
    break;
    case 19: ;
    if (offset < in->end) {
      {
      _1_gzskipline_buf_next = 7U;
      }
    } else {
      {
      _1_gzskipline_buf_next = 0U;
      }
    }
    break;
    case 17: 
    tmp = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
    in->end = 1UL + tmp;
    in->begin = (size_t___0 )1;
    {
    _1_gzskipline_buf_next = 6U;
    }
    break;
    case 6: 
    skipped_bytes = (size_t___0 )0;
    {
    _1_gzskipline_buf_next = 2U;
    }
    break;
    case 10: 
    tmp___1 = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
    in->end = 1UL + tmp___1;
    in->begin = (size_t___0 )1;
    {
    _1_gzskipline_buf_next = 2U;
    }
    break;
    case 0: 
    in->begin = offset;
    {
    _1_gzskipline_buf_next = 8U;
    }
    break;
    case 7: 
    tmp___0 = offset;
    offset ++;
    {
    _1_gzskipline_buf_next = 21U;
    }
    break;
    case 2: ;
    if (in->end > in->begin) {
      {
      _1_gzskipline_buf_next = 13U;
      }
    } else {
      {
      _1_gzskipline_buf_next = 11U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gzskipline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fskipline LOC=UNKNOWN */
__inline static size_t___0 fskipline(FILE *file ) 
{ 
  int c ;
  size_t___0 skipped_bytes ;
  unsigned int _1_fskipline_next ;

  {
  {
  _1_fskipline_next = 3U;
  }
  while (1) {
    switch (_1_fskipline_next) {
    case 4: ;
    return (skipped_bytes);
    break;
    case 8: 
    skipped_bytes ++;
    {
    _1_fskipline_next = 2U;
    }
    break;
    case 3: 
    skipped_bytes = (size_t___0 )0;
    {
    _1_fskipline_next = 0U;
    }
    break;
    case 5: ;
    if (! (c != -1)) {
      {
      _1_fskipline_next = 4U;
      }
    } else {
      {
      _1_fskipline_next = 8U;
      }
    }
    break;
    case 0: 
    c = fgetc(file);
    {
    _1_fskipline_next = 5U;
    }
    break;
    case 2: ;
    if (c == 10) {
      {
      _1_fskipline_next = 4U;
      }
    } else {
      {
      _1_fskipline_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF fskipline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF freadline LOC=UNKNOWN */
__inline static size_t___0 freadline(FILE *file , char **buf , size_t___0 *len , size_t___0 *size ) 
{ 
  size_t___0 r ;
  size_t___0 tmp ;
  size_t___0 origlen ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  unsigned int _1_freadline_next ;

  {
  {
  _1_freadline_next = 13U;
  }
  while (1) {
    switch (_1_freadline_next) {
    case 4: 
    cbuf_capacity(buf, size, *len + 1UL);
    {
    _1_freadline_next = 16U;
    }
    break;
    case 14: 
    tmp = (size_t___0 )4294967295U;
    {
    _1_freadline_next = 2U;
    }
    break;
    case 15: ;
    return (*len - origlen);
    break;
    case 12: ;
    if (*size - *len > 4294967295UL) {
      {
      _1_freadline_next = 11U;
      }
    } else {
      {
      _1_freadline_next = 3U;
      }
    }
    break;
    case 1: 
    tmp___1 = *size * 2UL;
    *size = tmp___1;
    tmp___2 = realloc((void *)*buf, tmp___1);
    *buf = (char *)tmp___2;
    {
    _1_freadline_next = 12U;
    }
    break;
    case 3: 
    r = *size - *len;
    {
    _1_freadline_next = 6U;
    }
    break;
    case 16: ;
    if (*size - *len > 4294967295UL) {
      {
      _1_freadline_next = 14U;
      }
    } else {
      {
      _1_freadline_next = 7U;
      }
    }
    break;
    case 11: 
    r = (size_t___0 )4294967295U;
    {
    _1_freadline_next = 6U;
    }
    break;
    case 9: ;
    return (*len - origlen);
    break;
    case 13: ;
    if (*len + 1UL >= *size) {
      {
      _1_freadline_next = 4U;
      }
    } else {
      {
      _1_freadline_next = 16U;
      }
    }
    break;
    case 17: ;
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
      {
      _1_freadline_next = 15U;
      }
    } else {
      {
      _1_freadline_next = 10U;
      }
    }
    break;
    case 6: 
    tmp___3 = fgets((char */* __restrict  */)(*buf + *len), (int )r, (FILE */* __restrict  */)file);
    {
    _1_freadline_next = 17U;
    }
    break;
    case 5: ;
    if ((int )*(*buf + (*len - 1UL)) == 10) {
      {
      _1_freadline_next = 9U;
      }
    } else {
      {
      _1_freadline_next = 1U;
      }
    }
    break;
    case 10: 
    tmp___0 = strlen((char const   *)(*buf + *len));
    *len += tmp___0;
    {
    _1_freadline_next = 5U;
    }
    break;
    case 7: 
    tmp = *size - *len;
    {
    _1_freadline_next = 2U;
    }
    break;
    case 2: 
    r = tmp;
    origlen = *len;
    {
    _1_freadline_next = 6U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF freadline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmdline_add_files LOC=UNKNOWN */
void cmdline_add_files(cmdline_t *cmd___0 , char *p1 , char *p2 ) 
{ 
  size_t___0 mem ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int _1_cmdline_add_files_next ;

  {
  {
  _1_cmdline_add_files_next = 4U;
  }
  while (1) {
    switch (_1_cmdline_add_files_next) {
    case 4: ;
    if (cmd___0->file_list_length == cmd___0->file_list_capacity) {
      {
      _1_cmdline_add_files_next = 5U;
      }
    } else {
      {
      _1_cmdline_add_files_next = 0U;
      }
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"%s:%i: Out of memory\n"),
            "src/alignment_cmdline.c", 545);
    exit(1);

    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"%s:%i: Out of memory\n"),
            "src/alignment_cmdline.c", 545);
    exit(1);

    break;
    case 6: ;
    return;
    break;
    case 5: 
    cmd___0->file_list_capacity *= 2UL;
    mem = sizeof(char *) * cmd___0->file_list_capacity;
    tmp = realloc((void *)cmd___0->file_paths1, mem);
    cmd___0->file_paths1 = (char **)tmp;
    tmp___0 = realloc((void *)cmd___0->file_paths2, mem);
    cmd___0->file_paths2 = (char **)tmp___0;
    {
    _1_cmdline_add_files_next = 7U;
    }
    break;
    case 0: 
    *(cmd___0->file_paths1 + cmd___0->file_list_length) = p1;
    *(cmd___0->file_paths2 + cmd___0->file_list_length) = p2;
    (cmd___0->file_list_length) ++;
    {
    _1_cmdline_add_files_next = 6U;
    }
    break;
    case 7: ;
    if ((unsigned long )cmd___0->file_paths1 == (unsigned long )((void *)0)) {
      {
      _1_cmdline_add_files_next = 1U;
      }
    } else {
      {
      _1_cmdline_add_files_next = 2U;
      }
    }
    break;
    case 2: ;
    if ((unsigned long )cmd___0->file_paths2 == (unsigned long )((void *)0)) {
      {
      _1_cmdline_add_files_next = 3U;
      }
    } else {
      {
      _1_cmdline_add_files_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cmdline_add_files LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmdline_get_num_of_file_pairs LOC=UNKNOWN */
size_t___0 cmdline_get_num_of_file_pairs(cmdline_t *cmd___0 ) 
{ 
  unsigned int _1_cmdline_get_num_of_file_pairs_next ;

  {
  {
  _1_cmdline_get_num_of_file_pairs_next = 0U;
  }
  while (1) {
    switch (_1_cmdline_get_num_of_file_pairs_next) {
    case 0: ;
    return (cmd___0->file_list_length);
    break;
    }
  }
}
}
/* END FUNCTION-DEF cmdline_get_num_of_file_pairs LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_free LOC=UNKNOWN */
void alignment_free(alignment_t *result___0 ) 
{ 
  unsigned int _1_alignment_free_next ;

  {
  {
  _1_alignment_free_next = 0U;
  }
  while (1) {
    switch (_1_alignment_free_next) {
    case 1: ;
    return;
    break;
    case 0: 
    free((void *)result___0->result_a);
    free((void *)result___0->result_b);
    free((void *)result___0);
    {
    _1_alignment_free_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_create LOC=UNKNOWN */
alignment_t *alignment_create(size_t___0 capacity ) 
{ 
  alignment_t *result___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char tmp___2 ;
  size_t___0 tmp___3 ;
  size_t___0 tmp___4 ;
  size_t___0 tmp___5 ;
  unsigned int _1_alignment_create_next ;

  {
  {
  _1_alignment_create_next = 0U;
  }
  while (1) {
    switch (_1_alignment_create_next) {
    case 1: ;
    return (result___0);
    break;
    case 0: 
    capacity = _rndup2pow64((unsigned long long )capacity);
    tmp = malloc(sizeof(alignment_t ));
    result___0 = (alignment_t *)tmp;
    tmp___0 = malloc(sizeof(char ) * capacity);
    result___0->result_a = (char *)tmp___0;
    tmp___1 = malloc(sizeof(char ) * capacity);
    result___0->result_b = (char *)tmp___1;
    result___0->capacity = capacity;
    result___0->length = (size_t___0 )0;
    tmp___2 = (char )'\000';
    *(result___0->result_b + 0) = tmp___2;
    *(result___0->result_a + 0) = tmp___2;
    tmp___5 = (size_t___0 )0;
    result___0->len_b = tmp___5;
    tmp___4 = tmp___5;
    result___0->len_a = tmp___4;
    tmp___3 = tmp___4;
    result___0->pos_b = tmp___3;
    result___0->pos_a = tmp___3;
    result___0->score = 0;
    {
    _1_alignment_create_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_create LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmdline_free LOC=UNKNOWN */
void cmdline_free(cmdline_t *cmd___0 ) 
{ 
  unsigned int _1_cmdline_free_next ;

  {
  {
  _1_cmdline_free_next = 0U;
  }
  while (1) {
    switch (_1_cmdline_free_next) {
    case 1: ;
    return;
    break;
    case 0: 
    free((void *)cmd___0->file_paths1);
    free((void *)cmd___0->file_paths2);
    free((void *)cmd___0);
    {
    _1_cmdline_free_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cmdline_free LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gzgetc_buf LOC=UNKNOWN */
__inline static int gzgetc_buf(gzFile file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  unsigned int _1_gzgetc_buf_next ;

  {
  {
  _1_gzgetc_buf_next = 7U;
  }
  while (1) {
    switch (_1_gzgetc_buf_next) {
    case 4: 
    tmp___1 = -1;
    {
    _1_gzgetc_buf_next = 2U;
    }
    break;
    case 8: ;
    return ((int )*(in->b + tmp___2));
    break;
    case 3: 
    tmp___2 = in->begin;
    (in->begin) ++;
    {
    _1_gzgetc_buf_next = 8U;
    }
    break;
    case 9: 
    tmp = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
    in->end = 1UL + tmp;
    in->begin = (size_t___0 )1;
    {
    _1_gzgetc_buf_next = 6U;
    }
    break;
    case 6: ;
    if (in->begin >= in->end) {
      {
      _1_gzgetc_buf_next = 4U;
      }
    } else {
      {
      _1_gzgetc_buf_next = 5U;
      }
    }
    break;
    case 5: 
    tmp___0 = in->begin;
    (in->begin) ++;
    tmp___1 = (int )*(in->b + tmp___0);
    {
    _1_gzgetc_buf_next = 2U;
    }
    break;
    case 7: ;
    if (in->begin >= in->end) {
      {
      _1_gzgetc_buf_next = 9U;
      }
    } else {
      {
      _1_gzgetc_buf_next = 3U;
      }
    }
    break;
    case 2: ;
    return (tmp___1);
    break;
    }
  }
}
}
/* END FUNCTION-DEF gzgetc_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_system_BLOSUM80 LOC=UNKNOWN */
void scoring_system_BLOSUM80(scoring_t *scoring___0 ) 
{ 
  unsigned int _1_scoring_system_BLOSUM80_next ;

  {
  {
  _1_scoring_system_BLOSUM80_next = 1U;
  }
  while (1) {
    switch (_1_scoring_system_BLOSUM80_next) {
    case 1: 
    scoring_init(scoring___0, 1, -8, -10, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                 (_Bool)0, (_Bool)0);
    scoring_add_mutations(scoring___0, (char const   *)(amino_acids), blosum80, (char)1);
    {
    _1_scoring_system_BLOSUM80_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_system_BLOSUM80 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_lookup LOC=UNKNOWN */
void scoring_lookup(scoring_t const   *scoring___0 , char a , char b , int *score ,
                    _Bool *is_match ) 
{ 
  int tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  unsigned int _1_scoring_lookup_next ;

  {
  {
  _1_scoring_lookup_next = 9U;
  }
  while (1) {
    switch (_1_scoring_lookup_next) {
    case 18: ;
    return;
    break;
    case 4: 
    *score = scoring___0->swap_scores[(size_t___0 )a][(size_t___0 )b];
    {
    _1_scoring_lookup_next = 15U;
    }
    break;
    case 14: ;
    if ((scoring___0->swap_set[(size_t___0 )a][(int )b >> 5] >> ((int )b & 31)) & 1U) {
      {
      _1_scoring_lookup_next = 4U;
      }
    } else {
      {
      _1_scoring_lookup_next = 6U;
      }
    }
    break;
    case 15: ;
    return;
    break;
    case 12: 
    *score = (int )scoring___0->mismatch;
    {
    _1_scoring_lookup_next = 0U;
    }
    break;
    case 8: 
    *is_match = (_Bool )((int )a == (int )b);
    {
    _1_scoring_lookup_next = 5U;
    }
    break;
    case 3: 
    tmp = tolower((int )a);
    a = (char )tmp;
    tmp___0 = tolower((int )b);
    b = (char )tmp___0;
    {
    _1_scoring_lookup_next = 8U;
    }
    break;
    case 16: 
    *score = (int )scoring___0->match;
    {
    _1_scoring_lookup_next = 0U;
    }
    break;
    case 11: ;
    return;
    break;
    case 9: ;
    if (! scoring___0->case_sensitive) {
      {
      _1_scoring_lookup_next = 3U;
      }
    } else {
      {
      _1_scoring_lookup_next = 8U;
      }
    }
    break;
    case 13: 
    tmp___1 = _scoring_check_wildcards(scoring___0, a, b, score);
    *is_match = (_Bool )tmp___1;
    {
    _1_scoring_lookup_next = 11U;
    }
    break;
    case 19: ;
    if (scoring___0->use_match_mismatch) {
      {
      _1_scoring_lookup_next = 10U;
      }
    } else {
      {
      _1_scoring_lookup_next = 17U;
      }
    }
    break;
    case 17: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error: Unknown character pair (%c,%c) and match/mismatch have not been set\n"),
            (int )a, (int )b);
    exit(1);

    break;
    case 6: 
    tmp___2 = _scoring_check_wildcards(scoring___0, a, b, score);
    {
    _1_scoring_lookup_next = 7U;
    }
    break;
    case 5: ;
    if (scoring___0->no_mismatches) {
      {
      _1_scoring_lookup_next = 2U;
      }
    } else {
      {
      _1_scoring_lookup_next = 14U;
      }
    }
    break;
    case 10: ;
    if (*is_match) {
      {
      _1_scoring_lookup_next = 16U;
      }
    } else {
      {
      _1_scoring_lookup_next = 12U;
      }
    }
    break;
    case 0: ;
    return;
    break;
    case 7: ;
    if (tmp___2) {
      {
      _1_scoring_lookup_next = 20U;
      }
    } else {
      {
      _1_scoring_lookup_next = 19U;
      }
    }
    break;
    case 2: ;
    if (! *is_match) {
      {
      _1_scoring_lookup_next = 13U;
      }
    } else {
      {
      _1_scoring_lookup_next = 14U;
      }
    }
    break;
    case 20: 
    *is_match = (_Bool)1;
    {
    _1_scoring_lookup_next = 18U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_lookup LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_plain_gz LOC=UNKNOWN */
__inline static int _seq_read_plain_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int _1__seq_read_plain_gz_next ;

  {
  {
  _1__seq_read_plain_gz_next = 7U;
  }
  while (1) {
    switch (_1__seq_read_plain_gz_next) {
    case 4: 
    tmp___0 = gzgetc(sf->gz_file);
    c = tmp___0;
    {
    _1__seq_read_plain_gz_next = 0U;
    }
    break;
    case 14: ;
    if (! tmp___1) {
      {
      _1__seq_read_plain_gz_next = 1U;
      }
    } else {
      {
      _1__seq_read_plain_gz_next = 12U;
      }
    }
    break;
    case 12: ;
    if (c != 10) {
      {
      _1__seq_read_plain_gz_next = 9U;
      }
    } else {
      {
      _1__seq_read_plain_gz_next = 13U;
      }
    }
    break;
    case 8: ;
    return (1);
    break;
    case 1: ;
    if (c == -1) {
      {
      _1__seq_read_plain_gz_next = 2U;
      }
    } else {
      {
      _1__seq_read_plain_gz_next = 3U;
      }
    }
    break;
    case 3: 
    cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
    gzreadline(sf->gz_file, & r->seq.b, & r->seq.end, & r->seq.size);
    cbuf_chomp(r->seq.b, & r->seq.end);
    {
    _1__seq_read_plain_gz_next = 8U;
    }
    break;
    case 11: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    c = (int )*tmp;
    {
    _1__seq_read_plain_gz_next = 0U;
    }
    break;
    case 9: 
    gzskipline(sf->gz_file);
    {
    _1__seq_read_plain_gz_next = 13U;
    }
    break;
    case 13: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_plain_gz_next = 11U;
      }
    } else {
      {
      _1__seq_read_plain_gz_next = 4U;
      }
    }
    break;
    case 5: 
    tmp___1 = isspace(c);
    {
    _1__seq_read_plain_gz_next = 14U;
    }
    break;
    case 0: ;
    if (c != -1) {
      {
      _1__seq_read_plain_gz_next = 5U;
      }
    } else {
      {
      _1__seq_read_plain_gz_next = 1U;
      }
    }
    break;
    case 7: 
    seq_read_reset(r);
    {
    _1__seq_read_plain_gz_next = 13U;
    }
    break;
    case 2: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_plain_gz LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_print LOC=UNKNOWN */
void scoring_print(scoring_t const   *scoring___0 ) 
{ 
  unsigned int _1_scoring_print_next ;

  {
  {
  _1_scoring_print_next = 0U;
  }
  while (1) {
    switch (_1_scoring_print_next) {
    case 1: ;
    return;
    break;
    case 0: 
    printf((char const   *)((char const   */* __restrict  */)"scoring:\n"));
    printf((char const   *)((char const   */* __restrict  */)"  match: %i; mismatch: %i; (use_match_mismatch: %i)\n"),
           scoring___0->match, scoring___0->mismatch, (int )scoring___0->use_match_mismatch);
    printf((char const   *)((char const   */* __restrict  */)"  gap_open: %i; gap_extend: %i;\n"),
           scoring___0->gap_open, scoring___0->gap_extend);
    printf((char const   *)((char const   */* __restrict  */)"  no_gaps_in_a: %i; no_gaps_in_b: %i; no_mismatches: %i;\n"),
           (int )scoring___0->no_gaps_in_a, (int )scoring___0->no_gaps_in_b, (int )scoring___0->no_mismatches);
    printf((char const   *)((char const   */* __restrict  */)"  no_start_gap_penalty: %i; no_end_gap_penalty: %i;\n"),
           (int )scoring___0->no_start_gap_penalty, (int )scoring___0->no_end_gap_penalty);
    {
    _1_scoring_print_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_print LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF bitset_dealloc LOC=UNKNOWN */
__inline static void bitset_dealloc(BitSet *bs ) 
{ 
  unsigned int _1_bitset_dealloc_next ;

  {
  {
  _1_bitset_dealloc_next = 0U;
  }
  while (1) {
    switch (_1_bitset_dealloc_next) {
    case 1: ;
    return;
    break;
    case 0: 
    free((void *)bs->b);
    memset((void *)bs, 0, sizeof(*bs));
    {
    _1_bitset_dealloc_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF bitset_dealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF strm_buf_alloc LOC=UNKNOWN */
__inline static StreamBuffer *strm_buf_alloc(StreamBuffer *b , size_t___0 s ) 
{ 
  size_t___0 tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  char tmp___3 ;
  unsigned int _1_strm_buf_alloc_next ;

  {
  {
  _1_strm_buf_alloc_next = 4U;
  }
  while (1) {
    switch (_1_strm_buf_alloc_next) {
    case 4: ;
    if (s < 16UL) {
      {
      _1_strm_buf_alloc_next = 0U;
      }
    } else {
      {
      _1_strm_buf_alloc_next = 5U;
      }
    }
    break;
    case 1: ;
    return ((StreamBuffer *)((void *)0));
    break;
    case 3: 
    b->size = tmp + 1UL;
    tmp___1 = malloc(b->size);
    tmp___0 = (char *)tmp___1;
    b->b = tmp___0;
    {
    _1_strm_buf_alloc_next = 7U;
    }
    break;
    case 6: ;
    return (b);
    break;
    case 5: 
    tmp = s;
    {
    _1_strm_buf_alloc_next = 3U;
    }
    break;
    case 0: 
    tmp = (size_t___0 )16;
    {
    _1_strm_buf_alloc_next = 3U;
    }
    break;
    case 7: ;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      _1_strm_buf_alloc_next = 1U;
      }
    } else {
      {
      _1_strm_buf_alloc_next = 2U;
      }
    }
    break;
    case 2: 
    tmp___2 = (size_t___0 )1;
    b->end = tmp___2;
    b->begin = tmp___2;
    tmp___3 = (char)0;
    *(b->b + (b->size - 1UL)) = tmp___3;
    *(b->b + b->end) = tmp___3;
    {
    _1_strm_buf_alloc_next = 6U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF strm_buf_alloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF needleman_wunsch_align2 LOC=UNKNOWN */
void needleman_wunsch_align2(char const   *a , char const   *b , size_t___0 len_a ,
                             size_t___0 len_b , scoring_t const   *scoring___0 , nw_aligner_t *nw ,
                             alignment_t *result___0 ) 
{ 
  size_t___0 longest_alignment ;
  size_t___0 next_char ;
  size_t___0 arr_size ;
  enum Matrix curr_matrix ;
  score_t curr_score ;
  char *alignment_a ;
  char *alignment_b ;
  size_t___0 score_x ;
  size_t___0 score_y ;
  size_t___0 arr_index ;
  int first_char ;
  int alignment_len ;
  unsigned int _1_needleman_wunsch_align2_next ;

  {
  {
  _1_needleman_wunsch_align2_next = 30U;
  }
  while (1) {
    switch (_1_needleman_wunsch_align2_next) {
    case 18: 
    curr_matrix = (enum Matrix )1;
    curr_score = *(nw->gap_a_scores + (arr_size - 1UL));
    {
    _1_needleman_wunsch_align2_next = 16U;
    }
    break;
    case 25: ;
    if (score_y > 0UL) {
      {
      _1_needleman_wunsch_align2_next = 26U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 1U;
      }
    }
    break;
    case 4: ;
    if (score_x > 0UL) {
      {
      _1_needleman_wunsch_align2_next = 15U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 11U;
      }
    }
    break;
    case 30: 
    aligner_align(nw, a, b, len_a, len_b, scoring___0, (char)0);
    longest_alignment = ((nw->score_width - 1UL) + nw->score_height) - 1UL;
    alignment_ensure_capacity(result___0, longest_alignment);
    next_char = longest_alignment - 1UL;
    arr_size = nw->score_width * nw->score_height;
    curr_matrix = (enum Matrix )0;
    curr_score = *(nw->match_scores + (arr_size - 1UL));
    {
    _1_needleman_wunsch_align2_next = 6U;
    }
    break;
    case 14: ;
    if (score_x > 0UL) {
      {
      _1_needleman_wunsch_align2_next = 7U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 25U;
      }
    }
    break;
    case 15: ;
    if (score_y > 0UL) {
      {
      _1_needleman_wunsch_align2_next = 27U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 11U;
      }
    }
    break;
    case 12: 
    *(alignment_a + next_char) = (char )*(nw->seq_a + (score_x - 1UL));
    *(alignment_b + next_char) = (char )*(nw->seq_b + (score_y - 1UL));
    {
    _1_needleman_wunsch_align2_next = 4U;
    }
    break;
    case 8: 
    curr_matrix = (enum Matrix )2;
    curr_score = *(nw->gap_b_scores + (arr_size - 1UL));
    {
    _1_needleman_wunsch_align2_next = 21U;
    }
    break;
    case 1: ;
    if (score_x > 0UL) {
      {
      _1_needleman_wunsch_align2_next = 28U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 22U;
      }
    }
    break;
    case 23: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Program error: invalid matrix number\n"));
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Please submit a bug report to: turner.isaac@gmail.com\n"));
    exit(1);

    break;
    case 16: 
    result___0->score = curr_score;
    alignment_a = result___0->result_a;
    alignment_b = result___0->result_b;
    score_x = nw->score_width - 1UL;
    score_y = nw->score_height - 1UL;
    arr_index = arr_size - 1UL;
    {
    _1_needleman_wunsch_align2_next = 14U;
    }
    break;
    case 24: 
    *(alignment_a + next_char) = (char )*(nw->seq_a + (score_x - 1UL));
    *(alignment_b + next_char) = (char )'-';
    {
    _1_needleman_wunsch_align2_next = 4U;
    }
    break;
    case 21: ;
    if (*(nw->gap_a_scores + (arr_size - 1UL)) >= curr_score) {
      {
      _1_needleman_wunsch_align2_next = 18U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 16U;
      }
    }
    break;
    case 26: 
    *(alignment_a + next_char) = (char )'-';
    *(alignment_b + next_char) = (char )*(nw->seq_b + (score_y - 1UL));
    next_char --;
    score_y --;
    {
    _1_needleman_wunsch_align2_next = 25U;
    }
    break;
    case 11: 
    next_char --;
    {
    _1_needleman_wunsch_align2_next = 14U;
    }
    break;
    case 13: 
    *(alignment_a + next_char) = (char )'-';
    *(alignment_b + next_char) = (char )*(nw->seq_b + (score_y - 1UL));
    {
    _1_needleman_wunsch_align2_next = 4U;
    }
    break;
    case 6: ;
    if (*(nw->gap_b_scores + (arr_size - 1UL)) >= curr_score) {
      {
      _1_needleman_wunsch_align2_next = 8U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 21U;
      }
    }
    break;
    case 27: 
    alignment_reverse_move(& curr_matrix, & curr_score, & score_x, & score_y, & arr_index,
                           (aligner_t const   *)nw);
    {
    _1_needleman_wunsch_align2_next = 11U;
    }
    break;
    case 22: 
    first_char = (int )(next_char + 1UL);
    alignment_len = (int )(longest_alignment - (size_t___0 )first_char);
    memmove((void *)alignment_a, (void const   *)(alignment_a + first_char), (size_t___0 )alignment_len);
    memmove((void *)alignment_b, (void const   *)(alignment_b + first_char), (size_t___0 )alignment_len);
    *(alignment_a + alignment_len) = (char )'\000';
    *(alignment_b + alignment_len) = (char )'\000';
    result___0->length = (size_t___0 )alignment_len;
    {
    _1_needleman_wunsch_align2_next = 0U;
    }
    break;
    case 28: 
    *(alignment_a + next_char) = (char )*(nw->seq_a + (score_x - 1UL));
    *(alignment_b + next_char) = (char )'-';
    next_char --;
    score_x --;
    {
    _1_needleman_wunsch_align2_next = 1U;
    }
    break;
    case 0: ;
    return;
    break;
    case 7: ;
    if (! (score_y > 0UL)) {
      {
      _1_needleman_wunsch_align2_next = 25U;
      }
    } else {
      {
      _1_needleman_wunsch_align2_next = 2U;
      }
    }
    break;
    case 2: ;
    switch ((unsigned int )curr_matrix) {
    case 0U: 
    {
    _1_needleman_wunsch_align2_next = 12U;
    }
    break;
    case 1U: 
    {
    _1_needleman_wunsch_align2_next = 13U;
    }
    break;
    case 2U: 
    {
    _1_needleman_wunsch_align2_next = 24U;
    }
    break;
    default: 
    {
    _1_needleman_wunsch_align2_next = 23U;
    }
    break;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF needleman_wunsch_align2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alignment_ensure_capacity LOC=UNKNOWN */
void alignment_ensure_capacity(alignment_t *result___0 , size_t___0 strlength ) 
{ 
  size_t___0 capacity ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int _1_alignment_ensure_capacity_next ;

  {
  {
  _1_alignment_ensure_capacity_next = 6U;
  }
  while (1) {
    switch (_1_alignment_ensure_capacity_next) {
    case 4: ;
    if (result___0->capacity < capacity) {
      {
      _1_alignment_ensure_capacity_next = 7U;
      }
    } else {
      {
      _1_alignment_ensure_capacity_next = 1U;
      }
    }
    break;
    case 1: ;
    return;
    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"%s:%i: Out of memory\n"),
            "src/alignment.c", 229);
    exit(1);

    break;
    case 6: 
    capacity = strlength + 1UL;
    {
    _1_alignment_ensure_capacity_next = 4U;
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"%s:%i: Out of memory\n"),
            "src/alignment.c", 229);
    exit(1);

    break;
    case 0: ;
    if ((unsigned long )result___0->result_b == (unsigned long )((void *)0)) {
      {
      _1_alignment_ensure_capacity_next = 3U;
      }
    } else {
      {
      _1_alignment_ensure_capacity_next = 1U;
      }
    }
    break;
    case 7: 
    capacity = _rndup2pow64((unsigned long long )capacity);
    tmp = realloc((void *)result___0->result_a, sizeof(char ) * capacity);
    result___0->result_a = (char *)tmp;
    tmp___0 = realloc((void *)result___0->result_b, sizeof(char ) * capacity);
    result___0->result_b = (char *)tmp___0;
    result___0->capacity = capacity;
    {
    _1_alignment_ensure_capacity_next = 2U;
    }
    break;
    case 2: ;
    if ((unsigned long )result___0->result_a == (unsigned long )((void *)0)) {
      {
      _1_alignment_ensure_capacity_next = 5U;
      }
    } else {
      {
      _1_alignment_ensure_capacity_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alignment_ensure_capacity LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fskipline_buf LOC=UNKNOWN */
__inline static size_t___0 fskipline_buf(FILE *file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 skipped_bytes ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  unsigned int _1_fskipline_buf_next ;

  {
  {
  _1_fskipline_buf_next = 22U;
  }
  while (1) {
    switch (_1_fskipline_buf_next) {
    case 18: ;
    if (! ((int )*(in->b + tmp___0) != 10)) {
      {
      _1_fskipline_buf_next = 10U;
      }
    } else {
      {
      _1_fskipline_buf_next = 17U;
      }
    }
    break;
    case 4: ;
    if (offset < in->end) {
      {
      _1_fskipline_buf_next = 14U;
      }
    } else {
      {
      _1_fskipline_buf_next = 10U;
      }
    }
    break;
    case 14: 
    tmp___0 = offset;
    offset ++;
    {
    _1_fskipline_buf_next = 18U;
    }
    break;
    case 15: ;
    return (skipped_bytes);
    break;
    case 1: 
    skipped_bytes = (size_t___0 )0;
    {
    _1_fskipline_buf_next = 6U;
    }
    break;
    case 3: ;
    if ((int )*(in->b + (offset - 1UL)) == 10) {
      {
      _1_fskipline_buf_next = 15U;
      }
    } else {
      {
      _1_fskipline_buf_next = 2U;
      }
    }
    break;
    case 16: 
    tmp = fread((void */* __restrict  */)(in->b + 1), (size_t___0 )1, in->size - 1UL,
                (FILE */* __restrict  */)file);
    in->end = 1UL + tmp;
    in->begin = (size_t___0 )1;
    {
    _1_fskipline_buf_next = 1U;
    }
    break;
    case 21: 
    offset = in->begin;
    {
    _1_fskipline_buf_next = 4U;
    }
    break;
    case 17: 
    skipped_bytes += offset - in->begin;
    {
    _1_fskipline_buf_next = 4U;
    }
    break;
    case 6: ;
    if (in->end > in->begin) {
      {
      _1_fskipline_buf_next = 21U;
      }
    } else {
      {
      _1_fskipline_buf_next = 15U;
      }
    }
    break;
    case 22: ;
    if (in->begin >= in->end) {
      {
      _1_fskipline_buf_next = 16U;
      }
    } else {
      {
      _1_fskipline_buf_next = 1U;
      }
    }
    break;
    case 10: 
    in->begin = offset;
    {
    _1_fskipline_buf_next = 3U;
    }
    break;
    case 2: 
    tmp___1 = fread((void */* __restrict  */)(in->b + 1), (size_t___0 )1, in->size - 1UL,
                    (FILE */* __restrict  */)file);
    in->end = 1UL + tmp___1;
    in->begin = (size_t___0 )1;
    {
    _1_fskipline_buf_next = 6U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF fskipline_buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF open_seq_file LOC=UNKNOWN */
static seq_file_t *open_seq_file(char const   *path , _Bool use_zlib ) 
{ 
  seq_file_t *tmp___0 ;
  int tmp___1 ;
  seq_file_t *tmp___2 ;
  seq_file_t *tmp___3 ;
  int tmp___4 ;
  unsigned int _1_open_seq_file_next ;

  {
  {
  _1_open_seq_file_next = 0U;
  }
  while (1) {
    switch (_1_open_seq_file_next) {
    case 4: ;
    if (tmp___4 != 0) {
      {
      _1_open_seq_file_next = 5U;
      }
    } else {
      {
      _1_open_seq_file_next = 2U;
      }
    }
    break;
    case 1: 
    tmp___1 = fileno(stdin);
    tmp___2 = seq_dopen(tmp___1, (char)0, (_Bool)0, (size_t___0 )0);
    tmp___3 = tmp___2;
    {
    _1_open_seq_file_next = 6U;
    }
    break;
    case 3: 
    tmp___0 = seq_open(path);
    tmp___3 = tmp___0;
    {
    _1_open_seq_file_next = 6U;
    }
    break;
    case 6: ;
    return (tmp___3);
    break;
    case 5: 
    tmp___0 = seq_open(path);
    tmp___3 = tmp___0;
    {
    _1_open_seq_file_next = 6U;
    }
    break;
    case 0: 
    tmp___4 = strcmp(path, "-");
    {
    _1_open_seq_file_next = 4U;
    }
    break;
    case 2: ;
    if (use_zlib) {
      {
      _1_open_seq_file_next = 3U;
      }
    } else {
      {
      _1_open_seq_file_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF open_seq_file LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_setup LOC=UNKNOWN */
__inline static char _seq_setup(seq_file_t *sf , _Bool use_zlib , size_t___0 buf_size ) 
{ 
  StreamBuffer *tmp ;
  unsigned int _1__seq_setup_next ;

  {
  {
  _1__seq_setup_next = 3U;
  }
  while (1) {
    switch (_1__seq_setup_next) {
    case 4: ;
    return ((char)0);
    break;
    case 12: ;
    if (use_zlib) {
      {
      _1__seq_setup_next = 9U;
      }
    } else {
      {
      _1__seq_setup_next = 10U;
      }
    }
    break;
    case 8: 
    sf->readfunc = sf->origreadfunc;
    {
    _1__seq_setup_next = 11U;
    }
    break;
    case 1: 
    sf->origreadfunc = & _seq_read_unknown_gz_buf;
    {
    _1__seq_setup_next = 8U;
    }
    break;
    case 3: ;
    if (buf_size) {
      {
      _1__seq_setup_next = 0U;
      }
    } else {
      {
      _1__seq_setup_next = 12U;
      }
    }
    break;
    case 11: ;
    return ((char)1);
    break;
    case 9: 
    sf->origreadfunc = & _seq_read_unknown_gz;
    {
    _1__seq_setup_next = 8U;
    }
    break;
    case 6: ;
    if (use_zlib) {
      {
      _1__seq_setup_next = 1U;
      }
    } else {
      {
      _1__seq_setup_next = 5U;
      }
    }
    break;
    case 5: 
    sf->origreadfunc = & _seq_read_unknown_f_buf;
    {
    _1__seq_setup_next = 8U;
    }
    break;
    case 10: 
    sf->origreadfunc = & _seq_read_unknown_f;
    {
    _1__seq_setup_next = 8U;
    }
    break;
    case 0: 
    tmp = strm_buf_alloc(& sf->in, buf_size);
    {
    _1__seq_setup_next = 7U;
    }
    break;
    case 7: ;
    if (! tmp) {
      {
      _1__seq_setup_next = 2U;
      }
    } else {
      {
      _1__seq_setup_next = 6U;
      }
    }
    break;
    case 2: 
    free((void *)sf);
    {
    _1__seq_setup_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_setup LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF seq_open2 LOC=UNKNOWN */
__inline static seq_file_t *seq_open2(char const   *p , _Bool ishts , _Bool use_zlib ,
                                      size_t___0 buf_size ) 
{ 
  seq_file_t *sf ;
  void *tmp ;
  gzFile tmp___0 ;
  FILE *tmp___1 ;
  char tmp___2 ;
  unsigned int _1_seq_open2_next ;

  {
  {
  _1_seq_open2_next = 16U;
  }
  while (1) {
    switch (_1_seq_open2_next) {
    case 4: 
    tmp___2 = _seq_setup(sf, use_zlib, buf_size);
    {
    _1_seq_open2_next = 0U;
    }
    break;
    case 14: ;
    return (sf);
    break;
    case 15: 
    _L: ;
    if (! use_zlib) {
      {
      _1_seq_open2_next = 8U;
      }
    } else {
      {
      _1_seq_open2_next = 4U;
      }
    }
    break;
    case 8: 
    tmp___1 = fopen((char const   */* __restrict  */)p, (char const   */* __restrict  */)"r");
    sf->f_file = tmp___1;
    {
    _1_seq_open2_next = 7U;
    }
    break;
    case 1: 
    tmp___0 = gzopen(p, "r");
    sf->gz_file = tmp___0;
    {
    _1_seq_open2_next = 5U;
    }
    break;
    case 3: 
    seq_close(sf);
    {
    _1_seq_open2_next = 17U;
    }
    break;
    case 16: 
    tmp = calloc((size_t )1, sizeof(seq_file_t ));
    sf = (seq_file_t *)tmp;
    sf->path = strdup(p);
    {
    _1_seq_open2_next = 11U;
    }
    break;
    case 11: ;
    if (ishts) {
      {
      _1_seq_open2_next = 9U;
      }
    } else {
      {
      _1_seq_open2_next = 10U;
      }
    }
    break;
    case 9: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"[%s:%i] Error: not compiled with sam/bam support\n"),
            "libs/seq_file/seq_file.h", 506);
    exit(1);

    break;
    case 13: ;
    return ((seq_file_t *)((void *)0));
    break;
    case 17: ;
    return ((seq_file_t *)((void *)0));
    break;
    case 6: ;
    return ((seq_file_t *)((void *)0));
    break;
    case 5: ;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      _1_seq_open2_next = 2U;
      }
    } else {
      {
      _1_seq_open2_next = 15U;
      }
    }
    break;
    case 10: ;
    if (use_zlib) {
      {
      _1_seq_open2_next = 1U;
      }
    } else {
      {
      _1_seq_open2_next = 15U;
      }
    }
    break;
    case 0: ;
    if (! tmp___2) {
      {
      _1_seq_open2_next = 6U;
      }
    } else {
      {
      _1_seq_open2_next = 14U;
      }
    }
    break;
    case 7: ;
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      _1_seq_open2_next = 3U;
      }
    } else {
      {
      _1_seq_open2_next = 4U;
      }
    }
    break;
    case 2: 
    seq_close(sf);
    {
    _1_seq_open2_next = 13U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF seq_open2 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gzreadline LOC=UNKNOWN */
__inline static size_t___0 gzreadline(gzFile file , char **buf , size_t___0 *len ,
                                      size_t___0 *size ) 
{ 
  size_t___0 r ;
  size_t___0 tmp ;
  size_t___0 origlen ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  unsigned int _1_gzreadline_next ;

  {
  {
  _1_gzreadline_next = 7U;
  }
  while (1) {
    switch (_1_gzreadline_next) {
    case 14: 
    tmp = *size - *len;
    {
    _1_gzreadline_next = 10U;
    }
    break;
    case 15: 
    tmp___1 = *size * 2UL;
    *size = tmp___1;
    tmp___2 = realloc((void *)*buf, tmp___1);
    *buf = (char *)tmp___2;
    {
    _1_gzreadline_next = 3U;
    }
    break;
    case 12: 
    cbuf_capacity(buf, size, *len + 1UL);
    {
    _1_gzreadline_next = 16U;
    }
    break;
    case 1: 
    tmp = (size_t___0 )4294967295U;
    {
    _1_gzreadline_next = 10U;
    }
    break;
    case 3: ;
    if (*size - *len > 4294967295UL) {
      {
      _1_gzreadline_next = 5U;
      }
    } else {
      {
      _1_gzreadline_next = 2U;
      }
    }
    break;
    case 16: ;
    if (*size - *len > 4294967295UL) {
      {
      _1_gzreadline_next = 1U;
      }
    } else {
      {
      _1_gzreadline_next = 14U;
      }
    }
    break;
    case 11: ;
    return (*len - origlen);
    break;
    case 9: 
    tmp___3 = gzgets(file, *buf + *len, (int )r);
    {
    _1_gzreadline_next = 0U;
    }
    break;
    case 13: 
    tmp___0 = strlen((char const   *)(*buf + *len));
    *len += tmp___0;
    {
    _1_gzreadline_next = 6U;
    }
    break;
    case 17: ;
    return (*len - origlen);
    break;
    case 6: ;
    if ((int )*(*buf + (*len - 1UL)) == 10) {
      {
      _1_gzreadline_next = 11U;
      }
    } else {
      {
      _1_gzreadline_next = 15U;
      }
    }
    break;
    case 5: 
    r = (size_t___0 )4294967295U;
    {
    _1_gzreadline_next = 9U;
    }
    break;
    case 10: 
    r = tmp;
    origlen = *len;
    {
    _1_gzreadline_next = 9U;
    }
    break;
    case 0: ;
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
      {
      _1_gzreadline_next = 17U;
      }
    } else {
      {
      _1_gzreadline_next = 13U;
      }
    }
    break;
    case 7: ;
    if (*len + 1UL >= *size) {
      {
      _1_gzreadline_next = 12U;
      }
    } else {
      {
      _1_gzreadline_next = 16U;
      }
    }
    break;
    case 2: 
    r = *size - *len;
    {
    _1_gzreadline_next = 9U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gzreadline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_system_PAM70 LOC=UNKNOWN */
void scoring_system_PAM70(scoring_t *scoring___0 ) 
{ 
  unsigned int _1_scoring_system_PAM70_next ;

  {
  {
  _1_scoring_system_PAM70_next = 1U;
  }
  while (1) {
    switch (_1_scoring_system_PAM70_next) {
    case 1: 
    scoring_init(scoring___0, 1, -11, -10, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                 (_Bool)0, (_Bool)0);
    scoring_add_mutations(scoring___0, (char const   *)(amino_acids), pam70, (char)1);
    {
    _1_scoring_system_PAM70_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_system_PAM70 LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _ensure_history_capacity LOC=UNKNOWN */
static void _ensure_history_capacity(sw_history_t *hist , size_t___0 arr_size ) 
{ 
  size_t___0 mem ;
  void *tmp ;
  unsigned int _1__ensure_history_capacity_next ;

  {
  {
  _1__ensure_history_capacity_next = 6U;
  }
  while (1) {
    switch (_1__ensure_history_capacity_next) {
    case 4: 
    hist->hits_capacity = _rndup2pow64___0((unsigned long long )arr_size);
    bitset_set_length(& hist->match_scores_mask, hist->hits_capacity);
    mem = hist->hits_capacity * sizeof(*(hist->sorted_match_indices));
    tmp = realloc((void *)hist->sorted_match_indices, mem);
    hist->sorted_match_indices = (size_t___0 *)tmp;
    {
    _1__ensure_history_capacity_next = 3U;
    }
    break;
    case 1: ;
    if (! hist->sorted_match_indices) {
      {
      _1__ensure_history_capacity_next = 0U;
      }
    } else {
      {
      _1__ensure_history_capacity_next = 5U;
      }
    }
    break;
    case 3: ;
    if (! hist->match_scores_mask.b) {
      {
      _1__ensure_history_capacity_next = 2U;
      }
    } else {
      {
      _1__ensure_history_capacity_next = 1U;
      }
    }
    break;
    case 6: ;
    if (arr_size > hist->hits_capacity) {
      {
      _1__ensure_history_capacity_next = 4U;
      }
    } else {
      {
      _1__ensure_history_capacity_next = 5U;
      }
    }
    break;
    case 5: ;
    return;
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"%s:%i: Out of memory\n"),
            "src/smith_waterman.c", 105);
    exit(1);

    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"%s:%i: Out of memory\n"),
            "src/smith_waterman.c", 105);
    exit(1);

    break;
    }
  }
}
}
/* END FUNCTION-DEF _ensure_history_capacity LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF scoring_add_mutations LOC=UNKNOWN */
void scoring_add_mutations(scoring_t *scoring___0 , char const   *str , int const   *scores ,
                           char use_match_mismatch ) 
{ 
  size_t___0 i ;
  size_t___0 j ;
  size_t___0 len ;
  size_t___0 tmp ;
  char a ;
  char b ;
  int score ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int _1_scoring_add_mutations_next ;

  {
  {
  _1_scoring_add_mutations_next = 8U;
  }
  while (1) {
    switch (_1_scoring_add_mutations_next) {
    case 4: 
    scoring___0->use_match_mismatch = (_Bool )use_match_mismatch;
    {
    _1_scoring_add_mutations_next = 15U;
    }
    break;
    case 14: ;
    if (scoring___0->case_sensitive) {
      {
      _1_scoring_add_mutations_next = 11U;
      }
    } else {
      {
      _1_scoring_add_mutations_next = 5U;
      }
    }
    break;
    case 15: ;
    return;
    break;
    case 12: 
    i ++;
    {
    _1_scoring_add_mutations_next = 1U;
    }
    break;
    case 8: 
    tmp = strlen(str);
    len = tmp;
    i = (size_t___0 )0;
    {
    _1_scoring_add_mutations_next = 1U;
    }
    break;
    case 1: ;
    if (i < len) {
      {
      _1_scoring_add_mutations_next = 6U;
      }
    } else {
      {
      _1_scoring_add_mutations_next = 4U;
      }
    }
    break;
    case 16: ;
    if (j < len) {
      {
      _1_scoring_add_mutations_next = 14U;
      }
    } else {
      {
      _1_scoring_add_mutations_next = 12U;
      }
    }
    break;
    case 11: 
    b = (char )*(str + j);
    {
    _1_scoring_add_mutations_next = 0U;
    }
    break;
    case 9: 
    tmp___0 = tolower((int )*(str + i));
    a = (char )tmp___0;
    {
    _1_scoring_add_mutations_next = 13U;
    }
    break;
    case 13: 
    j = (size_t___0 )0;
    {
    _1_scoring_add_mutations_next = 16U;
    }
    break;
    case 6: ;
    if (scoring___0->case_sensitive) {
      {
      _1_scoring_add_mutations_next = 2U;
      }
    } else {
      {
      _1_scoring_add_mutations_next = 9U;
      }
    }
    break;
    case 5: 
    tmp___1 = tolower((int )*(str + j));
    b = (char )tmp___1;
    {
    _1_scoring_add_mutations_next = 0U;
    }
    break;
    case 0: 
    score = (int )*(scores + (j * len + i));
    scoring_add_mutation(scoring___0, a, b, score);
    j ++;
    {
    _1_scoring_add_mutations_next = 16U;
    }
    break;
    case 2: 
    a = (char )*(str + i);
    {
    _1_scoring_add_mutations_next = 13U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF scoring_add_mutations LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _seq_read_unknown_gz LOC=UNKNOWN */
__inline static int _seq_read_unknown_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int _1__seq_read_unknown_gz_next ;

  {
  {
  _1__seq_read_unknown_gz_next = 17U;
  }
  while (1) {
    switch (_1__seq_read_unknown_gz_next) {
    case 18: ;
    if (c != -1) {
      {
      _1__seq_read_unknown_gz_next = 5U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_next = 6U;
      }
    }
    break;
    case 4: ;
    return (tmp___2);
    break;
    case 14: 
    gzskipline(sf->gz_file);
    {
    _1__seq_read_unknown_gz_next = 16U;
    }
    break;
    case 15: 
    tmp___0 = gzgetc(sf->gz_file);
    c = tmp___0;
    {
    _1__seq_read_unknown_gz_next = 18U;
    }
    break;
    case 12: 
    gzungetc(c, sf->gz_file);
    tmp___2 = (*(sf->origreadfunc))(sf, r);
    {
    _1__seq_read_unknown_gz_next = 4U;
    }
    break;
    case 8: ;
    if (c == 64) {
      {
      _1__seq_read_unknown_gz_next = 7U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_next = 11U;
      }
    }
    break;
    case 1: 
    sf->format = (seq_format )2;
    sf->origreadfunc = & _seq_read_fasta_gz;
    {
    _1__seq_read_unknown_gz_next = 12U;
    }
    break;
    case 3: ;
    if (! tmp___1) {
      {
      _1__seq_read_unknown_gz_next = 6U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_next = 10U;
      }
    }
    break;
    case 16: ;
    if ((sf->gz_file)->have) {
      {
      _1__seq_read_unknown_gz_next = 2U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_next = 15U;
      }
    }
    break;
    case 11: ;
    if (c == 62) {
      {
      _1__seq_read_unknown_gz_next = 1U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_next = 19U;
      }
    }
    break;
    case 19: 
    sf->format = (seq_format )1;
    sf->origreadfunc = & _seq_read_plain_gz;
    {
    _1__seq_read_unknown_gz_next = 12U;
    }
    break;
    case 17: 
    seq_read_reset(r);
    {
    _1__seq_read_unknown_gz_next = 16U;
    }
    break;
    case 6: ;
    if (c == -1) {
      {
      _1__seq_read_unknown_gz_next = 20U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_next = 8U;
      }
    }
    break;
    case 5: 
    tmp___1 = isspace(c);
    {
    _1__seq_read_unknown_gz_next = 3U;
    }
    break;
    case 10: ;
    if (c != 10) {
      {
      _1__seq_read_unknown_gz_next = 14U;
      }
    } else {
      {
      _1__seq_read_unknown_gz_next = 16U;
      }
    }
    break;
    case 7: 
    sf->format = (seq_format )4;
    sf->origreadfunc = & _seq_read_fastq_gz;
    {
    _1__seq_read_unknown_gz_next = 12U;
    }
    break;
    case 2: 
    ((sf->gz_file)->have) --;
    ((sf->gz_file)->pos) ++;
    tmp = (sf->gz_file)->next;
    ((sf->gz_file)->next) ++;
    c = (int )*tmp;
    {
    _1__seq_read_unknown_gz_next = 18U;
    }
    break;
    case 20: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF _seq_read_unknown_gz LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF align_scoring_load_matrix LOC=UNKNOWN */
void align_scoring_load_matrix(gzFile file , char const   *file_path , scoring_t *scoring___0 ,
                               char case_sensitive ) 
{ 
  StrBuf *sbuf ;
  StrBuf *tmp ;
  size_t___0 read_length ;
  int line_num ;
  char tmp___0 ;
  char sep ;
  char *characters ;
  void *tmp___1 ;
  int num_of_chars ;
  char *next ;
  int tmp___2 ;
  int tmp___3 ;
  char *from_char_pos ;
  char *tmp___4 ;
  char from_char ;
  int tmp___5 ;
  int tmp___6 ;
  char to_char ;
  char *score_txt ;
  int score ;
  int i ;
  int tmp___7 ;
  char *strtol_last_char_ptr ;
  long tmp___8 ;
  char tmp___9 ;
  size_t___0 i___0 ;
  char c ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int score___0 ;
  char from_char___0 ;
  int tmp___13 ;
  int tmp___14 ;
  char tmp___15 ;
  char *str_pos ;
  int to_char_index ;
  char to_char___0 ;
  int tmp___16 ;
  char *after_num_str ;
  long tmp___17 ;
  int tmp___18 ;
  unsigned int _1_align_scoring_load_matrix_next ;

  {
  {
  _1_align_scoring_load_matrix_next = 21U;
  }
  while (1) {
    switch (_1_align_scoring_load_matrix_next) {
    case 25: ;
    if ((int )*str_pos != (int )sep) {
      {
      _1_align_scoring_load_matrix_next = 87U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 12U;
      }
    }
    break;
    case 49: 
    from_char = (char )tmp___6;
    score_txt = sbuf->b + 1;
    i = 0;
    {
    _1_align_scoring_load_matrix_next = 90U;
    }
    break;
    case 52: ;
    if (! (read_length > 0UL)) {
      {
      _1_align_scoring_load_matrix_next = 31U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 81U;
      }
    }
    break;
    case 4: 
    strbuf_chomp(sbuf);
    tmp___4 = string_next_nonwhitespace(sbuf->b);
    from_char_pos = tmp___4;
    {
    _1_align_scoring_load_matrix_next = 29U;
    }
    break;
    case 30: ;
    if (! tmp___7) {
      {
      _1_align_scoring_load_matrix_next = 73U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 61U;
      }
    }
    break;
    case 62: 
    tmp___3 = tolower((int )*next);
    *(characters + tmp___2) = (char )tmp___3;
    {
    _1_align_scoring_load_matrix_next = 34U;
    }
    break;
    case 102: 
    tmp___16 = to_char_index;
    to_char_index ++;
    to_char___0 = *(characters + tmp___16);
    {
    _1_align_scoring_load_matrix_next = 25U;
    }
    break;
    case 14: ;
    if (case_sensitive) {
      {
      _1_align_scoring_load_matrix_next = 10U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 47U;
      }
    }
    break;
    case 15: ;
    if (sbuf->end <= 0UL) {
      {
      _1_align_scoring_load_matrix_next = 88U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 69U;
      }
    }
    break;
    case 82: 
    line_num ++;
    {
    _1_align_scoring_load_matrix_next = 22U;
    }
    break;
    case 89: 
    tmp___14 = (int )*(sbuf->b + 0);
    {
    _1_align_scoring_load_matrix_next = 51U;
    }
    break;
    case 56: ;
    if (tmp___15) {
      {
      _1_align_scoring_load_matrix_next = 23U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 65U;
      }
    }
    break;
    case 79: ;
    if (to_char_index >= num_of_chars) {
      {
      _1_align_scoring_load_matrix_next = 19U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 75U;
      }
    }
    break;
    case 31: ;
    if (line_num == 0) {
      {
      _1_align_scoring_load_matrix_next = 15U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 69U;
      }
    }
    break;
    case 12: 
    str_pos ++;
    after_num_str = str_pos;
    tmp___17 = strtol((char const   *)((char const   */* __restrict  */)str_pos),
                      (char **)((char **/* __restrict  */)(& after_num_str)), 10);
    score___0 = (int )tmp___17;
    {
    _1_align_scoring_load_matrix_next = 100U;
    }
    break;
    case 69: 
    sep = *(sbuf->b + 0);
    {
    _1_align_scoring_load_matrix_next = 70U;
    }
    break;
    case 8: ;
    if (sbuf->end > 0UL) {
      {
      _1_align_scoring_load_matrix_next = 0U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 82U;
      }
    }
    break;
    case 96: ;
    if ((int )*str_pos != 0) {
      {
      _1_align_scoring_load_matrix_next = 102U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 17U;
      }
    }
    break;
    case 54: 
    _loading_error("Numbers (0-9) and dashes (-) do not make good separators", file_path,
                   line_num, (char)0);

    break;
    case 78: 
    _loading_error("Too few column headings", file_path, line_num, (char)1);

    break;
    case 1: ;
    if (i___0 < sbuf->end) {
      {
      _1_align_scoring_load_matrix_next = 91U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 23U;
      }
    }
    break;
    case 81: 
    strbuf_chomp(sbuf);
    {
    _1_align_scoring_load_matrix_next = 8U;
    }
    break;
    case 23: 
    read_length = strbuf_reset_gzreadline(sbuf, file);
    {
    _1_align_scoring_load_matrix_next = 92U;
    }
    break;
    case 77: 
    _loading_error("Missing number value on line", file_path, line_num, (char)1);

    break;
    case 70: ;
    if ((int )sep >= 48) {
      {
      _1_align_scoring_load_matrix_next = 71U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 11U;
      }
    }
    break;
    case 3: 
    tmp___2 = num_of_chars;
    num_of_chars ++;
    {
    _1_align_scoring_load_matrix_next = 99U;
    }
    break;
    case 24: 
    tmp___13 = tolower((int )*(sbuf->b + 0));
    tmp___14 = tmp___13;
    {
    _1_align_scoring_load_matrix_next = 51U;
    }
    break;
    case 21: 
    tmp = strbuf_new((size_t___0 )500);
    sbuf = tmp;
    line_num = 0;
    {
    _1_align_scoring_load_matrix_next = 22U;
    }
    break;
    case 36: ;
    if (! tmp___9) {
      {
      _1_align_scoring_load_matrix_next = 97U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 59U;
      }
    }
    break;
    case 76: 
    _loading_error("Numbers (0-9) and dashes (-) do not make good separators", file_path,
                   line_num, (char)0);

    break;
    case 57: 
    tmp___9 = string_is_all_whitespace((char const   *)score_txt);
    {
    _1_align_scoring_load_matrix_next = 36U;
    }
    break;
    case 85: 
    i___0 = (size_t___0 )0;
    {
    _1_align_scoring_load_matrix_next = 1U;
    }
    break;
    case 100: ;
    if ((unsigned long )str_pos == (unsigned long )after_num_str) {
      {
      _1_align_scoring_load_matrix_next = 77U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 79U;
      }
    }
    break;
    case 98: ;
    if ((int )*score_txt != 0) {
      {
      _1_align_scoring_load_matrix_next = 57U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 59U;
      }
    }
    break;
    case 11: 
    _L: ;
    if ((int )sep == 45) {
      {
      _1_align_scoring_load_matrix_next = 76U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 53U;
      }
    }
    break;
    case 9: 
    tmp___6 = (int )*from_char_pos;
    {
    _1_align_scoring_load_matrix_next = 49U;
    }
    break;
    case 13: ;
    if ((unsigned long )strtol_last_char_ptr == (unsigned long )score_txt) {
      {
      _1_align_scoring_load_matrix_next = 38U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 5U;
      }
    }
    break;
    case 63: ;
    if ((int )*(sbuf->b + 0) == 35) {
      {
      _1_align_scoring_load_matrix_next = 95U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 46U;
      }
    }
    break;
    case 51: 
    from_char___0 = (char )tmp___14;
    {
    _1_align_scoring_load_matrix_next = 74U;
    }
    break;
    case 19: 
    _loading_error("Too many columns on row", file_path, line_num, (char)1);

    break;
    case 32: 
    *(characters + tmp___2) = *next;
    {
    _1_align_scoring_load_matrix_next = 34U;
    }
    break;
    case 17: 
    line_num ++;
    {
    _1_align_scoring_load_matrix_next = 23U;
    }
    break;
    case 90: ;
    if (i < num_of_chars) {
      {
      _1_align_scoring_load_matrix_next = 60U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 98U;
      }
    }
    break;
    case 60: 
    to_char = *(characters + i);
    tmp___7 = isspace((int )*score_txt);
    {
    _1_align_scoring_load_matrix_next = 30U;
    }
    break;
    case 59: 
    line_num ++;
    {
    _1_align_scoring_load_matrix_next = 95U;
    }
    break;
    case 6: 
    c = (char )tmp___11;
    tmp___12 = num_of_chars;
    num_of_chars ++;
    *(characters + tmp___12) = c;
    i___0 += 2UL;
    {
    _1_align_scoring_load_matrix_next = 1U;
    }
    break;
    case 27: 
    tmp___15 = string_is_all_whitespace((char const   *)sbuf->b);
    {
    _1_align_scoring_load_matrix_next = 56U;
    }
    break;
    case 38: 
    _loading_error("Missing number value on line", file_path, line_num, (char)1);

    break;
    case 61: 
    score_txt = string_next_nonwhitespace(score_txt + 1);
    strtol_last_char_ptr = score_txt;
    tmp___8 = strtol((char const   *)((char const   */* __restrict  */)strtol_last_char_ptr),
                     (char **)((char **/* __restrict  */)(& strtol_last_char_ptr)),
                     10);
    score = (int )tmp___8;
    {
    _1_align_scoring_load_matrix_next = 13U;
    }
    break;
    case 87: 
    _loading_error("Separator missing from line", file_path, line_num, (char)1);

    break;
    case 84: 
    _loading_error("Separator missing from line", file_path, line_num, (char)1);

    break;
    case 34: 
    next = string_next_nonwhitespace(next + 1);
    {
    _1_align_scoring_load_matrix_next = 44U;
    }
    break;
    case 74: ;
    if ((int )from_char___0 == 35) {
      {
      _1_align_scoring_load_matrix_next = 23U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 27U;
      }
    }
    break;
    case 75: 
    scoring_add_mutation(scoring___0, from_char___0, to_char___0, score___0);
    str_pos = after_num_str;
    {
    _1_align_scoring_load_matrix_next = 96U;
    }
    break;
    case 48: 
    strbuf_chomp(sbuf);
    {
    _1_align_scoring_load_matrix_next = 7U;
    }
    break;
    case 71: ;
    if ((int )sep <= 57) {
      {
      _1_align_scoring_load_matrix_next = 54U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 11U;
      }
    }
    break;
    case 22: 
    read_length = strbuf_reset_gzreadline(sbuf, file);
    {
    _1_align_scoring_load_matrix_next = 52U;
    }
    break;
    case 28: ;
    if (sbuf->end < 2UL) {
      {
      _1_align_scoring_load_matrix_next = 78U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 31U;
      }
    }
    break;
    case 53: 
    tmp___1 = malloc(sbuf->end);
    characters = (char *)tmp___1;
    num_of_chars = 0;
    tmp___18 = isspace((int )sep);
    {
    _1_align_scoring_load_matrix_next = 83U;
    }
    break;
    case 65: 
    str_pos = sbuf->b;
    to_char_index = 0;
    {
    _1_align_scoring_load_matrix_next = 96U;
    }
    break;
    case 47: 
    tmp___10 = tolower((int )*(sbuf->b + (i___0 + 1UL)));
    tmp___11 = tmp___10;
    {
    _1_align_scoring_load_matrix_next = 6U;
    }
    break;
    case 73: 
    _loading_error("Expected whitespace between elements - found character", file_path,
                   line_num, (char)1);

    break;
    case 44: ;
    if (! ((unsigned long )next != (unsigned long )((void *)0))) {
      {
      _1_align_scoring_load_matrix_next = 95U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 3U;
      }
    }
    break;
    case 5: 
    scoring_add_mutation(scoring___0, from_char, to_char, score);
    score_txt = strtol_last_char_ptr;
    i ++;
    {
    _1_align_scoring_load_matrix_next = 90U;
    }
    break;
    case 91: ;
    if ((int )*(sbuf->b + i___0) != (int )sep) {
      {
      _1_align_scoring_load_matrix_next = 84U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 14U;
      }
    }
    break;
    case 97: 
    _loading_error("Too many columns on row", file_path, line_num, (char)1);

    break;
    case 72: 
    tmp___5 = tolower((int )*from_char_pos);
    tmp___6 = tmp___5;
    {
    _1_align_scoring_load_matrix_next = 49U;
    }
    break;
    case 99: ;
    if (case_sensitive) {
      {
      _1_align_scoring_load_matrix_next = 32U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 62U;
      }
    }
    break;
    case 33: 
    next = sbuf->b;
    {
    _1_align_scoring_load_matrix_next = 34U;
    }
    break;
    case 64: ;
    return;
    break;
    case 41: 
    tmp___0 = string_is_all_whitespace((char const   *)sbuf->b);
    {
    _1_align_scoring_load_matrix_next = 42U;
    }
    break;
    case 95: 
    read_length = strbuf_reset_gzreadline(sbuf, file);
    {
    _1_align_scoring_load_matrix_next = 39U;
    }
    break;
    case 92: ;
    if (! (read_length > 0UL)) {
      {
      _1_align_scoring_load_matrix_next = 2U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 48U;
      }
    }
    break;
    case 10: 
    tmp___11 = (int )*(sbuf->b + (i___0 + 1UL));
    {
    _1_align_scoring_load_matrix_next = 6U;
    }
    break;
    case 42: ;
    if (! tmp___0) {
      {
      _1_align_scoring_load_matrix_next = 28U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 82U;
      }
    }
    break;
    case 0: ;
    if ((int )*(sbuf->b + 0) != 35) {
      {
      _1_align_scoring_load_matrix_next = 41U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 82U;
      }
    }
    break;
    case 46: ;
    if (case_sensitive) {
      {
      _1_align_scoring_load_matrix_next = 9U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 72U;
      }
    }
    break;
    case 39: ;
    if (! (read_length > 0UL)) {
      {
      _1_align_scoring_load_matrix_next = 2U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 4U;
      }
    }
    break;
    case 83: ;
    if (tmp___18) {
      {
      _1_align_scoring_load_matrix_next = 33U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 85U;
      }
    }
    break;
    case 7: ;
    if (case_sensitive) {
      {
      _1_align_scoring_load_matrix_next = 89U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 24U;
      }
    }
    break;
    case 88: 
    _loading_error("Empty file", file_path, -1, (char)0);

    break;
    case 29: ;
    if ((unsigned long )from_char_pos == (unsigned long )((void *)0)) {
      {
      _1_align_scoring_load_matrix_next = 95U;
      }
    } else {
      {
      _1_align_scoring_load_matrix_next = 63U;
      }
    }
    break;
    case 2: 
    free((void *)characters);
    strbuf_free(sbuf);
    {
    _1_align_scoring_load_matrix_next = 64U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF align_scoring_load_matrix LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF _loading_error LOC=UNKNOWN */
static  __attribute__((__noreturn__)) void _loading_error(char const   *err_msg ,
                                                          char const   *file_path ,
                                                          int line_num , char is_matrix ) ;
static void _loading_error(char const   *err_msg , char const   *file_path , int line_num ,
                           char is_matrix ) 
{ 
  unsigned int _1__loading_error_next ;

  {
  {
  _1__loading_error_next = 5U;
  }
  while (1) {
    switch (_1__loading_error_next) {
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Line: %s\n"),
            file_path);
    {
    _1__loading_error_next = 6U;
    }
    break;
    case 8: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"File: %s\n"),
            file_path);
    {
    _1__loading_error_next = 3U;
    }
    break;
    case 1: ;
    if ((unsigned long )file_path != (unsigned long )((void *)0)) {
      {
      _1__loading_error_next = 8U;
      }
    } else {
      {
      _1__loading_error_next = 3U;
      }
    }
    break;
    case 3: ;
    if (line_num != -1) {
      {
      _1__loading_error_next = 4U;
      }
    } else {
      {
      _1__loading_error_next = 6U;
      }
    }
    break;
    case 6: 
    exit(1);

    break;
    case 5: ;
    if (is_matrix) {
      {
      _1__loading_error_next = 7U;
      }
    } else {
      {
      _1__loading_error_next = 2U;
      }
    }
    break;
    case 7: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error: substitution matrix : %s\n"),
            err_msg);
    {
    _1__loading_error_next = 1U;
    }
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error: substitution pairs : %s\n"),
            err_msg);
    {
    _1__loading_error_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF _loading_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF parse_entire_uint LOC=UNKNOWN */
char parse_entire_uint(char *str , unsigned int *result___0 ) 
{ 
  size_t___0 len ;
  size_t___0 tmp ;
  char *strtol_last_char_ptr ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int _1_parse_entire_uint_next ;

  {
  {
  _1_parse_entire_uint_next = 6U;
  }
  while (1) {
    switch (_1_parse_entire_uint_next) {
    case 4: ;
    return ((char)1);
    break;
    case 1: ;
    if ((unsigned long )strtol_last_char_ptr != (unsigned long )(str + len)) {
      {
      _1_parse_entire_uint_next = 3U;
      }
    } else {
      {
      _1_parse_entire_uint_next = 0U;
      }
    }
    break;
    case 3: ;
    return ((char)0);
    break;
    case 6: 
    tmp = strlen((char const   *)str);
    len = tmp;
    strtol_last_char_ptr = str;
    tmp___1 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& strtol_last_char_ptr),
                      10);
    tmp___0 = tmp___1;
    {
    _1_parse_entire_uint_next = 5U;
    }
    break;
    case 5: ;
    if (tmp___0 > 4294967295UL) {
      {
      _1_parse_entire_uint_next = 7U;
      }
    } else {
      {
      _1_parse_entire_uint_next = 1U;
      }
    }
    break;
    case 0: 
    *result___0 = (unsigned int )tmp___0;
    {
    _1_parse_entire_uint_next = 4U;
    }
    break;
    case 7: ;
    return ((char)0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF parse_entire_uint LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF smith_waterman_fetch LOC=UNKNOWN */
int smith_waterman_fetch(sw_aligner_t *sw___0 , alignment_t *result___0 ) 
{ 
  sw_history_t *hist ;
  size_t___0 arr_index ;
  size_t___0 tmp ;
  char tmp___0 ;
  unsigned int _1_smith_waterman_fetch_next ;

  {
  {
  _1_smith_waterman_fetch_next = 5U;
  }
  while (1) {
    switch (_1_smith_waterman_fetch_next) {
    case 4: ;
    if (! ((*(hist->match_scores_mask.b + (arr_index >> 5)) >> (arr_index & 31UL)) & 1U)) {
      {
      _1_smith_waterman_fetch_next = 9U;
      }
    } else {
      {
      _1_smith_waterman_fetch_next = 1U;
      }
    }
    break;
    case 8: ;
    if (tmp___0) {
      {
      _1_smith_waterman_fetch_next = 0U;
      }
    } else {
      {
      _1_smith_waterman_fetch_next = 1U;
      }
    }
    break;
    case 1: ;
    if (hist->next_hit < hist->num_of_hits) {
      {
      _1_smith_waterman_fetch_next = 2U;
      }
    } else {
      {
      _1_smith_waterman_fetch_next = 6U;
      }
    }
    break;
    case 9: 
    tmp___0 = _follow_hit(sw___0, arr_index, result___0);
    {
    _1_smith_waterman_fetch_next = 8U;
    }
    break;
    case 6: ;
    return (0);
    break;
    case 5: 
    hist = & sw___0->history;
    {
    _1_smith_waterman_fetch_next = 1U;
    }
    break;
    case 0: ;
    return (1);
    break;
    case 2: 
    tmp = hist->next_hit;
    (hist->next_hit) ++;
    arr_index = *(hist->sorted_match_indices + tmp);
    {
    _1_smith_waterman_fetch_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF smith_waterman_fetch LOC=UNKNOWN */
