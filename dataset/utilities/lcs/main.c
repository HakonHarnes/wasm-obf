/* Generated by CIL v. %%VERSION_NUM%% */
/* print_CIL_Input is true */

#line 139 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned long size_t;
#line 46 "/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h"
typedef unsigned long size_t___0;
#line 210 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int uint32_t;
#line 398
struct _IO_FILE ;
#line 398 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef struct _IO_FILE FILE;
#line 16 "src/alignment_scoring.h"
typedef int score_t;
#line 19 "src/alignment_scoring.h"
struct __anonstruct_scoring_t_699705047 {
   int gap_open ;
   int gap_extend ;
   _Bool no_start_gap_penalty ;
   _Bool no_end_gap_penalty ;
   _Bool no_gaps_in_a ;
   _Bool no_gaps_in_b ;
   _Bool no_mismatches ;
   _Bool use_match_mismatch ;
   int match ;
   int mismatch ;
   _Bool case_sensitive ;
   uint32_t wildcards[8] ;
   uint32_t swap_set[256][8] ;
   score_t wildscores[256] ;
   score_t swap_scores[256][256] ;
   int min_penalty ;
   int max_penalty ;
};
#line 19 "src/alignment_scoring.h"
typedef struct __anonstruct_scoring_t_699705047 scoring_t;
#line 23 "src/alignment.h"
struct __anonstruct_aligner_t_94193678 {
   scoring_t const   *scoring ;
   char const   *seq_a ;
   char const   *seq_b ;
   size_t___0 score_width ;
   size_t___0 score_height ;
   score_t *match_scores ;
   score_t *gap_a_scores ;
   score_t *gap_b_scores ;
   size_t___0 capacity ;
};
#line 23 "src/alignment.h"
typedef struct __anonstruct_aligner_t_94193678 aligner_t;
#line 33 "src/alignment.h"
struct __anonstruct_alignment_t_970931537 {
   char *result_a ;
   char *result_b ;
   size_t___0 capacity ;
   size_t___0 length ;
   size_t___0 pos_a ;
   size_t___0 pos_b ;
   size_t___0 len_a ;
   size_t___0 len_b ;
   score_t score ;
};
#line 33 "src/alignment.h"
typedef struct __anonstruct_alignment_t_970931537 alignment_t;
#line 43
enum Matrix {
    MATCH = 0,
    GAP_A = 1,
    GAP_B = 2
} ;
#line 18 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef __builtin_va_list __isoc_va_list;
#line 241 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long off_t;
#line 22 "/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stdarg.h"
typedef __builtin_va_list va_list___0;
#line 410 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zconf.h"
typedef void *voidp;
#line 1302 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
struct gzFile_s ;
#line 1302 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1834 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
#line 67 "libs/seq_file/stream_buffer.h"
struct __anonstruct_StreamBuffer_653462436 {
   char *b ;
   size_t___0 begin ;
   size_t___0 end ;
   size_t___0 size ;
};
#line 67 "libs/seq_file/stream_buffer.h"
typedef struct __anonstruct_StreamBuffer_653462436 StreamBuffer;
#line 34 "libs/seq_file/seq_file.h"
enum __anonenum_seq_format_498167330 {
    SEQ_FMT_UNKNOWN = 0,
    SEQ_FMT_PLAIN = 1,
    SEQ_FMT_FASTA = 2,
    SEQ_FMT_FASTQ = 4,
    SEQ_FMT_SAM = 8,
    SEQ_FMT_BAM = 16,
    SEQ_FMT_CRAM = 16
} ;
#line 34 "libs/seq_file/seq_file.h"
typedef enum __anonenum_seq_format_498167330 seq_format;
#line 41
struct seq_file_struct ;
#line 41 "libs/seq_file/seq_file.h"
typedef struct seq_file_struct seq_file_t;
#line 42
struct read_struct ;
#line 42 "libs/seq_file/seq_file.h"
typedef struct read_struct read_t;
#line 44 "libs/seq_file/seq_file.h"
struct seq_file_struct {
   char *path ;
   FILE *f_file ;
   gzFile gz_file ;
   void *hts_file ;
   void *bam_hdr ;
   int (*readfunc)(seq_file_t *sf , read_t *r ) ;
   StreamBuffer in ;
   seq_format format ;
   read_t *rhead ;
   read_t *rtail ;
   int (*origreadfunc)(seq_file_t *sf , read_t *r ) ;
};
#line 61 "libs/seq_file/seq_file.h"
struct __anonstruct_seq_buf_t_653462437 {
   char *b ;
   size_t___0 end ;
   size_t___0 size ;
};
#line 61 "libs/seq_file/seq_file.h"
typedef struct __anonstruct_seq_buf_t_653462437 seq_buf_t;
#line 66 "libs/seq_file/seq_file.h"
struct read_struct {
   seq_buf_t name ;
   seq_buf_t seq ;
   seq_buf_t qual ;
   void *bam ;
   read_t *next ;
   _Bool from_sam ;
};
#line 21 "src/alignment_cmdline.h"
enum SeqAlignCmdType {
    SEQ_ALIGN_SW_CMD = 0,
    SEQ_ALIGN_NW_CMD = 1,
    SEQ_ALIGN_LCS_CMD = 2
} ;
#line 23 "src/alignment_cmdline.h"
struct __anonstruct_cmdline_t_751155579 {
   size_t___0 file_list_length ;
   size_t___0 file_list_capacity ;
   char **file_paths1 ;
   char **file_paths2 ;
   _Bool case_sensitive ;
   int match ;
   int mismatch ;
   int gap_open ;
   int gap_extend ;
   score_t min_score ;
   unsigned int print_context ;
   unsigned int max_hits_per_alignment ;
   _Bool min_score_set ;
   _Bool max_hits_per_alignment_set ;
   _Bool print_seq ;
   _Bool freestartgap_set ;
   _Bool freeendgap_set ;
   _Bool print_matrices ;
   _Bool print_scores ;
   _Bool zam_stle_output ;
   _Bool interactive ;
   _Bool print_fasta ;
   _Bool print_pretty ;
   _Bool print_colour ;
   _Bool no_gaps_in1 ;
   _Bool no_gaps_in2 ;
   _Bool no_mismatches ;
   char const   *seq1 ;
   char const   *seq2 ;
};
#line 23 "src/alignment_cmdline.h"
typedef struct __anonstruct_cmdline_t_751155579 cmdline_t;
#line 20 "libs/string_buffer/string_buffer.h"
struct __anonstruct_StrBuf_483684869 {
   char *b ;
   size_t___0 end ;
   size_t___0 size ;
};
#line 20 "libs/string_buffer/string_buffer.h"
typedef struct __anonstruct_StrBuf_483684869 StrBuf;
#line 16 "src/needleman_wunsch.h"
typedef aligner_t nw_aligner_t;
#line 15 "src/smith_waterman.h"
struct sw_aligner_t ;
#line 15 "src/smith_waterman.h"
typedef struct sw_aligner_t sw_aligner_t;
#line 21 "src/smith_waterman.c"
struct __anonstruct_BitSet_909456816 {
   uint32_t *b ;
   size_t___0 l ;
   size_t___0 s ;
};
#line 21 "src/smith_waterman.c"
typedef struct __anonstruct_BitSet_909456816 BitSet;
#line 49 "src/smith_waterman.c"
struct __anonstruct_sw_history_t_920808153 {
   BitSet match_scores_mask ;
   size_t___0 *sorted_match_indices ;
   size_t___0 hits_capacity ;
   size_t___0 num_of_hits ;
   size_t___0 next_hit ;
};
#line 49 "src/smith_waterman.c"
typedef struct __anonstruct_sw_history_t_920808153 sw_history_t;
#line 56 "src/smith_waterman.c"
struct sw_aligner_t {
   aligner_t aligner ;
   sw_history_t history ;
};
#line 64 "src/smith_waterman.c"
struct __anonstruct_MatrixSort_459211137 {
   score_t *match_scores ;
   unsigned int score_width ;
};
#line 64 "src/smith_waterman.c"
typedef struct __anonstruct_MatrixSort_459211137 MatrixSort;
#line 1 "cil-GUuUgZV4.o"
#pragma merger("0","/tmp/cil-v7IuWieZ.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 40 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern void *malloc(size_t  ) ;
#line 42
extern void *realloc(void * , size_t  ) ;
#line 43
extern void free(void * ) ;
#line 48
extern void exit(int  )  __attribute__((__noreturn__)) ;
#line 60
extern int abs(int  ) ;
#line 73 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern FILE *stdout ;
#line 74
extern FILE *stderr ;
#line 108
extern int putc(int  , FILE * ) ;
#line 116
extern int fputs(char const   * , FILE * ) ;
#line 119
extern int printf(char const   *  , ...) ;
#line 120
extern int fprintf(FILE * , char const   *  , ...) ;
#line 22 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h"
extern int tolower(int  ) ;
#line 72 "src/alignment_scoring.h"
void scoring_lookup(scoring_t const   *scoring , char a , char b , int *score , _Bool *is_match ) ;
#line 16 "src/alignment.h"
__inline static size_t___0 _rndup2pow64(unsigned long long x ) 
{ 


  {
#line 18
  x --;
#line 18
  x |= x >> 1;
#line 18
  x |= x >> 2;
#line 18
  x |= x >> 4;
#line 18
  x |= x >> 8;
#line 18
  x |= x >> 16;
#line 18
  x |= x >> 32;
#line 18
  x ++;
#line 19
  return ((size_t___0 )x);
}
}
#line 52
char const   align_col_mismatch[6] ;
#line 52
char const   align_col_indel[6] ;
#line 52
char const   align_col_context[6] ;
#line 53
char const   align_col_stop[5] ;
#line 56
void aligner_align(aligner_t *aligner , char const   *seq_a , char const   *seq_b ,
                   size_t___0 len_a , size_t___0 len_b , scoring_t const   *scoring ,
                   char is_sw ) ;
#line 60
void aligner_destroy(aligner_t *aligner ) ;
#line 63
alignment_t *alignment_create(size_t___0 capacity ) ;
#line 64
void alignment_ensure_capacity(alignment_t *result , size_t___0 strlength ) ;
#line 65
void alignment_free(alignment_t *result ) ;
#line 67
void alignment_reverse_move(enum Matrix *curr_matrix , score_t *curr_score , size_t___0 *score_x ,
                            size_t___0 *score_y , size_t___0 *arr_index , aligner_t const   *aligner ) ;
#line 72
void alignment_print_matrices(aligner_t const   *aligner ) ;
#line 74
void alignment_colour_print_against(char const   *alignment_a , char const   *alignment_b ,
                                    char case_sensitive ) ;
#line 78
void alignment_print_spacer(char const   *alignment_a , char const   *alignment_b ,
                            scoring_t const   *scoring ) ;
#line 21 "src/alignment.c"
char const   align_col_mismatch[6]  = {      (char const   )'\033',      (char const   )'[',      (char const   )'9',      (char const   )'2', 
        (char const   )'m',      (char const   )'\000'};
#line 22 "src/alignment.c"
char const   align_col_indel[6]  = {      (char const   )'\033',      (char const   )'[',      (char const   )'9',      (char const   )'1', 
        (char const   )'m',      (char const   )'\000'};
#line 24 "src/alignment.c"
char const   align_col_context[6]  = {      (char const   )'\033',      (char const   )'[',      (char const   )'9',      (char const   )'5', 
        (char const   )'m',      (char const   )'\000'};
#line 25 "src/alignment.c"
char const   align_col_stop[5]  = {      (char const   )'\033',      (char const   )'[',      (char const   )'0',      (char const   )'m', 
        (char const   )'\000'};
#line 28 "src/alignment.c"
static void alignment_fill_matrices(aligner_t *aligner , char is_sw ) 
{ 
  score_t *match_scores ;
  score_t *gap_a_scores ;
  score_t *gap_b_scores ;
  scoring_t const   *scoring ;
  size_t___0 score_width ;
  size_t___0 score_height ;
  size_t___0 i ;
  size_t___0 j ;
  int gap_open_penalty ;
  int gap_extend_penalty ;
  score_t min ;
  int tmp ;
  int tmp___0 ;
  size_t___0 seq_i ;
  size_t___0 seq_j ;
  size_t___0 len_i ;
  size_t___0 len_j ;
  size_t___0 index___0 ;
  size_t___0 index_left ;
  size_t___0 index_up ;
  size_t___0 index_upleft ;
  score_t tmp___1 ;
  score_t tmp___2 ;
  score_t tmp___3 ;
  score_t tmp___4 ;
  _Bool is_match ;
  int substitution_penalty ;
  score_t tmp___7 ;
  score_t tmp___8 ;
  score_t tmp___9 ;
  score_t tmp___10 ;
  score_t tmp___11 ;
  score_t tmp___14 ;
  score_t tmp___15 ;
  score_t tmp___16 ;
  score_t tmp___17 ;
  score_t tmp___18 ;
  score_t tmp___21 ;
  score_t tmp___22 ;
  score_t tmp___23 ;
  score_t tmp___24 ;

  {
#line 30
  match_scores = aligner->match_scores;
#line 31
  gap_a_scores = aligner->gap_a_scores;
#line 32
  gap_b_scores = aligner->gap_b_scores;
#line 33
  scoring = aligner->scoring;
#line 34
  score_width = aligner->score_width;
#line 35
  score_height = aligner->score_height;
#line 38
  gap_open_penalty = (int )(scoring->gap_extend + scoring->gap_open);
#line 39
  gap_extend_penalty = (int )scoring->gap_extend;
#line 41
  if (is_sw) {
#line 41
    tmp___0 = 0;
  } else {
#line 41
    tmp = abs((int )scoring->min_penalty);
#line 41
    tmp___0 = (-0x7FFFFFFF-1) + tmp;
  }
#line 41
  min = (score_t )tmp___0;
#line 43
  len_i = score_width - 1UL;
#line 43
  len_j = score_height - 1UL;
#line 47
  *(match_scores + 0) = 0;
#line 48
  *(gap_a_scores + 0) = 0;
#line 49
  *(gap_b_scores + 0) = 0;
#line 51
  if (is_sw) {
#line 53
    i = (size_t___0 )1;
#line 53
    while (i < score_width) {
#line 54
      tmp___2 = 0;
#line 54
      *(gap_b_scores + i) = tmp___2;
#line 54
      tmp___1 = tmp___2;
#line 54
      *(gap_a_scores + i) = tmp___1;
#line 54
      *(match_scores + i) = tmp___1;
#line 53
      i ++;
    }
#line 55
    j = (size_t___0 )1;
#line 55
    index___0 = score_width;
#line 55
    while (j < score_height) {
#line 56
      tmp___4 = (score_t )min;
#line 56
      *(gap_b_scores + index___0) = tmp___4;
#line 56
      tmp___3 = tmp___4;
#line 56
      *(gap_a_scores + index___0) = tmp___3;
#line 56
      *(match_scores + index___0) = tmp___3;
#line 55
      j ++;
#line 55
      index___0 += score_width;
    }
  } else {
#line 61
    i = (size_t___0 )1;
#line 61
    while (i < score_width) {
#line 63
      *(match_scores + i) = (score_t )min;
#line 66
      *(gap_a_scores + i) = (score_t )min;
#line 67
      if (scoring->no_start_gap_penalty) {
#line 67
        *(gap_b_scores + i) = 0;
      } else {
#line 67
        *(gap_b_scores + i) = (score_t )(scoring->gap_open + (int )((int )i * (int )scoring->gap_extend));
      }
#line 61
      i ++;
    }
#line 72
    j = (size_t___0 )1;
#line 72
    index___0 = score_width;
#line 72
    while (j < score_height) {
#line 74
      *(match_scores + index___0) = (score_t )min;
#line 77
      if (scoring->no_start_gap_penalty) {
#line 77
        *(gap_a_scores + index___0) = 0;
      } else {
#line 77
        *(gap_a_scores + index___0) = (score_t )(scoring->gap_open + (int )((int )j * (int )scoring->gap_extend));
      }
#line 79
      *(gap_b_scores + index___0) = (score_t )min;
#line 72
      j ++;
#line 72
      index___0 += score_width;
    }
  }
#line 84
  index_upleft = (size_t___0 )0;
#line 85
  index_up = (size_t___0 )1;
#line 86
  index_left = score_width;
#line 87
  index___0 = score_width + 1UL;
#line 89
  seq_j = (size_t___0 )0;
#line 89
  while (seq_j < len_j) {
#line 91
    seq_i = (size_t___0 )0;
#line 91
    while (seq_i < len_i) {
#line 98
      scoring_lookup(scoring, (char )*(aligner->seq_a + seq_i), (char )*(aligner->seq_b + seq_j),
                     & substitution_penalty, & is_match);
#line 101
      if (scoring->no_mismatches) {
#line 101
        if (! is_match) {
#line 103
          *(match_scores + index___0) = (score_t )min;
        } else {
#line 101
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 111
        if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_a_scores + index_upleft) + substitution_penalty) {
#line 111
          if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
#line 111
            tmp___10 = *(match_scores + index_upleft) + substitution_penalty;
          } else {
#line 111
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 111
          if (*(gap_a_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
#line 111
            tmp___9 = *(gap_a_scores + index_upleft) + substitution_penalty;
          } else {
#line 111
            tmp___9 = *(gap_b_scores + index_upleft) + substitution_penalty;
          }
#line 111
          tmp___10 = tmp___9;
        }
#line 111
        if (tmp___10 >= (score_t )min) {
#line 111
          if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_a_scores + index_upleft) + substitution_penalty) {
#line 111
            if (*(match_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
#line 111
              tmp___8 = *(match_scores + index_upleft) + substitution_penalty;
            } else {
#line 111
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 111
            if (*(gap_a_scores + index_upleft) + substitution_penalty >= *(gap_b_scores + index_upleft) + substitution_penalty) {
#line 111
              tmp___7 = *(gap_a_scores + index_upleft) + substitution_penalty;
            } else {
#line 111
              tmp___7 = *(gap_b_scores + index_upleft) + substitution_penalty;
            }
#line 111
            tmp___8 = tmp___7;
          }
#line 111
          *(match_scores + index___0) = tmp___8;
        } else {
#line 111
          *(match_scores + index___0) = (score_t )min;
        }
      }
#line 122
      if (seq_i == len_i - 1UL) {
#line 122
        if (scoring->no_end_gap_penalty) {
#line 124
          if (*(match_scores + index_up) >= *(gap_a_scores + index_up)) {
#line 124
            if (*(match_scores + index_up) >= *(gap_b_scores + index_up)) {
#line 124
              *(gap_a_scores + index___0) = *(match_scores + index_up);
            } else {
#line 124
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ 
#line 124
            if (*(gap_a_scores + index_up) >= *(gap_b_scores + index_up)) {
#line 124
              tmp___11 = *(gap_a_scores + index_up);
            } else {
#line 124
              tmp___11 = *(gap_b_scores + index_up);
            }
#line 124
            *(gap_a_scores + index___0) = tmp___11;
          }
        } else {
#line 122
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 128
      if (! scoring->no_gaps_in_a) {
#line 128
        goto _L___7;
      } else
#line 128
      if (seq_i == len_i - 1UL) {
        _L___7: /* CIL Label */ 
#line 130
        if (*(match_scores + index_up) + gap_open_penalty >= *(gap_a_scores + index_up) + gap_extend_penalty) {
#line 130
          if (*(match_scores + index_up) + gap_open_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
#line 130
            tmp___17 = *(match_scores + index_up) + gap_open_penalty;
          } else {
#line 130
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ 
#line 130
          if (*(gap_a_scores + index_up) + gap_extend_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
#line 130
            tmp___16 = *(gap_a_scores + index_up) + gap_extend_penalty;
          } else {
#line 130
            tmp___16 = *(gap_b_scores + index_up) + gap_open_penalty;
          }
#line 130
          tmp___17 = tmp___16;
        }
#line 130
        if (tmp___17 >= (score_t )min) {
#line 130
          if (*(match_scores + index_up) + gap_open_penalty >= *(gap_a_scores + index_up) + gap_extend_penalty) {
#line 130
            if (*(match_scores + index_up) + gap_open_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
#line 130
              tmp___15 = *(match_scores + index_up) + gap_open_penalty;
            } else {
#line 130
              goto _L___5;
            }
          } else {
            _L___5: /* CIL Label */ 
#line 130
            if (*(gap_a_scores + index_up) + gap_extend_penalty >= *(gap_b_scores + index_up) + gap_open_penalty) {
#line 130
              tmp___14 = *(gap_a_scores + index_up) + gap_extend_penalty;
            } else {
#line 130
              tmp___14 = *(gap_b_scores + index_up) + gap_open_penalty;
            }
#line 130
            tmp___15 = tmp___14;
          }
#line 130
          *(gap_a_scores + index___0) = tmp___15;
        } else {
#line 130
          *(gap_a_scores + index___0) = (score_t )min;
        }
      } else {
#line 137
        *(gap_a_scores + index___0) = (score_t )min;
      }
#line 140
      if (seq_j == len_j - 1UL) {
#line 140
        if (scoring->no_end_gap_penalty) {
#line 142
          if (*(match_scores + index_left) >= *(gap_a_scores + index_left)) {
#line 142
            if (*(match_scores + index_left) >= *(gap_b_scores + index_left)) {
#line 142
              *(gap_b_scores + index___0) = *(match_scores + index_left);
            } else {
#line 142
              goto _L___9;
            }
          } else {
            _L___9: /* CIL Label */ 
#line 142
            if (*(gap_a_scores + index_left) >= *(gap_b_scores + index_left)) {
#line 142
              tmp___18 = *(gap_a_scores + index_left);
            } else {
#line 142
              tmp___18 = *(gap_b_scores + index_left);
            }
#line 142
            *(gap_b_scores + index___0) = tmp___18;
          }
        } else {
#line 140
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 146
      if (! scoring->no_gaps_in_b) {
#line 146
        goto _L___13;
      } else
#line 146
      if (seq_j == len_j - 1UL) {
        _L___13: /* CIL Label */ 
#line 148
        if (*(match_scores + index_left) + gap_open_penalty >= *(gap_a_scores + index_left) + gap_open_penalty) {
#line 148
          if (*(match_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
#line 148
            tmp___24 = *(match_scores + index_left) + gap_open_penalty;
          } else {
#line 148
            goto _L___12;
          }
        } else {
          _L___12: /* CIL Label */ 
#line 148
          if (*(gap_a_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
#line 148
            tmp___23 = *(gap_a_scores + index_left) + gap_open_penalty;
          } else {
#line 148
            tmp___23 = *(gap_b_scores + index_left) + gap_extend_penalty;
          }
#line 148
          tmp___24 = tmp___23;
        }
#line 148
        if (tmp___24 >= (score_t )min) {
#line 148
          if (*(match_scores + index_left) + gap_open_penalty >= *(gap_a_scores + index_left) + gap_open_penalty) {
#line 148
            if (*(match_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
#line 148
              tmp___22 = *(match_scores + index_left) + gap_open_penalty;
            } else {
#line 148
              goto _L___11;
            }
          } else {
            _L___11: /* CIL Label */ 
#line 148
            if (*(gap_a_scores + index_left) + gap_open_penalty >= *(gap_b_scores + index_left) + gap_extend_penalty) {
#line 148
              tmp___21 = *(gap_a_scores + index_left) + gap_open_penalty;
            } else {
#line 148
              tmp___21 = *(gap_b_scores + index_left) + gap_extend_penalty;
            }
#line 148
            tmp___22 = tmp___21;
          }
#line 148
          *(gap_b_scores + index___0) = tmp___22;
        } else {
#line 148
          *(gap_b_scores + index___0) = (score_t )min;
        }
      } else {
#line 155
        *(gap_b_scores + index___0) = (score_t )min;
      }
#line 157
      index___0 ++;
#line 158
      index_left ++;
#line 159
      index_up ++;
#line 160
      index_upleft ++;
#line 91
      seq_i ++;
    }
#line 163
    index___0 ++;
#line 164
    index_left ++;
#line 165
    index_up ++;
#line 166
    index_upleft ++;
#line 89
    seq_j ++;
  }
#line 168
  return;
}
}
#line 170 "src/alignment.c"
void aligner_align(aligner_t *aligner , char const   *seq_a , char const   *seq_b ,
                   size_t___0 len_a , size_t___0 len_b , scoring_t const   *scoring ,
                   char is_sw ) 
{ 
  size_t___0 new_capacity ;
  size_t___0 mem ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 175
  aligner->scoring = scoring;
#line 176
  aligner->seq_a = seq_a;
#line 177
  aligner->seq_b = seq_b;
#line 178
  aligner->score_width = len_a + 1UL;
#line 179
  aligner->score_height = len_b + 1UL;
#line 181
  new_capacity = aligner->score_width * aligner->score_height;
#line 183
  if (aligner->capacity < new_capacity) {
#line 185
    aligner->capacity = _rndup2pow64((unsigned long long )new_capacity);
#line 186
    mem = sizeof(score_t ) * aligner->capacity;
#line 187
    tmp = realloc((void *)aligner->match_scores, mem);
#line 187
    aligner->match_scores = (score_t *)tmp;
#line 188
    tmp___0 = realloc((void *)aligner->gap_a_scores, mem);
#line 188
    aligner->gap_a_scores = (score_t *)tmp___0;
#line 189
    tmp___1 = realloc((void *)aligner->gap_b_scores, mem);
#line 189
    aligner->gap_b_scores = (score_t *)tmp___1;
  }
#line 192
  alignment_fill_matrices(aligner, is_sw);
#line 193
  return;
}
}
#line 195 "src/alignment.c"
void aligner_destroy(aligner_t *aligner ) 
{ 


  {
#line 197
  if (aligner->capacity > 0UL) {
#line 198
    free((void *)aligner->match_scores);
#line 199
    free((void *)aligner->gap_a_scores);
#line 200
    free((void *)aligner->gap_b_scores);
  }
#line 202
  return;
}
}
#line 205 "src/alignment.c"
alignment_t *alignment_create(size_t___0 capacity ) 
{ 
  alignment_t *result ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char tmp___2 ;
  size_t___0 tmp___3 ;
  size_t___0 tmp___4 ;
  size_t___0 tmp___5 ;

  {
#line 207
  capacity = _rndup2pow64((unsigned long long )capacity);
#line 208
  tmp = malloc(sizeof(alignment_t ));
#line 208
  result = (alignment_t *)tmp;
#line 209
  tmp___0 = malloc(sizeof(char ) * capacity);
#line 209
  result->result_a = (char *)tmp___0;
#line 210
  tmp___1 = malloc(sizeof(char ) * capacity);
#line 210
  result->result_b = (char *)tmp___1;
#line 211
  result->capacity = capacity;
#line 212
  result->length = (size_t___0 )0;
#line 213
  tmp___2 = (char )'\000';
#line 213
  *(result->result_b + 0) = tmp___2;
#line 213
  *(result->result_a + 0) = tmp___2;
#line 214
  tmp___5 = (size_t___0 )0;
#line 214
  result->len_b = tmp___5;
#line 214
  tmp___4 = tmp___5;
#line 214
  result->len_a = tmp___4;
#line 214
  tmp___3 = tmp___4;
#line 214
  result->pos_b = tmp___3;
#line 214
  result->pos_a = tmp___3;
#line 215
  result->score = 0;
#line 216
  return (result);
}
}
#line 219 "src/alignment.c"
void alignment_ensure_capacity(alignment_t *result , size_t___0 strlength ) 
{ 
  size_t___0 capacity ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 221
  capacity = strlength + 1UL;
#line 222
  if (result->capacity < capacity) {
#line 224
    capacity = _rndup2pow64((unsigned long long )capacity);
#line 225
    tmp = realloc((void *)result->result_a, sizeof(char ) * capacity);
#line 225
    result->result_a = (char *)tmp;
#line 226
    tmp___0 = realloc((void *)result->result_b, sizeof(char ) * capacity);
#line 226
    result->result_b = (char *)tmp___0;
#line 227
    result->capacity = capacity;
#line 228
    if ((unsigned long )result->result_a == (unsigned long )((void *)0)) {
#line 229
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: Out of memory\n",
              "src/alignment.c", 229);
#line 230
      exit(1);
    } else
#line 228
    if ((unsigned long )result->result_b == (unsigned long )((void *)0)) {
#line 229
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: Out of memory\n",
              "src/alignment.c", 229);
#line 230
      exit(1);
    }
  }
#line 233
  return;
}
}
#line 235 "src/alignment.c"
void alignment_free(alignment_t *result ) 
{ 


  {
#line 237
  free((void *)result->result_a);
#line 238
  free((void *)result->result_b);
#line 239
  free((void *)result);
#line 240
  return;
}
}
#line 244 "src/alignment.c"
void alignment_reverse_move(enum Matrix *curr_matrix , score_t *curr_score , size_t___0 *score_x ,
                            size_t___0 *score_y , size_t___0 *arr_index , aligner_t const   *aligner ) 
{ 
  size_t___0 seq_x ;
  size_t___0 seq_y ;
  size_t___0 len_i ;
  size_t___0 len_j ;
  _Bool is_match ;
  int match_penalty ;
  scoring_t const   *scoring ;
  int gap_a_open_penalty ;
  int gap_b_open_penalty ;
  int gap_a_extend_penalty ;
  int gap_b_extend_penalty ;
  int prev_match_penalty ;
  int prev_gap_a_penalty ;
  int prev_gap_b_penalty ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 248
  seq_x = *score_x - 1UL;
#line 248
  seq_y = *score_y - 1UL;
#line 249
  len_i = (size_t___0 )(aligner->score_width - 1UL);
#line 249
  len_j = (size_t___0 )(aligner->score_height - 1UL);
#line 253
  scoring = (scoring_t const   *)aligner->scoring;
#line 255
  scoring_lookup(scoring, (char )*(aligner->seq_a + seq_x), (char )*(aligner->seq_b + seq_y),
                 & match_penalty, & is_match);
#line 261
  gap_b_open_penalty = (int )(scoring->gap_extend + scoring->gap_open);
#line 261
  gap_a_open_penalty = gap_b_open_penalty;
#line 262
  gap_b_extend_penalty = (int )scoring->gap_extend;
#line 262
  gap_a_extend_penalty = gap_b_extend_penalty;
#line 265
  if (scoring->no_end_gap_penalty) {
#line 266
    if (*score_x == len_i) {
#line 266
      gap_a_extend_penalty = 0;
#line 266
      gap_a_open_penalty = gap_a_extend_penalty;
    }
#line 267
    if (*score_y == len_j) {
#line 267
      gap_b_extend_penalty = 0;
#line 267
      gap_b_open_penalty = gap_b_extend_penalty;
    }
  }
#line 269
  if (scoring->no_start_gap_penalty) {
#line 270
    if (*score_x == 0UL) {
#line 270
      gap_a_extend_penalty = 0;
#line 270
      gap_a_open_penalty = gap_a_extend_penalty;
    }
#line 271
    if (*score_y == 0UL) {
#line 271
      gap_b_extend_penalty = 0;
#line 271
      gap_b_open_penalty = gap_b_extend_penalty;
    }
  }
#line 276
  switch ((unsigned int )*curr_matrix) {
  case 0U: 
#line 279
  prev_match_penalty = match_penalty;
#line 280
  prev_gap_a_penalty = match_penalty;
#line 281
  prev_gap_b_penalty = match_penalty;
#line 282
  (*score_x) --;
#line 283
  (*score_y) --;
#line 284
  *arr_index -= (size_t___0 )(aligner->score_width + 1UL);
#line 285
  break;
  case 1U: 
#line 288
  prev_match_penalty = gap_a_open_penalty;
#line 289
  prev_gap_a_penalty = gap_a_extend_penalty;
#line 290
  prev_gap_b_penalty = gap_a_open_penalty;
#line 291
  (*score_y) --;
#line 292
  *arr_index -= (size_t___0 )aligner->score_width;
#line 293
  break;
  case 2U: 
#line 296
  prev_match_penalty = gap_b_open_penalty;
#line 297
  prev_gap_a_penalty = gap_b_open_penalty;
#line 298
  prev_gap_b_penalty = gap_b_extend_penalty;
#line 299
  (*score_x) --;
#line 300
  (*arr_index) --;
#line 301
  break;
  default: 
#line 304
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Program error: invalid matrix in get_reverse_move()\n");
#line 305
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Please submit a bug report to: turner.isaac@gmail.com\n");
#line 306
  exit(1);
  }
#line 311
  if (! scoring->no_gaps_in_a) {
#line 311
    goto _L___2;
  } else
#line 311
  if (*score_x == 0UL) {
#line 311
    goto _L___2;
  } else
#line 311
  if (*score_x == len_i) {
    _L___2: /* CIL Label */ 
#line 311
    if (*(aligner->gap_a_scores + *arr_index) + prev_gap_a_penalty == *curr_score) {
#line 314
      *curr_matrix = (enum Matrix )1;
#line 315
      *curr_score = *(aligner->gap_a_scores + *arr_index);
    } else {
#line 311
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 317
  if (! scoring->no_gaps_in_b) {
#line 317
    goto _L___0;
  } else
#line 317
  if (*score_y == 0UL) {
#line 317
    goto _L___0;
  } else
#line 317
  if (*score_y == len_j) {
    _L___0: /* CIL Label */ 
#line 317
    if (*(aligner->gap_b_scores + *arr_index) + prev_gap_b_penalty == *curr_score) {
#line 320
      *curr_matrix = (enum Matrix )2;
#line 321
      *curr_score = *(aligner->gap_b_scores + *arr_index);
    } else {
#line 317
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 323
  if (*(aligner->match_scores + *arr_index) + prev_match_penalty == *curr_score) {
#line 325
    *curr_matrix = (enum Matrix )0;
#line 326
    *curr_score = *(aligner->match_scores + *arr_index);
  } else {
#line 330
    alignment_print_matrices(aligner);
#line 332
    if ((unsigned int )*curr_matrix == 0U) {
#line 332
      tmp___0 = "MATCH";
    } else {
#line 332
      if ((unsigned int )*curr_matrix == 1U) {
#line 332
        tmp = "GAP_A";
      } else {
#line 332
        tmp = "GAP_B";
      }
#line 332
      tmp___0 = tmp;
    }
#line 332
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s:%zu,%zu]: %i [ismatch: %i] \'%c\' \'%c\'\n",
            tmp___0, *score_x, *score_y, *curr_score, (int )is_match, (int const   )*(aligner->seq_a + seq_x),
            (int const   )*(aligner->seq_b + seq_y));
#line 335
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" Penalties match: %i gap_open: %i gap_extend: %i\n",
            prev_match_penalty, prev_gap_a_penalty, prev_gap_b_penalty);
#line 337
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" Expected MATCH: %i GAP_A: %i GAP_B: %i\n",
            *(aligner->match_scores + *arr_index), *(aligner->gap_a_scores + *arr_index),
            *(aligner->gap_b_scores + *arr_index));
#line 342
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Program error: traceback fail (get_reverse_move)\nThis may be due to an integer overflow if your sequences are long or scores\nare large. If this is the case using smaller scores or shorter sequences may\nwork around this problem.  \n  If you think this is a bug, please report it to: turner.isaac@gmail.com\n");
#line 348
    exit(1);
  }
#line 350
  return;
}
}
#line 353 "src/alignment.c"
void alignment_print_matrices(aligner_t const   *aligner ) 
{ 
  score_t const   *match_scores ;
  score_t const   *gap_a_scores ;
  score_t const   *gap_b_scores ;
  size_t___0 i ;
  size_t___0 j ;

  {
#line 355
  match_scores = (score_t const   *)aligner->match_scores;
#line 356
  gap_a_scores = (score_t const   *)aligner->gap_a_scores;
#line 357
  gap_b_scores = (score_t const   *)aligner->gap_b_scores;
#line 361
  printf((char const   * __restrict  )"seq_a: %.*s\nseq_b: %.*s\n", (int )aligner->score_width - 1,
         aligner->seq_a, (int )aligner->score_height - 1, aligner->seq_b);
#line 365
  printf((char const   * __restrict  )"match_scores:\n");
#line 366
  j = (size_t___0 )0;
#line 366
  while (j < (size_t___0 )aligner->score_height) {
#line 368
    printf((char const   * __restrict  )"%3i:", (int )j);
#line 369
    i = (size_t___0 )0;
#line 369
    while (i < (size_t___0 )aligner->score_width) {
#line 371
      printf((char const   * __restrict  )"\t%3i", (int )*(match_scores + (j * (unsigned long )aligner->score_width + i)));
#line 369
      i ++;
    }
#line 373
    putc('\n', (FILE *)stdout);
#line 366
    j ++;
  }
#line 375
  printf((char const   * __restrict  )"gap_a_scores:\n");
#line 376
  j = (size_t___0 )0;
#line 376
  while (j < (size_t___0 )aligner->score_height) {
#line 378
    printf((char const   * __restrict  )"%3i:", (int )j);
#line 379
    i = (size_t___0 )0;
#line 379
    while (i < (size_t___0 )aligner->score_width) {
#line 381
      printf((char const   * __restrict  )"\t%3i", (int )*(gap_a_scores + (j * (unsigned long )aligner->score_width + i)));
#line 379
      i ++;
    }
#line 383
    putc('\n', (FILE *)stdout);
#line 376
    j ++;
  }
#line 385
  printf((char const   * __restrict  )"gap_b_scores:\n");
#line 386
  j = (size_t___0 )0;
#line 386
  while (j < (size_t___0 )aligner->score_height) {
#line 388
    printf((char const   * __restrict  )"%3i:", (int )j);
#line 389
    i = (size_t___0 )0;
#line 389
    while (i < (size_t___0 )aligner->score_width) {
#line 391
      printf((char const   * __restrict  )"\t%3i", (int )*(gap_b_scores + (j * (unsigned long )aligner->score_width + i)));
#line 389
      i ++;
    }
#line 393
    putc('\n', (FILE *)stdout);
#line 386
    j ++;
  }
#line 396
  printf((char const   * __restrict  )"match: %i mismatch: %i gapopen: %i gapexend: %i\n",
         (aligner->scoring)->match, (aligner->scoring)->mismatch, (aligner->scoring)->gap_open,
         (aligner->scoring)->gap_extend);
#line 399
  printf((char const   * __restrict  )"\n");
#line 400
  return;
}
}
#line 402 "src/alignment.c"
void alignment_colour_print_against(char const   *alignment_a , char const   *alignment_b ,
                                    char case_sensitive ) 
{ 
  int i ;
  char red ;
  char green ;
  int tmp ;
  int tmp___0 ;

  {
#line 407
  red = (char)0;
#line 407
  green = (char)0;
#line 409
  i = 0;
#line 409
  while ((int const   )*(alignment_a + i) != 0) {
#line 411
    if ((int const   )*(alignment_b + i) == 45) {
#line 413
      if (! red) {
#line 415
        fputs((char const   * __restrict  )(align_col_indel), (FILE * __restrict  )stdout);
#line 416
        red = (char)1;
      }
    } else
#line 419
    if (red) {
#line 421
      red = (char)0;
#line 422
      fputs((char const   * __restrict  )(align_col_stop), (FILE * __restrict  )stdout);
    }
#line 425
    if (case_sensitive) {
#line 425
      if ((int const   )*(alignment_a + i) != (int const   )*(alignment_b + i)) {
#line 425
        goto _L___1;
      } else {
#line 425
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 425
    if (! case_sensitive) {
#line 425
      tmp = tolower((int )*(alignment_a + i));
#line 425
      tmp___0 = tolower((int )*(alignment_b + i));
#line 425
      if (tmp != tmp___0) {
        _L___1: /* CIL Label */ 
#line 425
        if ((int const   )*(alignment_a + i) != 45) {
#line 425
          if ((int const   )*(alignment_b + i) != 45) {
#line 429
            if (! green) {
#line 431
              fputs((char const   * __restrict  )(align_col_mismatch), (FILE * __restrict  )stdout);
#line 432
              green = (char)1;
            }
          } else {
#line 425
            goto _L___2;
          }
        } else {
#line 425
          goto _L___2;
        }
      } else {
#line 425
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 435
    if (green) {
#line 437
      green = (char)0;
#line 438
      fputs((char const   * __restrict  )(align_col_stop), (FILE * __restrict  )stdout);
    }
#line 441
    putc((int )*(alignment_a + i), (FILE *)stdout);
#line 409
    i ++;
  }
#line 444
  if (green) {
#line 447
    fputs((char const   * __restrict  )(align_col_stop), (FILE * __restrict  )stdout);
  } else
#line 444
  if (red) {
#line 447
    fputs((char const   * __restrict  )(align_col_stop), (FILE * __restrict  )stdout);
  }
#line 449
  return;
}
}
#line 452 "src/alignment.c"
void alignment_print_spacer(char const   *alignment_a , char const   *alignment_b ,
                            scoring_t const   *scoring ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 457
  i = 0;
#line 457
  while ((int const   )*(alignment_a + i) != 0) {
#line 459
    if ((int const   )*(alignment_a + i) == 45) {
#line 461
      putc(' ', (FILE *)stdout);
    } else
#line 459
    if ((int const   )*(alignment_b + i) == 45) {
#line 461
      putc(' ', (FILE *)stdout);
    } else
#line 463
    if ((int const   )*(alignment_a + i) == (int const   )*(alignment_b + i)) {
#line 467
      putc('|', (FILE *)stdout);
    } else
#line 463
    if (! scoring->case_sensitive) {
#line 463
      tmp = tolower((int )*(alignment_a + i));
#line 463
      tmp___0 = tolower((int )*(alignment_b + i));
#line 463
      if (tmp == tmp___0) {
#line 467
        putc('|', (FILE *)stdout);
      } else {
#line 471
        putc('*', (FILE *)stdout);
      }
    } else {
#line 471
      putc('*', (FILE *)stdout);
    }
#line 457
    i ++;
  }
#line 474
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
#line 1 "cil-IbyNHiEb.o"
#pragma merger("0","/tmp/cil-S2g30jNo.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 32 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern long strtol(char const   * , char ** , int  ) ;
#line 33
extern unsigned long strtoul(char const   * __restrict   , char ** __restrict   ,
                             int  ) ;
#line 41
extern void *calloc(size_t  , size_t  ) ;
#line 72 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern FILE *stdin ;
#line 80
extern FILE *fopen(char const   * __restrict   , char const   * __restrict   ) ;
#line 82
extern int fclose(FILE * ) ;
#line 89
extern int fflush(FILE * ) ;
#line 99
extern size_t___0 fread(void * __restrict   , size_t___0  , size_t___0  , FILE * __restrict   ) ;
#line 102
extern int fgetc(FILE * ) ;
#line 105
extern int ungetc(int  , FILE * ) ;
#line 111
extern char *fgets(char * __restrict   , int  , FILE * __restrict   ) ;
#line 125
extern int vfprintf(FILE * __restrict   , char const   * __restrict   , __isoc_va_list  ) ;
#line 149
extern FILE *fdopen(int  , char const   * ) ;
#line 152
extern int fileno(FILE * ) ;
#line 27 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
#line 29
extern void *memset(void * , int  , size_t___0  ) ;
#line 39
extern int strcmp(char const   * , char const   * ) ;
#line 54
extern size_t___0 strlen(char const   * ) ;
#line 29 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h"
extern int strcasecmp(char const   * , char const   * ) ;
#line 70 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern char *strdup(char const   * ) ;
#line 19 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h"
extern int isspace(int  ) ;
#line 1342 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1392
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1491
extern char *gzgets(gzFile file , char *buf , int len ) ;
#line 1511
extern int gzgetc(gzFile file ) ;
#line 1520
extern int gzungetc(int c , gzFile file ) ;
#line 1631
extern int gzclose(gzFile file ) ;
#line 1893
extern gzFile gzopen(char const   * , char const   * ) ;
#line 19 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/assert.h"
extern void __assert_fail(char const   * , char const   * , int  , char const   * )  __attribute__((__noreturn__)) ;
#line 27 "libs/seq_file/stream_buffer.h"
__inline static void cbuf_capacity(char **buf , size_t___0 *sizeptr , size_t___0 len ) 
{ 
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 29
  len ++;
#line 30
  if (*sizeptr < len) {
#line 31
    tmp = __builtin_clzl(len);
#line 31
    *sizeptr = 0x1UL << (64 - tmp);
#line 32
    tmp___1 = realloc((void *)*buf, *sizeptr);
#line 32
    tmp___0 = (char *)tmp___1;
#line 32
    *buf = tmp___0;
#line 32
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 33
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Out of memory\n");
#line 34
      exit(1);
    }
  }
#line 37
  return;
}
}
#line 39 "libs/seq_file/stream_buffer.h"
__inline static void cbuf_append_char(char **buf , size_t___0 *lenptr , size_t___0 *sizeptr ,
                                      char c ) 
{ 
  size_t___0 tmp ;

  {
#line 42
  cbuf_capacity(buf, sizeptr, *lenptr + 1UL);
#line 43
  tmp = *lenptr;
#line 43
  (*lenptr) ++;
#line 43
  *(*buf + tmp) = c;
#line 44
  *(*buf + *lenptr) = (char )'\000';
#line 45
  return;
}
}
#line 56 "libs/seq_file/stream_buffer.h"
__inline static void cbuf_chomp(char *buf , size_t___0 *lenptr ) 
{ 


  {
#line 58
  while (1) {
#line 58
    if (*lenptr) {
#line 58
      if (! ((int )*(buf + (*lenptr - 1UL)) == 10)) {
#line 58
        if (! ((int )*(buf + (*lenptr - 1UL)) == 13)) {
#line 58
          break;
        }
      }
    } else {
#line 58
      break;
    }
#line 59
    (*lenptr) --;
  }
#line 60
  *(buf + *lenptr) = (char )'\000';
#line 61
  return;
}
}
#line 83 "libs/seq_file/stream_buffer.h"
__inline static StreamBuffer *strm_buf_alloc(StreamBuffer *b , size_t___0 s ) 
{ 
  size_t___0 tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  char tmp___3 ;

  {
#line 85
  if (s < 16UL) {
#line 85
    tmp = (size_t___0 )16;
  } else {
#line 85
    tmp = s;
  }
#line 85
  b->size = tmp + 1UL;
#line 86
  tmp___1 = malloc(b->size);
#line 86
  tmp___0 = (char *)tmp___1;
#line 86
  b->b = tmp___0;
#line 86
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 86
    return ((StreamBuffer *)((void *)0));
  }
#line 87
  tmp___2 = (size_t___0 )1;
#line 87
  b->end = tmp___2;
#line 87
  b->begin = tmp___2;
#line 88
  tmp___3 = (char)0;
#line 88
  *(b->b + (b->size - 1UL)) = tmp___3;
#line 88
  *(b->b + b->end) = tmp___3;
#line 89
  return (b);
}
}
#line 92 "libs/seq_file/stream_buffer.h"
__inline static void strm_buf_dealloc(StreamBuffer *b ) 
{ 


  {
#line 94
  free((void *)b->b);
#line 95
  memset((void *)b, 0, sizeof(StreamBuffer ));
#line 96
  return;
}
}
#line 145 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 gzread2(gzFile gz , void *ptr , size_t___0 len ) 
{ 
  size_t___0 nread ;
  size_t___0 n ;
  int s ;

  {
#line 147
  nread = (size_t___0 )0;
#line 149
  while (nread < len) {
#line 150
    n = len - nread;
#line 151
    if (n > 4294967295UL) {
#line 151
      n = (size_t___0 )4294967295U;
    }
#line 152
    s = gzread(gz, (voidp )((char *)ptr + nread), (unsigned int )n);
#line 153
    if (s <= 0) {
#line 153
      break;
    }
#line 154
    nread += (size_t___0 )s;
  }
#line 156
  return (nread);
}
}
#line 186 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 gzreadline(gzFile file , char **buf , size_t___0 *len ,
                                      size_t___0 *size ) 
{ 
  size_t___0 r ;
  size_t___0 tmp ;
  size_t___0 origlen ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 186
  if (*len + 1UL >= *size) {
#line 186
    cbuf_capacity(buf, size, *len + 1UL);
  }
#line 186
  if (*size - *len > 4294967295UL) {
#line 186
    tmp = (size_t___0 )4294967295U;
  } else {
#line 186
    tmp = *size - *len;
  }
#line 186
  r = tmp;
#line 186
  origlen = *len;
#line 186
  while (1) {
#line 186
    tmp___3 = gzgets(file, *buf + *len, (int )r);
#line 186
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 186
      break;
    }
#line 186
    tmp___0 = strlen((char const   *)(*buf + *len));
#line 186
    *len += tmp___0;
#line 186
    if ((int )*(*buf + (*len - 1UL)) == 10) {
#line 186
      return (*len - origlen);
    } else {
#line 186
      tmp___1 = *size * 2UL;
#line 186
      *size = tmp___1;
#line 186
      tmp___2 = realloc((void *)*buf, tmp___1);
#line 186
      *buf = (char *)tmp___2;
    }
#line 186
    if (*size - *len > 4294967295UL) {
#line 186
      r = (size_t___0 )4294967295U;
    } else {
#line 186
      r = *size - *len;
    }
  }
#line 186
  return (*len - origlen);
}
}
#line 187 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 freadline(FILE *file , char **buf , size_t___0 *len , size_t___0 *size ) 
{ 
  size_t___0 r ;
  size_t___0 tmp ;
  size_t___0 origlen ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 187
  if (*len + 1UL >= *size) {
#line 187
    cbuf_capacity(buf, size, *len + 1UL);
  }
#line 187
  if (*size - *len > 4294967295UL) {
#line 187
    tmp = (size_t___0 )4294967295U;
  } else {
#line 187
    tmp = *size - *len;
  }
#line 187
  r = tmp;
#line 187
  origlen = *len;
#line 187
  while (1) {
#line 187
    tmp___3 = fgets((char * __restrict  )(*buf + *len), (int )r, (FILE * __restrict  )file);
#line 187
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 187
      break;
    }
#line 187
    tmp___0 = strlen((char const   *)(*buf + *len));
#line 187
    *len += tmp___0;
#line 187
    if ((int )*(*buf + (*len - 1UL)) == 10) {
#line 187
      return (*len - origlen);
    } else {
#line 187
      tmp___1 = *size * 2UL;
#line 187
      *size = tmp___1;
#line 187
      tmp___2 = realloc((void *)*buf, tmp___1);
#line 187
      *buf = (char *)tmp___2;
    }
#line 187
    if (*size - *len > 4294967295UL) {
#line 187
      r = (size_t___0 )4294967295U;
    } else {
#line 187
      r = *size - *len;
    }
  }
#line 187
  return (*len - origlen);
}
}
#line 202 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 gzskipline(gzFile file ) 
{ 
  int c ;
  size_t___0 skipped_bytes ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 202
  skipped_bytes = (size_t___0 )0;
#line 202
  while (1) {
#line 202
    if (file->have) {
#line 202
      (file->have) --;
#line 202
      (file->pos) ++;
#line 202
      tmp = file->next;
#line 202
      (file->next) ++;
#line 202
      c = (int )*tmp;
    } else {
#line 202
      tmp___0 = gzgetc(file);
#line 202
      c = tmp___0;
    }
#line 202
    if (! (c != -1)) {
#line 202
      break;
    }
#line 202
    skipped_bytes ++;
#line 202
    if (c == 10) {
#line 202
      break;
    }
  }
#line 202
  return (skipped_bytes);
}
}
#line 203 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 fskipline(FILE *file ) 
{ 
  int c ;
  size_t___0 skipped_bytes ;

  {
#line 203
  skipped_bytes = (size_t___0 )0;
#line 203
  while (1) {
#line 203
    c = fgetc(file);
#line 203
    if (! (c != -1)) {
#line 203
      break;
    }
#line 203
    skipped_bytes ++;
#line 203
    if (c == 10) {
#line 203
      break;
    }
  }
#line 203
  return (skipped_bytes);
}
}
#line 240 "libs/seq_file/stream_buffer.h"
__inline static int fgetc_buf(FILE *file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;

  {
#line 240
  if (in->begin >= in->end) {
#line 240
    while (1) {
#line 240
      tmp = fread((void * __restrict  )(in->b + 1), (size_t___0 )1, in->size - 1UL,
                  (FILE * __restrict  )file);
#line 240
      in->end = 1UL + tmp;
#line 240
      in->begin = (size_t___0 )1;
#line 240
      break;
    }
#line 240
    if (in->begin >= in->end) {
#line 240
      tmp___1 = -1;
    } else {
#line 240
      tmp___0 = in->begin;
#line 240
      (in->begin) ++;
#line 240
      tmp___1 = (int )*(in->b + tmp___0);
    }
#line 240
    return (tmp___1);
  }
#line 240
  tmp___2 = in->begin;
#line 240
  (in->begin) ++;
#line 240
  return ((int )*(in->b + tmp___2));
}
}
#line 241 "libs/seq_file/stream_buffer.h"
__inline static int gzgetc_buf(gzFile file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;

  {
#line 241
  if (in->begin >= in->end) {
#line 241
    while (1) {
#line 241
      tmp = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
#line 241
      in->end = 1UL + tmp;
#line 241
      in->begin = (size_t___0 )1;
#line 241
      break;
    }
#line 241
    if (in->begin >= in->end) {
#line 241
      tmp___1 = -1;
    } else {
#line 241
      tmp___0 = in->begin;
#line 241
      (in->begin) ++;
#line 241
      tmp___1 = (int )*(in->b + tmp___0);
    }
#line 241
    return (tmp___1);
  }
#line 241
  tmp___2 = in->begin;
#line 241
  (in->begin) ++;
#line 241
  return ((int )*(in->b + tmp___2));
}
}
#line 245 "libs/seq_file/stream_buffer.h"
__inline static int ungetc_buf(int c , StreamBuffer *in ) 
{ 


  {
#line 247
  if (in->begin == 0UL) {
#line 248
    if (in->end == 0UL) {
#line 249
      *(in->b + 0) = (char )c;
#line 250
      in->end = (size_t___0 )1;
#line 251
      return (c);
    } else {
#line 253
      return (-1);
    }
  }
#line 255
  (in->begin) --;
#line 255
  *(in->b + in->begin) = (char )c;
#line 256
  return (c);
}
}
#line 317 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 gzreadline_buf(gzFile file , StreamBuffer *in , char **buf ,
                                          size_t___0 *len , size_t___0 *size ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 buffered ;
  size_t___0 total_read ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;

  {
#line 317
  if (in->begin >= in->end) {
#line 317
    while (1) {
#line 317
      tmp = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
#line 317
      in->end = 1UL + tmp;
#line 317
      in->begin = (size_t___0 )1;
#line 317
      break;
    }
  }
#line 317
  total_read = (size_t___0 )0;
#line 317
  while (in->end > in->begin) {
#line 317
    offset = in->begin;
#line 317
    while (1) {
#line 317
      if (offset < in->end) {
#line 317
        tmp___0 = offset;
#line 317
        offset ++;
#line 317
        if (! ((int )*(in->b + tmp___0) != 10)) {
#line 317
          break;
        }
      } else {
#line 317
        break;
      }
    }
#line 317
    buffered = offset - in->begin;
#line 317
    cbuf_capacity(buf, size, *len + buffered);
#line 317
    memcpy((void * __restrict  )(*buf + *len), (void const   * __restrict  )(in->b + in->begin),
           buffered);
#line 317
    *len += buffered;
#line 317
    in->begin = offset;
#line 317
    total_read += buffered;
#line 317
    if ((int )*(*buf + (*len - 1UL)) == 10) {
#line 317
      break;
    }
#line 317
    while (1) {
#line 317
      tmp___1 = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
#line 317
      in->end = 1UL + tmp___1;
#line 317
      in->begin = (size_t___0 )1;
#line 317
      break;
    }
  }
#line 317
  *(*buf + *len) = (char)0;
#line 317
  return (total_read);
}
}
#line 318 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 freadline_buf(FILE *file , StreamBuffer *in , char **buf ,
                                         size_t___0 *len , size_t___0 *size ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 buffered ;
  size_t___0 total_read ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;

  {
#line 318
  if (in->begin >= in->end) {
#line 318
    while (1) {
#line 318
      tmp = fread((void * __restrict  )(in->b + 1), (size_t___0 )1, in->size - 1UL,
                  (FILE * __restrict  )file);
#line 318
      in->end = 1UL + tmp;
#line 318
      in->begin = (size_t___0 )1;
#line 318
      break;
    }
  }
#line 318
  total_read = (size_t___0 )0;
#line 318
  while (in->end > in->begin) {
#line 318
    offset = in->begin;
#line 318
    while (1) {
#line 318
      if (offset < in->end) {
#line 318
        tmp___0 = offset;
#line 318
        offset ++;
#line 318
        if (! ((int )*(in->b + tmp___0) != 10)) {
#line 318
          break;
        }
      } else {
#line 318
        break;
      }
    }
#line 318
    buffered = offset - in->begin;
#line 318
    cbuf_capacity(buf, size, *len + buffered);
#line 318
    memcpy((void * __restrict  )(*buf + *len), (void const   * __restrict  )(in->b + in->begin),
           buffered);
#line 318
    *len += buffered;
#line 318
    in->begin = offset;
#line 318
    total_read += buffered;
#line 318
    if ((int )*(*buf + (*len - 1UL)) == 10) {
#line 318
      break;
    }
#line 318
    while (1) {
#line 318
      tmp___1 = fread((void * __restrict  )(in->b + 1), (size_t___0 )1, in->size - 1UL,
                      (FILE * __restrict  )file);
#line 318
      in->end = 1UL + tmp___1;
#line 318
      in->begin = (size_t___0 )1;
#line 318
      break;
    }
  }
#line 318
  *(*buf + *len) = (char)0;
#line 318
  return (total_read);
}
}
#line 338 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 gzskipline_buf(gzFile file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 skipped_bytes ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;

  {
#line 338
  if (in->begin >= in->end) {
#line 338
    while (1) {
#line 338
      tmp = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
#line 338
      in->end = 1UL + tmp;
#line 338
      in->begin = (size_t___0 )1;
#line 338
      break;
    }
  }
#line 338
  skipped_bytes = (size_t___0 )0;
#line 338
  while (in->end > in->begin) {
#line 338
    offset = in->begin;
#line 338
    while (1) {
#line 338
      if (offset < in->end) {
#line 338
        tmp___0 = offset;
#line 338
        offset ++;
#line 338
        if (! ((int )*(in->b + tmp___0) != 10)) {
#line 338
          break;
        }
      } else {
#line 338
        break;
      }
#line 338
      skipped_bytes += offset - in->begin;
    }
#line 338
    in->begin = offset;
#line 338
    if ((int )*(in->b + (offset - 1UL)) == 10) {
#line 338
      break;
    }
#line 338
    while (1) {
#line 338
      tmp___1 = gzread2(file, (void *)(in->b + 1), in->size - 1UL);
#line 338
      in->end = 1UL + tmp___1;
#line 338
      in->begin = (size_t___0 )1;
#line 338
      break;
    }
  }
#line 338
  return (skipped_bytes);
}
}
#line 339 "libs/seq_file/stream_buffer.h"
__inline static size_t___0 fskipline_buf(FILE *file , StreamBuffer *in ) 
{ 
  size_t___0 tmp ;
  size_t___0 offset ;
  size_t___0 skipped_bytes ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;

  {
#line 339
  if (in->begin >= in->end) {
#line 339
    while (1) {
#line 339
      tmp = fread((void * __restrict  )(in->b + 1), (size_t___0 )1, in->size - 1UL,
                  (FILE * __restrict  )file);
#line 339
      in->end = 1UL + tmp;
#line 339
      in->begin = (size_t___0 )1;
#line 339
      break;
    }
  }
#line 339
  skipped_bytes = (size_t___0 )0;
#line 339
  while (in->end > in->begin) {
#line 339
    offset = in->begin;
#line 339
    while (1) {
#line 339
      if (offset < in->end) {
#line 339
        tmp___0 = offset;
#line 339
        offset ++;
#line 339
        if (! ((int )*(in->b + tmp___0) != 10)) {
#line 339
          break;
        }
      } else {
#line 339
        break;
      }
#line 339
      skipped_bytes += offset - in->begin;
    }
#line 339
    in->begin = offset;
#line 339
    if ((int )*(in->b + (offset - 1UL)) == 10) {
#line 339
      break;
    }
#line 339
    while (1) {
#line 339
      tmp___1 = fread((void * __restrict  )(in->b + 1), (size_t___0 )1, in->size - 1UL,
                      (FILE * __restrict  )file);
#line 339
      in->end = 1UL + tmp___1;
#line 339
      in->begin = (size_t___0 )1;
#line 339
      break;
    }
  }
#line 339
  return (skipped_bytes);
}
}
#line 114 "libs/seq_file/seq_file.h"
__inline static void seq_close(seq_file_t *sf ) ;
#line 135 "libs/seq_file/seq_file.h"
__inline static void seq_read_reset(read_t *r ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
#line 136
  tmp___0 = (size_t___0 )0;
#line 136
  r->qual.end = tmp___0;
#line 136
  tmp = tmp___0;
#line 136
  r->seq.end = tmp;
#line 136
  r->name.end = tmp;
#line 137
  tmp___2 = (char )'\000';
#line 137
  *(r->qual.b + 0) = tmp___2;
#line 137
  tmp___1 = tmp___2;
#line 137
  *(r->seq.b + 0) = tmp___1;
#line 137
  *(r->name.b + 0) = tmp___1;
#line 138
  r->from_sam = (_Bool)0;
#line 139
  return;
}
}
#line 141 "libs/seq_file/seq_file.h"
__inline static void seq_read_dealloc(read_t *r ) 
{ 


  {
#line 143
  free((void *)r->name.b);
#line 144
  free((void *)r->seq.b);
#line 145
  free((void *)r->qual.b);
#line 149
  memset((void *)r, 0, sizeof(read_t ));
#line 150
  return;
}
}
#line 152 "libs/seq_file/seq_file.h"
__inline static read_t *seq_read_alloc(read_t *r ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  size_t___0 tmp___3 ;

  {
#line 154
  memset((void *)r, 0, sizeof(read_t ));
#line 156
  tmp = malloc((size_t )256);
#line 156
  r->name.b = (char *)tmp;
#line 157
  tmp___0 = malloc((size_t )256);
#line 157
  r->seq.b = (char *)tmp___0;
#line 158
  tmp___1 = malloc((size_t )256);
#line 158
  r->qual.b = (char *)tmp___1;
#line 159
  tmp___3 = (size_t___0 )256;
#line 159
  r->qual.size = tmp___3;
#line 159
  tmp___2 = tmp___3;
#line 159
  r->seq.size = tmp___2;
#line 159
  r->name.size = tmp___2;
#line 161
  if (! r->name.b) {
#line 163
    seq_read_dealloc(r);
#line 164
    return ((read_t *)((void *)0));
  } else
#line 161
  if (! r->seq.b) {
#line 163
    seq_read_dealloc(r);
#line 164
    return ((read_t *)((void *)0));
  } else
#line 161
  if (! r->qual.b) {
#line 163
    seq_read_dealloc(r);
#line 164
    return ((read_t *)((void *)0));
  }
#line 173
  return (r);
}
}
#line 184 "libs/seq_file/seq_file.h"
__inline static void seq_read_free(read_t *r ) 
{ 


  {
#line 186
  seq_read_dealloc(r);
#line 187
  free((void *)r);
#line 188
  return;
}
}
#line 406 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fastq_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  size_t___0 tmp___2 ;

  {
#line 406
  seq_read_reset(r);
#line 406
  tmp = fgetc(sf->f_file);
#line 406
  c = tmp;
#line 406
  if (c == -1) {
#line 406
    return (0);
  }
#line 406
  if (c != 64) {
#line 406
    return (-1);
  } else {
#line 406
    tmp___0 = freadline(sf->f_file, & r->name.b, & r->name.end, & r->name.size);
#line 406
    if (tmp___0 == 0UL) {
#line 406
      return (-1);
    }
  }
#line 406
  cbuf_chomp(r->name.b, & r->name.end);
#line 406
  while (1) {
#line 406
    c = fgetc(sf->f_file);
#line 406
    if (! (c != 43)) {
#line 406
      break;
    }
#line 406
    if (c == -1) {
#line 406
      return (-1);
    }
#line 406
    if (c != 13) {
#line 406
      if (c != 10) {
#line 406
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 406
        tmp___1 = freadline(sf->f_file, & r->seq.b, & r->seq.end, & r->seq.size);
#line 406
        if (tmp___1 == 0UL) {
#line 406
          return (-1);
        }
#line 406
        cbuf_chomp(r->seq.b, & r->seq.end);
      }
    }
  }
#line 406
  while (1) {
#line 406
    c = fgetc(sf->f_file);
#line 406
    if (c != -1) {
#line 406
      if (! (c != 10)) {
#line 406
        break;
      }
    } else {
#line 406
      break;
    }
  }
#line 406
  if (c == -1) {
#line 406
    return (-1);
  }
#line 406
  while (1) {
#line 406
    tmp___2 = freadline(sf->f_file, & r->qual.b, & r->qual.end, & r->qual.size);
#line 406
    if (tmp___2 > 0UL) {
#line 406
      cbuf_chomp(r->qual.b, & r->qual.end);
    } else {
#line 406
      return (1);
    }
#line 406
    if (! (r->qual.end < r->seq.end)) {
#line 406
      break;
    }
  }
#line 406
  while (1) {
#line 406
    c = fgetc(sf->f_file);
#line 406
    if (c != -1) {
#line 406
      if (! (c != 64)) {
#line 406
        break;
      }
    } else {
#line 406
      break;
    }
  }
#line 406
  ungetc(c, sf->f_file);
#line 406
  return (1);
}
}
#line 407 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fastq_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  size_t___0 tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  size_t___0 tmp___8 ;
  unsigned char *tmp___9 ;
  int tmp___10 ;

  {
#line 407
  seq_read_reset(r);
#line 407
  if ((sf->gz_file)->have) {
#line 407
    ((sf->gz_file)->have) --;
#line 407
    ((sf->gz_file)->pos) ++;
#line 407
    tmp = (sf->gz_file)->next;
#line 407
    ((sf->gz_file)->next) ++;
#line 407
    tmp___1 = (int )*tmp;
  } else {
#line 407
    tmp___0 = gzgetc(sf->gz_file);
#line 407
    tmp___1 = tmp___0;
  }
#line 407
  c = tmp___1;
#line 407
  if (c == -1) {
#line 407
    return (0);
  }
#line 407
  if (c != 64) {
#line 407
    return (-1);
  } else {
#line 407
    tmp___2 = gzreadline(sf->gz_file, & r->name.b, & r->name.end, & r->name.size);
#line 407
    if (tmp___2 == 0UL) {
#line 407
      return (-1);
    }
  }
#line 407
  cbuf_chomp(r->name.b, & r->name.end);
#line 407
  while (1) {
#line 407
    if ((sf->gz_file)->have) {
#line 407
      ((sf->gz_file)->have) --;
#line 407
      ((sf->gz_file)->pos) ++;
#line 407
      tmp___4 = (sf->gz_file)->next;
#line 407
      ((sf->gz_file)->next) ++;
#line 407
      c = (int )*tmp___4;
    } else {
#line 407
      tmp___5 = gzgetc(sf->gz_file);
#line 407
      c = tmp___5;
    }
#line 407
    if (! (c != 43)) {
#line 407
      break;
    }
#line 407
    if (c == -1) {
#line 407
      return (-1);
    }
#line 407
    if (c != 13) {
#line 407
      if (c != 10) {
#line 407
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 407
        tmp___3 = gzreadline(sf->gz_file, & r->seq.b, & r->seq.end, & r->seq.size);
#line 407
        if (tmp___3 == 0UL) {
#line 407
          return (-1);
        }
#line 407
        cbuf_chomp(r->seq.b, & r->seq.end);
      }
    }
  }
#line 407
  while (1) {
#line 407
    if ((sf->gz_file)->have) {
#line 407
      ((sf->gz_file)->have) --;
#line 407
      ((sf->gz_file)->pos) ++;
#line 407
      tmp___6 = (sf->gz_file)->next;
#line 407
      ((sf->gz_file)->next) ++;
#line 407
      c = (int )*tmp___6;
    } else {
#line 407
      tmp___7 = gzgetc(sf->gz_file);
#line 407
      c = tmp___7;
    }
#line 407
    if (c != -1) {
#line 407
      if (! (c != 10)) {
#line 407
        break;
      }
    } else {
#line 407
      break;
    }
  }
#line 407
  if (c == -1) {
#line 407
    return (-1);
  }
#line 407
  while (1) {
#line 407
    tmp___8 = gzreadline(sf->gz_file, & r->qual.b, & r->qual.end, & r->qual.size);
#line 407
    if (tmp___8 > 0UL) {
#line 407
      cbuf_chomp(r->qual.b, & r->qual.end);
    } else {
#line 407
      return (1);
    }
#line 407
    if (! (r->qual.end < r->seq.end)) {
#line 407
      break;
    }
  }
#line 407
  while (1) {
#line 407
    if ((sf->gz_file)->have) {
#line 407
      ((sf->gz_file)->have) --;
#line 407
      ((sf->gz_file)->pos) ++;
#line 407
      tmp___9 = (sf->gz_file)->next;
#line 407
      ((sf->gz_file)->next) ++;
#line 407
      c = (int )*tmp___9;
    } else {
#line 407
      tmp___10 = gzgetc(sf->gz_file);
#line 407
      c = tmp___10;
    }
#line 407
    if (c != -1) {
#line 407
      if (! (c != 64)) {
#line 407
        break;
      }
    } else {
#line 407
      break;
    }
  }
#line 407
  gzungetc(c, sf->gz_file);
#line 407
  return (1);
}
}
#line 408 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fastq_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  size_t___0 tmp___2 ;

  {
#line 408
  seq_read_reset(r);
#line 408
  tmp = fgetc_buf(sf->f_file, & sf->in);
#line 408
  c = tmp;
#line 408
  if (c == -1) {
#line 408
    return (0);
  }
#line 408
  if (c != 64) {
#line 408
    return (-1);
  } else {
#line 408
    tmp___0 = freadline_buf(sf->f_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
#line 408
    if (tmp___0 == 0UL) {
#line 408
      return (-1);
    }
  }
#line 408
  cbuf_chomp(r->name.b, & r->name.end);
#line 408
  while (1) {
#line 408
    c = fgetc_buf(sf->f_file, & sf->in);
#line 408
    if (! (c != 43)) {
#line 408
      break;
    }
#line 408
    if (c == -1) {
#line 408
      return (-1);
    }
#line 408
    if (c != 13) {
#line 408
      if (c != 10) {
#line 408
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 408
        tmp___1 = freadline_buf(sf->f_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
#line 408
        if (tmp___1 == 0UL) {
#line 408
          return (-1);
        }
#line 408
        cbuf_chomp(r->seq.b, & r->seq.end);
      }
    }
  }
#line 408
  while (1) {
#line 408
    c = fgetc_buf(sf->f_file, & sf->in);
#line 408
    if (c != -1) {
#line 408
      if (! (c != 10)) {
#line 408
        break;
      }
    } else {
#line 408
      break;
    }
  }
#line 408
  if (c == -1) {
#line 408
    return (-1);
  }
#line 408
  while (1) {
#line 408
    tmp___2 = freadline_buf(sf->f_file, & sf->in, & r->qual.b, & r->qual.end, & r->qual.size);
#line 408
    if (tmp___2 > 0UL) {
#line 408
      cbuf_chomp(r->qual.b, & r->qual.end);
    } else {
#line 408
      return (1);
    }
#line 408
    if (! (r->qual.end < r->seq.end)) {
#line 408
      break;
    }
  }
#line 408
  while (1) {
#line 408
    c = fgetc_buf(sf->f_file, & sf->in);
#line 408
    if (c != -1) {
#line 408
      if (! (c != 64)) {
#line 408
        break;
      }
    } else {
#line 408
      break;
    }
  }
#line 408
  ungetc_buf(c, & sf->in);
#line 408
  return (1);
}
}
#line 409 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fastq_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  size_t___0 tmp___1 ;
  size_t___0 tmp___2 ;

  {
#line 409
  seq_read_reset(r);
#line 409
  tmp = gzgetc_buf(sf->gz_file, & sf->in);
#line 409
  c = tmp;
#line 409
  if (c == -1) {
#line 409
    return (0);
  }
#line 409
  if (c != 64) {
#line 409
    return (-1);
  } else {
#line 409
    tmp___0 = gzreadline_buf(sf->gz_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
#line 409
    if (tmp___0 == 0UL) {
#line 409
      return (-1);
    }
  }
#line 409
  cbuf_chomp(r->name.b, & r->name.end);
#line 409
  while (1) {
#line 409
    c = gzgetc_buf(sf->gz_file, & sf->in);
#line 409
    if (! (c != 43)) {
#line 409
      break;
    }
#line 409
    if (c == -1) {
#line 409
      return (-1);
    }
#line 409
    if (c != 13) {
#line 409
      if (c != 10) {
#line 409
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 409
        tmp___1 = gzreadline_buf(sf->gz_file, & sf->in, & r->seq.b, & r->seq.end,
                                 & r->seq.size);
#line 409
        if (tmp___1 == 0UL) {
#line 409
          return (-1);
        }
#line 409
        cbuf_chomp(r->seq.b, & r->seq.end);
      }
    }
  }
#line 409
  while (1) {
#line 409
    c = gzgetc_buf(sf->gz_file, & sf->in);
#line 409
    if (c != -1) {
#line 409
      if (! (c != 10)) {
#line 409
        break;
      }
    } else {
#line 409
      break;
    }
  }
#line 409
  if (c == -1) {
#line 409
    return (-1);
  }
#line 409
  while (1) {
#line 409
    tmp___2 = gzreadline_buf(sf->gz_file, & sf->in, & r->qual.b, & r->qual.end, & r->qual.size);
#line 409
    if (tmp___2 > 0UL) {
#line 409
      cbuf_chomp(r->qual.b, & r->qual.end);
    } else {
#line 409
      return (1);
    }
#line 409
    if (! (r->qual.end < r->seq.end)) {
#line 409
      break;
    }
  }
#line 409
  while (1) {
#line 409
    c = gzgetc_buf(sf->gz_file, & sf->in);
#line 409
    if (c != -1) {
#line 409
      if (! (c != 64)) {
#line 409
        break;
      }
    } else {
#line 409
      break;
    }
  }
#line 409
  ungetc_buf(c, & sf->in);
#line 409
  return (1);
}
}
#line 412 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fasta_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  long nread ;
  size_t___0 tmp___1 ;

  {
#line 412
  seq_read_reset(r);
#line 412
  tmp = fgetc(sf->f_file);
#line 412
  c = tmp;
#line 412
  if (c == -1) {
#line 412
    return (0);
  }
#line 412
  if (c != 62) {
#line 412
    return (-1);
  } else {
#line 412
    tmp___0 = freadline(sf->f_file, & r->name.b, & r->name.end, & r->name.size);
#line 412
    if (tmp___0 == 0UL) {
#line 412
      return (-1);
    }
  }
#line 412
  cbuf_chomp(r->name.b, & r->name.end);
#line 412
  while (1) {
#line 412
    c = fgetc(sf->f_file);
#line 412
    if (! (c != 62)) {
#line 412
      break;
    }
#line 412
    if (c == -1) {
#line 412
      return (1);
    }
#line 412
    if (c != 13) {
#line 412
      if (c != 10) {
#line 412
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 412
        tmp___1 = freadline(sf->f_file, & r->seq.b, & r->seq.end, & r->seq.size);
#line 412
        nread = (long )tmp___1;
#line 412
        cbuf_chomp(r->seq.b, & r->seq.end);
#line 412
        if (nread <= 0L) {
#line 412
          return (1);
        }
      }
    }
  }
#line 412
  ungetc(c, sf->f_file);
#line 412
  return (1);
}
}
#line 413 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fasta_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  long nread ;
  size_t___0 tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;

  {
#line 413
  seq_read_reset(r);
#line 413
  if ((sf->gz_file)->have) {
#line 413
    ((sf->gz_file)->have) --;
#line 413
    ((sf->gz_file)->pos) ++;
#line 413
    tmp = (sf->gz_file)->next;
#line 413
    ((sf->gz_file)->next) ++;
#line 413
    tmp___1 = (int )*tmp;
  } else {
#line 413
    tmp___0 = gzgetc(sf->gz_file);
#line 413
    tmp___1 = tmp___0;
  }
#line 413
  c = tmp___1;
#line 413
  if (c == -1) {
#line 413
    return (0);
  }
#line 413
  if (c != 62) {
#line 413
    return (-1);
  } else {
#line 413
    tmp___2 = gzreadline(sf->gz_file, & r->name.b, & r->name.end, & r->name.size);
#line 413
    if (tmp___2 == 0UL) {
#line 413
      return (-1);
    }
  }
#line 413
  cbuf_chomp(r->name.b, & r->name.end);
#line 413
  while (1) {
#line 413
    if ((sf->gz_file)->have) {
#line 413
      ((sf->gz_file)->have) --;
#line 413
      ((sf->gz_file)->pos) ++;
#line 413
      tmp___4 = (sf->gz_file)->next;
#line 413
      ((sf->gz_file)->next) ++;
#line 413
      c = (int )*tmp___4;
    } else {
#line 413
      tmp___5 = gzgetc(sf->gz_file);
#line 413
      c = tmp___5;
    }
#line 413
    if (! (c != 62)) {
#line 413
      break;
    }
#line 413
    if (c == -1) {
#line 413
      return (1);
    }
#line 413
    if (c != 13) {
#line 413
      if (c != 10) {
#line 413
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 413
        tmp___3 = gzreadline(sf->gz_file, & r->seq.b, & r->seq.end, & r->seq.size);
#line 413
        nread = (long )tmp___3;
#line 413
        cbuf_chomp(r->seq.b, & r->seq.end);
#line 413
        if (nread <= 0L) {
#line 413
          return (1);
        }
      }
    }
  }
#line 413
  gzungetc(c, sf->gz_file);
#line 413
  return (1);
}
}
#line 414 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fasta_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  long nread ;
  size_t___0 tmp___1 ;

  {
#line 414
  seq_read_reset(r);
#line 414
  tmp = fgetc_buf(sf->f_file, & sf->in);
#line 414
  c = tmp;
#line 414
  if (c == -1) {
#line 414
    return (0);
  }
#line 414
  if (c != 62) {
#line 414
    return (-1);
  } else {
#line 414
    tmp___0 = freadline_buf(sf->f_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
#line 414
    if (tmp___0 == 0UL) {
#line 414
      return (-1);
    }
  }
#line 414
  cbuf_chomp(r->name.b, & r->name.end);
#line 414
  while (1) {
#line 414
    c = fgetc_buf(sf->f_file, & sf->in);
#line 414
    if (! (c != 62)) {
#line 414
      break;
    }
#line 414
    if (c == -1) {
#line 414
      return (1);
    }
#line 414
    if (c != 13) {
#line 414
      if (c != 10) {
#line 414
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 414
        tmp___1 = freadline_buf(sf->f_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
#line 414
        nread = (long )tmp___1;
#line 414
        cbuf_chomp(r->seq.b, & r->seq.end);
#line 414
        if (nread <= 0L) {
#line 414
          return (1);
        }
      }
    }
  }
#line 414
  ungetc_buf(c, & sf->in);
#line 414
  return (1);
}
}
#line 415 "libs/seq_file/seq_file.h"
__inline static int _seq_read_fasta_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  size_t___0 tmp___0 ;
  long nread ;
  size_t___0 tmp___1 ;

  {
#line 415
  seq_read_reset(r);
#line 415
  tmp = gzgetc_buf(sf->gz_file, & sf->in);
#line 415
  c = tmp;
#line 415
  if (c == -1) {
#line 415
    return (0);
  }
#line 415
  if (c != 62) {
#line 415
    return (-1);
  } else {
#line 415
    tmp___0 = gzreadline_buf(sf->gz_file, & sf->in, & r->name.b, & r->name.end, & r->name.size);
#line 415
    if (tmp___0 == 0UL) {
#line 415
      return (-1);
    }
  }
#line 415
  cbuf_chomp(r->name.b, & r->name.end);
#line 415
  while (1) {
#line 415
    c = gzgetc_buf(sf->gz_file, & sf->in);
#line 415
    if (! (c != 62)) {
#line 415
      break;
    }
#line 415
    if (c == -1) {
#line 415
      return (1);
    }
#line 415
    if (c != 13) {
#line 415
      if (c != 10) {
#line 415
        cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 415
        tmp___1 = gzreadline_buf(sf->gz_file, & sf->in, & r->seq.b, & r->seq.end,
                                 & r->seq.size);
#line 415
        nread = (long )tmp___1;
#line 415
        cbuf_chomp(r->seq.b, & r->seq.end);
#line 415
        if (nread <= 0L) {
#line 415
          return (1);
        }
      }
    }
  }
#line 415
  ungetc_buf(c, & sf->in);
#line 415
  return (1);
}
}
#line 418 "libs/seq_file/seq_file.h"
__inline static int _seq_read_plain_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;

  {
#line 418
  seq_read_reset(r);
#line 418
  while (1) {
#line 418
    c = fgetc(sf->f_file);
#line 418
    if (c != -1) {
#line 418
      tmp = isspace(c);
#line 418
      if (! tmp) {
#line 418
        break;
      }
    } else {
#line 418
      break;
    }
#line 418
    if (c != 10) {
#line 418
      fskipline(sf->f_file);
    }
  }
#line 418
  if (c == -1) {
#line 418
    return (0);
  }
#line 418
  cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 418
  freadline(sf->f_file, & r->seq.b, & r->seq.end, & r->seq.size);
#line 418
  cbuf_chomp(r->seq.b, & r->seq.end);
#line 418
  return (1);
}
}
#line 419 "libs/seq_file/seq_file.h"
__inline static int _seq_read_plain_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 419
  seq_read_reset(r);
#line 419
  while (1) {
#line 419
    if ((sf->gz_file)->have) {
#line 419
      ((sf->gz_file)->have) --;
#line 419
      ((sf->gz_file)->pos) ++;
#line 419
      tmp = (sf->gz_file)->next;
#line 419
      ((sf->gz_file)->next) ++;
#line 419
      c = (int )*tmp;
    } else {
#line 419
      tmp___0 = gzgetc(sf->gz_file);
#line 419
      c = tmp___0;
    }
#line 419
    if (c != -1) {
#line 419
      tmp___1 = isspace(c);
#line 419
      if (! tmp___1) {
#line 419
        break;
      }
    } else {
#line 419
      break;
    }
#line 419
    if (c != 10) {
#line 419
      gzskipline(sf->gz_file);
    }
  }
#line 419
  if (c == -1) {
#line 419
    return (0);
  }
#line 419
  cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 419
  gzreadline(sf->gz_file, & r->seq.b, & r->seq.end, & r->seq.size);
#line 419
  cbuf_chomp(r->seq.b, & r->seq.end);
#line 419
  return (1);
}
}
#line 420 "libs/seq_file/seq_file.h"
__inline static int _seq_read_plain_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;

  {
#line 420
  seq_read_reset(r);
#line 420
  while (1) {
#line 420
    c = fgetc_buf(sf->f_file, & sf->in);
#line 420
    if (c != -1) {
#line 420
      tmp = isspace(c);
#line 420
      if (! tmp) {
#line 420
        break;
      }
    } else {
#line 420
      break;
    }
#line 420
    if (c != 10) {
#line 420
      fskipline_buf(sf->f_file, & sf->in);
    }
  }
#line 420
  if (c == -1) {
#line 420
    return (0);
  }
#line 420
  cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 420
  freadline_buf(sf->f_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
#line 420
  cbuf_chomp(r->seq.b, & r->seq.end);
#line 420
  return (1);
}
}
#line 421 "libs/seq_file/seq_file.h"
__inline static int _seq_read_plain_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;

  {
#line 421
  seq_read_reset(r);
#line 421
  while (1) {
#line 421
    c = gzgetc_buf(sf->gz_file, & sf->in);
#line 421
    if (c != -1) {
#line 421
      tmp = isspace(c);
#line 421
      if (! tmp) {
#line 421
        break;
      }
    } else {
#line 421
      break;
    }
#line 421
    if (c != 10) {
#line 421
      gzskipline_buf(sf->gz_file, & sf->in);
    }
  }
#line 421
  if (c == -1) {
#line 421
    return (0);
  }
#line 421
  cbuf_append_char(& r->seq.b, & r->seq.end, & r->seq.size, (char )c);
#line 421
  gzreadline_buf(sf->gz_file, & sf->in, & r->seq.b, & r->seq.end, & r->seq.size);
#line 421
  cbuf_chomp(r->seq.b, & r->seq.end);
#line 421
  return (1);
}
}
#line 424 "libs/seq_file/seq_file.h"
__inline static int _seq_read_unknown_f(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 424
  seq_read_reset(r);
#line 424
  while (1) {
#line 424
    c = fgetc(sf->f_file);
#line 424
    if (c != -1) {
#line 424
      tmp = isspace(c);
#line 424
      if (! tmp) {
#line 424
        break;
      }
    } else {
#line 424
      break;
    }
#line 424
    if (c != 10) {
#line 424
      fskipline(sf->f_file);
    }
  }
#line 424
  if (c == -1) {
#line 424
    return (0);
  }
#line 424
  if (c == 64) {
#line 424
    sf->format = (seq_format )4;
#line 424
    sf->origreadfunc = & _seq_read_fastq_f;
  } else
#line 424
  if (c == 62) {
#line 424
    sf->format = (seq_format )2;
#line 424
    sf->origreadfunc = & _seq_read_fasta_f;
  } else {
#line 424
    sf->format = (seq_format )1;
#line 424
    sf->origreadfunc = & _seq_read_plain_f;
  }
#line 424
  ungetc(c, sf->f_file);
#line 424
  tmp___0 = (*(sf->origreadfunc))(sf, r);
#line 424
  return (tmp___0);
}
}
#line 425 "libs/seq_file/seq_file.h"
__inline static int _seq_read_unknown_gz(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 425
  seq_read_reset(r);
#line 425
  while (1) {
#line 425
    if ((sf->gz_file)->have) {
#line 425
      ((sf->gz_file)->have) --;
#line 425
      ((sf->gz_file)->pos) ++;
#line 425
      tmp = (sf->gz_file)->next;
#line 425
      ((sf->gz_file)->next) ++;
#line 425
      c = (int )*tmp;
    } else {
#line 425
      tmp___0 = gzgetc(sf->gz_file);
#line 425
      c = tmp___0;
    }
#line 425
    if (c != -1) {
#line 425
      tmp___1 = isspace(c);
#line 425
      if (! tmp___1) {
#line 425
        break;
      }
    } else {
#line 425
      break;
    }
#line 425
    if (c != 10) {
#line 425
      gzskipline(sf->gz_file);
    }
  }
#line 425
  if (c == -1) {
#line 425
    return (0);
  }
#line 425
  if (c == 64) {
#line 425
    sf->format = (seq_format )4;
#line 425
    sf->origreadfunc = & _seq_read_fastq_gz;
  } else
#line 425
  if (c == 62) {
#line 425
    sf->format = (seq_format )2;
#line 425
    sf->origreadfunc = & _seq_read_fasta_gz;
  } else {
#line 425
    sf->format = (seq_format )1;
#line 425
    sf->origreadfunc = & _seq_read_plain_gz;
  }
#line 425
  gzungetc(c, sf->gz_file);
#line 425
  tmp___2 = (*(sf->origreadfunc))(sf, r);
#line 425
  return (tmp___2);
}
}
#line 426 "libs/seq_file/seq_file.h"
__inline static int _seq_read_unknown_f_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 426
  seq_read_reset(r);
#line 426
  while (1) {
#line 426
    c = fgetc_buf(sf->f_file, & sf->in);
#line 426
    if (c != -1) {
#line 426
      tmp = isspace(c);
#line 426
      if (! tmp) {
#line 426
        break;
      }
    } else {
#line 426
      break;
    }
#line 426
    if (c != 10) {
#line 426
      fskipline(sf->f_file);
    }
  }
#line 426
  if (c == -1) {
#line 426
    return (0);
  }
#line 426
  if (c == 64) {
#line 426
    sf->format = (seq_format )4;
#line 426
    sf->origreadfunc = & _seq_read_fastq_f_buf;
  } else
#line 426
  if (c == 62) {
#line 426
    sf->format = (seq_format )2;
#line 426
    sf->origreadfunc = & _seq_read_fasta_f_buf;
  } else {
#line 426
    sf->format = (seq_format )1;
#line 426
    sf->origreadfunc = & _seq_read_plain_f_buf;
  }
#line 426
  ungetc_buf(c, & sf->in);
#line 426
  tmp___0 = (*(sf->origreadfunc))(sf, r);
#line 426
  return (tmp___0);
}
}
#line 427 "libs/seq_file/seq_file.h"
__inline static int _seq_read_unknown_gz_buf(seq_file_t *sf , read_t *r ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 427
  seq_read_reset(r);
#line 427
  while (1) {
#line 427
    c = gzgetc_buf(sf->gz_file, & sf->in);
#line 427
    if (c != -1) {
#line 427
      tmp = isspace(c);
#line 427
      if (! tmp) {
#line 427
        break;
      }
    } else {
#line 427
      break;
    }
#line 427
    if (c != 10) {
#line 427
      gzskipline(sf->gz_file);
    }
  }
#line 427
  if (c == -1) {
#line 427
    return (0);
  }
#line 427
  if (c == 64) {
#line 427
    sf->format = (seq_format )4;
#line 427
    sf->origreadfunc = & _seq_read_fastq_gz_buf;
  } else
#line 427
  if (c == 62) {
#line 427
    sf->format = (seq_format )2;
#line 427
    sf->origreadfunc = & _seq_read_fasta_gz_buf;
  } else {
#line 427
    sf->format = (seq_format )1;
#line 427
    sf->origreadfunc = & _seq_read_plain_gz_buf;
  }
#line 427
  ungetc_buf(c, & sf->in);
#line 427
  tmp___0 = (*(sf->origreadfunc))(sf, r);
#line 427
  return (tmp___0);
}
}
#line 430 "libs/seq_file/seq_file.h"
__inline static char _seq_setup(seq_file_t *sf , _Bool use_zlib , size_t___0 buf_size ) 
{ 
  StreamBuffer *tmp ;

  {
#line 432
  if (buf_size) {
#line 433
    tmp = strm_buf_alloc(& sf->in, buf_size);
#line 433
    if (! tmp) {
#line 433
      free((void *)sf);
#line 433
      return ((char)0);
    }
#line 434
    if (use_zlib) {
#line 434
      sf->origreadfunc = & _seq_read_unknown_gz_buf;
    } else {
#line 434
      sf->origreadfunc = & _seq_read_unknown_f_buf;
    }
  } else
#line 436
  if (use_zlib) {
#line 436
    sf->origreadfunc = & _seq_read_unknown_gz;
  } else {
#line 436
    sf->origreadfunc = & _seq_read_unknown_f;
  }
#line 437
  sf->readfunc = sf->origreadfunc;
#line 438
  return ((char)1);
}
}
#line 444 "libs/seq_file/seq_file.h"
__inline static seq_format seq_guess_filetype_from_extension(char const   *path ) 
{ 
  size_t___0 plen ;
  size_t___0 tmp ;
  char const   *exts[29] ;
  seq_format types[29] ;
  size_t___0 extlens[29] ;
  size_t___0 i ;
  int tmp___0 ;

  {
#line 446
  tmp = strlen(path);
#line 446
  plen = tmp;
#line 447
  exts[0] = (char const   *)".fa";
#line 447
  exts[1] = (char const   *)".fasta";
#line 447
  exts[2] = (char const   *)".fsa";
#line 447
  exts[3] = (char const   *)".fsa.gz";
#line 447
  exts[4] = (char const   *)"fsa.gzip";
#line 447
  exts[5] = (char const   *)".faz";
#line 447
  exts[6] = (char const   *)".fagz";
#line 447
  exts[7] = (char const   *)".fa.gz";
#line 447
  exts[8] = (char const   *)".fa.gzip";
#line 447
  exts[9] = (char const   *)".fastaz";
#line 447
  exts[10] = (char const   *)".fasta.gzip";
#line 447
  exts[11] = (char const   *)".fq";
#line 447
  exts[12] = (char const   *)".fastq";
#line 447
  exts[13] = (char const   *)".fsq";
#line 447
  exts[14] = (char const   *)".fsq.gz";
#line 447
  exts[15] = (char const   *)"fsq.gzip";
#line 447
  exts[16] = (char const   *)".fqz";
#line 447
  exts[17] = (char const   *)".fqgz";
#line 447
  exts[18] = (char const   *)".fq.gz";
#line 447
  exts[19] = (char const   *)".fq.gzip";
#line 447
  exts[20] = (char const   *)".fastqz";
#line 447
  exts[21] = (char const   *)".fastq.gzip";
#line 447
  exts[22] = (char const   *)".txt";
#line 447
  exts[23] = (char const   *)".txtgz";
#line 447
  exts[24] = (char const   *)".txt.gz";
#line 447
  exts[25] = (char const   *)".txt.gzip";
#line 447
  exts[26] = (char const   *)".sam";
#line 447
  exts[27] = (char const   *)".bam";
#line 447
  exts[28] = (char const   *)".cram";
#line 455
  types[0] = (seq_format )2;
#line 455
  types[1] = (seq_format )2;
#line 455
  types[2] = (seq_format )2;
#line 455
  types[3] = (seq_format )2;
#line 455
  types[4] = (seq_format )2;
#line 455
  types[5] = (seq_format )2;
#line 455
  types[6] = (seq_format )2;
#line 455
  types[7] = (seq_format )2;
#line 455
  types[8] = (seq_format )2;
#line 455
  types[9] = (seq_format )2;
#line 455
  types[10] = (seq_format )2;
#line 455
  types[11] = (seq_format )4;
#line 455
  types[12] = (seq_format )4;
#line 455
  types[13] = (seq_format )4;
#line 455
  types[14] = (seq_format )4;
#line 455
  types[15] = (seq_format )4;
#line 455
  types[16] = (seq_format )4;
#line 455
  types[17] = (seq_format )4;
#line 455
  types[18] = (seq_format )4;
#line 455
  types[19] = (seq_format )4;
#line 455
  types[20] = (seq_format )4;
#line 455
  types[21] = (seq_format )4;
#line 455
  types[22] = (seq_format )1;
#line 455
  types[23] = (seq_format )1;
#line 455
  types[24] = (seq_format )1;
#line 455
  types[25] = (seq_format )1;
#line 455
  types[26] = (seq_format )8;
#line 455
  types[27] = (seq_format )16;
#line 455
  types[28] = (seq_format )16;
#line 467
  i = (size_t___0 )0;
#line 467
  while (i < 29UL) {
#line 468
    extlens[i] = strlen(exts[i]);
#line 467
    i ++;
  }
#line 470
  i = (size_t___0 )0;
#line 470
  while (i < 29UL) {
#line 471
    if (extlens[i] <= plen) {
#line 471
      tmp___0 = strcasecmp((path + plen) - extlens[i], exts[i]);
#line 471
      if (tmp___0 == 0) {
#line 472
        return ((seq_format )types[i]);
      }
    }
#line 470
    i ++;
  }
#line 474
  return ((seq_format )0);
}
}
#line 479 "libs/seq_file/seq_file.h"
__inline static seq_file_t *seq_open2(char const   *p , _Bool ishts , _Bool use_zlib ,
                                      size_t___0 buf_size ) 
{ 
  seq_file_t *sf ;
  void *tmp ;
  gzFile tmp___0 ;
  FILE *tmp___1 ;
  char tmp___2 ;

  {
#line 482
  tmp = calloc((size_t )1, sizeof(seq_file_t ));
#line 482
  sf = (seq_file_t *)tmp;
#line 483
  sf->path = strdup(p);
#line 485
  if (ishts) {
#line 505
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s:%i] Error: not compiled with sam/bam support\n",
            "libs/seq_file/seq_file.h", 506);
#line 507
    exit(1);
  } else {
#line 512
    if (use_zlib) {
#line 512
      tmp___0 = gzopen(p, (char const   *)"r");
#line 512
      sf->gz_file = tmp___0;
#line 512
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 514
        seq_close(sf);
#line 515
        return ((seq_file_t *)((void *)0));
      } else {
#line 512
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 512
    if (! use_zlib) {
#line 512
      tmp___1 = fopen((char const   * __restrict  )p, (char const   * __restrict  )"r");
#line 512
      sf->f_file = tmp___1;
#line 512
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 514
        seq_close(sf);
#line 515
        return ((seq_file_t *)((void *)0));
      }
    }
#line 518
    tmp___2 = _seq_setup(sf, use_zlib, buf_size);
#line 518
    if (! tmp___2) {
#line 518
      return ((seq_file_t *)((void *)0));
    }
  }
#line 521
  return (sf);
}
}
#line 528 "libs/seq_file/seq_file.h"
__inline static seq_file_t *seq_dopen(int fd , char ishts , _Bool use_zlib , size_t___0 buf_size ) 
{ 
  seq_file_t *sf ;
  void *tmp ;
  FILE *tmp___0 ;
  gzFile tmp___1 ;
  char tmp___2 ;

  {
#line 531
  tmp = calloc((size_t )1, sizeof(seq_file_t ));
#line 531
  sf = (seq_file_t *)tmp;
#line 532
  sf->path = strdup((char const   *)"-");
#line 534
  if (ishts) {
#line 554
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s:%i] Error: not compiled with sam/bam support\n",
            "libs/seq_file/seq_file.h", 555);
#line 556
    exit(1);
  } else {
#line 561
    if (! use_zlib) {
#line 561
      tmp___0 = fdopen(fd, (char const   *)"r");
#line 561
      sf->f_file = tmp___0;
#line 561
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 563
        seq_close(sf);
#line 564
        return ((seq_file_t *)((void *)0));
      } else {
#line 561
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 561
    if (use_zlib) {
#line 561
      tmp___1 = gzdopen(fd, (char const   *)"r");
#line 561
      sf->gz_file = tmp___1;
#line 561
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 563
        seq_close(sf);
#line 564
        return ((seq_file_t *)((void *)0));
      }
    }
#line 567
    tmp___2 = _seq_setup(sf, use_zlib, buf_size);
#line 567
    if (! tmp___2) {
#line 567
      return ((seq_file_t *)((void *)0));
    }
  }
#line 570
  return (sf);
}
}
#line 573 "libs/seq_file/seq_file.h"
__inline static seq_file_t *seq_open(char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  seq_file_t *tmp___1 ;
  int tmp___2 ;
  seq_format fmt ;
  seq_format tmp___3 ;
  _Bool ishts ;
  int tmp___4 ;
  seq_file_t *tmp___5 ;

  {
#line 575
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 575
    tmp = 1;
  } else {
#line 575
    __assert_fail((char const   *)"p != NULL", (char const   *)"libs/seq_file/seq_file.h",
                  575, (char const   *)"seq_open");
#line 575
    tmp = 0;
  }
#line 576
  tmp___2 = strcmp(p, (char const   *)"-");
#line 576
  if (tmp___2 == 0) {
#line 576
    tmp___0 = fileno((FILE *)stdin);
#line 576
    tmp___1 = seq_dopen(tmp___0, (char)0, (_Bool)1, (size_t___0 )0);
#line 576
    return (tmp___1);
  }
#line 578
  tmp___3 = seq_guess_filetype_from_extension(p);
#line 578
  fmt = tmp___3;
#line 579
  if ((unsigned int )fmt == 8U) {
#line 579
    tmp___4 = 1;
  } else
#line 579
  if ((unsigned int )fmt == 16U) {
#line 579
    tmp___4 = 1;
  } else
#line 579
  if ((unsigned int )fmt == 16U) {
#line 579
    tmp___4 = 1;
  } else {
#line 579
    tmp___4 = 0;
  }
#line 579
  ishts = (_Bool )tmp___4;
#line 580
  tmp___5 = seq_open2(p, ishts, (_Bool)1, (size_t___0 )(1 << 20));
#line 580
  return (tmp___5);
}
}
#line 602 "libs/seq_file/seq_file.h"
__inline static void seq_close(seq_file_t *sf ) 
{ 
  int e ;
  read_t *r ;
  read_t *tmpr ;

  {
#line 605
  if ((unsigned long )sf->f_file != (unsigned long )((void *)0)) {
#line 605
    e = fclose(sf->f_file);
#line 605
    if (e != 0) {
#line 606
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s:%i] Error closing file: %s [%i]\n",
              "libs/seq_file/seq_file.h", 606, sf->path, e);
    }
  }
#line 609
  if ((unsigned long )sf->gz_file != (unsigned long )((void *)0)) {
#line 609
    e = gzclose(sf->gz_file);
#line 609
    if (e != 0) {
#line 610
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%s:%i] Error closing gzfile: %s [%i]\n",
              "libs/seq_file/seq_file.h", 610, sf->path, e);
    }
  }
#line 617
  strm_buf_dealloc(& sf->in);
#line 618
  free((void *)sf->path);
#line 619
  r = sf->rhead;
#line 620
  while ((unsigned long )r != (unsigned long )((void *)0)) {
#line 620
    tmpr = r->next;
#line 620
    seq_read_free(r);
#line 620
    r = tmpr;
  }
#line 621
  memset((void *)sf, 0, sizeof(*sf));
#line 622
  free((void *)sf);
#line 623
  return;
}
}
#line 66 "src/alignment_scoring.h"
void scoring_add_wildcard(scoring_t *scoring , char c , int score ) ;
#line 76
void scoring_system_PAM30(scoring_t *scoring ) ;
#line 77
void scoring_system_PAM70(scoring_t *scoring ) ;
#line 78
void scoring_system_BLOSUM80(scoring_t *scoring ) ;
#line 79
void scoring_system_BLOSUM62(scoring_t *scoring ) ;
#line 80
void scoring_system_DNA_hybridization(scoring_t *scoring ) ;
#line 58 "src/alignment_cmdline.h"
char parse_entire_int(char *str , int *result ) ;
#line 59
char parse_entire_uint(char *str , unsigned int *result ) ;
#line 61
cmdline_t *cmdline_new(int argc , char **argv , scoring_t *scoring , enum SeqAlignCmdType cmd_type ) ;
#line 63
void cmdline_free(cmdline_t *cmd ) ;
#line 65
void cmdline_add_files(cmdline_t *cmd , char *p1 , char *p2 ) ;
#line 66
size_t___0 cmdline_get_num_of_file_pairs(cmdline_t *cmd ) ;
#line 67
char *cmdline_get_file1(cmdline_t *cmd , size_t___0 i ) ;
#line 68
char *cmdline_get_file2(cmdline_t *cmd , size_t___0 i ) ;
#line 70
void align_from_file(char const   *path1 , char const   *path2 , void (*align)(read_t *r1 ,
                                                                               read_t *r2 ) ,
                     _Bool use_zlib ) ;
#line 14 "src/alignment_scoring_load.h"
void align_scoring_load_matrix(gzFile file , char const   *file_path , scoring_t *scoring ,
                               char case_sensitive ) ;
#line 17
void align_scoring_load_pairwise(gzFile file , char const   *file_path , scoring_t *scoring ,
                                 char case_sensitive ) ;
#line 28 "src/alignment_cmdline.c"
int file_list_length  =    0;
#line 29 "src/alignment_cmdline.c"
int file_list_capacity  =    0;
#line 30 "src/alignment_cmdline.c"
char **file_paths1  =    (char **)((void *)0);
#line 30 "src/alignment_cmdline.c"
char **file_paths2  =    (char **)((void *)0);
#line 32 "src/alignment_cmdline.c"
char parse_entire_int(char *str , int *result ) 
{ 
  size_t___0 len ;
  size_t___0 tmp ;
  char *strtol_last_char_ptr ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = strlen((char const   *)str);
#line 34
  len = tmp;
#line 36
  strtol_last_char_ptr = str;
#line 37
  tmp___1 = strtol((char const   * __restrict  )str, (char ** __restrict  )(& strtol_last_char_ptr),
                   10);
#line 37
  tmp___0 = tmp___1;
#line 39
  if (tmp___0 > 2147483647L) {
#line 41
    return ((char)0);
  } else
#line 39
  if (tmp___0 < (-0x7FFFFFFF-1)) {
#line 41
    return ((char)0);
  } else
#line 39
  if ((unsigned long )strtol_last_char_ptr != (unsigned long )(str + len)) {
#line 41
    return ((char)0);
  } else {
#line 45
    *result = (int )tmp___0;
#line 46
    return ((char)1);
  }
}
}
#line 50 "src/alignment_cmdline.c"
char parse_entire_uint(char *str , unsigned int *result ) 
{ 
  size_t___0 len ;
  size_t___0 tmp ;
  char *strtol_last_char_ptr ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 52
  tmp = strlen((char const   *)str);
#line 52
  len = tmp;
#line 54
  strtol_last_char_ptr = str;
#line 55
  tmp___1 = strtoul((char const   * __restrict  )str, (char ** __restrict  )(& strtol_last_char_ptr),
                    10);
#line 55
  tmp___0 = tmp___1;
#line 57
  if (tmp___0 > 4294967295UL) {
#line 59
    return ((char)0);
  } else
#line 57
  if ((unsigned long )strtol_last_char_ptr != (unsigned long )(str + len)) {
#line 59
    return ((char)0);
  } else {
#line 63
    *result = (unsigned int )tmp___0;
#line 64
    return ((char)1);
  }
}
}
#line 68
static void ( /* format attribute */  print_usage)(enum SeqAlignCmdType cmd_type ,
                                                   score_t *defaults , char const   *cmdstr ,
                                                   char const   *errfmt  , ...)  __attribute__((__noreturn__)) ;
#line 73
static void ( /* format attribute */  print_usage)(enum SeqAlignCmdType cmd_type ,
                                                   score_t *defaults , char const   *cmdstr ,
                                                   char const   *errfmt  , ...)  __attribute__((__noreturn__)) ;
#line 73 "src/alignment_cmdline.c"
static void ( /* format attribute */  print_usage)(enum SeqAlignCmdType cmd_type ,
                                                   score_t *defaults , char const   *cmdstr ,
                                                   char const   *errfmt  , ...) 
{ 
  va_list___0 argptr ;
  size_t___0 tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 76
  if ((unsigned long )errfmt != (unsigned long )((void *)0)) {
#line 77
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: ");
#line 79
    __builtin_va_start(argptr, errfmt);
#line 80
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )errfmt, argptr);
#line 81
    __builtin_va_end(argptr);
#line 83
    tmp = strlen(errfmt);
#line 83
    if ((int const   )*(errfmt + (tmp - 1UL)) != 10) {
#line 83
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
  }
#line 86
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: %s [OPTIONS] [seq1 seq2]\n",
          cmdstr);
#line 88
  if ((unsigned int )cmd_type == 0U) {
#line 88
    tmp___0 = "local";
  } else {
#line 88
    tmp___0 = "global";
  }
#line 88
  if ((unsigned int )cmd_type == 0U) {
#line 88
    tmp___1 = "Smith-Waterman";
  } else {
#line 88
    tmp___1 = "Needleman-Wunsch";
  }
#line 88
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %s optimal %s alignment (maximises score).  \n  Takes a pair of sequences on the command line, or can read from a\n  file and from sequence piped in.  Can read gzip files, FASTA and FASTQ.\n\n",
          tmp___1, tmp___0);
#line 95
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  OPTIONS:\n    --file <file>        Sequence file reading with gzip support - read two\n                         sequences at a time and align them\n    --files <f1> <f2>    Read one sequence from each file to align at one time\n    --stdin              Read from STDIN (same as \'--file -\')\n\n    --case_sensitive     Use case sensitive character comparison [default: off]\n\n    --match <score>      [default: %i]\n    --mismatch <score>   [default: %i]\n    --gapopen <score>    [default: %i]\n    --gapextend <score>  [default: %i]\n\n    --scoring <PAM30|PAM70|BLOSUM80|BLOSUM62>\n    --substitution_matrix <file>  see details for formatting\n    --substitution_pairs <file>   see details for formatting\n\n    --wildcard <w> <s>   Character <w> matches all characters with score <s>\n\n",
          *(defaults + 0), *(defaults + 1), *(defaults + 2), *(defaults + 3));
#line 117
  if ((unsigned int )cmd_type == 0U) {
#line 120
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    --minscore <score>   Minimum required score\n                         [default: match * MAX(0.2 * length, 2)]\n    --maxhits <hits>     Maximum number of results per alignment\n                         [default: no limit]\n\n    --context <n>        Print <n> bases of context\n    --printseq           Print sequences before local alignments\n");
  } else {
#line 132
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    --freestartgap       No penalty for gap at start of alignment\n    --freeendgap         No penalty for gap at end of alignment\n\n    --printscores        Print optimal alignment scores\n    --zam                A funky type of output\n");
  }
#line 141
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    --printmatrices      Print dynamic programming matrices\n    --printfasta         Print fasta header lines\n    --pretty             Print with a descriptor line\n    --colour             Print with colour\n\n  Experimental Options:\n    --nogapsin1          No gaps allowed within the first sequence\n    --nogapsin2          No gaps allowed within the second sequence\n    --nogaps             No gaps allowed in either sequence\n");
#line 152
  if ((unsigned int )cmd_type == 0U) {
#line 152
    tmp___2 = "";
  } else {
#line 152
    tmp___2 = " (cannot be used with --nogaps..)";
  }
#line 152
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    --nomismatches       No mismatches allowed%s\n",
          tmp___2);
#line 156
  printf((char const   * __restrict  )"\n DETAILS:\n  * For help choosing scoring, see the README file. \n  * Gap (of length N) penalty is: (open+N*extend)\n  * To do alignment without affine gap penalty, set \'--gapopen 0\'.\n  * Scoring files should be matrices, with entries separated by a single\n    character or whitespace. See files in the \'scores\' directory for examples.\n\n  turner.isaac@gmail.com  (compiled: %s %s)\n",
         "Apr 19 2023", "21:58:41");
#line 167
  exit(1);
}
}
#line 170 "src/alignment_cmdline.c"
void cmdline_free(cmdline_t *cmd ) 
{ 


  {
#line 172
  free((void *)cmd->file_paths1);
#line 173
  free((void *)cmd->file_paths2);
#line 174
  free((void *)cmd);
#line 175
  return;
}
}
#line 179 "src/alignment_cmdline.c"
cmdline_t *cmdline_new(int argc , char **argv , scoring_t *scoring , enum SeqAlignCmdType cmd_type ) 
{ 
  cmdline_t *cmd ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  score_t defaults[4] ;
  char scoring_set ;
  char substitutions_set ;
  char match_set ;
  char mismatch_set ;
  int argi ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  gzFile sub_matrix_file ;
  gzFile tmp___13 ;
  gzFile sub_pairs_file ;
  gzFile tmp___14 ;
  char tmp___15 ;
  char tmp___16 ;
  char tmp___17 ;
  char tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  char tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int wildscore ;
  size_t___0 tmp___24 ;
  char tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;

  {
#line 182
  tmp = calloc((size_t )1, sizeof(cmdline_t ));
#line 182
  cmd = (cmdline_t *)tmp;
#line 183
  cmd->file_list_length = (size_t___0 )0;
#line 184
  cmd->file_list_capacity = (size_t___0 )256;
#line 185
  tmp___0 = malloc(sizeof(char *) * cmd->file_list_capacity);
#line 185
  cmd->file_paths1 = (char **)tmp___0;
#line 186
  tmp___1 = malloc(sizeof(char *) * cmd->file_list_capacity);
#line 186
  cmd->file_paths2 = (char **)tmp___1;
#line 187
  tmp___2 = (char const   *)((void *)0);
#line 187
  cmd->seq2 = tmp___2;
#line 187
  cmd->seq1 = tmp___2;
#line 191
  defaults[0] = scoring->match;
#line 191
  defaults[1] = scoring->mismatch;
#line 191
  defaults[2] = scoring->gap_open;
#line 191
  defaults[3] = scoring->gap_extend;
#line 194
  if (argc == 1) {
#line 194
    print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)((void *)0));
  }
#line 200
  scoring_set = (char)0;
#line 200
  substitutions_set = (char)0;
#line 200
  match_set = (char)0;
#line 200
  mismatch_set = (char)0;
#line 203
  argi = 1;
#line 203
  while (argi < argc) {
#line 205
    tmp___10 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--help");
#line 205
    if (tmp___10 == 0) {
#line 209
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)((void *)0));
    } else {
#line 205
      tmp___11 = strcasecmp((char const   *)*(argv + argi), (char const   *)"-help");
#line 205
      if (tmp___11 == 0) {
#line 209
        print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                    (char const   *)((void *)0));
      } else {
#line 205
        tmp___12 = strcasecmp((char const   *)*(argv + argi), (char const   *)"-h");
#line 205
        if (tmp___12 == 0) {
#line 209
          print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                      (char const   *)((void *)0));
        } else {
#line 211
          tmp___9 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--case_sensitive");
#line 211
          if (tmp___9 == 0) {
#line 213
            cmd->case_sensitive = (_Bool)1;
          } else {
#line 215
            tmp___8 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--scoring");
#line 215
            if (tmp___8 == 0) {
#line 217
              if (scoring_set) {
#line 219
                print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                            (char const   *)"More than one scoring system specified - not permitted");
              }
#line 222
              tmp___7 = strcasecmp((char const   *)*(argv + (argi + 1)), (char const   *)"PAM30");
#line 222
              if (tmp___7 == 0) {
#line 224
                scoring_system_PAM30(scoring);
              } else {
#line 226
                tmp___6 = strcasecmp((char const   *)*(argv + (argi + 1)), (char const   *)"PAM70");
#line 226
                if (tmp___6 == 0) {
#line 228
                  scoring_system_PAM70(scoring);
                } else {
#line 230
                  tmp___5 = strcasecmp((char const   *)*(argv + (argi + 1)), (char const   *)"BLOSUM80");
#line 230
                  if (tmp___5 == 0) {
#line 232
                    scoring_system_BLOSUM80(scoring);
                  } else {
#line 234
                    tmp___4 = strcasecmp((char const   *)*(argv + (argi + 1)), (char const   *)"BLOSUM62");
#line 234
                    if (tmp___4 == 0) {
#line 236
                      scoring_system_BLOSUM62(scoring);
                    } else {
#line 238
                      tmp___3 = strcasecmp((char const   *)*(argv + (argi + 1)), (char const   *)"DNA_HYBRIDIZATION");
#line 238
                      if (tmp___3 == 0) {
#line 240
                        scoring_system_DNA_hybridization(scoring);
                      } else {
#line 243
                        print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                                    (char const   *)"Unknown --scoring choice, not one of PAM30|PAM70|BLOSUM80|BLOSUM62");
                      }
                    }
                  }
                }
              }
#line 247
              scoring_set = (char)1;
#line 248
              argi ++;
            }
          }
        }
      }
    }
#line 203
    argi ++;
  }
#line 252
  argi = 1;
#line 252
  while (argi < argc) {
#line 254
    if ((int )*(*(argv + argi) + 0) == 45) {
#line 257
      tmp___53 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--freestartgap");
#line 257
      if (tmp___53 == 0) {
#line 259
        if ((unsigned int )cmd_type != 1U) {
#line 260
          print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                      (char const   *)"--freestartgap only valid with Needleman-Wunsch");
        }
#line 261
        scoring->no_start_gap_penalty = (_Bool)1;
      } else {
#line 263
        tmp___52 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--freeendgap");
#line 263
        if (tmp___52 == 0) {
#line 265
          if ((unsigned int )cmd_type != 1U) {
#line 266
            print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                        (char const   *)"--freeendgap only valid with Needleman-Wunsch");
          }
#line 267
          scoring->no_end_gap_penalty = (_Bool)1;
        } else {
#line 269
          tmp___51 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--nogaps");
#line 269
          if (tmp___51 == 0) {
#line 271
            scoring->no_gaps_in_a = (_Bool)1;
#line 272
            scoring->no_gaps_in_b = (_Bool)1;
          } else {
#line 274
            tmp___50 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--nogapsin1");
#line 274
            if (tmp___50 == 0) {
#line 276
              scoring->no_gaps_in_a = (_Bool)1;
            } else {
#line 278
              tmp___49 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--nogapsin2");
#line 278
              if (tmp___49 == 0) {
#line 280
                scoring->no_gaps_in_b = (_Bool)1;
              } else {
#line 282
                tmp___48 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--nomismatches");
#line 282
                if (tmp___48 == 0) {
#line 284
                  scoring->no_mismatches = (_Bool)1;
                } else {
#line 286
                  tmp___47 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--case_sensitive");
#line 286
                  if (! (tmp___47 == 0)) {
#line 291
                    tmp___46 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--printseq");
#line 291
                    if (tmp___46 == 0) {
#line 293
                      if ((unsigned int )cmd_type != 0U) {
#line 294
                        print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                                    (char const   *)"--printseq only valid with Smith-Waterman");
                      }
#line 295
                      cmd->print_seq = (_Bool)1;
                    } else {
#line 297
                      tmp___45 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--printmatrices");
#line 297
                      if (tmp___45 == 0) {
#line 299
                        cmd->print_matrices = (_Bool)1;
                      } else {
#line 301
                        tmp___44 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--printscores");
#line 301
                        if (tmp___44 == 0) {
#line 303
                          if ((unsigned int )cmd_type != 1U) {
#line 304
                            print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                                        (char const   *)"--printscores only valid with Needleman-Wunsch");
                          }
#line 305
                          cmd->print_scores = (_Bool)1;
                        } else {
#line 307
                          tmp___43 = strcasecmp((char const   *)*(argv + argi), (char const   *)"--printfasta");
#line 307
                          if (tmp___43 == 0) {
#line 309
                            cmd->print_fasta = (_Bool)1;
                          } else {
#line 311
                            tmp___42 = strcasecmp((char const   *)*(argv + argi),
                                                  (char const   *)"--pretty");
#line 311
                            if (tmp___42 == 0) {
#line 313
                              cmd->print_pretty = (_Bool)1;
                            } else {
#line 315
                              tmp___41 = strcasecmp((char const   *)*(argv + argi),
                                                    (char const   *)"--colour");
#line 315
                              if (tmp___41 == 0) {
#line 317
                                cmd->print_colour = (_Bool)1;
                              } else {
#line 319
                                tmp___40 = strcasecmp((char const   *)*(argv + argi),
                                                      (char const   *)"--zam");
#line 319
                                if (tmp___40 == 0) {
#line 321
                                  if ((unsigned int )cmd_type != 1U) {
#line 322
                                    print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                                                (char const   *)"--zam only valid with Needleman-Wunsch");
                                  }
#line 323
                                  cmd->zam_stle_output = (_Bool)1;
                                } else {
#line 325
                                  tmp___39 = strcasecmp((char const   *)*(argv + argi),
                                                        (char const   *)"--stdin");
#line 325
                                  if (tmp___39 == 0) {
#line 328
                                    cmdline_add_files(cmd, "", (char *)((void *)0));
#line 329
                                    cmd->interactive = (_Bool)1;
                                  } else
#line 331
                                  if (argi == argc - 1) {
#line 334
                                    print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                                                (char const   *)"Unknown argument without parameter: %s",
                                                *(argv + argi));
                                  } else {
#line 336
                                    tmp___38 = strcasecmp((char const   *)*(argv + argi),
                                                          (char const   *)"--scoring");
#line 336
                                    if (tmp___38 == 0) {
#line 339
                                      argi ++;
                                    } else {
#line 341
                                      tmp___37 = strcasecmp((char const   *)*(argv + argi),
                                                            (char const   *)"--substitution_matrix");
#line 341
                                      if (tmp___37 == 0) {
#line 343
                                        tmp___13 = gzopen((char const   *)*(argv + (argi + 1)),
                                                          (char const   *)"r");
#line 343
                                        sub_matrix_file = tmp___13;
#line 344
                                        if ((unsigned long )sub_matrix_file == (unsigned long )((void *)0)) {
#line 344
                                          print_usage(cmd_type, (score_t *)(defaults),
                                                      (char const   *)*(argv + 0),
                                                      (char const   *)"Couldn\'t read: %s",
                                                      *(argv + (argi + 1)));
                                        }
#line 346
                                        align_scoring_load_matrix(sub_matrix_file,
                                                                  (char const   *)*(argv + (argi + 1)),
                                                                  scoring, (char )cmd->case_sensitive);
#line 349
                                        gzclose(sub_matrix_file);
#line 350
                                        substitutions_set = (char)1;
#line 352
                                        argi ++;
                                      } else {
#line 354
                                        tmp___36 = strcasecmp((char const   *)*(argv + argi),
                                                              (char const   *)"--substitution_pairs");
#line 354
                                        if (tmp___36 == 0) {
#line 356
                                          tmp___14 = gzopen((char const   *)*(argv + (argi + 1)),
                                                            (char const   *)"r");
#line 356
                                          sub_pairs_file = tmp___14;
#line 357
                                          if ((unsigned long )sub_pairs_file == (unsigned long )((void *)0)) {
#line 357
                                            print_usage(cmd_type, (score_t *)(defaults),
                                                        (char const   *)*(argv + 0),
                                                        (char const   *)"Couldn\'t read: %s",
                                                        *(argv + (argi + 1)));
                                          }
#line 359
                                          align_scoring_load_pairwise(sub_pairs_file,
                                                                      (char const   *)*(argv + (argi + 1)),
                                                                      scoring, (char )cmd->case_sensitive);
#line 362
                                          gzclose(sub_pairs_file);
#line 363
                                          substitutions_set = (char)1;
#line 365
                                          argi ++;
                                        } else {
#line 367
                                          tmp___35 = strcasecmp((char const   *)*(argv + argi),
                                                                (char const   *)"--minscore");
#line 367
                                          if (tmp___35 == 0) {
#line 369
                                            if ((unsigned int )cmd_type != 0U) {
#line 370
                                              print_usage(cmd_type, (score_t *)(defaults),
                                                          (char const   *)*(argv + 0),
                                                          (char const   *)"--minscore only valid with Smith-Waterman");
                                            }
#line 372
                                            tmp___15 = parse_entire_int(*(argv + (argi + 1)),
                                                                        & cmd->min_score);
#line 372
                                            if (! tmp___15) {
#line 373
                                              print_usage(cmd_type, (score_t *)(defaults),
                                                          (char const   *)*(argv + 0),
                                                          (char const   *)"Invalid --minscore <score> argument (must be a +ve int)");
                                            }
#line 375
                                            cmd->min_score_set = (_Bool)1;
#line 377
                                            argi ++;
                                          } else {
#line 379
                                            tmp___34 = strcasecmp((char const   *)*(argv + argi),
                                                                  (char const   *)"--maxhits");
#line 379
                                            if (tmp___34 == 0) {
#line 381
                                              if ((unsigned int )cmd_type != 0U) {
#line 382
                                                print_usage(cmd_type, (score_t *)(defaults),
                                                            (char const   *)*(argv + 0),
                                                            (char const   *)"--maxhits only valid with Smith-Waterman");
                                              }
#line 384
                                              tmp___16 = parse_entire_uint(*(argv + (argi + 1)),
                                                                           & cmd->max_hits_per_alignment);
#line 384
                                              if (! tmp___16) {
#line 385
                                                print_usage(cmd_type, (score_t *)(defaults),
                                                            (char const   *)*(argv + 0),
                                                            (char const   *)"Invalid --maxhits <hits> argument (must be a +ve int)");
                                              }
#line 387
                                              cmd->max_hits_per_alignment_set = (_Bool)1;
#line 389
                                              argi ++;
                                            } else {
#line 391
                                              tmp___33 = strcasecmp((char const   *)*(argv + argi),
                                                                    (char const   *)"--context");
#line 391
                                              if (tmp___33 == 0) {
#line 393
                                                if ((unsigned int )cmd_type != 0U) {
#line 394
                                                  print_usage(cmd_type, (score_t *)(defaults),
                                                              (char const   *)*(argv + 0),
                                                              (char const   *)"--context only valid with Smith-Waterman");
                                                }
#line 396
                                                tmp___17 = parse_entire_uint(*(argv + (argi + 1)),
                                                                             & cmd->print_context);
#line 396
                                                if (! tmp___17) {
#line 397
                                                  print_usage(cmd_type, (score_t *)(defaults),
                                                              (char const   *)*(argv + 0),
                                                              (char const   *)"Invalid --context <c> argument (must be >= 0)");
                                                }
#line 399
                                                argi ++;
                                              } else {
#line 401
                                                tmp___32 = strcasecmp((char const   *)*(argv + argi),
                                                                      (char const   *)"--match");
#line 401
                                                if (tmp___32 == 0) {
#line 403
                                                  tmp___18 = parse_entire_int(*(argv + (argi + 1)),
                                                                              & scoring->match);
#line 403
                                                  if (! tmp___18) {
#line 405
                                                    print_usage(cmd_type, (score_t *)(defaults),
                                                                (char const   *)*(argv + 0),
                                                                (char const   *)"Invalid --match argument (\'%s\') must be an int",
                                                                *(argv + (argi + 1)));
                                                  }
#line 408
                                                  match_set = (char)1;
#line 409
                                                  argi ++;
                                                } else {
#line 411
                                                  tmp___31 = strcasecmp((char const   *)*(argv + argi),
                                                                        (char const   *)"--mismatch");
#line 411
                                                  if (tmp___31 == 0) {
#line 413
                                                    tmp___19 = parse_entire_int(*(argv + (argi + 1)),
                                                                                & scoring->mismatch);
#line 413
                                                    if (! tmp___19) {
#line 415
                                                      print_usage(cmd_type, (score_t *)(defaults),
                                                                  (char const   *)*(argv + 0),
                                                                  (char const   *)"Invalid --mismatch argument (\'%s\') must be an int",
                                                                  *(argv + (argi + 1)));
                                                    }
#line 418
                                                    mismatch_set = (char)1;
#line 419
                                                    argi ++;
                                                  } else {
#line 421
                                                    tmp___30 = strcasecmp((char const   *)*(argv + argi),
                                                                          (char const   *)"--gapopen");
#line 421
                                                    if (tmp___30 == 0) {
#line 423
                                                      tmp___20 = parse_entire_int(*(argv + (argi + 1)),
                                                                                  & scoring->gap_open);
#line 423
                                                      if (! tmp___20) {
#line 425
                                                        print_usage(cmd_type, (score_t *)(defaults),
                                                                    (char const   *)*(argv + 0),
                                                                    (char const   *)"Invalid --gapopen argument (\'%s\') must be an int",
                                                                    *(argv + (argi + 1)));
                                                      }
#line 428
                                                      argi ++;
                                                    } else {
#line 430
                                                      tmp___29 = strcasecmp((char const   *)*(argv + argi),
                                                                            (char const   *)"--gapextend");
#line 430
                                                      if (tmp___29 == 0) {
#line 432
                                                        tmp___21 = parse_entire_int(*(argv + (argi + 1)),
                                                                                    & scoring->gap_extend);
#line 432
                                                        if (! tmp___21) {
#line 434
                                                          print_usage(cmd_type, (score_t *)(defaults),
                                                                      (char const   *)*(argv + 0),
                                                                      (char const   *)"Invalid --gapextend argument (\'%s\') must be an int",
                                                                      *(argv + (argi + 1)));
                                                        }
#line 438
                                                        argi ++;
                                                      } else {
#line 440
                                                        tmp___28 = strcasecmp((char const   *)*(argv + argi),
                                                                              (char const   *)"--file");
#line 440
                                                        if (tmp___28 == 0) {
#line 442
                                                          cmdline_add_files(cmd, *(argv + (argi + 1)),
                                                                            (char *)((void *)0));
#line 443
                                                          argi ++;
                                                        } else {
#line 446
                                                          tmp___27 = strcasecmp((char const   *)*(argv + argi),
                                                                                (char const   *)"--files");
#line 446
                                                          if (tmp___27 == 0) {
#line 448
                                                            if (argi >= argc - 2) {
#line 450
                                                              print_usage(cmd_type,
                                                                          (score_t *)(defaults),
                                                                          (char const   *)*(argv + 0),
                                                                          (char const   *)"--files option takes 2 arguments");
                                                            } else {
#line 452
                                                              tmp___22 = strcmp((char const   *)*(argv + (argi + 1)),
                                                                                (char const   *)"-");
#line 452
                                                              if (tmp___22 == 0) {
#line 452
                                                                tmp___23 = strcmp((char const   *)*(argv + (argi + 2)),
                                                                                  (char const   *)"-");
#line 452
                                                                if (tmp___23 == 0) {
#line 455
                                                                  cmdline_add_files(cmd,
                                                                                    *(argv + (argi + 1)),
                                                                                    (char *)((void *)0));
                                                                } else {
#line 459
                                                                  cmdline_add_files(cmd,
                                                                                    *(argv + (argi + 1)),
                                                                                    *(argv + (argi + 2)));
                                                                }
                                                              } else {
#line 459
                                                                cmdline_add_files(cmd,
                                                                                  *(argv + (argi + 1)),
                                                                                  *(argv + (argi + 2)));
                                                              }
                                                            }
#line 462
                                                            argi += 2;
                                                          } else {
#line 464
                                                            tmp___26 = strcasecmp((char const   *)*(argv + argi),
                                                                                  (char const   *)"--wildcard");
#line 464
                                                            if (tmp___26 == 0) {
#line 466
                                                              wildscore = 0;
#line 468
                                                              if (argi == argc - 2) {
#line 471
                                                                print_usage(cmd_type,
                                                                            (score_t *)(defaults),
                                                                            (char const   *)*(argv + 0),
                                                                            (char const   *)"--wildcard <w> <s> takes a single character and a number");
                                                              } else {
#line 468
                                                                tmp___24 = strlen((char const   *)*(argv + (argi + 1)));
#line 468
                                                                if (tmp___24 != 1UL) {
#line 471
                                                                  print_usage(cmd_type,
                                                                              (score_t *)(defaults),
                                                                              (char const   *)*(argv + 0),
                                                                              (char const   *)"--wildcard <w> <s> takes a single character and a number");
                                                                } else {
#line 468
                                                                  tmp___25 = parse_entire_int(*(argv + (argi + 2)),
                                                                                              & wildscore);
#line 468
                                                                  if (! tmp___25) {
#line 471
                                                                    print_usage(cmd_type,
                                                                                (score_t *)(defaults),
                                                                                (char const   *)*(argv + 0),
                                                                                (char const   *)"--wildcard <w> <s> takes a single character and a number");
                                                                  }
                                                                }
                                                              }
#line 474
                                                              scoring_add_wildcard(scoring,
                                                                                   *(*(argv + (argi + 1)) + 0),
                                                                                   wildscore);
#line 476
                                                              argi += 2;
                                                            } else {
#line 478
                                                              print_usage(cmd_type,
                                                                          (score_t *)(defaults),
                                                                          (char const   *)*(argv + 0),
                                                                          (char const   *)"Unknown argument \'%s\'",
                                                                          *(argv + argi));
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
#line 482
      if (argc - argi != 2) {
#line 482
        print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                    (char const   *)"Unknown options: \'%s\'", *(argv + argi));
      }
#line 483
      break;
    }
#line 252
    argi ++;
  }
#line 487
  if (match_set) {
#line 487
    if (! mismatch_set) {
#line 487
      if (! scoring->no_mismatches) {
#line 490
        print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                    (char const   *)"--match --mismatch must both be set or neither set");
      } else {
#line 487
        goto _L___1;
      }
    } else {
#line 487
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 487
  if (! match_set) {
#line 487
    if (mismatch_set) {
#line 490
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)"--match --mismatch must both be set or neither set");
    } else {
#line 487
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 492
  if (substitutions_set) {
#line 492
    if (! match_set) {
#line 495
      scoring->use_match_mismatch = (_Bool)0;
    }
  }
#line 498
  if (scoring->use_match_mismatch) {
#line 498
    if (scoring->match < scoring->mismatch) {
#line 499
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)"Match value should not be less than mismatch penalty");
    }
  }
#line 504
  if ((unsigned int )cmd_type == 1U) {
#line 504
    if (scoring->no_mismatches) {
#line 504
      if (scoring->no_gaps_in_a) {
#line 507
        print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                    (char const   *)"--nogaps.. --nomismatches cannot be used at together");
      } else
#line 504
      if (scoring->no_gaps_in_b) {
#line 507
        print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0),
                    (char const   *)"--nogaps.. --nomismatches cannot be used at together");
      }
    }
  }
#line 512
  if (argi < argc) {
#line 514
    cmd->seq1 = (char const   *)*(argv + argi);
#line 515
    cmd->seq2 = (char const   *)*(argv + (argi + 1));
  }
#line 518
  if ((unsigned long )cmd->seq1 == (unsigned long )((void *)0)) {
#line 518
    if (cmd->file_list_length == 0UL) {
#line 520
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)"No input specified");
    }
  }
#line 523
  if (cmd->zam_stle_output) {
#line 523
    if (cmd->print_pretty) {
#line 527
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)"Cannot use --printscore, --printfasta, --pretty or --colour with --zam");
    } else
#line 523
    if (cmd->print_scores) {
#line 527
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)"Cannot use --printscore, --printfasta, --pretty or --colour with --zam");
    } else
#line 523
    if (cmd->print_colour) {
#line 527
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)"Cannot use --printscore, --printfasta, --pretty or --colour with --zam");
    } else
#line 523
    if (cmd->print_fasta) {
#line 527
      print_usage(cmd_type, (score_t *)(defaults), (char const   *)*(argv + 0), (char const   *)"Cannot use --printscore, --printfasta, --pretty or --colour with --zam");
    }
  }
#line 531
  return (cmd);
}
}
#line 535 "src/alignment_cmdline.c"
void cmdline_add_files(cmdline_t *cmd , char *p1 , char *p2 ) 
{ 
  size_t___0 mem ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 537
  if (cmd->file_list_length == cmd->file_list_capacity) {
#line 539
    cmd->file_list_capacity *= 2UL;
#line 540
    mem = sizeof(char *) * cmd->file_list_capacity;
#line 541
    tmp = realloc((void *)cmd->file_paths1, mem);
#line 541
    cmd->file_paths1 = (char **)tmp;
#line 542
    tmp___0 = realloc((void *)cmd->file_paths2, mem);
#line 542
    cmd->file_paths2 = (char **)tmp___0;
#line 544
    if ((unsigned long )cmd->file_paths1 == (unsigned long )((void *)0)) {
#line 545
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: Out of memory\n",
              "src/alignment_cmdline.c", 545);
#line 546
      exit(1);
    } else
#line 544
    if ((unsigned long )cmd->file_paths2 == (unsigned long )((void *)0)) {
#line 545
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: Out of memory\n",
              "src/alignment_cmdline.c", 545);
#line 546
      exit(1);
    }
  }
#line 550
  *(cmd->file_paths1 + cmd->file_list_length) = p1;
#line 551
  *(cmd->file_paths2 + cmd->file_list_length) = p2;
#line 552
  (cmd->file_list_length) ++;
#line 553
  return;
}
}
#line 555 "src/alignment_cmdline.c"
size_t___0 cmdline_get_num_of_file_pairs(cmdline_t *cmd ) 
{ 


  {
#line 557
  return (cmd->file_list_length);
}
}
#line 560 "src/alignment_cmdline.c"
char *cmdline_get_file1(cmdline_t *cmd , size_t___0 i ) 
{ 


  {
#line 562
  return (*(cmd->file_paths1 + i));
}
}
#line 565 "src/alignment_cmdline.c"
char *cmdline_get_file2(cmdline_t *cmd , size_t___0 i ) 
{ 


  {
#line 567
  return (*(cmd->file_paths2 + i));
}
}
#line 570 "src/alignment_cmdline.c"
static seq_file_t *open_seq_file(char const   *path , _Bool use_zlib ) 
{ 
  seq_file_t *tmp___0 ;
  int tmp___1 ;
  seq_file_t *tmp___2 ;
  seq_file_t *tmp___3 ;
  int tmp___4 ;

  {
#line 572
  tmp___4 = strcmp(path, (char const   *)"-");
#line 572
  if (tmp___4 != 0) {
#line 572
    tmp___0 = seq_open(path);
#line 572
    tmp___3 = tmp___0;
  } else
#line 572
  if (use_zlib) {
#line 572
    tmp___0 = seq_open(path);
#line 572
    tmp___3 = tmp___0;
  } else {
#line 572
    tmp___1 = fileno((FILE *)stdin);
#line 572
    tmp___2 = seq_dopen(tmp___1, (char)0, (_Bool)0, (size_t___0 )0);
#line 572
    tmp___3 = tmp___2;
  }
#line 572
  return (tmp___3);
}
}
#line 578 "src/alignment_cmdline.c"
void align_from_file(char const   *path1 , char const   *path2 , void (*align)(read_t *r1 ,
                                                                               read_t *r2 ) ,
                     _Bool use_zlib ) 
{ 
  seq_file_t *sf1 ;
  seq_file_t *sf2 ;
  read_t read1 ;
  read_t read2 ;
  unsigned long alignments ;
  int tmp ;
  int tmp___0 ;

  {
#line 584
  sf1 = open_seq_file(path1, use_zlib);
#line 584
  if ((unsigned long )sf1 == (unsigned long )((void *)0)) {
#line 586
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Alignment Error: couldn\'t open file %s\n",
            path1);
#line 587
    fflush((FILE *)stderr);
#line 588
    return;
  }
#line 591
  if ((unsigned long )path2 == (unsigned long )((void *)0)) {
#line 593
    sf2 = sf1;
  } else {
#line 595
    sf2 = open_seq_file(path2, use_zlib);
#line 595
    if ((unsigned long )sf2 == (unsigned long )((void *)0)) {
#line 597
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Alignment Error: couldn\'t open file %s\n",
              path1);
#line 598
      fflush((FILE *)stderr);
#line 599
      return;
    }
  }
#line 605
  seq_read_alloc(& read1);
#line 606
  seq_read_alloc(& read2);
#line 611
  alignments = 0UL;
#line 611
  while (1) {
#line 611
    tmp___0 = (*(sf1->readfunc))(sf1, & read1);
#line 611
    if (! (tmp___0 > 0)) {
#line 611
      break;
    }
#line 613
    tmp = (*(sf2->readfunc))(sf2, & read2);
#line 613
    if (tmp <= 0) {
#line 615
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Alignment Error: Odd number of sequences - I read in pairs!\n");
#line 617
      fflush((FILE *)stderr);
#line 618
      break;
    }
#line 621
    (*align)(& read1, & read2);
#line 611
    alignments ++;
  }
#line 625
  if (alignments == 0UL) {
#line 627
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Alignment Warning: empty input\n");
#line 628
    fflush((FILE *)stderr);
  }
#line 632
  seq_close(sf1);
#line 634
  if ((unsigned long )path2 != (unsigned long )((void *)0)) {
#line 635
    seq_close(sf2);
  }
#line 638
  seq_read_dealloc(& read1);
#line 639
  seq_read_dealloc(& read2);
#line 640
  return;
}
}
#line 1 "cil-in6RvXkx.o"
#pragma merger("0","/tmp/cil-gWPtMrYO.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 58 "src/alignment_scoring.h"
void scoring_init(scoring_t *scoring , int match , int mismatch , int gap_open , int gap_extend ,
                  _Bool no_start_gap_penalty , _Bool no_end_gap_penalty , _Bool no_gaps_in_a ,
                  _Bool no_gaps_in_b , _Bool no_mismatches , _Bool case_sensitive ) ;
#line 68
void scoring_add_mutation(scoring_t *scoring , char a , char b , int score ) ;
#line 70
void scoring_print(scoring_t const   *scoring ) ;
#line 81
void scoring_system_default(scoring_t *scoring ) ;
#line 21 "src/alignment_scoring.c"
void scoring_init(scoring_t *scoring , int match , int mismatch , int gap_open , int gap_extend ,
                  _Bool no_start_gap_penalty , _Bool no_end_gap_penalty , _Bool no_gaps_in_a ,
                  _Bool no_gaps_in_b , _Bool no_mismatches , _Bool case_sensitive ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 30
  scoring->gap_open = gap_open;
#line 31
  scoring->gap_extend = gap_extend;
#line 33
  scoring->no_start_gap_penalty = no_start_gap_penalty;
#line 34
  scoring->no_end_gap_penalty = no_end_gap_penalty;
#line 36
  scoring->no_gaps_in_a = no_gaps_in_a;
#line 37
  scoring->no_gaps_in_b = no_gaps_in_b;
#line 38
  scoring->no_mismatches = no_mismatches;
#line 40
  scoring->use_match_mismatch = (_Bool)1;
#line 41
  scoring->match = match;
#line 42
  scoring->mismatch = mismatch;
#line 44
  scoring->case_sensitive = case_sensitive;
#line 46
  memset((void *)(scoring->wildcards), 0, sizeof(scoring->wildcards));
#line 47
  memset((void *)(scoring->swap_set), 0, sizeof(scoring->swap_set));
#line 49
  if (match <= mismatch) {
#line 49
    scoring->min_penalty = match;
  } else {
#line 49
    scoring->min_penalty = mismatch;
  }
#line 50
  if (match >= mismatch) {
#line 50
    scoring->max_penalty = match;
  } else {
#line 50
    scoring->max_penalty = mismatch;
  }
#line 51
  if (! no_gaps_in_a) {
#line 51
    goto _L___1;
  } else
#line 51
  if (! no_gaps_in_b) {
    _L___1: /* CIL Label */ 
#line 52
    if (scoring->min_penalty <= gap_open + gap_extend) {
#line 52
      if (scoring->min_penalty <= gap_extend) {
#line 52
        scoring->min_penalty = scoring->min_penalty;
      } else {
#line 52
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 52
      if (gap_open + gap_extend <= gap_extend) {
#line 52
        tmp = gap_open + gap_extend;
      } else {
#line 52
        tmp = gap_extend;
      }
#line 52
      scoring->min_penalty = tmp;
    }
#line 53
    if (scoring->max_penalty >= gap_open + gap_extend) {
#line 53
      if (scoring->max_penalty >= gap_extend) {
#line 53
        scoring->max_penalty = scoring->max_penalty;
      } else {
#line 53
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 53
      if (gap_open + gap_extend >= gap_extend) {
#line 53
        tmp___0 = gap_open + gap_extend;
      } else {
#line 53
        tmp___0 = gap_extend;
      }
#line 53
      scoring->max_penalty = tmp___0;
    }
  }
#line 55
  return;
}
}
#line 57 "src/alignment_scoring.c"
void scoring_add_wildcard(scoring_t *scoring , char c , int score ) 
{ 
  int tmp ;

  {
#line 59
  if (! scoring->case_sensitive) {
#line 59
    tmp = tolower((int )c);
#line 59
    c = (char )tmp;
  }
#line 60
  scoring->wildcards[(int )c >> 5] |= (unsigned int )(1 << ((int )c & 31));
#line 61
  scoring->wildscores[(size_t___0 )c] = score;
#line 62
  if (scoring->min_penalty <= score) {
#line 62
    scoring->min_penalty = scoring->min_penalty;
  } else {
#line 62
    scoring->min_penalty = score;
  }
#line 63
  if (scoring->max_penalty >= score) {
#line 63
    scoring->max_penalty = scoring->max_penalty;
  } else {
#line 63
    scoring->max_penalty = score;
  }
#line 64
  return;
}
}
#line 66 "src/alignment_scoring.c"
void scoring_add_mutation(scoring_t *scoring , char a , char b , int score ) 
{ 


  {
#line 68
  scoring->swap_scores[(size_t___0 )a][(size_t___0 )b] = score;
#line 69
  scoring->swap_set[(size_t___0 )a][(int )b >> 5] |= (unsigned int )(1 << ((int )b & 31));
#line 70
  if (scoring->min_penalty <= score) {
#line 70
    scoring->min_penalty = scoring->min_penalty;
  } else {
#line 70
    scoring->min_penalty = score;
  }
#line 71
  if (scoring->max_penalty >= score) {
#line 71
    scoring->max_penalty = scoring->max_penalty;
  } else {
#line 71
    scoring->max_penalty = score;
  }
#line 72
  return;
}
}
#line 74 "src/alignment_scoring.c"
void scoring_add_mutations(scoring_t *scoring , char const   *str , int const   *scores ,
                           char use_match_mismatch ) 
{ 
  size_t___0 i ;
  size_t___0 j ;
  size_t___0 len ;
  size_t___0 tmp ;
  char a ;
  char b ;
  int score ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 77
  tmp = strlen(str);
#line 77
  len = tmp;
#line 81
  i = (size_t___0 )0;
#line 81
  while (i < len) {
#line 83
    if (scoring->case_sensitive) {
#line 83
      a = (char )*(str + i);
    } else {
#line 83
      tmp___0 = tolower((int )*(str + i));
#line 83
      a = (char )tmp___0;
    }
#line 85
    j = (size_t___0 )0;
#line 85
    while (j < len) {
#line 87
      if (scoring->case_sensitive) {
#line 87
        b = (char )*(str + j);
      } else {
#line 87
        tmp___1 = tolower((int )*(str + j));
#line 87
        b = (char )tmp___1;
      }
#line 88
      score = (int )*(scores + (j * len + i));
#line 90
      scoring_add_mutation(scoring, a, b, score);
#line 85
      j ++;
    }
#line 81
    i ++;
  }
#line 94
  scoring->use_match_mismatch = (_Bool )use_match_mismatch;
#line 95
  return;
}
}
#line 97 "src/alignment_scoring.c"
void scoring_print(scoring_t const   *scoring ) 
{ 


  {
#line 99
  printf((char const   * __restrict  )"scoring:\n");
#line 100
  printf((char const   * __restrict  )"  match: %i; mismatch: %i; (use_match_mismatch: %i)\n",
         scoring->match, scoring->mismatch, (int )scoring->use_match_mismatch);
#line 103
  printf((char const   * __restrict  )"  gap_open: %i; gap_extend: %i;\n", scoring->gap_open,
         scoring->gap_extend);
#line 106
  printf((char const   * __restrict  )"  no_gaps_in_a: %i; no_gaps_in_b: %i; no_mismatches: %i;\n",
         (int )scoring->no_gaps_in_a, (int )scoring->no_gaps_in_b, (int )scoring->no_mismatches);
#line 109
  printf((char const   * __restrict  )"  no_start_gap_penalty: %i; no_end_gap_penalty: %i;\n",
         (int )scoring->no_start_gap_penalty, (int )scoring->no_end_gap_penalty);
#line 111
  return;
}
}
#line 115 "src/alignment_scoring.c"
static char _scoring_check_wildcards(scoring_t const   *scoring , char a , char b ,
                                     int *score ) 
{ 
  int tmp_score ;

  {
#line 119
  tmp_score = 2147483647;
#line 120
  if ((scoring->wildcards[(int )a >> 5] >> ((int )a & 31)) & 1U) {
#line 120
    tmp_score = scoring->wildscores[(size_t___0 )a];
  }
#line 121
  if ((scoring->wildcards[(int )b >> 5] >> ((int )b & 31)) & 1U) {
#line 121
    if (scoring->wildscores[(size_t___0 )b] <= tmp_score) {
#line 121
      tmp_score = scoring->wildscores[(size_t___0 )b];
    } else {
#line 121
      tmp_score = tmp_score;
    }
  }
#line 122
  if (tmp_score != 2147483647) {
#line 123
    *score = tmp_score;
#line 124
    return ((char)1);
  }
#line 127
  *score = 0;
#line 128
  return ((char)0);
}
}
#line 133 "src/alignment_scoring.c"
void scoring_lookup(scoring_t const   *scoring , char a , char b , int *score , _Bool *is_match ) 
{ 
  int tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
#line 136
  if (! scoring->case_sensitive) {
#line 138
    tmp = tolower((int )a);
#line 138
    a = (char )tmp;
#line 139
    tmp___0 = tolower((int )b);
#line 139
    b = (char )tmp___0;
  }
#line 146
  *is_match = (_Bool )((int )a == (int )b);
#line 148
  if (scoring->no_mismatches) {
#line 148
    if (! *is_match) {
#line 151
      tmp___1 = _scoring_check_wildcards(scoring, a, b, score);
#line 151
      *is_match = (_Bool )tmp___1;
#line 152
      return;
    }
  }
#line 156
  if ((scoring->swap_set[(size_t___0 )a][(int )b >> 5] >> ((int )b & 31)) & 1U) {
#line 158
    *score = scoring->swap_scores[(size_t___0 )a][(size_t___0 )b];
#line 159
    return;
  }
#line 165
  tmp___2 = _scoring_check_wildcards(scoring, a, b, score);
#line 165
  if (tmp___2) {
#line 167
    *is_match = (_Bool)1;
#line 168
    return;
  }
#line 172
  if (scoring->use_match_mismatch) {
#line 174
    if (*is_match) {
#line 174
      *score = (int )scoring->match;
    } else {
#line 174
      *score = (int )scoring->mismatch;
    }
#line 175
    return;
  }
#line 179
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Unknown character pair (%c,%c) and match/mismatch have not been set\n",
          (int )a, (int )b);
#line 181
  exit(1);
}
}
#line 188 "src/alignment_scoring.c"
static char amino_acids[25]  = 
#line 188
  {      (char )'A',      (char )'R',      (char )'N',      (char )'D', 
        (char )'C',      (char )'Q',      (char )'E',      (char )'G', 
        (char )'H',      (char )'I',      (char )'L',      (char )'K', 
        (char )'M',      (char )'F',      (char )'P',      (char )'S', 
        (char )'T',      (char )'W',      (char )'Y',      (char )'V', 
        (char )'B',      (char )'Z',      (char )'X',      (char )'*', 
        (char )'\000'};
#line 190 "src/alignment_scoring.c"
static int const   pam30[576]  = 
#line 190
  {      (int const   )6,      (int const   )-7,      (int const   )-4,      (int const   )-3, 
        (int const   )-6,      (int const   )-4,      (int const   )-2,      (int const   )-2, 
        (int const   )-7,      (int const   )-5,      (int const   )-6,      (int const   )-7, 
        (int const   )-5,      (int const   )-8,      (int const   )-2,      (int const   )0, 
        (int const   )-1,      (int const   )-13,      (int const   )-8,      (int const   )-2, 
        (int const   )-3,      (int const   )-3,      (int const   )-3,      (int const   )-17, 
        (int const   )-7,      (int const   )8,      (int const   )-6,      (int const   )-10, 
        (int const   )-8,      (int const   )-2,      (int const   )-9,      (int const   )-9, 
        (int const   )-2,      (int const   )-5,      (int const   )-8,      (int const   )0, 
        (int const   )-4,      (int const   )-9,      (int const   )-4,      (int const   )-3, 
        (int const   )-6,      (int const   )-2,      (int const   )-10,      (int const   )-8, 
        (int const   )-7,      (int const   )-4,      (int const   )-6,      (int const   )-17, 
        (int const   )-4,      (int const   )-6,      (int const   )8,      (int const   )2, 
        (int const   )-11,      (int const   )-3,      (int const   )-2,      (int const   )-3, 
        (int const   )0,      (int const   )-5,      (int const   )-7,      (int const   )-1, 
        (int const   )-9,      (int const   )-9,      (int const   )-6,      (int const   )0, 
        (int const   )-2,      (int const   )-8,      (int const   )-4,      (int const   )-8, 
        (int const   )6,      (int const   )-3,      (int const   )-3,      (int const   )-17, 
        (int const   )-3,      (int const   )-10,      (int const   )2,      (int const   )8, 
        (int const   )-14,      (int const   )-2,      (int const   )2,      (int const   )-3, 
        (int const   )-4,      (int const   )-7,      (int const   )-12,      (int const   )-4, 
        (int const   )-11,      (int const   )-15,      (int const   )-8,      (int const   )-4, 
        (int const   )-5,      (int const   )-15,      (int const   )-11,      (int const   )-8, 
        (int const   )6,      (int const   )1,      (int const   )-5,      (int const   )-17, 
        (int const   )-6,      (int const   )-8,      (int const   )-11,      (int const   )-14, 
        (int const   )10,      (int const   )-14,      (int const   )-14,      (int const   )-9, 
        (int const   )-7,      (int const   )-6,      (int const   )-15,      (int const   )-14, 
        (int const   )-13,      (int const   )-13,      (int const   )-8,      (int const   )-3, 
        (int const   )-8,      (int const   )-15,      (int const   )-4,      (int const   )-6, 
        (int const   )-12,      (int const   )-14,      (int const   )-9,      (int const   )-17, 
        (int const   )-4,      (int const   )-2,      (int const   )-3,      (int const   )-2, 
        (int const   )-14,      (int const   )8,      (int const   )1,      (int const   )-7, 
        (int const   )1,      (int const   )-8,      (int const   )-5,      (int const   )-3, 
        (int const   )-4,      (int const   )-13,      (int const   )-3,      (int const   )-5, 
        (int const   )-5,      (int const   )-13,      (int const   )-12,      (int const   )-7, 
        (int const   )-3,      (int const   )6,      (int const   )-5,      (int const   )-17, 
        (int const   )-2,      (int const   )-9,      (int const   )-2,      (int const   )2, 
        (int const   )-14,      (int const   )1,      (int const   )8,      (int const   )-4, 
        (int const   )-5,      (int const   )-5,      (int const   )-9,      (int const   )-4, 
        (int const   )-7,      (int const   )-14,      (int const   )-5,      (int const   )-4, 
        (int const   )-6,      (int const   )-17,      (int const   )-8,      (int const   )-6, 
        (int const   )1,      (int const   )6,      (int const   )-5,      (int const   )-17, 
        (int const   )-2,      (int const   )-9,      (int const   )-3,      (int const   )-3, 
        (int const   )-9,      (int const   )-7,      (int const   )-4,      (int const   )6, 
        (int const   )-9,      (int const   )-11,      (int const   )-10,      (int const   )-7, 
        (int const   )-8,      (int const   )-9,      (int const   )-6,      (int const   )-2, 
        (int const   )-6,      (int const   )-15,      (int const   )-14,      (int const   )-5, 
        (int const   )-3,      (int const   )-5,      (int const   )-5,      (int const   )-17, 
        (int const   )-7,      (int const   )-2,      (int const   )0,      (int const   )-4, 
        (int const   )-7,      (int const   )1,      (int const   )-5,      (int const   )-9, 
        (int const   )9,      (int const   )-9,      (int const   )-6,      (int const   )-6, 
        (int const   )-10,      (int const   )-6,      (int const   )-4,      (int const   )-6, 
        (int const   )-7,      (int const   )-7,      (int const   )-3,      (int const   )-6, 
        (int const   )-1,      (int const   )-1,      (int const   )-5,      (int const   )-17, 
        (int const   )-5,      (int const   )-5,      (int const   )-5,      (int const   )-7, 
        (int const   )-6,      (int const   )-8,      (int const   )-5,      (int const   )-11, 
        (int const   )-9,      (int const   )8,      (int const   )-1,      (int const   )-6, 
        (int const   )-1,      (int const   )-2,      (int const   )-8,      (int const   )-7, 
        (int const   )-2,      (int const   )-14,      (int const   )-6,      (int const   )2, 
        (int const   )-6,      (int const   )-6,      (int const   )-5,      (int const   )-17, 
        (int const   )-6,      (int const   )-8,      (int const   )-7,      (int const   )-12, 
        (int const   )-15,      (int const   )-5,      (int const   )-9,      (int const   )-10, 
        (int const   )-6,      (int const   )-1,      (int const   )7,      (int const   )-8, 
        (int const   )1,      (int const   )-3,      (int const   )-7,      (int const   )-8, 
        (int const   )-7,      (int const   )-6,      (int const   )-7,      (int const   )-2, 
        (int const   )-9,      (int const   )-7,      (int const   )-6,      (int const   )-17, 
        (int const   )-7,      (int const   )0,      (int const   )-1,      (int const   )-4, 
        (int const   )-14,      (int const   )-3,      (int const   )-4,      (int const   )-7, 
        (int const   )-6,      (int const   )-6,      (int const   )-8,      (int const   )7, 
        (int const   )-2,      (int const   )-14,      (int const   )-6,      (int const   )-4, 
        (int const   )-3,      (int const   )-12,      (int const   )-9,      (int const   )-9, 
        (int const   )-2,      (int const   )-4,      (int const   )-5,      (int const   )-17, 
        (int const   )-5,      (int const   )-4,      (int const   )-9,      (int const   )-11, 
        (int const   )-13,      (int const   )-4,      (int const   )-7,      (int const   )-8, 
        (int const   )-10,      (int const   )-1,      (int const   )1,      (int const   )-2, 
        (int const   )11,      (int const   )-4,      (int const   )-8,      (int const   )-5, 
        (int const   )-4,      (int const   )-13,      (int const   )-11,      (int const   )-1, 
        (int const   )-10,      (int const   )-5,      (int const   )-5,      (int const   )-17, 
        (int const   )-8,      (int const   )-9,      (int const   )-9,      (int const   )-15, 
        (int const   )-13,      (int const   )-13,      (int const   )-14,      (int const   )-9, 
        (int const   )-6,      (int const   )-2,      (int const   )-3,      (int const   )-14, 
        (int const   )-4,      (int const   )9,      (int const   )-10,      (int const   )-6, 
        (int const   )-9,      (int const   )-4,      (int const   )2,      (int const   )-8, 
        (int const   )-10,      (int const   )-13,      (int const   )-8,      (int const   )-17, 
        (int const   )-2,      (int const   )-4,      (int const   )-6,      (int const   )-8, 
        (int const   )-8,      (int const   )-3,      (int const   )-5,      (int const   )-6, 
        (int const   )-4,      (int const   )-8,      (int const   )-7,      (int const   )-6, 
        (int const   )-8,      (int const   )-10,      (int const   )8,      (int const   )-2, 
        (int const   )-4,      (int const   )-14,      (int const   )-13,      (int const   )-6, 
        (int const   )-7,      (int const   )-4,      (int const   )-5,      (int const   )-17, 
        (int const   )0,      (int const   )-3,      (int const   )0,      (int const   )-4, 
        (int const   )-3,      (int const   )-5,      (int const   )-4,      (int const   )-2, 
        (int const   )-6,      (int const   )-7,      (int const   )-8,      (int const   )-4, 
        (int const   )-5,      (int const   )-6,      (int const   )-2,      (int const   )6, 
        (int const   )0,      (int const   )-5,      (int const   )-7,      (int const   )-6, 
        (int const   )-1,      (int const   )-5,      (int const   )-3,      (int const   )-17, 
        (int const   )-1,      (int const   )-6,      (int const   )-2,      (int const   )-5, 
        (int const   )-8,      (int const   )-5,      (int const   )-6,      (int const   )-6, 
        (int const   )-7,      (int const   )-2,      (int const   )-7,      (int const   )-3, 
        (int const   )-4,      (int const   )-9,      (int const   )-4,      (int const   )0, 
        (int const   )7,      (int const   )-13,      (int const   )-6,      (int const   )-3, 
        (int const   )-3,      (int const   )-6,      (int const   )-4,      (int const   )-17, 
        (int const   )-13,      (int const   )-2,      (int const   )-8,      (int const   )-15, 
        (int const   )-15,      (int const   )-13,      (int const   )-17,      (int const   )-15, 
        (int const   )-7,      (int const   )-14,      (int const   )-6,      (int const   )-12, 
        (int const   )-13,      (int const   )-4,      (int const   )-14,      (int const   )-5, 
        (int const   )-13,      (int const   )13,      (int const   )-5,      (int const   )-15, 
        (int const   )-10,      (int const   )-14,      (int const   )-11,      (int const   )-17, 
        (int const   )-8,      (int const   )-10,      (int const   )-4,      (int const   )-11, 
        (int const   )-4,      (int const   )-12,      (int const   )-8,      (int const   )-14, 
        (int const   )-3,      (int const   )-6,      (int const   )-7,      (int const   )-9, 
        (int const   )-11,      (int const   )2,      (int const   )-13,      (int const   )-7, 
        (int const   )-6,      (int const   )-5,      (int const   )10,      (int const   )-7, 
        (int const   )-6,      (int const   )-9,      (int const   )-7,      (int const   )-17, 
        (int const   )-2,      (int const   )-8,      (int const   )-8,      (int const   )-8, 
        (int const   )-6,      (int const   )-7,      (int const   )-6,      (int const   )-5, 
        (int const   )-6,      (int const   )2,      (int const   )-2,      (int const   )-9, 
        (int const   )-1,      (int const   )-8,      (int const   )-6,      (int const   )-6, 
        (int const   )-3,      (int const   )-15,      (int const   )-7,      (int const   )7, 
        (int const   )-8,      (int const   )-6,      (int const   )-5,      (int const   )-17, 
        (int const   )-3,      (int const   )-7,      (int const   )6,      (int const   )6, 
        (int const   )-12,      (int const   )-3,      (int const   )1,      (int const   )-3, 
        (int const   )-1,      (int const   )-6,      (int const   )-9,      (int const   )-2, 
        (int const   )-10,      (int const   )-10,      (int const   )-7,      (int const   )-1, 
        (int const   )-3,      (int const   )-10,      (int const   )-6,      (int const   )-8, 
        (int const   )6,      (int const   )0,      (int const   )-5,      (int const   )-17, 
        (int const   )-3,      (int const   )-4,      (int const   )-3,      (int const   )1, 
        (int const   )-14,      (int const   )6,      (int const   )6,      (int const   )-5, 
        (int const   )-1,      (int const   )-6,      (int const   )-7,      (int const   )-4, 
        (int const   )-5,      (int const   )-13,      (int const   )-4,      (int const   )-5, 
        (int const   )-6,      (int const   )-14,      (int const   )-9,      (int const   )-6, 
        (int const   )0,      (int const   )6,      (int const   )-5,      (int const   )-17, 
        (int const   )-3,      (int const   )-6,      (int const   )-3,      (int const   )-5, 
        (int const   )-9,      (int const   )-5,      (int const   )-5,      (int const   )-5, 
        (int const   )-5,      (int const   )-5,      (int const   )-6,      (int const   )-5, 
        (int const   )-5,      (int const   )-8,      (int const   )-5,      (int const   )-3, 
        (int const   )-4,      (int const   )-11,      (int const   )-7,      (int const   )-5, 
        (int const   )-5,      (int const   )-5,      (int const   )-5,      (int const   )-17, 
        (int const   )-17,      (int const   )-17,      (int const   )-17,      (int const   )-17, 
        (int const   )-17,      (int const   )-17,      (int const   )-17,      (int const   )-17, 
        (int const   )-17,      (int const   )-17,      (int const   )-17,      (int const   )-17, 
        (int const   )-17,      (int const   )-17,      (int const   )-17,      (int const   )-17, 
        (int const   )-17,      (int const   )-17,      (int const   )-17,      (int const   )-17, 
        (int const   )-17,      (int const   )-17,      (int const   )-17,      (int const   )1};
#line 216 "src/alignment_scoring.c"
static int const   pam70[576]  = 
#line 216
  {      (int const   )5,      (int const   )-4,      (int const   )-2,      (int const   )-1, 
        (int const   )-4,      (int const   )-2,      (int const   )-1,      (int const   )0, 
        (int const   )-4,      (int const   )-2,      (int const   )-4,      (int const   )-4, 
        (int const   )-3,      (int const   )-6,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )-9,      (int const   )-5,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-2,      (int const   )-11, 
        (int const   )-4,      (int const   )8,      (int const   )-3,      (int const   )-6, 
        (int const   )-5,      (int const   )0,      (int const   )-5,      (int const   )-6, 
        (int const   )0,      (int const   )-3,      (int const   )-6,      (int const   )2, 
        (int const   )-2,      (int const   )-7,      (int const   )-2,      (int const   )-1, 
        (int const   )-4,      (int const   )0,      (int const   )-7,      (int const   )-5, 
        (int const   )-4,      (int const   )-2,      (int const   )-3,      (int const   )-11, 
        (int const   )-2,      (int const   )-3,      (int const   )6,      (int const   )3, 
        (int const   )-7,      (int const   )-1,      (int const   )0,      (int const   )-1, 
        (int const   )1,      (int const   )-3,      (int const   )-5,      (int const   )0, 
        (int const   )-5,      (int const   )-6,      (int const   )-3,      (int const   )1, 
        (int const   )0,      (int const   )-6,      (int const   )-3,      (int const   )-5, 
        (int const   )5,      (int const   )-1,      (int const   )-2,      (int const   )-11, 
        (int const   )-1,      (int const   )-6,      (int const   )3,      (int const   )6, 
        (int const   )-9,      (int const   )0,      (int const   )3,      (int const   )-1, 
        (int const   )-1,      (int const   )-5,      (int const   )-8,      (int const   )-2, 
        (int const   )-7,      (int const   )-10,      (int const   )-4,      (int const   )-1, 
        (int const   )-2,      (int const   )-10,      (int const   )-7,      (int const   )-5, 
        (int const   )5,      (int const   )2,      (int const   )-3,      (int const   )-11, 
        (int const   )-4,      (int const   )-5,      (int const   )-7,      (int const   )-9, 
        (int const   )9,      (int const   )-9,      (int const   )-9,      (int const   )-6, 
        (int const   )-5,      (int const   )-4,      (int const   )-10,      (int const   )-9, 
        (int const   )-9,      (int const   )-8,      (int const   )-5,      (int const   )-1, 
        (int const   )-5,      (int const   )-11,      (int const   )-2,      (int const   )-4, 
        (int const   )-8,      (int const   )-9,      (int const   )-6,      (int const   )-11, 
        (int const   )-2,      (int const   )0,      (int const   )-1,      (int const   )0, 
        (int const   )-9,      (int const   )7,      (int const   )2,      (int const   )-4, 
        (int const   )2,      (int const   )-5,      (int const   )-3,      (int const   )-1, 
        (int const   )-2,      (int const   )-9,      (int const   )-1,      (int const   )-3, 
        (int const   )-3,      (int const   )-8,      (int const   )-8,      (int const   )-4, 
        (int const   )-1,      (int const   )5,      (int const   )-2,      (int const   )-11, 
        (int const   )-1,      (int const   )-5,      (int const   )0,      (int const   )3, 
        (int const   )-9,      (int const   )2,      (int const   )6,      (int const   )-2, 
        (int const   )-2,      (int const   )-4,      (int const   )-6,      (int const   )-2, 
        (int const   )-4,      (int const   )-9,      (int const   )-3,      (int const   )-2, 
        (int const   )-3,      (int const   )-11,      (int const   )-6,      (int const   )-4, 
        (int const   )2,      (int const   )5,      (int const   )-3,      (int const   )-11, 
        (int const   )0,      (int const   )-6,      (int const   )-1,      (int const   )-1, 
        (int const   )-6,      (int const   )-4,      (int const   )-2,      (int const   )6, 
        (int const   )-6,      (int const   )-6,      (int const   )-7,      (int const   )-5, 
        (int const   )-6,      (int const   )-7,      (int const   )-3,      (int const   )0, 
        (int const   )-3,      (int const   )-10,      (int const   )-9,      (int const   )-3, 
        (int const   )-1,      (int const   )-3,      (int const   )-3,      (int const   )-11, 
        (int const   )-4,      (int const   )0,      (int const   )1,      (int const   )-1, 
        (int const   )-5,      (int const   )2,      (int const   )-2,      (int const   )-6, 
        (int const   )8,      (int const   )-6,      (int const   )-4,      (int const   )-3, 
        (int const   )-6,      (int const   )-4,      (int const   )-2,      (int const   )-3, 
        (int const   )-4,      (int const   )-5,      (int const   )-1,      (int const   )-4, 
        (int const   )0,      (int const   )1,      (int const   )-3,      (int const   )-11, 
        (int const   )-2,      (int const   )-3,      (int const   )-3,      (int const   )-5, 
        (int const   )-4,      (int const   )-5,      (int const   )-4,      (int const   )-6, 
        (int const   )-6,      (int const   )7,      (int const   )1,      (int const   )-4, 
        (int const   )1,      (int const   )0,      (int const   )-5,      (int const   )-4, 
        (int const   )-1,      (int const   )-9,      (int const   )-4,      (int const   )3, 
        (int const   )-4,      (int const   )-4,      (int const   )-3,      (int const   )-11, 
        (int const   )-4,      (int const   )-6,      (int const   )-5,      (int const   )-8, 
        (int const   )-10,      (int const   )-3,      (int const   )-6,      (int const   )-7, 
        (int const   )-4,      (int const   )1,      (int const   )6,      (int const   )-5, 
        (int const   )2,      (int const   )-1,      (int const   )-5,      (int const   )-6, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )0, 
        (int const   )-6,      (int const   )-4,      (int const   )-4,      (int const   )-11, 
        (int const   )-4,      (int const   )2,      (int const   )0,      (int const   )-2, 
        (int const   )-9,      (int const   )-1,      (int const   )-2,      (int const   )-5, 
        (int const   )-3,      (int const   )-4,      (int const   )-5,      (int const   )6, 
        (int const   )0,      (int const   )-9,      (int const   )-4,      (int const   )-2, 
        (int const   )-1,      (int const   )-7,      (int const   )-7,      (int const   )-6, 
        (int const   )-1,      (int const   )-2,      (int const   )-3,      (int const   )-11, 
        (int const   )-3,      (int const   )-2,      (int const   )-5,      (int const   )-7, 
        (int const   )-9,      (int const   )-2,      (int const   )-4,      (int const   )-6, 
        (int const   )-6,      (int const   )1,      (int const   )2,      (int const   )0, 
        (int const   )10,      (int const   )-2,      (int const   )-5,      (int const   )-3, 
        (int const   )-2,      (int const   )-8,      (int const   )-7,      (int const   )0, 
        (int const   )-6,      (int const   )-3,      (int const   )-3,      (int const   )-11, 
        (int const   )-6,      (int const   )-7,      (int const   )-6,      (int const   )-10, 
        (int const   )-8,      (int const   )-9,      (int const   )-9,      (int const   )-7, 
        (int const   )-4,      (int const   )0,      (int const   )-1,      (int const   )-9, 
        (int const   )-2,      (int const   )8,      (int const   )-7,      (int const   )-4, 
        (int const   )-6,      (int const   )-2,      (int const   )4,      (int const   )-5, 
        (int const   )-7,      (int const   )-9,      (int const   )-5,      (int const   )-11, 
        (int const   )0,      (int const   )-2,      (int const   )-3,      (int const   )-4, 
        (int const   )-5,      (int const   )-1,      (int const   )-3,      (int const   )-3, 
        (int const   )-2,      (int const   )-5,      (int const   )-5,      (int const   )-4, 
        (int const   )-5,      (int const   )-7,      (int const   )7,      (int const   )0, 
        (int const   )-2,      (int const   )-9,      (int const   )-9,      (int const   )-3, 
        (int const   )-4,      (int const   )-2,      (int const   )-3,      (int const   )-11, 
        (int const   )1,      (int const   )-1,      (int const   )1,      (int const   )-1, 
        (int const   )-1,      (int const   )-3,      (int const   )-2,      (int const   )0, 
        (int const   )-3,      (int const   )-4,      (int const   )-6,      (int const   )-2, 
        (int const   )-3,      (int const   )-4,      (int const   )0,      (int const   )5, 
        (int const   )2,      (int const   )-3,      (int const   )-5,      (int const   )-3, 
        (int const   )0,      (int const   )-2,      (int const   )-1,      (int const   )-11, 
        (int const   )1,      (int const   )-4,      (int const   )0,      (int const   )-2, 
        (int const   )-5,      (int const   )-3,      (int const   )-3,      (int const   )-3, 
        (int const   )-4,      (int const   )-1,      (int const   )-4,      (int const   )-1, 
        (int const   )-2,      (int const   )-6,      (int const   )-2,      (int const   )2, 
        (int const   )6,      (int const   )-8,      (int const   )-4,      (int const   )-1, 
        (int const   )-1,      (int const   )-3,      (int const   )-2,      (int const   )-11, 
        (int const   )-9,      (int const   )0,      (int const   )-6,      (int const   )-10, 
        (int const   )-11,      (int const   )-8,      (int const   )-11,      (int const   )-10, 
        (int const   )-5,      (int const   )-9,      (int const   )-4,      (int const   )-7, 
        (int const   )-8,      (int const   )-2,      (int const   )-9,      (int const   )-3, 
        (int const   )-8,      (int const   )13,      (int const   )-3,      (int const   )-10, 
        (int const   )-7,      (int const   )-10,      (int const   )-7,      (int const   )-11, 
        (int const   )-5,      (int const   )-7,      (int const   )-3,      (int const   )-7, 
        (int const   )-2,      (int const   )-8,      (int const   )-6,      (int const   )-9, 
        (int const   )-1,      (int const   )-4,      (int const   )-4,      (int const   )-7, 
        (int const   )-7,      (int const   )4,      (int const   )-9,      (int const   )-5, 
        (int const   )-4,      (int const   )-3,      (int const   )9,      (int const   )-5, 
        (int const   )-4,      (int const   )-7,      (int const   )-5,      (int const   )-11, 
        (int const   )-1,      (int const   )-5,      (int const   )-5,      (int const   )-5, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-3, 
        (int const   )-4,      (int const   )3,      (int const   )0,      (int const   )-6, 
        (int const   )0,      (int const   )-5,      (int const   )-3,      (int const   )-3, 
        (int const   )-1,      (int const   )-10,      (int const   )-5,      (int const   )6, 
        (int const   )-5,      (int const   )-4,      (int const   )-2,      (int const   )-11, 
        (int const   )-1,      (int const   )-4,      (int const   )5,      (int const   )5, 
        (int const   )-8,      (int const   )-1,      (int const   )2,      (int const   )-1, 
        (int const   )0,      (int const   )-4,      (int const   )-6,      (int const   )-1, 
        (int const   )-6,      (int const   )-7,      (int const   )-4,      (int const   )0, 
        (int const   )-1,      (int const   )-7,      (int const   )-4,      (int const   )-5, 
        (int const   )5,      (int const   )1,      (int const   )-2,      (int const   )-11, 
        (int const   )-1,      (int const   )-2,      (int const   )-1,      (int const   )2, 
        (int const   )-9,      (int const   )5,      (int const   )5,      (int const   )-3, 
        (int const   )1,      (int const   )-4,      (int const   )-4,      (int const   )-2, 
        (int const   )-3,      (int const   )-9,      (int const   )-2,      (int const   )-2, 
        (int const   )-3,      (int const   )-10,      (int const   )-7,      (int const   )-4, 
        (int const   )1,      (int const   )5,      (int const   )-3,      (int const   )-11, 
        (int const   )-2,      (int const   )-3,      (int const   )-2,      (int const   )-3, 
        (int const   )-6,      (int const   )-2,      (int const   )-3,      (int const   )-3, 
        (int const   )-3,      (int const   )-3,      (int const   )-4,      (int const   )-3, 
        (int const   )-3,      (int const   )-5,      (int const   )-3,      (int const   )-1, 
        (int const   )-2,      (int const   )-7,      (int const   )-5,      (int const   )-2, 
        (int const   )-2,      (int const   )-3,      (int const   )-3,      (int const   )-11, 
        (int const   )-11,      (int const   )-11,      (int const   )-11,      (int const   )-11, 
        (int const   )-11,      (int const   )-11,      (int const   )-11,      (int const   )-11, 
        (int const   )-11,      (int const   )-11,      (int const   )-11,      (int const   )-11, 
        (int const   )-11,      (int const   )-11,      (int const   )-11,      (int const   )-11, 
        (int const   )-11,      (int const   )-11,      (int const   )-11,      (int const   )-11, 
        (int const   )-11,      (int const   )-11,      (int const   )-11,      (int const   )1};
#line 242 "src/alignment_scoring.c"
static int const   blosum80[576]  = 
#line 242
  {      (int const   )7,      (int const   )-3,      (int const   )-3,      (int const   )-3, 
        (int const   )-1,      (int const   )-2,      (int const   )-2,      (int const   )0, 
        (int const   )-3,      (int const   )-3,      (int const   )-3,      (int const   )-1, 
        (int const   )-2,      (int const   )-4,      (int const   )-1,      (int const   )2, 
        (int const   )0,      (int const   )-5,      (int const   )-4,      (int const   )-1, 
        (int const   )-3,      (int const   )-2,      (int const   )-1,      (int const   )-8, 
        (int const   )-3,      (int const   )9,      (int const   )-1,      (int const   )-3, 
        (int const   )-6,      (int const   )1,      (int const   )-1,      (int const   )-4, 
        (int const   )0,      (int const   )-5,      (int const   )-4,      (int const   )3, 
        (int const   )-3,      (int const   )-5,      (int const   )-3,      (int const   )-2, 
        (int const   )-2,      (int const   )-5,      (int const   )-4,      (int const   )-4, 
        (int const   )-2,      (int const   )0,      (int const   )-2,      (int const   )-8, 
        (int const   )-3,      (int const   )-1,      (int const   )9,      (int const   )2, 
        (int const   )-5,      (int const   )0,      (int const   )-1,      (int const   )-1, 
        (int const   )1,      (int const   )-6,      (int const   )-6,      (int const   )0, 
        (int const   )-4,      (int const   )-6,      (int const   )-4,      (int const   )1, 
        (int const   )0,      (int const   )-7,      (int const   )-4,      (int const   )-5, 
        (int const   )5,      (int const   )-1,      (int const   )-2,      (int const   )-8, 
        (int const   )-3,      (int const   )-3,      (int const   )2,      (int const   )10, 
        (int const   )-7,      (int const   )-1,      (int const   )2,      (int const   )-3, 
        (int const   )-2,      (int const   )-7,      (int const   )-7,      (int const   )-2, 
        (int const   )-6,      (int const   )-6,      (int const   )-3,      (int const   )-1, 
        (int const   )-2,      (int const   )-8,      (int const   )-6,      (int const   )-6, 
        (int const   )6,      (int const   )1,      (int const   )-3,      (int const   )-8, 
        (int const   )-1,      (int const   )-6,      (int const   )-5,      (int const   )-7, 
        (int const   )13,      (int const   )-5,      (int const   )-7,      (int const   )-6, 
        (int const   )-7,      (int const   )-2,      (int const   )-3,      (int const   )-6, 
        (int const   )-3,      (int const   )-4,      (int const   )-6,      (int const   )-2, 
        (int const   )-2,      (int const   )-5,      (int const   )-5,      (int const   )-2, 
        (int const   )-6,      (int const   )-7,      (int const   )-4,      (int const   )-8, 
        (int const   )-2,      (int const   )1,      (int const   )0,      (int const   )-1, 
        (int const   )-5,      (int const   )9,      (int const   )3,      (int const   )-4, 
        (int const   )1,      (int const   )-5,      (int const   )-4,      (int const   )2, 
        (int const   )-1,      (int const   )-5,      (int const   )-3,      (int const   )-1, 
        (int const   )-1,      (int const   )-4,      (int const   )-3,      (int const   )-4, 
        (int const   )-1,      (int const   )5,      (int const   )-2,      (int const   )-8, 
        (int const   )-2,      (int const   )-1,      (int const   )-1,      (int const   )2, 
        (int const   )-7,      (int const   )3,      (int const   )8,      (int const   )-4, 
        (int const   )0,      (int const   )-6,      (int const   )-6,      (int const   )1, 
        (int const   )-4,      (int const   )-6,      (int const   )-2,      (int const   )-1, 
        (int const   )-2,      (int const   )-6,      (int const   )-5,      (int const   )-4, 
        (int const   )1,      (int const   )6,      (int const   )-2,      (int const   )-8, 
        (int const   )0,      (int const   )-4,      (int const   )-1,      (int const   )-3, 
        (int const   )-6,      (int const   )-4,      (int const   )-4,      (int const   )9, 
        (int const   )-4,      (int const   )-7,      (int const   )-7,      (int const   )-3, 
        (int const   )-5,      (int const   )-6,      (int const   )-5,      (int const   )-1, 
        (int const   )-3,      (int const   )-6,      (int const   )-6,      (int const   )-6, 
        (int const   )-2,      (int const   )-4,      (int const   )-3,      (int const   )-8, 
        (int const   )-3,      (int const   )0,      (int const   )1,      (int const   )-2, 
        (int const   )-7,      (int const   )1,      (int const   )0,      (int const   )-4, 
        (int const   )12,      (int const   )-6,      (int const   )-5,      (int const   )-1, 
        (int const   )-4,      (int const   )-2,      (int const   )-4,      (int const   )-2, 
        (int const   )-3,      (int const   )-4,      (int const   )3,      (int const   )-5, 
        (int const   )-1,      (int const   )0,      (int const   )-2,      (int const   )-8, 
        (int const   )-3,      (int const   )-5,      (int const   )-6,      (int const   )-7, 
        (int const   )-2,      (int const   )-5,      (int const   )-6,      (int const   )-7, 
        (int const   )-6,      (int const   )7,      (int const   )2,      (int const   )-5, 
        (int const   )2,      (int const   )-1,      (int const   )-5,      (int const   )-4, 
        (int const   )-2,      (int const   )-5,      (int const   )-3,      (int const   )4, 
        (int const   )-6,      (int const   )-6,      (int const   )-2,      (int const   )-8, 
        (int const   )-3,      (int const   )-4,      (int const   )-6,      (int const   )-7, 
        (int const   )-3,      (int const   )-4,      (int const   )-6,      (int const   )-7, 
        (int const   )-5,      (int const   )2,      (int const   )6,      (int const   )-4, 
        (int const   )3,      (int const   )0,      (int const   )-5,      (int const   )-4, 
        (int const   )-3,      (int const   )-4,      (int const   )-2,      (int const   )1, 
        (int const   )-7,      (int const   )-5,      (int const   )-2,      (int const   )-8, 
        (int const   )-1,      (int const   )3,      (int const   )0,      (int const   )-2, 
        (int const   )-6,      (int const   )2,      (int const   )1,      (int const   )-3, 
        (int const   )-1,      (int const   )-5,      (int const   )-4,      (int const   )8, 
        (int const   )-3,      (int const   )-5,      (int const   )-2,      (int const   )-1, 
        (int const   )-1,      (int const   )-6,      (int const   )-4,      (int const   )-4, 
        (int const   )-1,      (int const   )1,      (int const   )-2,      (int const   )-8, 
        (int const   )-2,      (int const   )-3,      (int const   )-4,      (int const   )-6, 
        (int const   )-3,      (int const   )-1,      (int const   )-4,      (int const   )-5, 
        (int const   )-4,      (int const   )2,      (int const   )3,      (int const   )-3, 
        (int const   )9,      (int const   )0,      (int const   )-4,      (int const   )-3, 
        (int const   )-1,      (int const   )-3,      (int const   )-3,      (int const   )1, 
        (int const   )-5,      (int const   )-3,      (int const   )-2,      (int const   )-8, 
        (int const   )-4,      (int const   )-5,      (int const   )-6,      (int const   )-6, 
        (int const   )-4,      (int const   )-5,      (int const   )-6,      (int const   )-6, 
        (int const   )-2,      (int const   )-1,      (int const   )0,      (int const   )-5, 
        (int const   )0,      (int const   )10,      (int const   )-6,      (int const   )-4, 
        (int const   )-4,      (int const   )0,      (int const   )4,      (int const   )-2, 
        (int const   )-6,      (int const   )-6,      (int const   )-3,      (int const   )-8, 
        (int const   )-1,      (int const   )-3,      (int const   )-4,      (int const   )-3, 
        (int const   )-6,      (int const   )-3,      (int const   )-2,      (int const   )-5, 
        (int const   )-4,      (int const   )-5,      (int const   )-5,      (int const   )-2, 
        (int const   )-4,      (int const   )-6,      (int const   )12,      (int const   )-2, 
        (int const   )-3,      (int const   )-7,      (int const   )-6,      (int const   )-4, 
        (int const   )-4,      (int const   )-2,      (int const   )-3,      (int const   )-8, 
        (int const   )2,      (int const   )-2,      (int const   )1,      (int const   )-1, 
        (int const   )-2,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-2,      (int const   )-4,      (int const   )-4,      (int const   )-1, 
        (int const   )-3,      (int const   )-4,      (int const   )-2,      (int const   )7, 
        (int const   )2,      (int const   )-6,      (int const   )-3,      (int const   )-3, 
        (int const   )0,      (int const   )-1,      (int const   )-1,      (int const   )-8, 
        (int const   )0,      (int const   )-2,      (int const   )0,      (int const   )-2, 
        (int const   )-2,      (int const   )-1,      (int const   )-2,      (int const   )-3, 
        (int const   )-3,      (int const   )-2,      (int const   )-3,      (int const   )-1, 
        (int const   )-1,      (int const   )-4,      (int const   )-3,      (int const   )2, 
        (int const   )8,      (int const   )-5,      (int const   )-3,      (int const   )0, 
        (int const   )-1,      (int const   )-2,      (int const   )-1,      (int const   )-8, 
        (int const   )-5,      (int const   )-5,      (int const   )-7,      (int const   )-8, 
        (int const   )-5,      (int const   )-4,      (int const   )-6,      (int const   )-6, 
        (int const   )-4,      (int const   )-5,      (int const   )-4,      (int const   )-6, 
        (int const   )-3,      (int const   )0,      (int const   )-7,      (int const   )-6, 
        (int const   )-5,      (int const   )16,      (int const   )3,      (int const   )-5, 
        (int const   )-8,      (int const   )-5,      (int const   )-5,      (int const   )-8, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-6, 
        (int const   )-5,      (int const   )-3,      (int const   )-5,      (int const   )-6, 
        (int const   )3,      (int const   )-3,      (int const   )-2,      (int const   )-4, 
        (int const   )-3,      (int const   )4,      (int const   )-6,      (int const   )-3, 
        (int const   )-3,      (int const   )3,      (int const   )11,      (int const   )-3, 
        (int const   )-5,      (int const   )-4,      (int const   )-3,      (int const   )-8, 
        (int const   )-1,      (int const   )-4,      (int const   )-5,      (int const   )-6, 
        (int const   )-2,      (int const   )-4,      (int const   )-4,      (int const   )-6, 
        (int const   )-5,      (int const   )4,      (int const   )1,      (int const   )-4, 
        (int const   )1,      (int const   )-2,      (int const   )-4,      (int const   )-3, 
        (int const   )0,      (int const   )-5,      (int const   )-3,      (int const   )7, 
        (int const   )-6,      (int const   )-4,      (int const   )-2,      (int const   )-8, 
        (int const   )-3,      (int const   )-2,      (int const   )5,      (int const   )6, 
        (int const   )-6,      (int const   )-1,      (int const   )1,      (int const   )-2, 
        (int const   )-1,      (int const   )-6,      (int const   )-7,      (int const   )-1, 
        (int const   )-5,      (int const   )-6,      (int const   )-4,      (int const   )0, 
        (int const   )-1,      (int const   )-8,      (int const   )-5,      (int const   )-6, 
        (int const   )6,      (int const   )0,      (int const   )-3,      (int const   )-8, 
        (int const   )-2,      (int const   )0,      (int const   )-1,      (int const   )1, 
        (int const   )-7,      (int const   )5,      (int const   )6,      (int const   )-4, 
        (int const   )0,      (int const   )-6,      (int const   )-5,      (int const   )1, 
        (int const   )-3,      (int const   )-6,      (int const   )-2,      (int const   )-1, 
        (int const   )-2,      (int const   )-5,      (int const   )-4,      (int const   )-4, 
        (int const   )0,      (int const   )6,      (int const   )-1,      (int const   )-8, 
        (int const   )-1,      (int const   )-2,      (int const   )-2,      (int const   )-3, 
        (int const   )-4,      (int const   )-2,      (int const   )-2,      (int const   )-3, 
        (int const   )-2,      (int const   )-2,      (int const   )-2,      (int const   )-2, 
        (int const   )-2,      (int const   )-3,      (int const   )-3,      (int const   )-1, 
        (int const   )-1,      (int const   )-5,      (int const   )-3,      (int const   )-2, 
        (int const   )-3,      (int const   )-1,      (int const   )-2,      (int const   )-8, 
        (int const   )-8,      (int const   )-8,      (int const   )-8,      (int const   )-8, 
        (int const   )-8,      (int const   )-8,      (int const   )-8,      (int const   )-8, 
        (int const   )-8,      (int const   )-8,      (int const   )-8,      (int const   )-8, 
        (int const   )-8,      (int const   )-8,      (int const   )-8,      (int const   )-8, 
        (int const   )-8,      (int const   )-8,      (int const   )-8,      (int const   )-8, 
        (int const   )-8,      (int const   )-8,      (int const   )-8,      (int const   )1};
#line 268 "src/alignment_scoring.c"
int blosum62[576]  = 
#line 268
  {      4,      -1,      -2,      -2, 
        0,      -1,      -1,      0, 
        -2,      -1,      -1,      -1, 
        -1,      -2,      -1,      1, 
        0,      -3,      -2,      0, 
        -2,      -1,      0,      -4, 
        -1,      5,      0,      -2, 
        -3,      1,      0,      -2, 
        0,      -3,      -2,      2, 
        -1,      -3,      -2,      -1, 
        -1,      -3,      -2,      -3, 
        -1,      0,      -1,      -4, 
        -2,      0,      6,      1, 
        -3,      0,      0,      0, 
        1,      -3,      -3,      0, 
        -2,      -3,      -2,      1, 
        0,      -4,      -2,      -3, 
        3,      0,      -1,      -4, 
        -2,      -2,      1,      6, 
        -3,      0,      2,      -1, 
        -1,      -3,      -4,      -1, 
        -3,      -3,      -1,      0, 
        -1,      -4,      -3,      -3, 
        4,      1,      -1,      -4, 
        0,      -3,      -3,      -3, 
        9,      -3,      -4,      -3, 
        -3,      -1,      -1,      -3, 
        -1,      -2,      -3,      -1, 
        -1,      -2,      -2,      -1, 
        -3,      -3,      -2,      -4, 
        -1,      1,      0,      0, 
        -3,      5,      2,      -2, 
        0,      -3,      -2,      1, 
        0,      -3,      -1,      0, 
        -1,      -2,      -1,      -2, 
        0,      3,      -1,      -4, 
        -1,      0,      0,      2, 
        -4,      2,      5,      -2, 
        0,      -3,      -3,      1, 
        -2,      -3,      -1,      0, 
        -1,      -3,      -2,      -2, 
        1,      4,      -1,      -4, 
        0,      -2,      0,      -1, 
        -3,      -2,      -2,      6, 
        -2,      -4,      -4,      -2, 
        -3,      -3,      -2,      0, 
        -2,      -2,      -3,      -3, 
        -1,      -2,      -1,      -4, 
        -2,      0,      1,      -1, 
        -3,      0,      0,      -2, 
        8,      -3,      -3,      -1, 
        -2,      -1,      -2,      -1, 
        -2,      -2,      2,      -3, 
        0,      0,      -1,      -4, 
        -1,      -3,      -3,      -3, 
        -1,      -3,      -3,      -4, 
        -3,      4,      2,      -3, 
        1,      0,      -3,      -2, 
        -1,      -3,      -1,      3, 
        -3,      -3,      -1,      -4, 
        -1,      -2,      -3,      -4, 
        -1,      -2,      -3,      -4, 
        -3,      2,      4,      -2, 
        2,      0,      -3,      -2, 
        -1,      -2,      -1,      1, 
        -4,      -3,      -1,      -4, 
        -1,      2,      0,      -1, 
        -3,      1,      1,      -2, 
        -1,      -3,      -2,      5, 
        -1,      -3,      -1,      0, 
        -1,      -3,      -2,      -2, 
        0,      1,      -1,      -4, 
        -1,      -1,      -2,      -3, 
        -1,      0,      -2,      -3, 
        -2,      1,      2,      -1, 
        5,      0,      -2,      -1, 
        -1,      -1,      -1,      1, 
        -3,      -1,      -1,      -4, 
        -2,      -3,      -3,      -3, 
        -2,      -3,      -3,      -3, 
        -1,      0,      0,      -3, 
        0,      6,      -4,      -2, 
        -2,      1,      3,      -1, 
        -3,      -3,      -1,      -4, 
        -1,      -2,      -2,      -1, 
        -3,      -1,      -1,      -2, 
        -2,      -3,      -3,      -1, 
        -2,      -4,      7,      -1, 
        -1,      -4,      -3,      -2, 
        -2,      -1,      -2,      -4, 
        1,      -1,      1,      0, 
        -1,      0,      0,      0, 
        -1,      -2,      -2,      0, 
        -1,      -2,      -1,      4, 
        1,      -3,      -2,      -2, 
        0,      0,      0,      -4, 
        0,      -1,      0,      -1, 
        -1,      -1,      -1,      -2, 
        -2,      -1,      -1,      -1, 
        -1,      -2,      -1,      1, 
        5,      -2,      -2,      0, 
        -1,      -1,      0,      -4, 
        -3,      -3,      -4,      -4, 
        -2,      -2,      -3,      -2, 
        -2,      -3,      -2,      -3, 
        -1,      1,      -4,      -3, 
        -2,      11,      2,      -3, 
        -4,      -3,      -2,      -4, 
        -2,      -2,      -2,      -3, 
        -2,      -1,      -2,      -3, 
        2,      -1,      -1,      -2, 
        -1,      3,      -3,      -2, 
        -2,      2,      7,      -1, 
        -3,      -2,      -1,      -4, 
        0,      -3,      -3,      -3, 
        -1,      -2,      -2,      -3, 
        -3,      3,      1,      -2, 
        1,      -1,      -2,      -2, 
        0,      -3,      -1,      4, 
        -3,      -2,      -1,      -4, 
        -2,      -1,      3,      4, 
        -3,      0,      1,      -1, 
        0,      -3,      -4,      0, 
        -3,      -3,      -2,      0, 
        -1,      -4,      -3,      -3, 
        4,      1,      -1,      -4, 
        -1,      0,      0,      1, 
        -3,      3,      4,      -2, 
        0,      -3,      -3,      1, 
        -1,      -3,      -1,      0, 
        -1,      -3,      -2,      -2, 
        1,      4,      -1,      -4, 
        0,      -1,      -1,      -1, 
        -2,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -2,      0, 
        0,      -2,      -1,      -1, 
        -1,      -1,      -1,      -4, 
        -4,      -4,      -4,      -4, 
        -4,      -4,      -4,      -4, 
        -4,      -4,      -4,      -4, 
        -4,      -4,      -4,      -4, 
        -4,      -4,      -4,      -4, 
        -4,      -4,      -4,      1};
#line 294 "src/alignment_scoring.c"
static char const   dna_bases[9]  = 
#line 294
  {      (char const   )'A',      (char const   )'a',      (char const   )'C',      (char const   )'c', 
        (char const   )'G',      (char const   )'g',      (char const   )'T',      (char const   )'t', 
        (char const   )'\000'};
#line 296 "src/alignment_scoring.c"
static int const   sub_matrix[64]  = 
#line 296
  {      (int const   )2,      (int const   )2,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )2,      (int const   )2,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )5,      (int const   )5, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )5,      (int const   )5, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )5,      (int const   )5,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )5,      (int const   )5,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )2,      (int const   )2, 
        (int const   )-4,      (int const   )-4,      (int const   )-4,      (int const   )-4, 
        (int const   )-4,      (int const   )-4,      (int const   )2,      (int const   )2};
#line 307 "src/alignment_scoring.c"
void scoring_system_PAM30(scoring_t *scoring ) 
{ 


  {
#line 314
  scoring_init(scoring, 1, -17, -9, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
               (_Bool)0);
#line 317
  scoring_add_mutations(scoring, (char const   *)(amino_acids), pam30, (char)1);
#line 318
  return;
}
}
#line 321 "src/alignment_scoring.c"
void scoring_system_PAM70(scoring_t *scoring ) 
{ 


  {
#line 328
  scoring_init(scoring, 1, -11, -10, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
               (_Bool)0);
#line 331
  scoring_add_mutations(scoring, (char const   *)(amino_acids), pam70, (char)1);
#line 332
  return;
}
}
#line 335 "src/alignment_scoring.c"
void scoring_system_BLOSUM80(scoring_t *scoring ) 
{ 


  {
#line 342
  scoring_init(scoring, 1, -8, -10, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
               (_Bool)0);
#line 345
  scoring_add_mutations(scoring, (char const   *)(amino_acids), blosum80, (char)1);
#line 346
  return;
}
}
#line 349 "src/alignment_scoring.c"
void scoring_system_BLOSUM62(scoring_t *scoring ) 
{ 


  {
#line 356
  scoring_init(scoring, 1, -4, -10, -1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
               (_Bool)0);
#line 359
  scoring_add_mutations(scoring, (char const   *)(amino_acids), (int const   *)(blosum62),
                        (char)1);
#line 360
  return;
}
}
#line 366 "src/alignment_scoring.c"
void scoring_system_DNA_hybridization(scoring_t *scoring ) 
{ 


  {
#line 373
  scoring_init(scoring, 0, 0, -10, -10, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
               (_Bool)0);
#line 376
  scoring_add_mutations(scoring, dna_bases, sub_matrix, (char)0);
#line 377
  return;
}
}
#line 380 "src/alignment_scoring.c"
void scoring_system_default(scoring_t *scoring ) 
{ 
  int match_default ;
  int mismatch_default ;
  int gap_open_default ;
  int gap_extend_default ;

  {
#line 382
  match_default = 1;
#line 383
  mismatch_default = -2;
#line 384
  gap_open_default = -4;
#line 385
  gap_extend_default = -1;
#line 389
  scoring_init(scoring, match_default, mismatch_default, gap_open_default, gap_extend_default,
               (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0);
#line 392
  return;
}
}
#line 1 "cil-iQWKGu4o.o"
#pragma merger("0","/tmp/cil-CN23c2BC.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 33 "libs/string_buffer/string_buffer.h"
extern StrBuf *strbuf_new(size_t___0 len ) ;
#line 34 "libs/string_buffer/string_buffer.h"
__inline static void strbuf_free(StrBuf *sb ) 
{ 


  {
#line 34
  free((void *)sb->b);
#line 34
  free((void *)sb);
#line 34
  return;
}
}
#line 159
extern size_t___0 strbuf_chomp(StrBuf *sb ) ;
#line 233
extern size_t___0 strbuf_reset_gzreadline(StrBuf *sb , gzFile gz_file ) ;
#line 280
extern char string_is_all_whitespace(char const   *s ) ;
#line 281
extern char *string_next_nonwhitespace(char *s ) ;
#line 23 "src/alignment_scoring_load.c"
static void _loading_error(char const   *err_msg , char const   *file_path , int line_num ,
                           char is_matrix )  __attribute__((__noreturn__)) ;
#line 27
static void _loading_error(char const   *err_msg , char const   *file_path , int line_num ,
                           char is_matrix )  __attribute__((__noreturn__)) ;
#line 27 "src/alignment_scoring_load.c"
static void _loading_error(char const   *err_msg , char const   *file_path , int line_num ,
                           char is_matrix ) 
{ 


  {
#line 30
  if (is_matrix) {
#line 30
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: substitution matrix : %s\n",
            err_msg);
  } else {
#line 31
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: substitution pairs : %s\n",
            err_msg);
  }
#line 33
  if ((unsigned long )file_path != (unsigned long )((void *)0)) {
#line 33
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"File: %s\n",
            file_path);
  }
#line 34
  if (line_num != -1) {
#line 34
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Line: %s\n",
            file_path);
  }
#line 36
  exit(1);
}
}
#line 39 "src/alignment_scoring_load.c"
void align_scoring_load_matrix(gzFile file , char const   *file_path , scoring_t *scoring ,
                               char case_sensitive ) 
{ 
  StrBuf *sbuf ;
  StrBuf *tmp ;
  size_t___0 read_length ;
  int line_num ;
  char tmp___0 ;
  char sep ;
  char *characters ;
  void *tmp___1 ;
  int num_of_chars ;
  char *next ;
  int tmp___2 ;
  int tmp___3 ;
  char *from_char_pos ;
  char *tmp___4 ;
  char from_char ;
  int tmp___5 ;
  int tmp___6 ;
  char to_char ;
  char *score_txt ;
  int score ;
  int i ;
  int tmp___7 ;
  char *strtol_last_char_ptr ;
  long tmp___8 ;
  char tmp___9 ;
  size_t___0 i___0 ;
  char c ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int score___0 ;
  char from_char___0 ;
  int tmp___13 ;
  int tmp___14 ;
  char tmp___15 ;
  char *str_pos ;
  int to_char_index ;
  char to_char___0 ;
  int tmp___16 ;
  char *after_num_str ;
  long tmp___17 ;
  int tmp___18 ;

  {
#line 42
  tmp = strbuf_new((size_t___0 )500);
#line 42
  sbuf = tmp;
#line 44
  line_num = 0;
#line 47
  while (1) {
#line 47
    read_length = strbuf_reset_gzreadline(sbuf, file);
#line 47
    if (! (read_length > 0UL)) {
#line 47
      break;
    }
#line 49
    strbuf_chomp(sbuf);
#line 51
    if (sbuf->end > 0UL) {
#line 51
      if ((int )*(sbuf->b + 0) != 35) {
#line 51
        tmp___0 = string_is_all_whitespace((char const   *)sbuf->b);
#line 51
        if (! tmp___0) {
#line 56
          if (sbuf->end < 2UL) {
#line 58
            _loading_error((char const   *)"Too few column headings", file_path, line_num,
                           (char)1);
          }
#line 61
          break;
        }
      }
    }
#line 64
    line_num ++;
  }
#line 67
  if (line_num == 0) {
#line 67
    if (sbuf->end <= 0UL) {
#line 69
      _loading_error((char const   *)"Empty file", file_path, -1, (char)0);
    }
  }
#line 74
  sep = *(sbuf->b + 0);
#line 76
  if ((int )sep >= 48) {
#line 76
    if ((int )sep <= 57) {
#line 78
      _loading_error((char const   *)"Numbers (0-9) and dashes (-) do not make good separators",
                     file_path, line_num, (char)0);
    } else {
#line 76
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 76
  if ((int )sep == 45) {
#line 78
    _loading_error((char const   *)"Numbers (0-9) and dashes (-) do not make good separators",
                   file_path, line_num, (char)0);
  }
#line 82
  tmp___1 = malloc(sbuf->end);
#line 82
  characters = (char *)tmp___1;
#line 83
  num_of_chars = 0;
#line 85
  tmp___18 = isspace((int )sep);
#line 85
  if (tmp___18) {
#line 87
    next = sbuf->b;
#line 89
    while (1) {
#line 89
      next = string_next_nonwhitespace(next + 1);
#line 89
      if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 89
        break;
      }
#line 91
      tmp___2 = num_of_chars;
#line 91
      num_of_chars ++;
#line 91
      if (case_sensitive) {
#line 91
        *(characters + tmp___2) = *next;
      } else {
#line 91
        tmp___3 = tolower((int )*next);
#line 91
        *(characters + tmp___2) = (char )tmp___3;
      }
    }
#line 95
    while (1) {
#line 95
      read_length = strbuf_reset_gzreadline(sbuf, file);
#line 95
      if (! (read_length > 0UL)) {
#line 95
        break;
      }
#line 97
      strbuf_chomp(sbuf);
#line 99
      tmp___4 = string_next_nonwhitespace(sbuf->b);
#line 99
      from_char_pos = tmp___4;
#line 101
      if ((unsigned long )from_char_pos == (unsigned long )((void *)0)) {
#line 104
        continue;
      } else
#line 101
      if ((int )*(sbuf->b + 0) == 35) {
#line 104
        continue;
      }
#line 107
      if (case_sensitive) {
#line 107
        tmp___6 = (int )*from_char_pos;
      } else {
#line 107
        tmp___5 = tolower((int )*from_char_pos);
#line 107
        tmp___6 = tmp___5;
      }
#line 107
      from_char = (char )tmp___6;
#line 110
      score_txt = sbuf->b + 1;
#line 114
      i = 0;
#line 114
      while (i < num_of_chars) {
#line 116
        to_char = *(characters + i);
#line 118
        tmp___7 = isspace((int )*score_txt);
#line 118
        if (! tmp___7) {
#line 120
          _loading_error((char const   *)"Expected whitespace between elements - found character",
                         file_path, line_num, (char)1);
        }
#line 124
        score_txt = string_next_nonwhitespace(score_txt + 1);
#line 126
        strtol_last_char_ptr = score_txt;
#line 127
        tmp___8 = strtol((char const   * __restrict  )strtol_last_char_ptr, (char ** __restrict  )(& strtol_last_char_ptr),
                         10);
#line 127
        score = (int )tmp___8;
#line 130
        if ((unsigned long )strtol_last_char_ptr == (unsigned long )score_txt) {
#line 132
          _loading_error((char const   *)"Missing number value on line", file_path,
                         line_num, (char)1);
        }
#line 135
        scoring_add_mutation(scoring, from_char, to_char, score);
#line 137
        score_txt = strtol_last_char_ptr;
#line 114
        i ++;
      }
#line 140
      if ((int )*score_txt != 0) {
#line 140
        tmp___9 = string_is_all_whitespace((char const   *)score_txt);
#line 140
        if (! tmp___9) {
#line 142
          _loading_error((char const   *)"Too many columns on row", file_path, line_num,
                         (char)1);
        }
      }
#line 145
      line_num ++;
    }
  } else {
#line 152
    i___0 = (size_t___0 )0;
#line 152
    while (i___0 < sbuf->end) {
#line 154
      if ((int )*(sbuf->b + i___0) != (int )sep) {
#line 156
        _loading_error((char const   *)"Separator missing from line", file_path, line_num,
                       (char)1);
      }
#line 159
      if (case_sensitive) {
#line 159
        tmp___11 = (int )*(sbuf->b + (i___0 + 1UL));
      } else {
#line 159
        tmp___10 = tolower((int )*(sbuf->b + (i___0 + 1UL)));
#line 159
        tmp___11 = tmp___10;
      }
#line 159
      c = (char )tmp___11;
#line 160
      tmp___12 = num_of_chars;
#line 160
      num_of_chars ++;
#line 160
      *(characters + tmp___12) = c;
#line 152
      i___0 += 2UL;
    }
#line 166
    while (1) {
#line 166
      read_length = strbuf_reset_gzreadline(sbuf, file);
#line 166
      if (! (read_length > 0UL)) {
#line 166
        break;
      }
#line 168
      strbuf_chomp(sbuf);
#line 170
      if (case_sensitive) {
#line 170
        tmp___14 = (int )*(sbuf->b + 0);
      } else {
#line 170
        tmp___13 = tolower((int )*(sbuf->b + 0));
#line 170
        tmp___14 = tmp___13;
      }
#line 170
      from_char___0 = (char )tmp___14;
#line 172
      if ((int )from_char___0 == 35) {
#line 175
        continue;
      } else {
#line 172
        tmp___15 = string_is_all_whitespace((char const   *)sbuf->b);
#line 172
        if (tmp___15) {
#line 175
          continue;
        }
      }
#line 178
      str_pos = sbuf->b;
#line 180
      to_char_index = 0;
#line 183
      while ((int )*str_pos != 0) {
#line 185
        tmp___16 = to_char_index;
#line 185
        to_char_index ++;
#line 185
        to_char___0 = *(characters + tmp___16);
#line 187
        if ((int )*str_pos != (int )sep) {
#line 189
          _loading_error((char const   *)"Separator missing from line", file_path,
                         line_num, (char)1);
        }
#line 193
        str_pos ++;
#line 195
        after_num_str = str_pos;
#line 196
        tmp___17 = strtol((char const   * __restrict  )str_pos, (char ** __restrict  )(& after_num_str),
                          10);
#line 196
        score___0 = (int )tmp___17;
#line 199
        if ((unsigned long )str_pos == (unsigned long )after_num_str) {
#line 201
          _loading_error((char const   *)"Missing number value on line", file_path,
                         line_num, (char)1);
        }
#line 204
        if (to_char_index >= num_of_chars) {
#line 206
          _loading_error((char const   *)"Too many columns on row", file_path, line_num,
                         (char)1);
        }
#line 209
        scoring_add_mutation(scoring, from_char___0, to_char___0, score___0);
#line 211
        str_pos = after_num_str;
      }
#line 214
      line_num ++;
    }
  }
#line 218
  free((void *)characters);
#line 219
  strbuf_free(sbuf);
#line 220
  return;
}
}
#line 223 "src/alignment_scoring_load.c"
void align_scoring_load_pairwise(gzFile file , char const   *file_path , scoring_t *scoring ,
                                 char case_sensitive ) 
{ 
  StrBuf *sbuf ;
  StrBuf *tmp ;
  size_t___0 read_length ;
  int line_num ;
  char a ;
  char b ;
  int score ;
  int num_pairs_added ;
  size_t___0 char2_pos ;
  int tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char tmp___7 ;

  {
#line 226
  tmp = strbuf_new((size_t___0 )200);
#line 226
  sbuf = tmp;
#line 228
  line_num = 0;
#line 233
  num_pairs_added = 0;
#line 235
  while (1) {
#line 235
    read_length = strbuf_reset_gzreadline(sbuf, file);
#line 235
    if (! (read_length > 0UL)) {
#line 235
      break;
    }
#line 237
    strbuf_chomp(sbuf);
#line 239
    if (sbuf->end > 0UL) {
#line 239
      if ((int )*(sbuf->b + 0) != 35) {
#line 239
        tmp___7 = string_is_all_whitespace((char const   *)sbuf->b);
#line 239
        if (! tmp___7) {
#line 242
          if (read_length < 5UL) {
#line 244
            _loading_error((char const   *)"Too few column headings", file_path, line_num,
                           (char)0);
          }
#line 247
          tmp___4 = isspace((int )*(sbuf->b + 1));
#line 247
          if (tmp___4) {
#line 250
            a = *(sbuf->b + 0);
#line 254
            char2_pos = (size_t___0 )1;
#line 254
            while (1) {
#line 254
              if ((int )*(sbuf->b + char2_pos) != 0) {
#line 254
                tmp___0 = isspace((int )*(sbuf->b + char2_pos));
#line 254
                if (! tmp___0) {
#line 254
                  break;
                }
              } else {
#line 254
                break;
              }
#line 254
              char2_pos ++;
            }
#line 258
            if (char2_pos + 2UL >= sbuf->end) {
#line 260
              _loading_error((char const   *)"Line too short", file_path, line_num,
                             (char)0);
            } else {
#line 258
              tmp___1 = isspace((int )*(sbuf->b + (char2_pos + 1UL)));
#line 258
              if (! tmp___1) {
#line 260
                _loading_error((char const   *)"Line too short", file_path, line_num,
                               (char)0);
              }
            }
#line 263
            b = *(sbuf->b + char2_pos);
#line 265
            tmp___2 = parse_entire_int((sbuf->b + char2_pos) + 2, & score);
#line 265
            if (! tmp___2) {
#line 267
              _loading_error((char const   *)"Invalid number", file_path, line_num,
                             (char)0);
            }
          } else {
#line 272
            if ((int )*(sbuf->b + 1) != (int )*(sbuf->b + 3)) {
#line 274
              _loading_error((char const   *)"Inconsistent separators used", file_path,
                             line_num, (char)0);
            }
#line 277
            a = *(sbuf->b + 0);
#line 278
            b = *(sbuf->b + 2);
#line 280
            tmp___3 = parse_entire_int(sbuf->b + 4, & score);
#line 280
            if (! tmp___3) {
#line 282
              _loading_error((char const   *)"Invalid number", file_path, line_num,
                             (char)0);
            }
          }
#line 286
          if (! case_sensitive) {
#line 288
            tmp___5 = tolower((int )a);
#line 288
            a = (char )tmp___5;
#line 289
            tmp___6 = tolower((int )b);
#line 289
            b = (char )tmp___6;
          }
#line 292
          scoring_add_mutation(scoring, a, b, score);
#line 293
          num_pairs_added ++;
        }
      }
    }
#line 296
    line_num ++;
  }
#line 299
  strbuf_free(sbuf);
#line 301
  if (num_pairs_added == 0) {
#line 303
    _loading_error((char const   *)"No pairs added from file (file empty?)", file_path,
                   line_num, (char)0);
  }
#line 306
  return;
}
}
#line 1 "cil-VAgL4LX8.o"
#pragma merger("0","/tmp/cil-HkygAP7m.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 28 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern void *memmove(void * , void const   * , size_t___0  ) ;
#line 22 "src/needleman_wunsch.h"
nw_aligner_t *needleman_wunsch_new(void) ;
#line 23
void needleman_wunsch_free(nw_aligner_t *nw ) ;
#line 25
void needleman_wunsch_align(char const   *a , char const   *b , scoring_t const   *scoring ,
                            nw_aligner_t *nw , alignment_t *result ) ;
#line 29
void needleman_wunsch_align2(char const   *a , char const   *b , size_t___0 len_a ,
                             size_t___0 len_b , scoring_t const   *scoring , nw_aligner_t *nw ,
                             alignment_t *result ) ;
#line 15 "src/needleman_wunsch.c"
nw_aligner_t *needleman_wunsch_new(void) 
{ 
  nw_aligner_t *nw ;
  void *tmp ;

  {
#line 17
  tmp = calloc((size_t )1, sizeof(nw_aligner_t ));
#line 17
  nw = (nw_aligner_t *)tmp;
#line 18
  return (nw);
}
}
#line 21 "src/needleman_wunsch.c"
void needleman_wunsch_free(nw_aligner_t *nw ) 
{ 


  {
#line 23
  aligner_destroy(nw);
#line 24
  free((void *)nw);
#line 25
  return;
}
}
#line 27 "src/needleman_wunsch.c"
void needleman_wunsch_align(char const   *a , char const   *b , scoring_t const   *scoring ,
                            nw_aligner_t *nw , alignment_t *result ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;

  {
#line 31
  tmp = strlen(b);
#line 31
  tmp___0 = strlen(a);
#line 31
  needleman_wunsch_align2(a, b, tmp___0, tmp, scoring, nw, result);
#line 32
  return;
}
}
#line 34 "src/needleman_wunsch.c"
void needleman_wunsch_align2(char const   *a , char const   *b , size_t___0 len_a ,
                             size_t___0 len_b , scoring_t const   *scoring , nw_aligner_t *nw ,
                             alignment_t *result ) 
{ 
  size_t___0 longest_alignment ;
  size_t___0 next_char ;
  size_t___0 arr_size ;
  enum Matrix curr_matrix ;
  score_t curr_score ;
  char *alignment_a ;
  char *alignment_b ;
  size_t___0 score_x ;
  size_t___0 score_y ;
  size_t___0 arr_index ;
  int first_char ;
  int alignment_len ;

  {
#line 39
  aligner_align(nw, a, b, len_a, len_b, scoring, (char)0);
#line 44
  longest_alignment = ((nw->score_width - 1UL) + nw->score_height) - 1UL;
#line 45
  alignment_ensure_capacity(result, longest_alignment);
#line 48
  next_char = longest_alignment - 1UL;
#line 50
  arr_size = nw->score_width * nw->score_height;
#line 53
  curr_matrix = (enum Matrix )0;
#line 54
  curr_score = *(nw->match_scores + (arr_size - 1UL));
#line 56
  if (*(nw->gap_b_scores + (arr_size - 1UL)) >= curr_score) {
#line 58
    curr_matrix = (enum Matrix )2;
#line 59
    curr_score = *(nw->gap_b_scores + (arr_size - 1UL));
  }
#line 62
  if (*(nw->gap_a_scores + (arr_size - 1UL)) >= curr_score) {
#line 64
    curr_matrix = (enum Matrix )1;
#line 65
    curr_score = *(nw->gap_a_scores + (arr_size - 1UL));
  }
#line 72
  result->score = curr_score;
#line 73
  alignment_a = result->result_a;
#line 73
  alignment_b = result->result_b;
#line 76
  score_x = nw->score_width - 1UL;
#line 76
  score_y = nw->score_height - 1UL;
#line 77
  arr_index = arr_size - 1UL;
#line 79
  while (1) {
#line 79
    if (score_x > 0UL) {
#line 79
      if (! (score_y > 0UL)) {
#line 79
        break;
      }
    } else {
#line 79
      break;
    }
#line 86
    switch ((unsigned int )curr_matrix) {
    case 0U: 
#line 89
    *(alignment_a + next_char) = (char )*(nw->seq_a + (score_x - 1UL));
#line 90
    *(alignment_b + next_char) = (char )*(nw->seq_b + (score_y - 1UL));
#line 91
    break;
    case 1U: 
#line 94
    *(alignment_a + next_char) = (char )'-';
#line 95
    *(alignment_b + next_char) = (char )*(nw->seq_b + (score_y - 1UL));
#line 96
    break;
    case 2U: 
#line 99
    *(alignment_a + next_char) = (char )*(nw->seq_a + (score_x - 1UL));
#line 100
    *(alignment_b + next_char) = (char )'-';
#line 101
    break;
    default: 
#line 104
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Program error: invalid matrix number\n");
#line 105
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Please submit a bug report to: turner.isaac@gmail.com\n");
#line 106
    exit(1);
    }
#line 109
    if (score_x > 0UL) {
#line 109
      if (score_y > 0UL) {
#line 111
        alignment_reverse_move(& curr_matrix, & curr_score, & score_x, & score_y,
                               & arr_index, (aligner_t const   *)nw);
      }
    }
#line 79
    next_char --;
  }
#line 117
  while (score_y > 0UL) {
#line 119
    *(alignment_a + next_char) = (char )'-';
#line 120
    *(alignment_b + next_char) = (char )*(nw->seq_b + (score_y - 1UL));
#line 121
    next_char --;
#line 122
    score_y --;
  }
#line 126
  while (score_x > 0UL) {
#line 128
    *(alignment_a + next_char) = (char )*(nw->seq_a + (score_x - 1UL));
#line 129
    *(alignment_b + next_char) = (char )'-';
#line 130
    next_char --;
#line 131
    score_x --;
  }
#line 135
  first_char = (int )(next_char + 1UL);
#line 136
  alignment_len = (int )(longest_alignment - (size_t___0 )first_char);
#line 139
  memmove((void *)alignment_a, (void const   *)(alignment_a + first_char), (size_t___0 )alignment_len);
#line 140
  memmove((void *)alignment_b, (void const   *)(alignment_b + first_char), (size_t___0 )alignment_len);
#line 142
  *(alignment_a + alignment_len) = (char )'\000';
#line 143
  *(alignment_b + alignment_len) = (char )'\000';
#line 145
  result->length = (size_t___0 )alignment_len;
#line 146
  return;
}
}
#line 1 "cil-bZeSPgEo.o"
#pragma merger("0","/tmp/cil-CTRg7PcT.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 47 "libs/sort_r/sort_r.h"
__inline static int sort_r_cmpswap(char * __restrict  a , char * __restrict  b , size_t___0 w ,
                                   int (*compar)(void const   *_a , void const   *_b ,
                                                 void *_arg ) , void *arg ) 
{ 
  char tmp ;
  char *end ;
  int tmp___0 ;

  {
#line 52
  end = (char *)(a + w);
#line 53
  tmp___0 = (*compar)((void const   *)a, (void const   *)b, arg);
#line 53
  if (tmp___0 > 0) {
#line 54
    while ((unsigned long )a < (unsigned long )end) {
#line 54
      tmp = *a;
#line 54
      *a = *b;
#line 54
      *b = tmp;
#line 54
      a ++;
#line 54
      b ++;
    }
#line 55
    return (1);
  }
#line 57
  return (0);
}
}
#line 62 "libs/sort_r/sort_r.h"
__inline static void sort_r_simple(void *base , size_t___0 nel , size_t___0 w , int (*compar)(void const   *_a ,
                                                                                              void const   *_b ,
                                                                                              void *_arg ) ,
                                   void *arg ) 
{ 
  char *b ;
  char *end ;
  char *pi ;
  char *pj ;
  int tmp ;
  char *x ;
  char *y ;
  char *xend ;
  char ch ;
  char *pl ;
  char *pr ;
  char *last ;
  char *tmp___0 ;
  char *l[3] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 67
  b = (char *)base;
#line 67
  end = b + nel * w;
#line 68
  if (nel < 7UL) {
#line 71
    pi = b + w;
#line 71
    while ((unsigned long )pi < (unsigned long )end) {
#line 72
      pj = pi;
#line 72
      while (1) {
#line 72
        if ((unsigned long )pj > (unsigned long )b) {
#line 72
          tmp = sort_r_cmpswap((char * __restrict  )(pj - w), (char * __restrict  )pj,
                               w, compar, arg);
#line 72
          if (! tmp) {
#line 72
            break;
          }
        } else {
#line 72
          break;
        }
#line 72
        pj -= w;
      }
#line 71
      pi += w;
    }
  } else {
#line 82
    last = b + w * (nel - 1UL);
#line 84
    l[0] = b;
#line 85
    l[1] = b + w * (nel / 2UL);
#line 86
    l[2] = last;
#line 88
    tmp___1 = (*compar)((void const   *)l[0], (void const   *)l[1], arg);
#line 88
    if (tmp___1 > 0) {
#line 88
      tmp___0 = l[0];
#line 88
      l[0] = l[1];
#line 88
      l[1] = tmp___0;
    }
#line 89
    tmp___3 = (*compar)((void const   *)l[1], (void const   *)l[2], arg);
#line 89
    if (tmp___3 > 0) {
#line 90
      tmp___0 = l[1];
#line 90
      l[1] = l[2];
#line 90
      l[2] = tmp___0;
#line 91
      tmp___2 = (*compar)((void const   *)l[0], (void const   *)l[1], arg);
#line 91
      if (tmp___2 > 0) {
#line 91
        tmp___0 = l[0];
#line 91
        l[0] = l[1];
#line 91
        l[1] = tmp___0;
      }
    }
#line 95
    x = l[1];
#line 95
    y = last;
#line 95
    xend = x + w;
#line 95
    while ((unsigned long )x < (unsigned long )xend) {
#line 96
      ch = *x;
#line 96
      *x = *y;
#line 96
      *y = ch;
#line 95
      x ++;
#line 95
      y ++;
    }
#line 99
    pl = b;
#line 100
    pr = last;
#line 102
    while ((unsigned long )pl < (unsigned long )pr) {
#line 103
      while ((unsigned long )pl < (unsigned long )pr) {
#line 104
        tmp___4 = sort_r_cmpswap((char * __restrict  )pl, (char * __restrict  )pr,
                                 w, compar, arg);
#line 104
        if (tmp___4) {
#line 105
          pr -= w;
#line 106
          break;
        }
#line 103
        pl += w;
      }
#line 109
      while ((unsigned long )pl < (unsigned long )pr) {
#line 110
        tmp___5 = sort_r_cmpswap((char * __restrict  )pl, (char * __restrict  )pr,
                                 w, compar, arg);
#line 110
        if (tmp___5) {
#line 111
          pl += w;
#line 112
          break;
        }
#line 109
        pr -= w;
      }
    }
#line 117
    sort_r_simple((void *)b, (size_t___0 )(pl - b) / w, w, compar, arg);
#line 118
    sort_r_simple((void *)(pl + w), (size_t___0 )(end - (pl + w)) / w, w, compar,
                  arg);
  }
#line 120
  return;
}
}
#line 179 "libs/sort_r/sort_r.h"
__inline static void sort_r(void *base , size_t___0 nel , size_t___0 width , int (*compar)(void const   *_a ,
                                                                                           void const   *_b ,
                                                                                           void *_arg ) ,
                            void *arg ) 
{ 


  {
#line 213
  sort_r_simple(base, nel, width, compar, arg);
#line 216
  return;
}
}
#line 16 "src/alignment.h"
__inline static size_t___0 _rndup2pow64___0(unsigned long long x ) 
{ 


  {
#line 18
  x --;
#line 18
  x |= x >> 1;
#line 18
  x |= x >> 2;
#line 18
  x |= x >> 4;
#line 18
  x |= x >> 8;
#line 18
  x |= x >> 16;
#line 18
  x |= x >> 32;
#line 18
  x ++;
#line 19
  return ((size_t___0 )x);
}
}
#line 21 "src/smith_waterman.h"
sw_aligner_t *smith_waterman_new(void) ;
#line 22
void smith_waterman_free(sw_aligner_t *sw ) ;
#line 24
aligner_t *smith_waterman_get_aligner(sw_aligner_t *sw ) ;
#line 30
void smith_waterman_align(char const   *a , char const   *b , scoring_t const   *scoring ,
                          sw_aligner_t *sw ) ;
#line 33
void smith_waterman_align2(char const   *a , char const   *b , size_t___0 len_a ,
                           size_t___0 len_b , scoring_t const   *scoring , sw_aligner_t *sw ) ;
#line 39
int smith_waterman_fetch(sw_aligner_t *sw , alignment_t *result ) ;
#line 25 "src/smith_waterman.c"
__inline static BitSet *bitset_alloc(BitSet *bs , size_t___0 l ) 
{ 
  void *tmp ;
  BitSet *tmp___0 ;

  {
#line 26
  bs->s = (l + 31UL) / 32UL;
#line 27
  bs->l = l;
#line 28
  tmp = calloc(sizeof(*(bs->b + 0)), bs->s);
#line 28
  bs->b = (uint32_t *)tmp;
#line 29
  if (bs->b) {
#line 29
    tmp___0 = bs;
  } else {
#line 29
    tmp___0 = (BitSet *)((void *)0);
  }
#line 29
  return (tmp___0);
}
}
#line 32 "src/smith_waterman.c"
__inline static void bitset_dealloc(BitSet *bs ) 
{ 


  {
#line 33
  free((void *)bs->b);
#line 34
  memset((void *)bs, 0, sizeof(*bs));
#line 35
  return;
}
}
#line 37 "src/smith_waterman.c"
__inline static BitSet *bitset_set_length(BitSet *bs , size_t___0 l ) 
{ 
  size_t___0 ss ;
  void *tmp ;
  BitSet *tmp___0 ;

  {
#line 38
  ss = (l + 31UL) / 32UL;
#line 39
  if (ss > bs->s) {
#line 40
    tmp = realloc((void *)bs->b, ss * sizeof(*(bs->b + 0)));
#line 40
    bs->b = (uint32_t *)tmp;
#line 41
    memset((void *)(bs->b + bs->s), 0, (ss - bs->s) * sizeof(*(bs->b + 0)));
#line 42
    bs->s = ss;
  }
#line 44
  bs->l = l;
#line 45
  if (bs->b) {
#line 45
    tmp___0 = bs;
  } else {
#line 45
    tmp___0 = (BitSet *)((void *)0);
  }
#line 45
  return (tmp___0);
}
}
#line 71 "src/smith_waterman.c"
int sort_match_indices(void const   *aa , void const   *bb , void *arg ) 
{ 
  size_t___0 const   *a ;
  size_t___0 const   *b ;
  MatrixSort const   *tmp ;
  score_t const   *match_scores ;
  size_t___0 score_width ;
  long diff ;
  int tmp___0 ;

  {
#line 73
  a = (size_t___0 const   *)aa;
#line 74
  b = (size_t___0 const   *)bb;
#line 75
  tmp = (MatrixSort const   *)arg;
#line 78
  match_scores = (score_t const   *)tmp->match_scores;
#line 79
  score_width = (size_t___0 )tmp->score_width;
#line 81
  diff = (long )*(match_scores + *b) - (long )*(match_scores + *a);
#line 84
  if (diff == 0L) {
#line 84
    return ((int )(*a % (unsigned long const   )score_width - *b % (unsigned long const   )score_width));
  } else {
#line 85
    if (diff > 0L) {
#line 85
      tmp___0 = 1;
    } else {
#line 85
      tmp___0 = -1;
    }
#line 85
    return (tmp___0);
  }
}
}
#line 88 "src/smith_waterman.c"
static void _init_history(sw_history_t *hist ) 
{ 
  size_t___0 mem ;
  void *tmp ;

  {
#line 90
  bitset_alloc(& hist->match_scores_mask, (size_t___0 )256);
#line 91
  hist->hits_capacity = (size_t___0 )256;
#line 92
  mem = hist->hits_capacity * sizeof(*(hist->sorted_match_indices));
#line 93
  tmp = malloc(mem);
#line 93
  hist->sorted_match_indices = (size_t___0 *)tmp;
#line 94
  return;
}
}
#line 96 "src/smith_waterman.c"
static void _ensure_history_capacity(sw_history_t *hist , size_t___0 arr_size ) 
{ 
  size_t___0 mem ;
  void *tmp ;

  {
#line 98
  if (arr_size > hist->hits_capacity) {
#line 99
    hist->hits_capacity = _rndup2pow64___0((unsigned long long )arr_size);
#line 100
    bitset_set_length(& hist->match_scores_mask, hist->hits_capacity);
#line 102
    mem = hist->hits_capacity * sizeof(*(hist->sorted_match_indices));
#line 103
    tmp = realloc((void *)hist->sorted_match_indices, mem);
#line 103
    hist->sorted_match_indices = (size_t___0 *)tmp;
#line 104
    if (! hist->match_scores_mask.b) {
#line 105
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: Out of memory\n",
              "src/smith_waterman.c", 105);
#line 106
      exit(1);
    } else
#line 104
    if (! hist->sorted_match_indices) {
#line 105
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: Out of memory\n",
              "src/smith_waterman.c", 105);
#line 106
      exit(1);
    }
  }
#line 109
  return;
}
}
#line 111 "src/smith_waterman.c"
sw_aligner_t *smith_waterman_new(void) 
{ 
  sw_aligner_t *sw ;
  void *tmp ;

  {
#line 113
  tmp = calloc((size_t )1, sizeof(sw_aligner_t ));
#line 113
  sw = (sw_aligner_t *)tmp;
#line 114
  _init_history(& sw->history);
#line 115
  return (sw);
}
}
#line 118 "src/smith_waterman.c"
void smith_waterman_free(sw_aligner_t *sw ) 
{ 


  {
#line 120
  aligner_destroy(& sw->aligner);
#line 121
  bitset_dealloc(& sw->history.match_scores_mask);
#line 122
  free((void *)sw->history.sorted_match_indices);
#line 123
  free((void *)sw);
#line 124
  return;
}
}
#line 126 "src/smith_waterman.c"
aligner_t *smith_waterman_get_aligner(sw_aligner_t *sw ) 
{ 


  {
#line 128
  return (& sw->aligner);
}
}
#line 131 "src/smith_waterman.c"
void smith_waterman_align(char const   *a , char const   *b , scoring_t const   *scoring ,
                          sw_aligner_t *sw ) 
{ 
  size_t___0 tmp ;
  size_t___0 tmp___0 ;

  {
#line 134
  tmp = strlen(b);
#line 134
  tmp___0 = strlen(a);
#line 134
  smith_waterman_align2(a, b, tmp___0, tmp, scoring, sw);
#line 135
  return;
}
}
#line 137 "src/smith_waterman.c"
void smith_waterman_align2(char const   *a , char const   *b , size_t___0 len_a ,
                           size_t___0 len_b , scoring_t const   *scoring , sw_aligner_t *sw ) 
{ 
  aligner_t *aligner ;
  sw_history_t *hist ;
  size_t___0 arr_size ;
  size_t___0 tmp ;
  size_t___0 pos ;
  size_t___0 tmp___0 ;
  MatrixSort tmp_struct ;

  {
#line 141
  aligner = & sw->aligner;
#line 142
  hist = & sw->history;
#line 143
  aligner_align(aligner, a, b, len_a, len_b, scoring, (char)1);
#line 145
  arr_size = aligner->score_width * aligner->score_height;
#line 146
  _ensure_history_capacity(hist, arr_size);
#line 149
  memset((void *)hist->match_scores_mask.b, 0, (hist->match_scores_mask.l + 31UL) / 32UL);
#line 150
  tmp = (size_t___0 )0;
#line 150
  hist->next_hit = tmp;
#line 150
  hist->num_of_hits = tmp;
#line 153
  pos = (size_t___0 )0;
#line 153
  while (pos < arr_size) {
#line 154
    if (*(aligner->match_scores + pos) > 0) {
#line 155
      tmp___0 = hist->num_of_hits;
#line 155
      (hist->num_of_hits) ++;
#line 155
      *(hist->sorted_match_indices + tmp___0) = pos;
    }
#line 153
    pos ++;
  }
#line 159
  tmp_struct.match_scores = aligner->match_scores;
#line 159
  tmp_struct.score_width = (unsigned int )aligner->score_width;
#line 160
  sort_r((void *)hist->sorted_match_indices, hist->num_of_hits, sizeof(size_t___0 ),
         & sort_match_indices, (void *)(& tmp_struct));
#line 162
  return;
}
}
#line 165 "src/smith_waterman.c"
static char _follow_hit(sw_aligner_t *sw , size_t___0 arr_index , alignment_t *result ) 
{ 
  aligner_t const   *aligner ;
  sw_history_t const   *hist ;
  size_t___0 score_x ;
  size_t___0 score_y ;
  enum Matrix curr_matrix ;
  score_t curr_score ;
  size_t___0 end_arr_index ;
  size_t___0 end_score_x ;
  size_t___0 end_score_y ;
  score_t end_score ;
  size_t___0 length ;
  unsigned int i ;

  {
#line 168
  aligner = (aligner_t const   *)(& sw->aligner);
#line 169
  hist = (sw_history_t const   *)(& sw->history);
#line 172
  score_x = arr_index % (unsigned long )aligner->score_width;
#line 173
  score_y = arr_index / (size_t___0 )aligner->score_width;
#line 176
  curr_matrix = (enum Matrix )0;
#line 177
  curr_score = *(aligner->match_scores + arr_index);
#line 180
  end_arr_index = arr_index;
#line 181
  end_score_x = score_x;
#line 182
  end_score_y = score_y;
#line 183
  end_score = curr_score;
#line 187
  length = (size_t___0 )0;
#line 187
  while (1) {
#line 189
    if ((*(hist->match_scores_mask.b + (arr_index >> 5)) >> (arr_index & 31UL)) & 1U) {
#line 189
      return ((char)0);
    }
#line 190
    *(hist->match_scores_mask.b + (arr_index >> 5)) |= (unsigned int )(1 << (arr_index & 31UL));
#line 192
    if (curr_score == 0) {
#line 192
      break;
    }
#line 197
    alignment_reverse_move(& curr_matrix, & curr_score, & score_x, & score_y, & arr_index,
                           aligner);
#line 187
    length ++;
  }
#line 203
  result->length = length;
#line 205
  alignment_ensure_capacity(result, length);
#line 208
  arr_index = end_arr_index;
#line 209
  score_x = end_score_x;
#line 210
  score_y = end_score_y;
#line 211
  curr_matrix = (enum Matrix )0;
#line 212
  curr_score = end_score;
#line 217
  i = (unsigned int )(length - 1UL);
#line 217
  while (curr_score > 0) {
#line 219
    switch ((unsigned int )curr_matrix) {
    case 0U: 
#line 222
    *(result->result_a + i) = (char )*(aligner->seq_a + (score_x - 1UL));
#line 223
    *(result->result_b + i) = (char )*(aligner->seq_b + (score_y - 1UL));
#line 224
    break;
    case 1U: 
#line 227
    *(result->result_a + i) = (char )'-';
#line 228
    *(result->result_b + i) = (char )*(aligner->seq_b + (score_y - 1UL));
#line 229
    break;
    case 2U: 
#line 232
    *(result->result_a + i) = (char )*(aligner->seq_a + (score_x - 1UL));
#line 233
    *(result->result_b + i) = (char )'-';
#line 234
    break;
    default: 
#line 237
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Program error: invalid matrix in _follow_hit()\n");
#line 238
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Please submit a bug report to: turner.isaac@gmail.com\n");
#line 239
    exit(1);
    }
#line 242
    alignment_reverse_move(& curr_matrix, & curr_score, & score_x, & score_y, & arr_index,
                           aligner);
#line 217
    i --;
  }
#line 246
  *(result->result_a + length) = (char )'\000';
#line 247
  *(result->result_b + length) = (char )'\000';
#line 249
  result->score = end_score;
#line 251
  result->pos_a = score_x;
#line 252
  result->pos_b = score_y;
#line 254
  result->len_a = end_score_x - score_x;
#line 255
  result->len_b = end_score_y - score_y;
#line 257
  return ((char)1);
}
}
#line 260 "src/smith_waterman.c"
int smith_waterman_fetch(sw_aligner_t *sw , alignment_t *result ) 
{ 
  sw_history_t *hist ;
  size_t___0 arr_index ;
  size_t___0 tmp ;
  char tmp___0 ;

  {
#line 262
  hist = & sw->history;
#line 264
  while (hist->next_hit < hist->num_of_hits) {
#line 266
    tmp = hist->next_hit;
#line 266
    (hist->next_hit) ++;
#line 266
    arr_index = *(hist->sorted_match_indices + tmp);
#line 269
    if (! ((*(hist->match_scores_mask.b + (arr_index >> 5)) >> (arr_index & 31UL)) & 1U)) {
#line 269
      tmp___0 = _follow_hit(sw, arr_index, result);
#line 269
      if (tmp___0) {
#line 272
        return (1);
      }
    }
  }
#line 276
  return (0);
}
}
#line 1 "cil-OaWHvVcb.o"
#pragma merger("0","/tmp/cil-k0NGYbzC.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 20 "src/tools/lcs_cmdline.c"
static void print_usage___0(char **argv ) 
{ 


  {
#line 22
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s [options] <sequence>\n",
          *(argv + 0));
#line 23
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  Print substrings in decreasing order of length\n");
#line 28
  exit(1);
}
}
#line 31 "src/tools/lcs_cmdline.c"
int main(int argc , char **argv ) 
{ 
  char *seq ;
  size_t___0 seqlen ;
  size_t___0 tmp ;
  int match ;
  int mismatch ;
  int gap_open ;
  int gap_extend ;
  _Bool no_start_gap_penalty ;
  _Bool no_end_gap_penalty ;
  _Bool no_gaps_in_a ;
  _Bool no_gaps_in_b ;
  _Bool no_mismatches ;
  _Bool case_sensitive ;
  scoring_t scoring ;
  sw_aligner_t *sw ;
  sw_aligner_t *tmp___0 ;
  alignment_t *aln ;
  alignment_t *tmp___1 ;
  int tmp___2 ;

  {
#line 33
  if (argc != 2) {
#line 33
    print_usage___0(argv);
  }
#line 35
  seq = *(argv + 1);
#line 36
  tmp = strlen((char const   *)seq);
#line 36
  seqlen = tmp;
#line 39
  match = 1;
#line 39
  mismatch = -1;
#line 39
  gap_open = -4;
#line 39
  gap_extend = -1;
#line 41
  no_start_gap_penalty = (_Bool)0;
#line 41
  no_end_gap_penalty = (_Bool)0;
#line 42
  no_gaps_in_a = (_Bool)1;
#line 42
  no_gaps_in_b = (_Bool)1;
#line 43
  no_mismatches = (_Bool)1;
#line 43
  case_sensitive = (_Bool)1;
#line 46
  scoring_init(& scoring, match, mismatch, gap_open, gap_extend, no_start_gap_penalty,
               no_end_gap_penalty, no_gaps_in_a, no_gaps_in_b, no_mismatches, case_sensitive);
#line 52
  tmp___0 = smith_waterman_new();
#line 52
  sw = tmp___0;
#line 53
  tmp___1 = alignment_create(seqlen + 1UL);
#line 53
  aln = tmp___1;
#line 55
  smith_waterman_align((char const   *)seq, (char const   *)seq, (scoring_t const   *)(& scoring),
                       sw);
#line 58
  while (1) {
#line 58
    tmp___2 = smith_waterman_fetch(sw, aln);
#line 58
    if (! tmp___2) {
#line 58
      break;
    }
#line 60
    if (aln->pos_a < aln->pos_b) {
#line 61
      fputs((char const   * __restrict  )aln->result_a, (FILE * __restrict  )stdout);
#line 62
      printf((char const   * __restrict  )" [%zu,%zu]\n", aln->pos_a, aln->pos_b);
    }
  }
#line 66
  smith_waterman_free(sw);
#line 67
  alignment_free(aln);
#line 69
  return (0);
}
}
