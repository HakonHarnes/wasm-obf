/* Generated by CIL v. %%VERSION_NUM%% */
/* print_CIL_Input is true */

#line 46 "/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h"
typedef unsigned long size_t___0;
#line 398 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
struct _IO_FILE ;
#line 398 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef struct _IO_FILE FILE;
#line 65 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h"
typedef unsigned short u_short;
#line 86 "../tree.h"
enum __anonenum_bool_753424039 {
    FALSE = 0,
    TRUE = 1
} ;
#line 86 "../tree.h"
typedef enum __anonenum_bool_753424039 bool;
#line 146 "../tree.h"
struct colortable {
   char *term_flg ;
   char *CSS_name ;
   char *font_fg ;
   char *font_bg ;
};
#line 149 "../tree.h"
struct extensions {
   char *ext ;
   char *term_flg ;
   char *CSS_name ;
   char *web_fg ;
   char *web_bg ;
   char *web_extattr ;
   struct extensions *nxt ;
};
#line 154 "../tree.h"
struct linedraw {
   char const   **name ;
   char const   *vert ;
   char const   *vert_left ;
   char const   *corner ;
   char const   *copy ;
   char const   *ctop ;
   char const   *cbot ;
   char const   *cmid ;
   char const   *cext ;
   char const   *csingle ;
};
#line 176 "../color.c"
struct __anonstruct_cmds_476363767 {
   char *cmd ;
   char cmdnum ;
};
#line 139 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned long size_t;
#line 241 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long off_t;
#line 81 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long long time_t;
#line 231 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int mode_t;
#line 246 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned long long ino_t;
#line 251 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int dev_t;
#line 328 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int uid_t;
#line 333 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int gid_t;
#line 67 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h"
typedef unsigned long u_long;
#line 91 "../tree.h"
struct _info {
   char *name ;
   char *lnk ;
   bool isdir ;
   bool issok ;
   bool isfifo ;
   bool isexe ;
   bool orphan ;
   mode_t mode ;
   mode_t lnkmode ;
   uid_t uid ;
   gid_t gid ;
   off_t size ;
   time_t atime ;
   time_t ctime ;
   time_t mtime ;
   dev_t dev ;
   dev_t ldev ;
   ino_t inode ;
   ino_t linode ;
   char *err ;
   char const   *tag ;
   char **comment ;
   struct _info **child ;
   struct _info *next ;
   struct _info *tchild ;
};
#line 164 "../tree.h"
struct pattern {
   char *pattern ;
   int relative ;
   struct pattern *next ;
};
#line 170 "../tree.h"
struct ignorefile {
   char *path ;
   struct pattern *remove ;
   struct pattern *reverse ;
   struct ignorefile *next ;
};
#line 20 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   uid_t pw_uid ;
   gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 19 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   gid_t gr_gid ;
   char **gr_mem ;
};
#line 134 "../tree.h"
struct xtable {
   unsigned int xid ;
   char *name ;
   struct xtable *nxt ;
};
#line 139 "../tree.h"
struct inotable {
   ino_t inode ;
   dev_t device ;
   struct inotable *nxt ;
};
#line 64 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h"
typedef unsigned char u_char;
#line 66 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h"
typedef unsigned int u_int;
#line 116 "../tree.h"
struct totals {
   u_long files ;
   u_long dirs ;
   off_t size ;
};
#line 177 "../tree.h"
struct comment {
   struct pattern *pattern ;
   char **desc ;
   struct comment *next ;
};
#line 183 "../tree.h"
struct infofile {
   char *path ;
   struct comment *comments ;
   struct infofile *next ;
};
#line 312 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
#line 236 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned long nlink_t;
#line 256 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef int blksize_t;
#line 261 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef int blkcnt_t;
#line 4 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h"
struct stat {
   dev_t st_dev ;
   int __st_dev_padding ;
   long __st_ino_truncated ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   int __st_rdev_padding ;
   off_t st_size ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   ino_t st_ino ;
};
#line 121 "../tree.h"
struct listingcalls {
   void (*intro)(void) ;
   void (*outtro)(void) ;
   int (*printinfo)(char *dirname , struct _info *file , int level ) ;
   int (*printfile)(char *dirname , char *filename , struct _info *file , int descend ) ;
   int (*error)(char *error ) ;
   void (*newline)(struct _info *file , int level , int postdir , int needcomma ) ;
   void (*close)(struct _info *file , int level , int needcomma ) ;
   void (*report)(struct totals tot ) ;
};
#line 38 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef int wchar_t;
#line 74 "/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h"
typedef int wchar_t___0;
#line 154 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef long ssize_t;
#line 40 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 5 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h"
struct dirent {
   ino_t d_ino ;
   off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 20 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h"
struct __dirstream ;
#line 20 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h"
typedef struct __dirstream DIR;
#line 11 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/nl_types.h"
typedef int nl_item;
#line 51 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h"
typedef unsigned int wint_t;
#line 83 "../tree.c"
struct sorts {
   char *name ;
   int (*cmpfunc)() ;
};
#line 1 "cil-GYQoP7E8.o"
#pragma merger("0","/tmp/cil-Hu4juU2I.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 43 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern void free(void * ) ;
#line 53
extern char *getenv(char const   * ) ;
#line 74 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern FILE *stderr ;
#line 116
extern int fputs(char const   * , FILE * ) ;
#line 120
extern int fprintf(FILE * , char const   *  , ...) ;
#line 121
extern int sprintf(char * , char const   *  , ...) ;
#line 33 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern char *strcpy(char * , char const   * ) ;
#line 39
extern int strcmp(char const   * , char const   * ) ;
#line 52
extern char *strtok(char * __restrict   , char const   * __restrict   ) ;
#line 54
extern size_t___0 strlen(char const   * ) ;
#line 29 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h"
extern int strcasecmp(char const   * , char const   * ) ;
#line 118 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h"
extern int isatty(int  ) ;
#line 210 "../tree.h"
void *xmalloc(size_t___0 size ) ;
#line 210
void *xrealloc(void *ptr , size_t___0 size ) ;
#line 275
void parse_dir_colors(void) ;
#line 276
int color(u_short mode , char *name , bool orphan , bool islink ) ;
#line 277
void endcolor(void) ;
#line 278
char const   *getcharset(void) ;
#line 279
void initlinedraw(int flag ) ;
#line 55 "../color.c"
bool colorize  =    (bool )0;
#line 55 "../color.c"
bool ansilines  =    (bool )0;
#line 55 "../color.c"
bool linktargetcolor  =    (bool )0;
#line 56 "../color.c"
char *term  ;
#line 56 "../color.c"
char termmatch  =    (char)0;
#line 56 "../color.c"
char istty  ;
#line 58 "../color.c"
char *color_code[26]  = {      (char *)((void *)0)};
#line 60 "../color.c"
char *vgacolor[18]  = 
#line 60
  {      "black",      "red",      "green",      "yellow", 
        "blue",      "fuchsia",      "aqua",      "white", 
        (char *)((void *)0),      (char *)((void *)0),      "transparent",      "red", 
        "green",      "yellow",      "blue",      "fuchsia", 
        "aqua",      "black"};
#line 66 "../color.c"
struct colortable colortable[11]  ;
#line 67 "../color.c"
struct extensions *ext  =    (struct extensions *)((void *)0);
#line 68 "../color.c"
struct linedraw  const  *linedraw  ;
#line 70
char **split(char *str , char *delim , int *nwrds ) ;
#line 71
int cmd(char *s ) ;
#line 73
FILE *outfile ;
#line 74
bool Hflag ;
#line 74
bool force_color ;
#line 74
bool nocolor ;
#line 75
char const   *charset ;
#line 77 "../color.c"
void parse_dir_colors(void) 
{ 
  char buf___1[1025] ;
  char **arg ;
  char **c ;
  char *colors ;
  char *s ;
  char *cc ;
  int i ;
  int n ;
  int col ;
  struct extensions *e ;
  char *tmp ;
  char *tmp___0 ;
  size_t___0 tmp___1 ;
  int tmp___2 ;
  int i___0 ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  size_t___0 tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  size_t___0 tmp___11 ;
  void *tmp___12 ;
  size_t___0 tmp___13 ;
  void *tmp___14 ;
  size_t___0 tmp___15 ;
  void *tmp___16 ;
  size_t___0 tmp___17 ;
  void *tmp___18 ;
  size_t___0 tmp___19 ;
  void *tmp___20 ;

  {
#line 83
  if (Hflag) {
#line 83
    return;
  }
#line 85
  tmp = getenv((char const   *)"TERM");
#line 85
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 86
    colorize = (bool )0;
#line 87
    return;
  }
#line 90
  s = getenv((char const   *)"TREE_COLORS");
#line 91
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 91
    s = getenv((char const   *)"LS_COLORS");
  }
#line 92
  cc = getenv((char const   *)"CLICOLOR");
#line 93
  tmp___0 = getenv((char const   *)"CLICOLOR_FORCE");
#line 93
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 93
    if (! nocolor) {
#line 93
      force_color = (bool )1;
    }
  }
#line 94
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 94
    goto _L;
  } else {
#line 94
    tmp___1 = strlen((char const   *)s);
#line 94
    if (tmp___1 == 0UL) {
      _L: /* CIL Label */ 
#line 94
      if (force_color) {
#line 94
        s = ":no=00:rs=0:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:";
      } else
#line 94
      if ((unsigned long )cc != (unsigned long )((void *)0)) {
#line 94
        s = ":no=00:rs=0:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:";
      }
    }
  }
#line 96
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 97
    colorize = (bool )0;
#line 98
    return;
  } else
#line 96
  if (! force_color) {
#line 96
    if (nocolor) {
#line 97
      colorize = (bool )0;
#line 98
      return;
    } else {
#line 96
      tmp___2 = isatty(1);
#line 96
      if (! tmp___2) {
#line 97
        colorize = (bool )0;
#line 98
        return;
      }
    }
  }
#line 101
  colorize = (bool )1;
#line 103
  i___0 = 0;
#line 103
  while (i___0 < 25) {
#line 103
    color_code[i___0] = (char *)((void *)0);
#line 103
    i___0 ++;
  }
#line 105
  tmp___3 = strlen((char const   *)s);
#line 105
  tmp___4 = xmalloc(tmp___3 + 1UL);
#line 105
  colors = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )s);
#line 107
  arg = split(colors, ":", & n);
#line 109
  i = 0;
#line 109
  while (*(arg + i)) {
#line 110
    c = split(*(arg + i), "=", & n);
#line 112
    col = cmd(*(c + 0));
#line 112
    switch (col) {
    case -1: 
#line 114
    break;
    case 25: 
#line 116
    if (*(c + 1)) {
#line 117
      tmp___5 = xmalloc(sizeof(struct extensions ));
#line 117
      e = (struct extensions *)tmp___5;
#line 118
      tmp___6 = strlen((char const   *)(*(c + 0) + 1));
#line 118
      tmp___7 = xmalloc(tmp___6 + 1UL);
#line 118
      e->ext = strcpy((char * __restrict  )tmp___7, (char const   * __restrict  )(*(c + 0) + 1));
#line 119
      tmp___8 = strlen((char const   *)*(c + 1));
#line 119
      tmp___9 = xmalloc(tmp___8 + 1UL);
#line 119
      e->term_flg = strcpy((char * __restrict  )tmp___9, (char const   * __restrict  )*(c + 1));
#line 120
      e->nxt = ext;
#line 121
      ext = e;
    }
#line 123
    break;
    case 8: 
#line 125
    if (*(c + 1)) {
#line 125
      tmp___10 = strcasecmp((char const   *)"target", (char const   *)*(c + 1));
#line 125
      if (tmp___10 == 0) {
#line 126
        linktargetcolor = (bool )1;
#line 127
        color_code[8] = "01;36";
#line 128
        break;
      }
    }
    default: 
#line 131
    if (*(c + 1)) {
#line 131
      tmp___11 = strlen((char const   *)*(c + 1));
#line 131
      tmp___12 = xmalloc(tmp___11 + 1UL);
#line 131
      color_code[col] = strcpy((char * __restrict  )tmp___12, (char const   * __restrict  )*(c + 1));
    }
#line 132
    break;
    }
#line 135
    free((void *)c);
#line 109
    i ++;
  }
#line 137
  free((void *)arg);
#line 143
  if (! color_code[22]) {
#line 143
    tmp___13 = strlen((char const   *)"\033[");
#line 143
    tmp___14 = xmalloc(tmp___13 + 1UL);
#line 143
    color_code[22] = strcpy((char * __restrict  )tmp___14, (char const   * __restrict  )"\033[");
  }
#line 144
  if (! color_code[23]) {
#line 144
    tmp___15 = strlen((char const   *)"m");
#line 144
    tmp___16 = xmalloc(tmp___15 + 1UL);
#line 144
    color_code[23] = strcpy((char * __restrict  )tmp___16, (char const   * __restrict  )"m");
  }
#line 145
  if (! color_code[4]) {
#line 145
    tmp___17 = strlen((char const   *)"0");
#line 145
    tmp___18 = xmalloc(tmp___17 + 1UL);
#line 145
    color_code[4] = strcpy((char * __restrict  )tmp___18, (char const   * __restrict  )"0");
  }
#line 146
  if (! color_code[24]) {
#line 147
    sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%s%s%s",
            color_code[22], color_code[4], color_code[23]);
#line 148
    tmp___19 = strlen((char const   *)(buf___1));
#line 148
    tmp___20 = xmalloc(tmp___19 + 1UL);
#line 148
    color_code[24] = strcpy((char * __restrict  )tmp___20, (char const   * __restrict  )(buf___1));
  }
#line 151
  free((void *)colors);
#line 152
  return;
}
}
#line 158 "../color.c"
char **split(char *str , char *delim , int *nwrds ) 
{ 
  int n ;
  char **w ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 160
  n = 128;
#line 161
  tmp = xmalloc(sizeof(char *) * (unsigned long )n);
#line 161
  w = (char **)tmp;
#line 163
  tmp___0 = 0;
#line 163
  *nwrds = tmp___0;
#line 163
  *(w + tmp___0) = strtok((char * __restrict  )str, (char const   * __restrict  )delim);
#line 165
  while (*(w + *nwrds)) {
#line 166
    if (*nwrds == n - 2) {
#line 166
      n += 256;
#line 166
      tmp___1 = xrealloc((void *)w, sizeof(char *) * (unsigned long )n);
#line 166
      w = (char **)tmp___1;
    }
#line 167
    (*nwrds) ++;
#line 167
    *(w + *nwrds) = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )delim);
  }
#line 170
  *(w + *nwrds) = (char *)((void *)0);
#line 171
  return (w);
}
}
#line 179 "../color.c"
static struct __anonstruct_cmds_476363767 cmds[22]  = 
#line 179
  {      {"rs", (char)4}, 
        {"no", (char)5}, 
        {"fi", (char)6}, 
        {"di", (char)7}, 
        {"ln", (char)8}, 
        {"pi", (char)9}, 
        {"do", (char)10}, 
        {"bd", (char)11}, 
        {"cd", (char)12}, 
        {"or", (char)13}, 
        {"so", (char)14}, 
        {"su", (char)15}, 
        {"sg", (char)16}, 
        {"tw", (char)17}, 
        {"ow", (char)18}, 
        {"st", (char)19}, 
        {"ex", (char)20}, 
        {"mi", (char)21}, 
        {"lc", (char)22}, 
        {"rc", (char)23}, 
        {"ec", (char)24}, 
        {(char *)((void *)0), (char)0}};
#line 174 "../color.c"
int cmd(char *s ) 
{ 
  int i ;
  int tmp ;

  {
#line 190
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 190
    return (-1);
  }
#line 192
  if ((int )*(s + 0) == 42) {
#line 192
    return (25);
  }
#line 193
  i = 0;
#line 193
  while (cmds[i].cmdnum) {
#line 194
    tmp = strcmp((char const   *)cmds[i].cmd, (char const   *)s);
#line 194
    if (! tmp) {
#line 194
      return ((int )cmds[i].cmdnum);
    }
#line 193
    i ++;
  }
#line 196
  return (-1);
}
}
#line 199 "../color.c"
int print_color(int color___0 ) 
{ 


  {
#line 201
  if (! color_code[color___0]) {
#line 201
    return (0);
  }
#line 203
  fputs((char const   * __restrict  )color_code[22], (FILE * __restrict  )outfile);
#line 204
  fputs((char const   * __restrict  )color_code[color___0], (FILE * __restrict  )outfile);
#line 205
  fputs((char const   * __restrict  )color_code[23], (FILE * __restrict  )outfile);
#line 206
  return (1);
}
}
#line 209 "../color.c"
void endcolor(void) 
{ 


  {
#line 211
  if (color_code[24]) {
#line 212
    fputs((char const   * __restrict  )color_code[24], (FILE * __restrict  )outfile);
  }
#line 213
  return;
}
}
#line 215 "../color.c"
int color(u_short mode , char *name , bool orphan , bool islink ) 
{ 
  struct extensions *e ;
  int l ;
  int xl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t___0 tmp___13 ;
  size_t___0 tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 220
  if (orphan) {
#line 221
    if (islink) {
#line 222
      tmp = print_color(21);
#line 222
      if (tmp) {
#line 222
        return (1);
      }
    } else {
#line 224
      tmp___0 = print_color(13);
#line 224
      if (tmp___0) {
#line 224
        return (1);
      }
    }
  }
#line 229
  switch ((int )mode & 0170000) {
  case 0010000: 
#line 231
  tmp___1 = print_color(9);
#line 231
  return (tmp___1);
  case 0020000: 
#line 233
  tmp___2 = print_color(12);
#line 233
  return (tmp___2);
  case 0040000: 
#line 235
  if ((int )mode & 01000) {
#line 236
    if ((int )mode & 0002) {
#line 237
      tmp___3 = print_color(17);
#line 237
      if (tmp___3) {
#line 237
        return (1);
      }
    }
#line 238
    if (! ((int )mode & 0002)) {
#line 239
      tmp___4 = print_color(19);
#line 239
      if (tmp___4) {
#line 239
        return (1);
      }
    }
  }
#line 241
  if ((int )mode & 0002) {
#line 242
    tmp___5 = print_color(18);
#line 242
    if (tmp___5) {
#line 242
      return (1);
    }
  }
#line 243
  tmp___6 = print_color(7);
#line 243
  return (tmp___6);
  case 0060000: 
#line 246
  tmp___7 = print_color(11);
#line 246
  return (tmp___7);
  case 0120000: 
#line 248
  tmp___8 = print_color(8);
#line 248
  return (tmp___8);
  case 0140000: 
#line 255
  tmp___9 = print_color(14);
#line 255
  return (tmp___9);
  case 0100000: 
#line 257
  if ((int )mode & 04000) {
#line 258
    tmp___10 = print_color(15);
#line 258
    if (tmp___10) {
#line 258
      return (1);
    }
  }
#line 259
  if ((int )mode & 02000) {
#line 260
    tmp___11 = print_color(16);
#line 260
    if (tmp___11) {
#line 260
      return (1);
    }
  }
#line 261
  if ((int )mode & 73) {
#line 262
    tmp___12 = print_color(20);
#line 262
    if (tmp___12) {
#line 262
      return (1);
    }
  }
#line 265
  tmp___13 = strlen((char const   *)name);
#line 265
  l = (int )tmp___13;
#line 266
  e = ext;
#line 266
  while (e) {
#line 267
    tmp___14 = strlen((char const   *)e->ext);
#line 267
    xl = (int )tmp___14;
#line 268
    if (l > xl) {
#line 268
      tmp___15 = name + (l - xl);
    } else {
#line 268
      tmp___15 = name;
    }
#line 268
    tmp___16 = strcmp((char const   *)tmp___15, (char const   *)e->ext);
#line 268
    if (! tmp___16) {
#line 269
      fputs((char const   * __restrict  )color_code[22], (FILE * __restrict  )outfile);
#line 270
      fputs((char const   * __restrict  )e->term_flg, (FILE * __restrict  )outfile);
#line 271
      fputs((char const   * __restrict  )color_code[23], (FILE * __restrict  )outfile);
#line 272
      return (1);
    }
#line 266
    e = e->nxt;
  }
#line 276
  tmp___17 = print_color(6);
#line 276
  return (tmp___17);
  }
#line 278
  tmp___18 = print_color(5);
#line 278
  return (tmp___18);
}
}
#line 284 "../color.c"
char const   *getcharset(void) 
{ 
  char *tmp ;

  {
#line 287
  tmp = getenv((char const   *)"TREE_CHARSET");
#line 287
  return ((char const   *)tmp);
}
}
#line 353 "../color.c"
static char const   *latin1_3[15]  = 
#line 353
  {      (char const   *)"ISO-8859-1",      (char const   *)"ISO-8859-1:1987",      (char const   *)"ISO_8859-1",      (char const   *)"latin1", 
        (char const   *)"l1",      (char const   *)"IBM819",      (char const   *)"CP819",      (char const   *)"csISOLatin1", 
        (char const   *)"ISO-8859-3",      (char const   *)"ISO_8859-3:1988",      (char const   *)"ISO_8859-3",      (char const   *)"latin3", 
        (char const   *)"ls",      (char const   *)"csISOLatin3",      (char const   *)((void *)0)};
#line 358 "../color.c"
static char const   *iso8859_789[22]  = 
#line 358
  {      (char const   *)"ISO-8859-7",      (char const   *)"ISO_8859-7:1987",      (char const   *)"ISO_8859-7",      (char const   *)"ELOT_928", 
        (char const   *)"ECMA-118",      (char const   *)"greek",      (char const   *)"greek8",      (char const   *)"csISOLatinGreek", 
        (char const   *)"ISO-8859-8",      (char const   *)"ISO_8859-8:1988",      (char const   *)"iso-ir-138",      (char const   *)"ISO_8859-8", 
        (char const   *)"hebrew",      (char const   *)"csISOLatinHebrew",      (char const   *)"ISO-8859-9",      (char const   *)"ISO_8859-9:1989", 
        (char const   *)"iso-ir-148",      (char const   *)"ISO_8859-9",      (char const   *)"latin5",      (char const   *)"l5", 
        (char const   *)"csISOLatin5",      (char const   *)((void *)0)};
#line 365 "../color.c"
static char const   *shift_jis[4]  = {      (char const   *)"Shift_JIS",      (char const   *)"MS_Kanji",      (char const   *)"csShiftJIS",      (char const   *)((void *)0)};
#line 368 "../color.c"
static char const   *euc_jp[4]  = {      (char const   *)"EUC-JP",      (char const   *)"Extended_UNIX_Code_Packed_Format_for_Japanese",      (char const   *)"csEUCPkdFmtJapanese",      (char const   *)((void *)0)};
#line 372 "../color.c"
static char const   *euc_kr[3]  = {      (char const   *)"EUC-KR",      (char const   *)"csEUCKR",      (char const   *)((void *)0)};
#line 375 "../color.c"
static char const   *iso2022jp[5]  = {      (char const   *)"ISO-2022-JP",      (char const   *)"csISO2022JP",      (char const   *)"ISO-2022-JP-2",      (char const   *)"csISO2022JP2", 
        (char const   *)((void *)0)};
#line 378 "../color.c"
static char const   *ibm_pc[25]  = 
#line 378
  {      (char const   *)"IBM437",      (char const   *)"cp437",      (char const   *)"437",      (char const   *)"csPC8CodePage437", 
        (char const   *)"IBM852",      (char const   *)"cp852",      (char const   *)"852",      (char const   *)"csPCp852", 
        (char const   *)"IBM863",      (char const   *)"cp863",      (char const   *)"863",      (char const   *)"csIBM863", 
        (char const   *)"IBM855",      (char const   *)"cp855",      (char const   *)"855",      (char const   *)"csIBM855", 
        (char const   *)"IBM865",      (char const   *)"cp865",      (char const   *)"865",      (char const   *)"csIBM865", 
        (char const   *)"IBM866",      (char const   *)"cp866",      (char const   *)"866",      (char const   *)"csIBM866", 
        (char const   *)((void *)0)};
#line 384 "../color.c"
static char const   *ibm_ps2[9]  = 
#line 384
  {      (char const   *)"IBM850",      (char const   *)"cp850",      (char const   *)"850",      (char const   *)"csPC850Multilingual", 
        (char const   *)"IBM00858",      (char const   *)"CCSID00858",      (char const   *)"CP00858",      (char const   *)"PC-Multilingual-850+euro", 
        (char const   *)((void *)0)};
#line 388 "../color.c"
static char const   *ibm_gr[6]  = {      (char const   *)"IBM869",      (char const   *)"cp869",      (char const   *)"869",      (char const   *)"cp-gr", 
        (char const   *)"csIBM869",      (char const   *)((void *)0)};
#line 391 "../color.c"
static char const   *gb[3]  = {      (char const   *)"GB2312",      (char const   *)"csGB2312",      (char const   *)((void *)0)};
#line 394 "../color.c"
static char const   *utf8[3]  = {      (char const   *)"UTF-8",      (char const   *)"utf8",      (char const   *)((void *)0)};
#line 397 "../color.c"
static char const   *big5[3]  = {      (char const   *)"Big5",      (char const   *)"csBig5",      (char const   *)((void *)0)};
#line 400 "../color.c"
static char const   *viscii[3]  = {      (char const   *)"VISCII",      (char const   *)"csVISCII",      (char const   *)((void *)0)};
#line 403 "../color.c"
static char const   *koi8ru[4]  = {      (char const   *)"KOI8-R",      (char const   *)"csKOI8R",      (char const   *)"KOI8-U",      (char const   *)((void *)0)};
#line 406 "../color.c"
static char const   *windows[13]  = 
#line 406
  {      (char const   *)"ISO-8859-1-Windows-3.1-Latin-1",      (char const   *)"csWindows31Latin1",      (char const   *)"ISO-8859-2-Windows-Latin-2",      (char const   *)"csWindows31Latin2", 
        (char const   *)"windows-1250",      (char const   *)"windows-1251",      (char const   *)"windows-1253",      (char const   *)"windows-1254", 
        (char const   *)"windows-1255",      (char const   *)"windows-1256",      (char const   *)"windows-1256",      (char const   *)"windows-1257", 
        (char const   *)((void *)0)};
#line 413 "../color.c"
static struct linedraw  const  cstable[16]  = 
#line 413
  {      {latin1_3, (char const   *)"|  ", (char const   *)"|--", (char const   *)"&middot;--",
      (char const   *)"&copy;", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {iso8859_789, (char const   *)"|  ", (char const   *)"|--", (char const   *)"&middot;--",
      (char const   *)"(c)", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {shift_jis, (char const   *)"\204\240 ", (char const   *)"\204\245", (char const   *)"\204\244",
      (char const   *)"(c)", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {euc_jp, (char const   *)"\250\242 ", (char const   *)"\250\247", (char const   *)"\250\246",
      (char const   *)"(c)", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {euc_kr, (char const   *)"\246\242 ", (char const   *)"\246\247", (char const   *)"\246\246",
      (char const   *)"(c)", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {iso2022jp, (char const   *)"\033$B(\"\033(B ", (char const   *)"\033$B(\'\033(B",
      (char const   *)"\033$B(&\033(B", (char const   *)"(c)", (char const   *)" [",
      (char const   *)" [", (char const   *)" [", (char const   *)" [", (char const   *)" ["}, 
        {ibm_pc, (char const   *)"\263  ", (char const   *)"\303\304\304", (char const   *)"\300\304\304",
      (char const   *)"(c)", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {ibm_ps2, (char const   *)"\263  ", (char const   *)"\303\304\304", (char const   *)"\300\304\304",
      (char const   *)"\227", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {ibm_gr, (char const   *)"\263  ", (char const   *)"\303\304\304", (char const   *)"\300\304\304",
      (char const   *)"\270", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {gb, (char const   *)"\251\246 ", (char const   *)"\251\300", (char const   *)"\251\270",
      (char const   *)"(c)", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {utf8, (char const   *)"\342\224\202\302\240\302\240", (char const   *)"\342\224\234\342\224\200\342\224\200",
      (char const   *)"\342\224\224\342\224\200\342\224\200", (char const   *)"\302\251",
      (char const   *)" \342\216\247", (char const   *)" \342\216\251", (char const   *)" \342\216\250",
      (char const   *)" \342\216\252", (char const   *)" {"}, 
        {big5, (char const   *)"\242x ", (char const   *)"\242u", (char const   *)"\242|",
      (char const   *)"(c)", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {viscii, (char const   *)"|  ", (char const   *)"|--", (char const   *)"`--",
      (char const   *)"\371", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {koi8ru, (char const   *)"\201  ", (char const   *)"\206\200\200", (char const   *)"\204\200\200",
      (char const   *)"\277", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {windows, (char const   *)"|  ", (char const   *)"|--", (char const   *)"`--",
      (char const   *)"\251", (char const   *)" [", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" ["}, 
        {(char const   **)((void *)0), (char const   *)"|  ", (char const   *)"|--",
      (char const   *)"`--", (char const   *)"(c)", (char const   *)" [", (char const   *)" [",
      (char const   *)" [", (char const   *)" [", (char const   *)" ["}};
#line 351 "../color.c"
void initlinedraw(int flag ) 
{ 
  char const   **s ;
  int tmp ;

  {
#line 450
  if (flag) {
#line 451
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --charset, valid charsets include:\n");
#line 452
    linedraw = cstable;
#line 452
    while (linedraw->name) {
#line 453
      s = (char const   **)linedraw->name;
#line 453
      while (*s) {
#line 454
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %s\n",
                *s);
#line 453
        s ++;
      }
#line 452
      linedraw ++;
    }
#line 457
    return;
  }
#line 459
  if (charset) {
#line 460
    linedraw = cstable;
#line 460
    while (linedraw->name) {
#line 461
      s = (char const   **)linedraw->name;
#line 461
      while (*s) {
#line 462
        tmp = strcasecmp(charset, *s);
#line 462
        if (! tmp) {
#line 462
          return;
        }
#line 461
        s ++;
      }
#line 460
      linedraw ++;
    }
  }
#line 464
  linedraw = (cstable + sizeof(cstable) / sizeof(cstable[0])) - 1;
#line 465
  return;
}
}
#line 1 "cil-narFNwCR.o"
#pragma merger("0","/tmp/cil-Rb_dOvMG.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 58 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern void qsort(void * , size_t  , size_t  , int (*)(void const   * , void const   * ) ) ;
#line 72 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern FILE *stdin ;
#line 80
extern FILE *fopen(char const   * , char const   * ) ;
#line 82
extern int fclose(FILE * ) ;
#line 111
extern char *fgets(char * , int  , FILE * ) ;
#line 29 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern void *memset(void * , int  , size_t___0  ) ;
#line 45
extern char *strchr(char const   * , int  ) ;
#line 19 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h"
extern int isspace(int  ) ;
#line 195 "../tree.h"
int patignore(char *name , int isdir ) ;
#line 196
int patinclude(char *name , int isdir ) ;
#line 288
struct _info **file_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) ;
#line 21 "../file.c"
bool dflag ;
#line 21
bool aflag ;
#line 21
bool pruneflag ;
#line 22
bool matchdirs ;
#line 24
int pattern ;
#line 24
int ipattern ;
#line 26
int (*topsort)() ;
#line 33
char *file_comment ;
#line 33
char *file_pathsep ;
#line 39
char *nextpc(char **p , int *tok ) ;
#line 39 "../file.c"
static char prev  =    (char)0;
#line 37 "../file.c"
char *nextpc(char **p , int *tok ) 
{ 
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 40
  s = *p;
#line 41
  if (! *(*p)) {
#line 42
    *tok = 3;
#line 43
    return ((char *)((void *)0));
  }
#line 45
  if (prev) {
#line 46
    prev = (char)0;
#line 47
    *tok = 0;
#line 48
    return ((char *)((void *)0));
  }
#line 50
  tmp = strchr((char const   *)file_pathsep, (int )*(*p));
#line 50
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 51
    (*p) ++;
#line 52
    *tok = 0;
#line 53
    return ((char *)((void *)0));
  }
#line 55
  while (1) {
#line 55
    if (*(*p)) {
#line 55
      tmp___0 = strchr((char const   *)file_pathsep, (int )*(*p));
#line 55
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 55
        break;
      }
    } else {
#line 55
      break;
    }
#line 55
    (*p) ++;
  }
#line 57
  if (*(*p)) {
#line 58
    *tok = 1;
#line 59
    prev = *(*p);
#line 60
    tmp___1 = *p;
#line 60
    (*p) ++;
#line 60
    *tmp___1 = (char )'\000';
  } else {
#line 61
    *tok = 2;
  }
#line 62
  return (s);
}
}
#line 65 "../file.c"
struct _info *newent(char *name ) 
{ 
  struct _info *n ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  struct _info *tmp___2 ;

  {
#line 66
  tmp = xmalloc(sizeof(struct _info ));
#line 66
  n = (struct _info *)tmp;
#line 67
  memset((void *)n, 0, sizeof(struct _info ));
#line 68
  tmp___0 = strlen((char const   *)name);
#line 68
  tmp___1 = xmalloc(tmp___0 + 1UL);
#line 68
  n->name = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )name);
#line 69
  n->child = (struct _info **)((void *)0);
#line 70
  tmp___2 = (struct _info *)((void *)0);
#line 70
  n->next = tmp___2;
#line 70
  n->tchild = tmp___2;
#line 71
  return (n);
}
}
#line 75 "../file.c"
struct _info *search(struct _info **dir , char *name ) 
{ 
  struct _info *ptr ;
  struct _info *prev___0 ;
  struct _info *n ;
  int cmp ;
  struct _info *tmp ;

  {
#line 80
  if ((unsigned long )*dir == (unsigned long )((void *)0)) {
#line 80
    tmp = newent(name);
#line 80
    *dir = tmp;
#line 80
    return (tmp);
  }
#line 82
  ptr = *dir;
#line 82
  prev___0 = ptr;
#line 82
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 83
    cmp = strcmp((char const   *)ptr->name, (char const   *)name);
#line 84
    if (cmp == 0) {
#line 84
      return (ptr);
    }
#line 85
    if (cmp > 0) {
#line 85
      break;
    }
#line 86
    prev___0 = ptr;
#line 82
    ptr = ptr->next;
  }
#line 88
  n = newent(name);
#line 89
  n->next = ptr;
#line 90
  if ((unsigned long )prev___0 == (unsigned long )ptr) {
#line 90
    *dir = n;
  } else {
#line 91
    prev___0->next = n;
  }
#line 92
  return (n);
}
}
#line 95 "../file.c"
void freefiletree(struct _info *ent ) 
{ 
  struct _info *ptr ;
  struct _info *t ;

  {
#line 97
  ptr = ent;
#line 99
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 100
    if (ptr->tchild) {
#line 100
      freefiletree(ptr->tchild);
    }
#line 101
    t = ptr;
#line 102
    ptr = ptr->next;
#line 103
    free((void *)t);
  }
#line 105
  return;
}
}
#line 111 "../file.c"
struct _info **fprune(struct _info *head , bool matched , bool root ) 
{ 
  struct _info **dir ;
  struct _info *new ;
  struct _info *end ;
  struct _info *ent ;
  struct _info *t ;
  int show ;
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct _info *tmp___2 ;
  void *tmp___3 ;

  {
#line 113
  new = (struct _info *)((void *)0);
#line 113
  end = (struct _info *)((void *)0);
#line 114
  count = 0;
#line 116
  ent = head;
#line 116
  while ((unsigned long )ent != (unsigned long )((void *)0)) {
#line 117
    if (ent->tchild) {
#line 117
      ent->isdir = (bool )1;
    }
#line 119
    show = 1;
#line 120
    if (dflag) {
#line 120
      if (! ent->isdir) {
#line 120
        show = 0;
      }
    }
#line 121
    if (! aflag) {
#line 121
      if (! root) {
#line 121
        if ((int )*(ent->name + 0) == 46) {
#line 121
          show = 0;
        }
      }
    }
#line 122
    if (show) {
#line 122
      if (! matched) {
#line 123
        if (! ent->isdir) {
#line 124
          if (pattern) {
#line 124
            tmp = patinclude(ent->name, 0);
#line 124
            if (! tmp) {
#line 124
              show = 0;
            }
          }
#line 125
          if (ipattern) {
#line 125
            tmp___0 = patignore(ent->name, 0);
#line 125
            if (tmp___0) {
#line 125
              show = 0;
            }
          }
        }
#line 127
        if (ent->isdir) {
#line 127
          if (show) {
#line 127
            if (matchdirs) {
#line 127
              if (pattern) {
#line 128
                tmp___1 = patinclude(ent->name, 1);
#line 128
                if (tmp___1) {
#line 128
                  matched = (bool )1;
                }
              }
            }
          }
        }
      }
    }
#line 131
    if (pruneflag) {
#line 131
      if (! matched) {
#line 131
        if (ent->isdir) {
#line 131
          if ((unsigned long )ent->tchild == (unsigned long )((void *)0)) {
#line 131
            show = 0;
          }
        }
      }
    }
#line 132
    if (show) {
#line 132
      if ((unsigned long )ent->tchild != (unsigned long )((void *)0)) {
#line 132
        ent->child = fprune(ent->tchild, matched, (bool )0);
      }
    }
#line 134
    t = ent;
#line 135
    ent = ent->next;
#line 136
    if (show) {
#line 137
      if (end) {
#line 137
        tmp___2 = t;
#line 137
        end->next = tmp___2;
#line 137
        end = tmp___2;
      } else {
#line 138
        end = t;
#line 138
        new = end;
      }
#line 139
      count ++;
    } else {
#line 141
      t->next = (struct _info *)((void *)0);
#line 142
      freefiletree(t);
    }
  }
#line 145
  if (end) {
#line 145
    end->next = (struct _info *)((void *)0);
  }
#line 147
  tmp___3 = xmalloc(sizeof(struct _info *) * (unsigned long )(count + 1));
#line 147
  dir = (struct _info **)tmp___3;
#line 148
  count = 0;
#line 148
  ent = new;
#line 148
  while ((unsigned long )ent != (unsigned long )((void *)0)) {
#line 149
    *(dir + count) = ent;
#line 148
    ent = ent->next;
#line 148
    count ++;
  }
#line 151
  *(dir + count) = (struct _info *)((void *)0);
#line 153
  if (topsort) {
#line 153
    qsort((void *)dir, (size_t )count, sizeof(struct _info *), (int (*)(void const   * ,
                                                                        void const   * ))topsort);
  }
#line 155
  return (dir);
}
}
#line 158 "../file.c"
struct _info **file_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  char *path___0 ;
  char *spath ;
  char *s ;
  long pathsize___0 ;
  struct _info *root ;
  struct _info **cwd ;
  struct _info *ent ;
  int l ;
  int tok ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t___0 tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  struct _info **tmp___8 ;

  {
#line 160
  tmp___2 = strcmp((char const   *)d, (char const   *)".");
#line 160
  if (tmp___2) {
#line 160
    tmp___0 = fopen((char const   * __restrict  )d, (char const   * __restrict  )"r");
#line 160
    tmp___1 = tmp___0;
  } else {
#line 160
    tmp___1 = (FILE *)stdin;
  }
#line 160
  fp = tmp___1;
#line 163
  root = (struct _info *)((void *)0);
#line 166
  size = (off_t *)0;
#line 167
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 168
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error opening %s for reading.\n",
            d);
#line 169
    return ((struct _info **)((void *)0));
  }
#line 172
  pathsize___0 = 65536L;
#line 172
  tmp___3 = xmalloc(sizeof(char *) * (unsigned long )pathsize___0);
#line 172
  path___0 = (char *)tmp___3;
#line 174
  while (1) {
#line 174
    tmp___7 = fgets((char * __restrict  )path___0, (int )pathsize___0, (FILE * __restrict  )fp);
#line 174
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 174
      break;
    }
#line 175
    if ((unsigned long )file_comment != (unsigned long )((void *)0)) {
#line 175
      tmp___4 = strcmp((char const   *)path___0, (char const   *)file_comment);
#line 175
      if (tmp___4 == 0) {
#line 175
        continue;
      }
    }
#line 176
    tmp___5 = strlen((char const   *)path___0);
#line 176
    l = (int )tmp___5;
#line 177
    while (1) {
#line 177
      if (l) {
#line 177
        tmp___6 = isspace((int )*(path___0 + (l - 1)));
#line 177
        if (! tmp___6) {
#line 177
          break;
        }
      } else {
#line 177
        break;
      }
#line 177
      l --;
#line 177
      *(path___0 + l) = (char )'\000';
    }
#line 178
    if (l == 0) {
#line 178
      continue;
    }
#line 180
    spath = path___0;
#line 181
    cwd = & root;
#line 182
    while (1) {
#line 183
      s = nextpc(& spath, & tok);
#line 184
      if (tok == 0) {
#line 184
        goto __Cont;
      }
#line 185
      switch (tok) {
      case 0: 
#line 186
      goto __Cont;
      case 1: 
      case 2: 
#line 190
      ent = search(cwd, s);
#line 192
      if (tok == 1) {
#line 193
        ent->isdir = (bool )1;
#line 194
        ent->mode = (mode_t )0040000;
      } else {
#line 196
        ent->mode = (mode_t )0100000;
      }
#line 198
      cwd = & ent->tchild;
#line 199
      break;
      }
      __Cont: /* CIL Label */ 
#line 182
      if (tok != 2) {
#line 182
        if (! (tok != 3)) {
#line 182
          break;
        }
      } else {
#line 182
        break;
      }
    }
  }
#line 203
  if ((unsigned long )fp != (unsigned long )stdin) {
#line 203
    fclose(fp);
  }
#line 206
  tmp___8 = fprune(root, (bool )0, (bool )1);
#line 206
  return (tmp___8);
}
}
#line 1 "cil-7ZAjp9E8.o"
#pragma merger("0","/tmp/cil-mQfoqFRQ.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 122 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern int snprintf(char * , size_t___0  , char const   *  , ...) ;
#line 212 "../tree.h"
int patmatch(char *buf___1 , char *pat , int isdir ) ;
#line 291
void gittrim(char *s ) ;
#line 292
struct pattern *new_pattern(char *pattern___0 ) ;
#line 293
int filtercheck(char *path___0 , char *name , int isdir ) ;
#line 294
struct ignorefile *new_ignorefile(char *path___0 ) ;
#line 295
void push_filterstack(struct ignorefile *ig ) ;
#line 296
struct ignorefile *pop_filterstack(void) ;
#line 21 "../filter.c"
struct ignorefile *filterstack  =    (struct ignorefile *)((void *)0);
#line 23 "../filter.c"
static char fpattern[4096]  ;
#line 25 "../filter.c"
void gittrim(char *s ) 
{ 
  int i ;
  int e ;
  size_t___0 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 27
  tmp = strlen((char const   *)s);
#line 27
  e = (int )(tmp - 1UL);
#line 29
  if ((int )*(s + e) == 10) {
#line 29
    e --;
  }
#line 31
  i = e;
#line 31
  while (i >= 0) {
#line 32
    if ((int )*(s + i) != 32) {
#line 32
      break;
    }
#line 33
    if (i) {
#line 33
      if ((int )*(s + (i - 1)) != 92) {
#line 33
        e --;
      }
    }
#line 31
    i --;
  }
#line 35
  *(s + (e + 1)) = (char )'\000';
#line 36
  e = 0;
#line 36
  i = e;
#line 36
  while ((int )*(s + i) != 0) {
#line 37
    if ((int )*(s + i) == 92) {
#line 37
      i ++;
    }
#line 38
    tmp___0 = e;
#line 38
    e ++;
#line 38
    tmp___1 = i;
#line 38
    i ++;
#line 38
    *(s + tmp___0) = *(s + tmp___1);
  }
#line 40
  *(s + e) = (char )'\000';
#line 41
  return;
}
}
#line 43 "../filter.c"
struct pattern *new_pattern(char *pattern___0 ) 
{ 
  struct pattern *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 45
  tmp = xmalloc(sizeof(struct pattern ));
#line 45
  p = (struct pattern *)tmp;
#line 46
  if ((int )*(pattern___0 + 0) == 47) {
#line 46
    tmp___0 = 1;
  } else {
#line 46
    tmp___0 = 0;
  }
#line 46
  if ((int )*(pattern___0 + 0) == 47) {
#line 46
    tmp___1 = 1;
  } else {
#line 46
    tmp___1 = 0;
  }
#line 46
  tmp___2 = strlen((char const   *)(pattern___0 + tmp___1));
#line 46
  tmp___3 = xmalloc(tmp___2 + 1UL);
#line 46
  p->pattern = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )(pattern___0 + tmp___0));
#line 47
  tmp___4 = strchr((char const   *)pattern___0, '/');
#line 47
  p->relative = (unsigned long )tmp___4 == (unsigned long )((void *)0);
#line 48
  p->next = (struct pattern *)((void *)0);
#line 49
  return (p);
}
}
#line 52 "../filter.c"
struct ignorefile *new_ignorefile(char *path___0 ) 
{ 
  char buf___1[4096] ;
  struct ignorefile *ig ;
  struct pattern *remove___0 ;
  struct pattern *remend ;
  struct pattern *p ;
  struct pattern *reverse___0 ;
  struct pattern *revend ;
  int rev ;
  FILE *fp ;
  size_t___0 tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;

  {
#line 56
  remove___0 = (struct pattern *)((void *)0);
#line 57
  reverse___0 = (struct pattern *)((void *)0);
#line 61
  snprintf((char * __restrict  )(buf___1), (size_t___0 )4096, (char const   * __restrict  )"%s/.gitignore",
           path___0);
#line 62
  fp = fopen((char const   * __restrict  )(buf___1), (char const   * __restrict  )"r");
#line 63
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 63
    return ((struct ignorefile *)((void *)0));
  }
#line 65
  while (1) {
#line 65
    tmp___1 = fgets((char * __restrict  )(buf___1), 4096, (FILE * __restrict  )fp);
#line 65
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 65
      break;
    }
#line 66
    if ((int )buf___1[0] == 35) {
#line 66
      continue;
    }
#line 67
    rev = (int )buf___1[0] == 33;
#line 68
    gittrim(buf___1);
#line 69
    tmp = strlen((char const   *)(buf___1));
#line 69
    if (tmp == 0UL) {
#line 69
      continue;
    }
#line 70
    if (rev) {
#line 70
      tmp___0 = 1;
    } else {
#line 70
      tmp___0 = 0;
    }
#line 70
    p = new_pattern(buf___1 + tmp___0);
#line 71
    if (rev) {
#line 72
      if ((unsigned long )reverse___0 == (unsigned long )((void *)0)) {
#line 72
        revend = p;
#line 72
        reverse___0 = revend;
      } else {
#line 74
        revend->next = p;
#line 75
        revend = p;
      }
    } else
#line 78
    if ((unsigned long )remove___0 == (unsigned long )((void *)0)) {
#line 78
      remend = p;
#line 78
      remove___0 = remend;
    } else {
#line 80
      remend->next = p;
#line 81
      remend = p;
    }
  }
#line 86
  fclose(fp);
#line 88
  tmp___2 = xmalloc(sizeof(struct ignorefile ));
#line 88
  ig = (struct ignorefile *)tmp___2;
#line 89
  ig->remove = remove___0;
#line 90
  ig->reverse = reverse___0;
#line 91
  tmp___3 = strlen((char const   *)path___0);
#line 91
  tmp___4 = xmalloc(tmp___3 + 1UL);
#line 91
  ig->path = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )path___0);
#line 92
  ig->next = (struct ignorefile *)((void *)0);
#line 94
  return (ig);
}
}
#line 97 "../filter.c"
void push_filterstack(struct ignorefile *ig ) 
{ 


  {
#line 99
  if ((unsigned long )ig == (unsigned long )((void *)0)) {
#line 99
    return;
  }
#line 100
  ig->next = filterstack;
#line 101
  filterstack = ig;
#line 102
  return;
}
}
#line 104 "../filter.c"
struct ignorefile *pop_filterstack(void) 
{ 
  struct ignorefile *ig ;
  struct pattern *p ;
  struct pattern *c ;

  {
#line 106
  ig = filterstack;
#line 108
  filterstack = filterstack->next;
#line 110
  c = ig->remove;
#line 110
  p = c;
#line 110
  while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 111
    p = p->next;
#line 112
    free((void *)c->pattern);
#line 110
    c = p;
  }
#line 114
  c = ig->reverse;
#line 114
  p = c;
#line 114
  while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 115
    p = p->next;
#line 116
    free((void *)c->pattern);
#line 114
    c = p;
  }
#line 118
  free((void *)ig->path);
#line 119
  free((void *)ig);
#line 120
  return ((struct ignorefile *)((void *)0));
}
}
#line 126 "../filter.c"
int filtercheck(char *path___0 , char *name , int isdir ) 
{ 
  int filter ;
  struct ignorefile *ig ;
  struct pattern *p ;
  int fpos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int fpos___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 128
  filter = 0;
#line 132
  ig = filterstack;
#line 132
  while (1) {
#line 132
    if (! filter) {
#line 132
      if (! ig) {
#line 132
        break;
      }
    } else {
#line 132
      break;
    }
#line 133
    tmp = sprintf((char * __restrict  )(fpattern), (char const   * __restrict  )"%s/",
                  ig->path);
#line 133
    fpos = tmp;
#line 135
    p = ig->remove;
#line 135
    while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 136
      if (p->relative) {
#line 137
        tmp___0 = patmatch(name, p->pattern, isdir);
#line 137
        if (tmp___0 == 1) {
#line 139
          filter = 1;
#line 140
          break;
        }
      } else {
#line 143
        sprintf((char * __restrict  )(fpattern + fpos), (char const   * __restrict  )"%s",
                p->pattern);
#line 145
        tmp___1 = patmatch(path___0, fpattern, isdir);
#line 145
        if (tmp___1 == 1) {
#line 147
          filter = 1;
#line 148
          break;
        }
      }
#line 135
      p = p->next;
    }
#line 132
    ig = ig->next;
  }
#line 164
  if (! filter) {
#line 164
    return (0);
  }
#line 166
  ig = filterstack;
#line 166
  while (ig) {
#line 167
    tmp___2 = sprintf((char * __restrict  )(fpattern), (char const   * __restrict  )"%s/",
                      ig->path);
#line 167
    fpos___0 = tmp___2;
#line 169
    p = ig->reverse;
#line 169
    while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 170
      if (p->relative) {
#line 171
        tmp___3 = patmatch(name, p->pattern, isdir);
#line 171
        if (tmp___3 == 1) {
#line 171
          return (0);
        }
      } else {
#line 173
        sprintf((char * __restrict  )(fpattern + fpos___0), (char const   * __restrict  )"%s",
                p->pattern);
#line 174
        tmp___4 = patmatch(path___0, fpattern, isdir);
#line 174
        if (tmp___4 == 1) {
#line 174
          return (0);
        }
      }
#line 169
      p = p->next;
    }
#line 166
    ig = ig->next;
  }
#line 186
  return (1);
}
}
#line 1 "cil-I232m9Io.o"
#pragma merger("0","/tmp/cil-BMi3HdqY.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 36 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h"
extern struct passwd *getpwuid(uid_t  ) ;
#line 26 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h"
extern struct group *getgrgid(gid_t  ) ;
#line 282 "../tree.h"
char *uidtoname(uid_t uid ) ;
#line 283
char *gidtoname(gid_t gid ) ;
#line 284
int findino(ino_t inode , dev_t device ) ;
#line 285
void saveino(ino_t inode , dev_t device ) ;
#line 23 "../hash.c"
struct xtable *gtable[256]  ;
#line 23 "../hash.c"
struct xtable *utable[256]  ;
#line 26 "../hash.c"
struct inotable *itable[256]  ;
#line 28 "../hash.c"
char *uidtoname(uid_t uid ) 
{ 
  struct xtable *o ;
  struct xtable *p ;
  struct xtable *t ;
  struct passwd *ent ;
  char ubuf[32] ;
  int uent ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;

  {
#line 33
  uent = (int )(uid & 255U);
#line 35
  p = utable[uent];
#line 35
  o = p;
#line 35
  while (p) {
#line 36
    if (uid == p->xid) {
#line 36
      return (p->name);
    } else
#line 37
    if (uid < p->xid) {
#line 37
      break;
    }
#line 38
    o = p;
#line 35
    p = p->nxt;
  }
#line 41
  tmp = xmalloc(sizeof(struct xtable ));
#line 41
  t = (struct xtable *)tmp;
#line 42
  ent = getpwuid(uid);
#line 42
  if ((unsigned long )ent != (unsigned long )((void *)0)) {
#line 42
    tmp___0 = strlen((char const   *)ent->pw_name);
#line 42
    tmp___1 = xmalloc(tmp___0 + 1UL);
#line 42
    t->name = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )ent->pw_name);
  } else {
#line 44
    snprintf((char * __restrict  )(ubuf), (size_t___0 )30, (char const   * __restrict  )"%d",
             uid);
#line 45
    ubuf[31] = (char)0;
#line 46
    tmp___2 = strlen((char const   *)(ubuf));
#line 46
    tmp___3 = xmalloc(tmp___2 + 1UL);
#line 46
    t->name = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )(ubuf));
  }
#line 48
  t->xid = uid;
#line 49
  t->nxt = p;
#line 50
  if ((unsigned long )p == (unsigned long )utable[uent]) {
#line 50
    utable[uent] = t;
  } else {
#line 51
    o->nxt = t;
  }
#line 52
  return (t->name);
}
}
#line 55 "../hash.c"
char *gidtoname(gid_t gid ) 
{ 
  struct xtable *o ;
  struct xtable *p ;
  struct xtable *t ;
  struct group *ent ;
  char gbuf[32] ;
  int gent ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;

  {
#line 60
  gent = (int )(gid & 255U);
#line 62
  p = gtable[gent];
#line 62
  o = p;
#line 62
  while (p) {
#line 63
    if (gid == p->xid) {
#line 63
      return (p->name);
    } else
#line 64
    if (gid < p->xid) {
#line 64
      break;
    }
#line 65
    o = p;
#line 62
    p = p->nxt;
  }
#line 68
  tmp = xmalloc(sizeof(struct xtable ));
#line 68
  t = (struct xtable *)tmp;
#line 69
  ent = getgrgid(gid);
#line 69
  if ((unsigned long )ent != (unsigned long )((void *)0)) {
#line 69
    tmp___0 = strlen((char const   *)ent->gr_name);
#line 69
    tmp___1 = xmalloc(tmp___0 + 1UL);
#line 69
    t->name = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )ent->gr_name);
  } else {
#line 71
    snprintf((char * __restrict  )(gbuf), (size_t___0 )30, (char const   * __restrict  )"%d",
             gid);
#line 72
    gbuf[31] = (char)0;
#line 73
    tmp___2 = strlen((char const   *)(gbuf));
#line 73
    tmp___3 = xmalloc(tmp___2 + 1UL);
#line 73
    t->name = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )(gbuf));
  }
#line 75
  t->xid = gid;
#line 76
  t->nxt = p;
#line 77
  if ((unsigned long )p == (unsigned long )gtable[gent]) {
#line 77
    gtable[gent] = t;
  } else {
#line 78
    o->nxt = t;
  }
#line 79
  return (t->name);
}
}
#line 83 "../hash.c"
void saveino(ino_t inode , dev_t device ) 
{ 
  struct inotable *it ;
  struct inotable *ip ;
  struct inotable *pp ;
  int hp ;
  void *tmp ;

  {
#line 86
  hp = (int )(inode & 255ULL);
#line 88
  ip = itable[hp];
#line 88
  pp = ip;
#line 88
  while (ip) {
#line 89
    if (ip->inode > inode) {
#line 89
      break;
    }
#line 90
    if (ip->inode == inode) {
#line 90
      if (ip->device >= device) {
#line 90
        break;
      }
    }
#line 91
    pp = ip;
#line 88
    ip = ip->nxt;
  }
#line 94
  if (ip) {
#line 94
    if (ip->inode == inode) {
#line 94
      if (ip->device == device) {
#line 94
        return;
      }
    }
  }
#line 96
  tmp = xmalloc(sizeof(struct inotable ));
#line 96
  it = (struct inotable *)tmp;
#line 97
  it->inode = inode;
#line 98
  it->device = device;
#line 99
  it->nxt = ip;
#line 100
  if ((unsigned long )ip == (unsigned long )itable[hp]) {
#line 100
    itable[hp] = it;
  } else {
#line 101
    pp->nxt = it;
  }
#line 102
  return;
}
}
#line 104 "../hash.c"
int findino(ino_t inode , dev_t device ) 
{ 
  struct inotable *it ;

  {
#line 108
  it = itable[inode & 255ULL];
#line 108
  while (it) {
#line 109
    if (it->inode > inode) {
#line 109
      break;
    }
#line 110
    if (it->inode == inode) {
#line 110
      if (it->device >= device) {
#line 110
        break;
      }
    }
#line 108
    it = it->nxt;
  }
#line 113
  if (it) {
#line 113
    if (it->inode == inode) {
#line 113
      if (it->device == device) {
#line 113
        return (1);
      }
    }
  }
#line 114
  return (0);
}
}
#line 1 "cil-Mc5vnDUd.o"
#pragma merger("0","/tmp/cil-P_2dvFnt.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 107 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern int fputc(int  , FILE * ) ;
#line 108
extern int putc(int  , FILE * ) ;
#line 17 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h"
extern int isprint(int  ) ;
#line 213 "../tree.h"
void indent(int maxlevel ) ;
#line 222
int psize(char *buf___1 , off_t size ) ;
#line 225
char *fillinfo(char *buf___1 , struct _info *ent ) ;
#line 242
void html_intro(void) ;
#line 243
void html_outtro(void) ;
#line 244
int html_printinfo(char *dirname , struct _info *file , int level ) ;
#line 245
int html_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
#line 246
int html_error(char *error ) ;
#line 247
void html_newline(struct _info *file , int level , int postdir , int needcomma ) ;
#line 248
void html_close(struct _info *file , int level , int needcomma ) ;
#line 249
void html_report(struct totals tot ) ;
#line 250
void html_encode(FILE *fd , char *s ) ;
#line 21 "../html.c"
char *version ;
#line 21
char *hversion ;
#line 23
bool duflag ;
#line 23
bool hflag ;
#line 23
bool siflag ;
#line 24
bool noindent ;
#line 24
bool nolinks ;
#line 24
bool metafirst ;
#line 25
char *host ;
#line 25
char *sp ;
#line 25
char *title ;
#line 35 "../html.c"
int htmldirlen  =    0;
#line 37 "../html.c"
char *class(struct _info *info___1 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  if (info___1->isdir) {
#line 39
    tmp___2 = "DIR";
  } else {
#line 39
    if (info___1->isexe) {
#line 39
      tmp___1 = "EXEC";
    } else {
#line 39
      if (info___1->isfifo) {
#line 39
        tmp___0 = "FIFO";
      } else {
#line 39
        if (info___1->issok) {
#line 39
          tmp = "SOCK";
        } else {
#line 39
          tmp = "NORM";
        }
#line 39
        tmp___0 = tmp;
      }
#line 39
      tmp___1 = tmp___0;
    }
#line 39
    tmp___2 = tmp___1;
  }
#line 39
  return (tmp___2);
}
}
#line 46 "../html.c"
void html_encode(FILE *fd , char *s ) 
{ 


  {
#line 48
  while (*s) {
#line 49
    switch ((int )*s) {
    case 60: 
#line 51
    fputs((char const   * __restrict  )"&lt;", (FILE * __restrict  )fd);
#line 52
    break;
    case 62: 
#line 54
    fputs((char const   * __restrict  )"&gt;", (FILE * __restrict  )fd);
#line 55
    break;
    case 38: 
#line 57
    fputs((char const   * __restrict  )"&amp;", (FILE * __restrict  )fd);
#line 58
    break;
    case 34: 
#line 60
    fputs((char const   * __restrict  )"&quot;", (FILE * __restrict  )fd);
#line 61
    break;
    default: 
#line 63
    fputc((int )*s, fd);
#line 65
    break;
    }
#line 48
    s ++;
  }
#line 68
  return;
}
}
#line 70 "../html.c"
void url_encode(FILE *fd , char *s ) 
{ 
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 72
  while (*s) {
#line 73
    switch ((int )*s) {
    case 43: 
    case 63: 
    case 92: 
    case 94: 
    case 93: 
    case 91: 
    case 62: 
    case 60: 
    case 37: 
    case 35: 
    case 34: 
    case 32: 
#line 86
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%%%02X", (int )*s);
#line 87
    break;
    case 38: 
#line 89
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"&amp;");
#line 90
    break;
    default: 
#line 92
    tmp___1 = isprint((int )((u_int )*s));
#line 92
    if (tmp___1) {
#line 92
      tmp___0 = "%c";
    } else {
#line 92
      tmp___0 = "%%%02X";
    }
#line 92
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )tmp___0, (int )((u_char )*s));
#line 93
    break;
    }
#line 72
    s ++;
  }
#line 96
  return;
}
}
#line 98 "../html.c"
void html_intro(void) 
{ 
  char const   *tmp ;

  {
#line 100
  if (charset) {
#line 100
    tmp = charset;
  } else {
#line 100
    tmp = (char const   *)"iso-8859-1";
  }
#line 100
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<!DOCTYPE html>\n<html>\n<head>\n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=%s\">\n <meta name=\"Author\" content=\"Made by \'tree\'\">\n <meta name=\"GENERATOR\" content=\"%s\">\n <title>%s</title>\n <style type=\"text/css\">\n  BODY { font-family : monospace, sans-serif;  color: black;}\n  P { font-family : monospace, sans-serif; color: black; margin:0px; padding: 0px;}\n  A:visited { text-decoration : none; margin : 0px; padding : 0px;}\n  A:link    { text-decoration : none; margin : 0px; padding : 0px;}\n  A:hover   { text-decoration: underline; background-color : yellow; margin : 0px; padding : 0px;}\n  A:active  { margin : 0px; padding : 0px;}\n  .VERSION { font-size: small; font-family : arial, sans-serif; }\n  .NORM  { color: black;  }\n  .FIFO  { color: purple; }\n  .CHAR  { color: yellow; }\n  .DIR   { color: blue;   }\n  .BLOCK { color: yellow; }\n  .LINK  { color: aqua;   }\n  .SOCK  { color: fuchsia;}\n  .EXEC  { color: green;  }\n </style>\n</head>\n<body>\n\t<h1>%s</h1><p>\n",
          tmp, version, title, title);
#line 128
  return;
}
}
#line 130 "../html.c"
void html_outtro(void) 
{ 


  {
#line 132
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\t<hr>\n");
#line 133
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\t<p class=\"VERSION\">\n");
#line 134
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )hversion, linedraw->copy,
          linedraw->copy, linedraw->copy, linedraw->copy);
#line 135
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\t</p>\n");
#line 136
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"</body>\n");
#line 137
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"</html>\n");
#line 138
  return;
}
}
#line 140 "../html.c"
void html_print(char *s ) 
{ 
  int i ;

  {
#line 142
  i = 0;
#line 142
  while (*(s + i)) {
#line 143
    if ((int )*(s + i) == 32) {
#line 143
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s", sp);
    } else {
#line 144
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%c", (int )*(s + i));
    }
#line 142
    i ++;
  }
#line 146
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s%s", sp, sp);
#line 147
  return;
}
}
#line 149 "../html.c"
int html_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  char info___1[512] ;

  {
#line 153
  fillinfo(info___1, file);
#line 154
  if (metafirst) {
#line 155
    if ((int )info___1[0] == 91) {
#line 156
      html_print(info___1);
#line 157
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s%s", sp,
              sp);
    }
#line 159
    if (! noindent) {
#line 159
      indent(level);
    }
  } else {
#line 161
    if (! noindent) {
#line 161
      indent(level);
    }
#line 162
    if ((int )info___1[0] == 91) {
#line 163
      html_print(info___1);
#line 164
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s%s", sp,
              sp);
    }
  }
#line 168
  return (0);
}
}
#line 172 "../html.c"
int html_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  char *tmp ;
  int i ;
  int len ;
  size_t___0 tmp___0 ;
  int off ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 175
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<a");
#line 176
  if (file) {
#line 177
    if (force_color) {
#line 177
      tmp = class(file);
#line 177
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" class=\"%s\"",
              tmp);
    }
#line 178
    if (file->comment) {
#line 179
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" title=\"");
#line 180
      i = 0;
#line 180
      while (*(file->comment + i)) {
#line 181
        html_encode(outfile, *(file->comment + i));
#line 182
        if (*(file->comment + (i + 1))) {
#line 182
          fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\n");
        }
#line 180
        i ++;
      }
#line 184
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\"");
    }
#line 187
    if (! nolinks) {
#line 188
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" href=\"%s",
              host);
#line 189
      if ((unsigned long )dirname != (unsigned long )((void *)0)) {
#line 190
        tmp___0 = strlen((char const   *)dirname);
#line 190
        len = (int )tmp___0;
#line 191
        if (len >= htmldirlen) {
#line 191
          tmp___1 = htmldirlen;
        } else {
#line 191
          tmp___1 = 0;
        }
#line 191
        off = tmp___1;
#line 192
        url_encode(outfile, dirname + off);
#line 193
        putc('/', outfile);
#line 194
        url_encode(outfile, filename);
#line 195
        if (file->isdir) {
#line 195
          tmp___2 = "/";
        } else {
#line 195
          tmp___2 = "";
        }
#line 195
        if (descend > 1) {
#line 195
          tmp___3 = "/00Tree.html";
        } else {
#line 195
          tmp___3 = "";
        }
#line 195
        fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s%s\"",
                tmp___3, tmp___2);
      } else {
#line 197
        if (descend > 1) {
#line 197
          tmp___4 = "/00Tree.html";
        } else {
#line 197
          tmp___4 = "";
        }
#line 197
        fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s\"",
                tmp___4);
      }
    }
  }
#line 201
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )">");
#line 203
  if (dirname) {
#line 203
    html_encode(outfile, filename);
  } else {
#line 204
    html_encode(outfile, host);
  }
#line 206
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"</a>");
#line 207
  return (0);
}
}
#line 210 "../html.c"
int html_error(char *error ) 
{ 


  {
#line 212
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"  [%s]", error);
#line 213
  return (0);
}
}
#line 216 "../html.c"
void html_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 


  {
#line 218
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<br>\n");
#line 219
  return;
}
}
#line 221 "../html.c"
void html_close(struct _info *file , int level , int needcomma ) 
{ 


  {
#line 223
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"</%s><br>\n",
          file->tag);
#line 224
  return;
}
}
#line 226 "../html.c"
void html_report(struct totals tot ) 
{ 
  char buf___1[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 230
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<br><br><p>\n\n");
#line 232
  if (duflag) {
#line 233
    psize(buf___1, tot.size);
#line 234
    if (hflag) {
#line 234
      tmp = "";
    } else
#line 234
    if (siflag) {
#line 234
      tmp = "";
    } else {
#line 234
      tmp = " bytes";
    }
#line 234
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s%s used in ",
            buf___1, tmp);
  }
#line 236
  if (dflag) {
#line 237
    if (tot.dirs == 1UL) {
#line 237
      tmp___0 = "y";
    } else {
#line 237
      tmp___0 = "ies";
    }
#line 237
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%ld director%s\n",
            tot.dirs, tmp___0);
  } else {
#line 239
    if (tot.files == 1UL) {
#line 239
      tmp___1 = "";
    } else {
#line 239
      tmp___1 = "s";
    }
#line 239
    if (tot.dirs == 1UL) {
#line 239
      tmp___2 = "y";
    } else {
#line 239
      tmp___2 = "ies";
    }
#line 239
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%ld director%s, %ld file%s\n",
            tot.dirs, tmp___2, tot.files, tmp___1);
  }
#line 241
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\n</p>\n");
#line 242
  return;
}
}
#line 1 "cil-zzSVmEW6.o"
#pragma merger("0","/tmp/cil-Z0JqcW8b.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 299 "../tree.h"
struct infofile *new_infofile(char *path___0 ) ;
#line 300
void push_infostack(struct infofile *inf ) ;
#line 301
struct infofile *pop_infostack(void) ;
#line 302
struct comment *infocheck(char *path___0 , char *name , int top , int isdir ) ;
#line 303
void printcomment(int line , int lines , char *s ) ;
#line 33 "../info.c"
struct infofile *infostack  =    (struct infofile *)((void *)0);
#line 35 "../info.c"
struct comment *new_comment(struct pattern *phead , char **line , int lines ) 
{ 
  struct comment *com ;
  void *tmp ;
  void *tmp___0 ;
  int i ;

  {
#line 37
  tmp = xmalloc(sizeof(struct comment ));
#line 37
  com = (struct comment *)tmp;
#line 38
  com->pattern = phead;
#line 39
  tmp___0 = xmalloc(sizeof(char *) * (unsigned long )(lines + 1));
#line 39
  com->desc = (char **)tmp___0;
#line 41
  i = 0;
#line 41
  while (i < lines) {
#line 41
    *(com->desc + i) = *(line + i);
#line 41
    i ++;
  }
#line 42
  *(com->desc + i) = (char *)((void *)0);
#line 43
  com->next = (struct comment *)((void *)0);
#line 44
  return (com);
}
}
#line 47 "../info.c"
struct infofile *new_infofile(char *path___0 ) 
{ 
  char buf___1[4096] ;
  struct infofile *inf ;
  struct comment *chead ;
  struct comment *cend ;
  struct comment *com ;
  struct pattern *phead ;
  struct pattern *pend ;
  struct pattern *p ;
  char *line[4096] ;
  FILE *fp ;
  int lines ;
  int tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  struct comment *tmp___4 ;
  int i ;
  struct pattern *tmp___5 ;
  char *tmp___6 ;
  struct comment *tmp___7 ;
  int i___0 ;
  void *tmp___8 ;
  size_t___0 tmp___9 ;
  void *tmp___10 ;

  {
#line 51
  chead = (struct comment *)((void *)0);
#line 51
  cend = (struct comment *)((void *)0);
#line 52
  phead = (struct pattern *)((void *)0);
#line 52
  pend = (struct pattern *)((void *)0);
#line 55
  lines = 0;
#line 57
  tmp = strcmp((char const   *)path___0, (char const   *)"/usr/share/finfo/global_info");
#line 57
  if (tmp == 0) {
#line 57
    fp = fopen((char const   * __restrict  )path___0, (char const   * __restrict  )"r");
  } else {
#line 59
    snprintf((char * __restrict  )(buf___1), (size_t___0 )4096, (char const   * __restrict  )"%s/.info",
             path___0);
#line 60
    fp = fopen((char const   * __restrict  )(buf___1), (char const   * __restrict  )"r");
  }
#line 62
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 62
    return ((struct infofile *)((void *)0));
  }
#line 64
  while (1) {
#line 64
    tmp___6 = fgets((char * __restrict  )(buf___1), 4096, (FILE * __restrict  )fp);
#line 64
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 64
      break;
    }
#line 65
    if ((int )buf___1[0] == 35) {
#line 65
      continue;
    }
#line 66
    gittrim(buf___1);
#line 67
    tmp___0 = strlen((char const   *)(buf___1));
#line 67
    if (tmp___0 < 1UL) {
#line 67
      continue;
    }
#line 69
    if ((int )buf___1[0] == 9) {
#line 70
      tmp___1 = lines;
#line 70
      lines ++;
#line 70
      tmp___2 = strlen((char const   *)(buf___1 + 1));
#line 70
      tmp___3 = xmalloc(tmp___2 + 1UL);
#line 70
      line[tmp___1] = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )(buf___1 + 1));
    } else {
#line 72
      if (lines) {
#line 74
        if (phead) {
#line 75
          com = new_comment(phead, line, lines);
#line 76
          if (! chead) {
#line 76
            cend = com;
#line 76
            chead = cend;
          } else {
#line 77
            tmp___4 = com;
#line 77
            cend->next = tmp___4;
#line 77
            cend = tmp___4;
          }
        } else {
#line 80
          i = 0;
#line 80
          while (i < lines) {
#line 80
            free((void *)line[i]);
#line 80
            i ++;
          }
        }
#line 83
        pend = (struct pattern *)((void *)0);
#line 83
        phead = pend;
#line 84
        lines = 0;
      }
#line 86
      p = new_pattern(buf___1);
#line 87
      if ((unsigned long )phead == (unsigned long )((void *)0)) {
#line 87
        pend = p;
#line 87
        phead = pend;
      } else {
#line 88
        tmp___5 = p;
#line 88
        pend->next = tmp___5;
#line 88
        pend = tmp___5;
      }
    }
  }
#line 91
  if (phead) {
#line 92
    com = new_comment(phead, line, lines);
#line 93
    if (! chead) {
#line 93
      cend = com;
#line 93
      chead = cend;
    } else {
#line 94
      tmp___7 = com;
#line 94
      cend->next = tmp___7;
#line 94
      cend = tmp___7;
    }
  } else {
#line 96
    i___0 = 0;
#line 96
    while (i___0 < lines) {
#line 96
      free((void *)line[i___0]);
#line 96
      i___0 ++;
    }
  }
#line 99
  fclose(fp);
#line 101
  tmp___8 = xmalloc(sizeof(struct infofile ));
#line 101
  inf = (struct infofile *)tmp___8;
#line 102
  inf->comments = chead;
#line 103
  tmp___9 = strlen((char const   *)path___0);
#line 103
  tmp___10 = xmalloc(tmp___9 + 1UL);
#line 103
  inf->path = strcpy((char * __restrict  )tmp___10, (char const   * __restrict  )path___0);
#line 104
  inf->next = (struct infofile *)((void *)0);
#line 106
  return (inf);
}
}
#line 109 "../info.c"
void push_infostack(struct infofile *inf ) 
{ 


  {
#line 111
  if ((unsigned long )inf == (unsigned long )((void *)0)) {
#line 111
    return;
  }
#line 112
  inf->next = infostack;
#line 113
  infostack = inf;
#line 114
  return;
}
}
#line 116 "../info.c"
struct infofile *pop_infostack(void) 
{ 
  struct infofile *inf ;
  struct comment *cn ;
  struct comment *cc ;
  struct pattern *p ;
  struct pattern *c ;
  int i ;

  {
#line 118
  inf = infostack;
#line 121
  infostack = infostack->next;
#line 123
  if ((unsigned long )inf == (unsigned long )((void *)0)) {
#line 123
    return ((struct infofile *)((void *)0));
  }
#line 125
  cc = inf->comments;
#line 125
  cn = cc;
#line 125
  while ((unsigned long )cn != (unsigned long )((void *)0)) {
#line 126
    cn = cn->next;
#line 127
    c = cc->pattern;
#line 127
    p = c;
#line 127
    while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 128
      p = p->next;
#line 129
      free((void *)c->pattern);
#line 127
      c = p;
    }
#line 131
    i = 0;
#line 131
    while ((unsigned long )*(cc->desc + i) != (unsigned long )((void *)0)) {
#line 131
      free((void *)*(cc->desc + i));
#line 131
      i ++;
    }
#line 132
    free((void *)cc->desc);
#line 133
    free((void *)cc);
#line 125
    cc = cn;
  }
#line 135
  free((void *)inf->path);
#line 136
  free((void *)inf);
#line 137
  return ((struct infofile *)((void *)0));
}
}
#line 144 "../info.c"
struct comment *infocheck(char *path___0 , char *name , int top , int isdir ) 
{ 
  struct infofile *inf ;
  struct comment *com ;
  struct pattern *p ;
  int tmp ;
  int tmp___0 ;

  {
#line 146
  inf = infostack;
#line 150
  if ((unsigned long )inf == (unsigned long )((void *)0)) {
#line 150
    return ((struct comment *)((void *)0));
  }
#line 152
  inf = infostack;
#line 152
  while ((unsigned long )inf != (unsigned long )((void *)0)) {
#line 153
    com = inf->comments;
#line 153
    while ((unsigned long )com != (unsigned long )((void *)0)) {
#line 154
      p = com->pattern;
#line 154
      while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 155
        tmp = patmatch(path___0, p->pattern, isdir);
#line 155
        if (tmp == 1) {
#line 155
          return (com);
        }
#line 156
        if (top) {
#line 156
          tmp___0 = patmatch(name, p->pattern, isdir);
#line 156
          if (tmp___0 == 1) {
#line 156
            return (com);
          }
        }
#line 154
        p = p->next;
      }
#line 153
      com = com->next;
    }
#line 159
    top = 0;
#line 152
    inf = inf->next;
  }
#line 161
  return ((struct comment *)((void *)0));
}
}
#line 164 "../info.c"
void printcomment(int line , int lines , char *s ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 166
  if (lines == 1) {
#line 166
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s ", linedraw->csingle);
  } else
#line 168
  if (line == 0) {
#line 168
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s ", linedraw->ctop);
  } else
#line 169
  if (line < 2) {
#line 170
    if (lines == 2) {
#line 170
      tmp = linedraw->cbot;
    } else {
#line 170
      tmp = linedraw->cmid;
    }
#line 170
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s ", tmp);
  } else {
#line 172
    if (line == lines - 1) {
#line 172
      tmp___0 = linedraw->cbot;
    } else {
#line 172
      tmp___0 = linedraw->cext;
    }
#line 172
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s ", tmp___0);
  }
#line 175
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s\n", s);
#line 176
  return;
}
}
#line 1 "cil-ATcM_aoA.o"
#pragma merger("0","/tmp/cil-0dBnSK4d.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 218 "../tree.h"
char *prot(mode_t m ) ;
#line 220
char *do_date(time_t t ) ;
#line 263
void json_indent(int maxlevel ) ;
#line 264
void json_fillinfo(struct _info *ent ) ;
#line 265
void json_intro(void) ;
#line 266
void json_outtro(void) ;
#line 267
int json_printinfo(char *dirname , struct _info *file , int level ) ;
#line 268
int json_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
#line 269
int json_error(char *error ) ;
#line 270
void json_newline(struct _info *file , int level , int postdir , int needcomma ) ;
#line 271
void json_close(struct _info *file , int level , int needcomma ) ;
#line 272
void json_report(struct totals tot ) ;
#line 21 "../json.c"
bool pflag ;
#line 21
bool sflag ;
#line 21
bool uflag ;
#line 21
bool gflag ;
#line 22
bool Dflag ;
#line 22
bool inodeflag ;
#line 22
bool devflag ;
#line 22
bool cflag ;
#line 25
int const   ifmt[8] ;
#line 26
char const   *ftype[9] ;
#line 54 "../json.c"
void json_encode(FILE *fd , char *s ) 
{ 
  char *ctrl ;

  {
#line 56
  ctrl = "0-------btn-fr------------------";
#line 58
  while (*s) {
#line 59
    if ((int )((unsigned char )*s) < 32) {
#line 60
      if ((int )*(ctrl + (unsigned char )*s) != 45) {
#line 60
        fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\\%c", (int )*(ctrl + (unsigned char )*s));
      } else {
#line 61
        fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\\u%04x", (int )((unsigned char )*s));
      }
    } else
#line 62
    if ((int )*s == 34) {
#line 62
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\\%c", (int )*s);
    } else
#line 62
    if ((int )*s == 92) {
#line 62
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\\%c", (int )*s);
    } else {
#line 63
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%c", (int )*s);
    }
#line 58
    s ++;
  }
#line 65
  return;
}
}
#line 67 "../json.c"
void json_indent(int maxlevel ) 
{ 
  int i ;

  {
#line 71
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"  ");
#line 72
  i = 0;
#line 72
  while (i < maxlevel) {
#line 73
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"  ");
#line 72
    i ++;
  }
#line 74
  return;
}
}
#line 76 "../json.c"
void json_fillinfo(struct _info *ent ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char nbuf[64] ;
  int i ;
  int tmp___2 ;
  time_t tmp___3 ;
  char *tmp___4 ;

  {
#line 81
  if (inodeflag) {
#line 81
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"inode\":%ld",
            (long )ent->inode);
  }
#line 83
  if (devflag) {
#line 83
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"dev\":%d",
            (int )ent->dev);
  }
#line 87
  if (pflag) {
#line 87
    tmp = prot(ent->mode);
#line 87
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"mode\":\"%04o\",\"prot\":\"%s\"",
            ent->mode & 4095U, tmp);
  }
#line 89
  if (uflag) {
#line 89
    tmp___0 = uidtoname(ent->uid);
#line 89
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"user\":\"%s\"",
            tmp___0);
  }
#line 90
  if (gflag) {
#line 90
    tmp___1 = gidtoname(ent->gid);
#line 90
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"group\":\"%s\"",
            tmp___1);
  }
#line 91
  if (sflag) {
#line 92
    if (hflag) {
#line 92
      goto _L;
    } else
#line 92
    if (siflag) {
      _L: /* CIL Label */ 
#line 95
      psize(nbuf, ent->size);
#line 96
      i = 0;
#line 96
      while (1) {
#line 96
        tmp___2 = isspace((int )nbuf[i]);
#line 96
        if (! tmp___2) {
#line 96
          break;
        }
#line 96
        i ++;
      }
#line 97
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"size\":\"%s\"",
              nbuf + i);
    } else {
#line 99
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"size\":%lld",
              ent->size);
    }
  }
#line 101
  if (Dflag) {
#line 101
    if (cflag) {
#line 101
      tmp___3 = ent->ctime;
    } else {
#line 101
      tmp___3 = ent->mtime;
    }
#line 101
    tmp___4 = do_date(tmp___3);
#line 101
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"time\":\"%s\"",
            tmp___4);
  }
#line 102
  return;
}
}
#line 107
char *_nl ;
#line 105 "../json.c"
void json_intro(void) 
{ 
  char *tmp ;

  {
#line 108
  if (noindent) {
#line 108
    tmp = "";
  } else {
#line 108
    tmp = _nl;
  }
#line 108
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"[%s", tmp);
#line 109
  return;
}
}
#line 111 "../json.c"
void json_outtro(void) 
{ 
  char *tmp ;

  {
#line 114
  if (noindent) {
#line 114
    tmp = "";
  } else {
#line 114
    tmp = _nl;
  }
#line 114
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s]\n", tmp);
#line 115
  return;
}
}
#line 117 "../json.c"
int json_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  mode_t mt ;
  int t ;

  {
#line 122
  if (! noindent) {
#line 122
    json_indent(level);
  }
#line 124
  if (file->lnk) {
#line 124
    mt = file->mode & 61440U;
  } else {
#line 125
    mt = file->mode & 61440U;
  }
#line 127
  t = 0;
#line 127
  while (ifmt[t]) {
#line 128
    if ((mode_t )ifmt[t] == mt) {
#line 128
      break;
    }
#line 127
    t ++;
  }
#line 129
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"{\"type\":\"%s\"",
          ftype[t]);
#line 131
  return (0);
}
}
#line 134 "../json.c"
int json_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int i ;

  {
#line 136
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"name\":\"");
#line 137
  json_encode(outfile, filename);
#line 138
  fputc('\"', outfile);
#line 140
  if (file) {
#line 140
    if (file->comment) {
#line 141
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"info\":\"");
#line 142
      i = 0;
#line 142
      while (*(file->comment + i)) {
#line 143
        json_encode(outfile, *(file->comment + i));
#line 144
        if (*(file->comment + (i + 1))) {
#line 144
          fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\\n");
        }
#line 142
        i ++;
      }
#line 146
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\"");
    }
  }
#line 149
  if (file) {
#line 149
    if (file->lnk) {
#line 150
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"target\":\"");
#line 151
      json_encode(outfile, file->lnk);
#line 152
      fputc('\"', outfile);
    }
  }
#line 154
  if (file) {
#line 154
    json_fillinfo(file);
  }
#line 156
  if (file) {
#line 156
    if (file->err) {
#line 156
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"error\": \"%s\"",
              file->err);
    }
  }
#line 157
  if (! descend) {
#line 157
    fputc('}', outfile);
  } else {
#line 158
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"contents\":[");
  }
#line 160
  return (descend);
}
}
#line 163 "../json.c"
int json_error(char *error ) 
{ 
  char *tmp ;

  {
#line 165
  if (noindent) {
#line 165
    tmp = "";
  } else {
#line 165
    tmp = "\n";
  }
#line 165
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"{\"error\": \"%s\"}%s",
          error, tmp);
#line 166
  return (0);
}
}
#line 169 "../json.c"
void json_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  char *tmp ;

  {
#line 173
  if (needcomma) {
#line 173
    tmp = ",";
  } else {
#line 173
    tmp = "";
  }
#line 173
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s%s", tmp,
          _nl);
#line 174
  return;
}
}
#line 176 "../json.c"
void json_close(struct _info *file , int level , int needcomma ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 178
  if (! noindent) {
#line 178
    json_indent(level - 1);
  }
#line 179
  if (noindent) {
#line 179
    tmp = "";
  } else {
#line 179
    tmp = "\n";
  }
#line 179
  if (needcomma) {
#line 179
    tmp___0 = ",";
  } else {
#line 179
    tmp___0 = "";
  }
#line 179
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"]}%s%s", tmp___0,
          tmp);
#line 180
  return;
}
}
#line 182 "../json.c"
void json_report(struct totals tot ) 
{ 
  char *tmp ;

  {
#line 184
  if (noindent) {
#line 184
    tmp = "";
  } else {
#line 184
    tmp = "\n  ";
  }
#line 184
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",%s{\"type\":\"report\"",
          tmp);
#line 185
  if (duflag) {
#line 185
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"size\":%lld",
            tot.size);
  }
#line 186
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"directories\":%ld",
          tot.dirs);
#line 187
  if (! dflag) {
#line 187
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )",\"files\":%ld",
            tot.files);
  }
#line 188
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"}");
#line 189
  return;
}
}
#line 1 "cil-6v6Utvet.o"
#pragma merger("0","/tmp/cil-P_5uu9MH.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 27 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
#line 75 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h"
extern int lstat(char const   * , struct stat * ) ;
#line 192 "../tree.h"
void setoutput(char *filename ) ;
#line 194
void push_files(char *dir , struct ignorefile **ig , struct infofile **inf ) ;
#line 198
struct _info **read_dir(char *dir , int *n , int infotop ) ;
#line 214
void free_dir(struct _info **d ) ;
#line 224
struct _info *stat2info(struct stat *st ) ;
#line 228
void null_intro(void) ;
#line 229
void null_outtro(void) ;
#line 230
void null_close(struct _info *file , int level , int needcomma ) ;
#line 231
void emit_tree(char **dirname , bool needfulltree ) ;
#line 232
struct totals listdir(char *dirname , struct _info **dir , int lev , dev_t dev , bool hasfulltree ) ;
#line 21 "../list.c"
bool lflag ;
#line 21
bool fflag ;
#line 22
bool Rflag ;
#line 23
bool Jflag ;
#line 23
bool noreport ;
#line 23
bool xdev ;
#line 25
struct _info **(*getfulltree)(char *d , u_long lev , dev_t dev , off_t *size , char **err ) ;
#line 28
int flimit ;
#line 28
int Level ;
#line 28
int *dirs ;
#line 28
int errors ;
#line 35 "../list.c"
static char errbuf[256]  ;
#line 43
struct listingcalls lc ;
#line 45 "../list.c"
void null_intro(void) 
{ 


  {
#line 47
  return;
}
}
#line 50 "../list.c"
void null_outtro(void) 
{ 


  {
#line 52
  return;
}
}
#line 55 "../list.c"
void null_close(struct _info *file , int level , int needcomma ) 
{ 


  {
#line 57
  return;
}
}
#line 59 "../list.c"
void emit_tree(char **dirname , bool needfulltree ) 
{ 
  struct totals tot ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **dir ;
  struct _info *info___1 ;
  char *err ;
  int i ;
  int j ;
  int n ;
  int needsclosed ;
  struct stat st ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  struct totals __constr_expr_0 ;

  {
#line 61
  tot.files = (u_long )0;
#line 61
  tot.dirs = 0UL;
#line 61
  tot.size = 0LL;
#line 62
  ig = (struct ignorefile *)((void *)0);
#line 63
  inf = (struct infofile *)((void *)0);
#line 64
  dir = (struct _info **)((void *)0);
#line 64
  info___1 = (struct _info *)((void *)0);
#line 69
  (*(lc.intro))();
#line 71
  i = 0;
#line 71
  while (*(dirname + i)) {
#line 72
    if (fflag) {
#line 73
      tmp = strlen((char const   *)*(dirname + i));
#line 73
      j = (int )tmp;
#line 74
      while (1) {
#line 75
        if (j > 1) {
#line 75
          if ((int )*(*(dirname + i) + (j - 1)) == 47) {
#line 75
            j --;
#line 75
            *(*(dirname + i) + j) = (char)0;
          }
        }
#line 74
        if (j > 1) {
#line 74
          if (! ((int )*(*(dirname + i) + (j - 1)) == 47)) {
#line 74
            break;
          }
        } else {
#line 74
          break;
        }
      }
    }
#line 78
    if (Hflag) {
#line 78
      tmp___0 = strlen((char const   *)*(dirname + i));
#line 78
      htmldirlen = (int )tmp___0;
    }
#line 80
    n = lstat((char const   * __restrict  )*(dirname + i), (struct stat * __restrict  )(& st));
#line 80
    if (n >= 0) {
#line 81
      saveino(st.st_ino, st.st_dev);
#line 82
      info___1 = stat2info(& st);
#line 83
      info___1->name = *(dirname + i);
#line 85
      if (needfulltree) {
#line 86
        dir = (*getfulltree)(*(dirname + i), (u_long )0, st.st_dev, & info___1->size,
                             & err);
#line 87
        if (err) {
#line 87
          n = -1;
        } else {
#line 87
          n = 0;
        }
      } else {
#line 89
        push_files(*(dirname + i), & ig, & inf);
#line 90
        dir = read_dir(*(dirname + i), & n, (unsigned long )inf != (unsigned long )((void *)0));
      }
#line 93
      (*(lc.printinfo))(*(dirname + i), info___1, 0);
    } else {
#line 94
      info___1 = (struct _info *)((void *)0);
    }
#line 96
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
#line 96
      tmp___1 = 1;
    } else
#line 96
    if (! dir) {
#line 96
      if (n) {
#line 96
        tmp___1 = 1;
      } else {
#line 96
        tmp___1 = 0;
      }
    } else {
#line 96
      tmp___1 = 0;
    }
#line 96
    needsclosed = (*(lc.printfile))((char *)((void *)0), *(dirname + i), info___1,
                                    tmp___1);
#line 98
    if (! dir) {
#line 98
      if (n) {
#line 99
        (*(lc.error))("error opening dir");
#line 100
        (*(lc.newline))(info___1, 0, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
#line 101
        errors ++;
      } else {
#line 98
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 102
    if (flimit > 0) {
#line 102
      if (n > flimit) {
#line 103
        sprintf((char * __restrict  )(errbuf), (char const   * __restrict  )"%d entries exceeds filelimit, not opening dir",
                n);
#line 104
        (*(lc.error))(errbuf);
#line 105
        (*(lc.newline))(info___1, 0, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
#line 106
        errors ++;
      } else {
#line 102
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 108
      (*(lc.newline))(info___1, 0, 0, 0);
#line 109
      if (dir) {
#line 110
        tot = listdir(*(dirname + i), dir, 1, st.st_dev, needfulltree);
      } else {
#line 111
        __constr_expr_0.files = (u_long )0;
#line 111
        __constr_expr_0.dirs = (u_long )0;
#line 111
        __constr_expr_0.size = 0LL;
#line 111
        tot = __constr_expr_0;
      }
    }
#line 113
    if (dir) {
#line 114
      free_dir(dir);
#line 115
      dir = (struct _info **)((void *)0);
    }
#line 117
    if (needsclosed) {
#line 117
      (*(lc.close))(info___1, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
    }
#line 119
    if (duflag) {
#line 119
      tot.size = info___1->size;
    } else {
#line 120
      tot.size += st.st_size;
    }
#line 122
    if ((unsigned long )ig != (unsigned long )((void *)0)) {
#line 122
      ig = pop_filterstack();
    }
#line 123
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
#line 123
      inf = pop_infostack();
    }
#line 71
    i ++;
  }
#line 126
  if (! noreport) {
#line 126
    (*(lc.report))(tot);
  }
#line 128
  (*(lc.outtro))();
#line 129
  return;
}
}
#line 131 "../list.c"
struct totals listdir(char *dirname , struct _info **dir , int lev , dev_t dev , bool hasfulltree ) 
{ 
  struct totals tot ;
  struct totals subtotal ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **subdir ;
  int descend ;
  int htmldescend ;
  int found ;
  int n ;
  int dirlen ;
  size_t___0 tmp ;
  int pathlen ;
  int needsclosed ;
  char *path___0 ;
  char *newpath ;
  char *filename ;
  char *err ;
  int es ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  FILE *outsave ;
  char *paths[2] ;
  char *output ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  int *dirsave ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 133
  tot.files = (u_long )0;
#line 133
  tot.dirs = 0UL;
#line 133
  tot.size = 0LL;
#line 134
  ig = (struct ignorefile *)((void *)0);
#line 135
  inf = (struct infofile *)((void *)0);
#line 136
  subdir = (struct _info **)((void *)0);
#line 137
  htmldescend = 0;
#line 137
  tmp = strlen((char const   *)dirname);
#line 137
  dirlen = (int )tmp;
#line 137
  pathlen = dirlen + 257;
#line 139
  err = (char *)((void *)0);
#line 141
  tmp___0 = strlen((char const   *)dirname);
#line 141
  es = (int )*(dirname + (tmp___0 - 1UL)) == 47;
#line 143
  n = 0;
#line 143
  while (*(dir + n)) {
#line 143
    n ++;
  }
#line 144
  if (topsort) {
#line 144
    qsort((void *)dir, (size_t )n, sizeof(struct _info *), (int (*)(void const   * ,
                                                                    void const   * ))topsort);
  }
#line 146
  if (*(dir + 1)) {
#line 146
    *(dirs + lev) = 1;
  } else {
#line 146
    *(dirs + lev) = 2;
  }
#line 148
  tmp___1 = xmalloc(sizeof(char ) * (unsigned long )pathlen);
#line 148
  path___0 = (char *)tmp___1;
#line 150
  while ((unsigned long )*dir != (unsigned long )((void *)0)) {
#line 151
    (*(lc.printinfo))(dirname, *dir, lev);
#line 153
    if (es) {
#line 153
      sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s%s",
              dirname, (*dir)->name);
    } else {
#line 154
      sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s",
              dirname, (*dir)->name);
    }
#line 155
    if (fflag) {
#line 155
      filename = path___0;
    } else {
#line 156
      filename = (*dir)->name;
    }
#line 158
    descend = 0;
#line 159
    err = (char *)((void *)0);
#line 161
    if ((*dir)->isdir) {
#line 162
      (tot.dirs) ++;
#line 164
      found = findino((*dir)->inode, (*dir)->dev);
#line 165
      if (! found) {
#line 165
        saveino((*dir)->inode, (*dir)->dev);
      }
#line 167
      if (xdev) {
#line 167
        if (! (dev != (*dir)->dev)) {
#line 167
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 167
      if (! (*dir)->lnk) {
#line 167
        goto _L;
      } else
#line 167
      if ((*dir)->lnk) {
#line 167
        if (lflag) {
          _L: /* CIL Label */ 
#line 168
          descend = 1;
#line 169
          newpath = path___0;
#line 171
          if ((*dir)->lnk) {
#line 172
            if ((int )*((*dir)->lnk) == 47) {
#line 172
              newpath = (*dir)->lnk;
            } else
#line 174
            if (fflag) {
#line 174
              tmp___2 = strcmp((char const   *)dirname, (char const   *)"/");
#line 174
              if (tmp___2) {
#line 175
                sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s",
                        dirname, (*dir)->lnk);
              } else {
#line 174
                sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s%s",
                        dirname, (*dir)->lnk);
              }
            } else {
#line 175
              sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s",
                      dirname, (*dir)->lnk);
            }
#line 177
            if (found) {
#line 178
              err = "recursive, not followed";
#line 179
              descend = 0;
            }
          }
#line 183
          if (Level >= 0) {
#line 183
            if (lev > Level) {
#line 184
              if (Rflag) {
#line 185
                outsave = outfile;
#line 186
                paths[0] = newpath;
#line 186
                paths[1] = (char *)((void *)0);
#line 186
                tmp___3 = strlen((char const   *)newpath);
#line 186
                tmp___4 = xmalloc(tmp___3 + 13UL);
#line 186
                output = (char *)tmp___4;
#line 187
                tmp___5 = xmalloc(sizeof(int ) * (unsigned long )(lev + 2));
#line 187
                dirsave = (int *)tmp___5;
#line 189
                memcpy((void * __restrict  )dirsave, (void const   * __restrict  )dirs,
                       sizeof(int ) * (unsigned long )(lev + 1));
#line 190
                sprintf((char * __restrict  )output, (char const   * __restrict  )"%s/00Tree.html",
                        newpath);
#line 191
                setoutput(output);
#line 192
                emit_tree(paths, hasfulltree);
#line 194
                free((void *)output);
#line 195
                fclose(outfile);
#line 196
                outfile = outsave;
#line 198
                memcpy((void * __restrict  )dirs, (void const   * __restrict  )dirsave,
                       sizeof(int ) * (unsigned long )(lev + 1));
#line 199
                free((void *)dirsave);
#line 200
                htmldescend = 10;
              } else {
#line 201
                htmldescend = 0;
              }
#line 202
              descend = 0;
            }
          }
#line 205
          if (descend) {
#line 206
            if (hasfulltree) {
#line 207
              subdir = (*dir)->child;
#line 208
              err = (*dir)->err;
            } else {
#line 210
              push_files(newpath, & ig, & inf);
#line 211
              subdir = read_dir(newpath, & n, (unsigned long )inf != (unsigned long )((void *)0));
#line 212
              if (! subdir) {
#line 212
                if (n) {
#line 213
                  err = "error opening dir";
#line 214
                  errors ++;
                }
              }
#line 215
              if (flimit > 0) {
#line 215
                if (n > flimit) {
#line 216
                  err = errbuf;
#line 216
                  sprintf((char * __restrict  )err, (char const   * __restrict  )"%d entries exceeds filelimit, not opening dir",
                          n);
#line 217
                  errors ++;
#line 218
                  free_dir(subdir);
#line 219
                  subdir = (struct _info **)((void *)0);
                }
              }
            }
#line 222
            if ((unsigned long )subdir == (unsigned long )((void *)0)) {
#line 222
              descend = 0;
            }
          }
        }
      }
    } else {
#line 225
      (tot.files) ++;
    }
#line 227
    if (Jflag) {
#line 227
      if (errors) {
#line 227
        tmp___6 = 1;
      } else {
#line 227
        tmp___6 = 0;
      }
    } else {
#line 227
      tmp___6 = 0;
    }
#line 227
    needsclosed = (*(lc.printfile))(dirname, filename, *dir, (descend + htmldescend) + tmp___6);
#line 228
    if (err) {
#line 228
      (*(lc.error))(err);
    }
#line 230
    if (descend) {
#line 231
      (*(lc.newline))(*dir, lev, 0, 0);
#line 233
      subtotal = listdir(newpath, subdir, lev + 1, dev, hasfulltree);
#line 234
      tot.dirs += subtotal.dirs;
#line 235
      tot.files += subtotal.files;
#line 236
      tot.size += subtotal.size;
    } else
#line 237
    if (! needsclosed) {
#line 237
      (*(lc.newline))(*dir, lev, 0, (unsigned long )*(dir + 1) != (unsigned long )((void *)0));
    }
#line 239
    if (subdir) {
#line 240
      free_dir(subdir);
#line 241
      subdir = (struct _info **)((void *)0);
    }
#line 243
    if (needsclosed) {
#line 243
      if (descend) {
#line 243
        tmp___7 = lev;
      } else {
#line 243
        tmp___7 = -1;
      }
#line 243
      (*(lc.close))(*dir, tmp___7, (unsigned long )*(dir + 1) != (unsigned long )((void *)0));
    }
#line 245
    if (*(dir + 1)) {
#line 245
      if (! *(dir + 2)) {
#line 245
        *(dirs + lev) = 2;
      }
    }
#line 246
    tot.size += (*dir)->size;
#line 248
    if ((unsigned long )ig != (unsigned long )((void *)0)) {
#line 248
      ig = pop_filterstack();
    }
#line 249
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
#line 249
      inf = pop_infostack();
    }
#line 150
    dir ++;
  }
#line 252
  *(dirs + lev) = 0;
#line 253
  free((void *)path___0);
#line 254
  return (tot);
}
}
#line 1 "cil-JudxBsk1.o"
#pragma merger("0","/tmp/cil-0A5qHwSS.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 14 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h"
extern int isdigit(int  ) ;
#line 103 "../strverscmp.c"
int strverscmp(char const   *s1 , char const   *s2 ) ;
#line 103 "../strverscmp.c"
static unsigned int const   next_state[16]  = 
#line 103
  {      (unsigned int const   )0x0,      (unsigned int const   )0x4,      (unsigned int const   )0xC,      (unsigned int const   )0x0, 
        (unsigned int const   )0x0,      (unsigned int const   )0x4,      (unsigned int const   )0x4,      (unsigned int const   )0x4, 
        (unsigned int const   )0x0,      (unsigned int const   )0x8,      (unsigned int const   )0x8,      (unsigned int const   )0x8, 
        (unsigned int const   )0x0,      (unsigned int const   )0x8,      (unsigned int const   )0xC,      (unsigned int const   )0xC};
#line 112 "../strverscmp.c"
static int const   result_type[60]  = 
#line 112
  {      (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )3,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )-1,      (int const   )-1,      (int const   )2, 
        (int const   )1,      (int const   )3,      (int const   )3,      (int const   )2, 
        (int const   )1,      (int const   )3,      (int const   )3,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )3,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )-1,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )-1,      (int const   )2,      (int const   )2,      (int const   )2};
#line 92 "../strverscmp.c"
int strverscmp(char const   *s1 , char const   *s2 ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int state ;
  int diff ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char const   *tmp___6 ;
  int tmp___7 ;
  unsigned char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 95
  p1 = (unsigned char const   *)s1;
#line 96
  p2 = (unsigned char const   *)s2;
#line 127
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 128
    return (0);
  }
#line 130
  tmp = p1;
#line 130
  p1 ++;
#line 130
  c1 = (unsigned char )*tmp;
#line 131
  tmp___0 = p2;
#line 131
  p2 ++;
#line 131
  c2 = (unsigned char )*tmp___0;
#line 133
  tmp___1 = isdigit((int )c1);
#line 133
  state = ((int )c1 == 48) + (tmp___1 != 0);
#line 135
  while (1) {
#line 135
    diff = (int )c1 - (int )c2;
#line 135
    if (diff == 0) {
#line 135
      if (! ((int )c1 != 0)) {
#line 135
        break;
      }
    } else {
#line 135
      break;
    }
#line 137
    state = (int )next_state[state];
#line 138
    tmp___2 = p1;
#line 138
    p1 ++;
#line 138
    c1 = (unsigned char )*tmp___2;
#line 139
    tmp___3 = p2;
#line 139
    p2 ++;
#line 139
    c2 = (unsigned char )*tmp___3;
#line 140
    tmp___4 = isdigit((int )c1);
#line 140
    state |= ((int )c1 == 48) + (tmp___4 != 0);
  }
#line 143
  tmp___5 = isdigit((int )c2);
#line 143
  state = (int )result_type[(state << 2) | (((int )c2 == 48) + (tmp___5 != 0))];
#line 145
  switch (state) {
  case 2: 
#line 148
  return (diff);
  case 3: 
#line 151
  while (1) {
#line 151
    tmp___8 = p1;
#line 151
    p1 ++;
#line 151
    tmp___9 = isdigit((int )*tmp___8);
#line 151
    if (! tmp___9) {
#line 151
      break;
    }
#line 152
    tmp___6 = p2;
#line 152
    p2 ++;
#line 152
    tmp___7 = isdigit((int )*tmp___6);
#line 152
    if (! tmp___7) {
#line 153
      return (1);
    }
  }
#line 155
  tmp___12 = isdigit((int )*p2);
#line 155
  if (tmp___12) {
#line 155
    tmp___11 = -1;
  } else {
#line 155
    tmp___11 = diff;
  }
#line 155
  return (tmp___11);
  default: 
#line 158
  return (state);
  }
}
}
#line 1 "cil-U79bif8p.o"
#pragma merger("0","/tmp/cil-Voeg1cNE.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 23 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdlib.h"
extern int atoi(char const   * ) ;
#line 33
extern unsigned long strtoul(char const   * __restrict   , char ** __restrict   ,
                             int  ) ;
#line 40
extern void *malloc(size_t  ) ;
#line 42
extern void *realloc(void * , size_t  ) ;
#line 48
extern void exit(int  ) ;
#line 75
extern size_t mbstowcs(wchar_t * __restrict   , char const   * __restrict   , size_t  ) ;
#line 81
extern size_t __ctype_get_mb_cur_max(void) ;
#line 73 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h"
extern FILE *stdout ;
#line 119
extern int printf(char const   *  , ...) ;
#line 55 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h"
extern time_t time(time_t * ) ;
#line 58
extern size_t___0 strftime(char * __restrict   , size_t___0  , char const   * __restrict   ,
                           struct tm  const  * __restrict   ) ;
#line 60
extern struct tm *localtime(time_t const   * ) ;
#line 40 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h"
extern int strncmp(char const   * , char const   * , size_t___0  ) ;
#line 42
extern int strcoll(char const   * , char const   * ) ;
#line 73 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h"
extern int stat(char const   * __restrict   , struct stat * __restrict   ) ;
#line 24 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h"
extern int closedir(DIR * ) ;
#line 26
extern DIR *opendir(char const   * ) ;
#line 27
extern struct dirent *readdir(DIR * ) ;
#line 22 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h"
extern int tolower(int  ) ;
#line 74 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h"
extern ssize_t readlink(char const   * __restrict   , char * __restrict   , size_t___0  ) ;
#line 92
extern char *getcwd(char * , size_t___0  ) ;
#line 55 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/locale.h"
extern char *setlocale(int  , char const   * ) ;
#line 91 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/langinfo.h"
extern char *nl_langinfo(nl_item  ) ;
#line 187 "/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/wchar.h"
extern int iswprint(wint_t  ) ;
#line 193 "../tree.h"
void usage(int n ) ;
#line 197
struct _info **unix_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) ;
#line 200
int filesfirst(struct _info **a , struct _info **b ) ;
#line 201
int dirsfirst(struct _info **a , struct _info **b ) ;
#line 202
int alnumsort(struct _info **a , struct _info **b ) ;
#line 203
int versort(struct _info **a , struct _info **b ) ;
#line 205
int mtimesort(struct _info **a , struct _info **b ) ;
#line 206
int ctimesort(struct _info **a , struct _info **b ) ;
#line 207
int sizecmp(off_t a , off_t b ) ;
#line 208
int fsizesort(struct _info **a , struct _info **b ) ;
#line 211
char *gnu_getcwd(void) ;
#line 221
void printit(char *s ) ;
#line 223
char Ftype(mode_t mode ) ;
#line 235
int unix_printinfo(char *dirname , struct _info *file , int level ) ;
#line 236
int unix_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
#line 237
int unix_error(char *error ) ;
#line 238
void unix_newline(struct _info *file , int level , int postdir , int needcomma ) ;
#line 239
void unix_report(struct totals tot ) ;
#line 253
void xml_intro(void) ;
#line 254
void xml_outtro(void) ;
#line 255
int xml_printinfo(char *dirname , struct _info *file , int level ) ;
#line 256
int xml_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
#line 257
int xml_error(char *error ) ;
#line 258
void xml_newline(struct _info *file , int level , int postdir , int needcomma ) ;
#line 259
void xml_close(struct _info *file , int level , int needcomma ) ;
#line 260
void xml_report(struct totals tot ) ;
#line 22 "../tree.c"
char *version  =    "$Version: $ tree v2.0.4 (c) 1996 - 2022 by Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro $";
#line 25 "../tree.c"
char *hversion  =    "\t\t tree v2.0.4 %s 1996 - 2022 by Steve Baker and Thomas Moore <br>\n\t\t HTML output hacked and copyleft %s 1998 by Francesc Rocher <br>\n\t\t JSON output hacked and copyleft %s 2014 by Florian Sesser <br>\n\t\t Charsets / OS/2 support %s 2001 by Kyosuke Tokoro\n";
#line 32 "../tree.c"
bool dflag  ;
#line 32 "../tree.c"
bool lflag  ;
#line 32 "../tree.c"
bool pflag  ;
#line 32 "../tree.c"
bool sflag  ;
#line 32 "../tree.c"
bool Fflag  ;
#line 32 "../tree.c"
bool aflag  ;
#line 32 "../tree.c"
bool fflag  ;
#line 32 "../tree.c"
bool uflag  ;
#line 32 "../tree.c"
bool gflag  ;
#line 33 "../tree.c"
bool qflag  ;
#line 33 "../tree.c"
bool Nflag  ;
#line 33 "../tree.c"
bool Qflag  ;
#line 33 "../tree.c"
bool Dflag  ;
#line 33 "../tree.c"
bool inodeflag  ;
#line 33 "../tree.c"
bool devflag  ;
#line 33 "../tree.c"
bool hflag  ;
#line 33 "../tree.c"
bool Rflag  ;
#line 34 "../tree.c"
bool Hflag  ;
#line 34 "../tree.c"
bool siflag  ;
#line 34 "../tree.c"
bool cflag  ;
#line 34 "../tree.c"
bool Xflag  ;
#line 34 "../tree.c"
bool Jflag  ;
#line 34 "../tree.c"
bool duflag  ;
#line 34 "../tree.c"
bool pruneflag  ;
#line 35 "../tree.c"
bool noindent  ;
#line 35 "../tree.c"
bool force_color  ;
#line 35 "../tree.c"
bool nocolor  ;
#line 35 "../tree.c"
bool xdev  ;
#line 35 "../tree.c"
bool noreport  ;
#line 35 "../tree.c"
bool nolinks  ;
#line 36 "../tree.c"
bool ignorecase  ;
#line 36 "../tree.c"
bool matchdirs  ;
#line 36 "../tree.c"
bool fromfile  ;
#line 36 "../tree.c"
bool metafirst  ;
#line 36 "../tree.c"
bool gitignore  ;
#line 36 "../tree.c"
bool showinfo  ;
#line 37 "../tree.c"
bool reverse  ;
#line 38 "../tree.c"
int flimit  ;
#line 40 "../tree.c"
struct listingcalls lc  ;
#line 42 "../tree.c"
int pattern  =    0;
#line 42 "../tree.c"
int maxpattern  =    0;
#line 42 "../tree.c"
int ipattern  =    0;
#line 42 "../tree.c"
int maxipattern  =    0;
#line 43 "../tree.c"
char **patterns  =    (char **)((void *)0);
#line 43 "../tree.c"
char **ipatterns  =    (char **)((void *)0);
#line 45 "../tree.c"
char *host  =    (char *)((void *)0);
#line 45 "../tree.c"
char *title  =    "Directory Tree";
#line 45 "../tree.c"
char *sp  =    " ";
#line 45 "../tree.c"
char *_nl  =    "\n";
#line 46 "../tree.c"
char *file_comment  =    "#";
#line 46 "../tree.c"
char *file_pathsep  =    "/";
#line 47 "../tree.c"
char *timefmt  =    (char *)((void *)0);
#line 48 "../tree.c"
char const   *charset  =    (char const   *)((void *)0);
#line 50 "../tree.c"
struct _info **(*getfulltree)(char *d , u_long lev , dev_t dev , off_t *size , char **err )  =    & unix_getfulltree;
#line 53 "../tree.c"
int (*basesort)()  =    (int (*)())(& alnumsort);
#line 54 "../tree.c"
int (*topsort)()  =    (int (*)())((void *)0);
#line 56 "../tree.c"
char *sLevel  ;
#line 56 "../tree.c"
char *curdir  ;
#line 57 "../tree.c"
FILE *outfile  =    (FILE *)((void *)0);
#line 58 "../tree.c"
int Level  ;
#line 58 "../tree.c"
int *dirs  ;
#line 58 "../tree.c"
int maxdirs  ;
#line 59 "../tree.c"
int errors  ;
#line 61 "../tree.c"
int mb_cur_max  ;
#line 75 "../tree.c"
int const   ifmt[8]  = 
#line 75
  {      (int const   )0100000,      (int const   )0040000,      (int const   )0120000,      (int const   )0020000, 
        (int const   )0060000,      (int const   )0140000,      (int const   )0010000,      (int const   )0};
#line 77 "../tree.c"
char const   fmt[9]  = 
#line 77
  {      (char const   )'-',      (char const   )'d',      (char const   )'l',      (char const   )'c', 
        (char const   )'b',      (char const   )'s',      (char const   )'p',      (char const   )'?', 
        (char const   )'\000'};
#line 78 "../tree.c"
char const   *ftype[9]  = 
#line 78
  {      (char const   *)"file",      (char const   *)"directory",      (char const   *)"link",      (char const   *)"char", 
        (char const   *)"block",      (char const   *)"socket",      (char const   *)"fifo",      (char const   *)"unknown", 
        (char const   *)((void *)0)};
#line 86 "../tree.c"
struct sorts sorts[6]  = {      {"name", (int (*)())(& alnumsort)}, 
        {"version", (int (*)())(& versort)}, 
        {"size", (int (*)())(& fsizesort)}, 
        {"mtime", (int (*)())(& mtimesort)}, 
        {"ctime", (int (*)())(& ctimesort)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 99 "../tree.c"
int main(int argc , char **argv ) 
{ 
  char **dirname ;
  int i ;
  int j ;
  int k ;
  int n ;
  int optf ;
  int p ;
  int q ;
  char *stmp ;
  char *outfilename ;
  bool needfulltree ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct listingcalls __constr_expr_0 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct listingcalls __constr_expr_1 ;
  struct listingcalls __constr_expr_2 ;
  struct listingcalls __constr_expr_3 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *v ;
  size_t___0 tmp___18 ;
  int tmp___19 ;
  size_t___0 tmp___20 ;
  int tmp___21 ;
  size_t___0 tmp___22 ;
  int tmp___23 ;
  size_t___0 tmp___24 ;
  int tmp___25 ;
  size_t___0 tmp___26 ;
  int tmp___27 ;
  size_t___0 tmp___28 ;
  int tmp___29 ;
  size_t___0 tmp___30 ;
  int tmp___31 ;
  size_t___0 tmp___32 ;
  int tmp___33 ;
  size_t___0 tmp___34 ;
  int tmp___35 ;
  size_t___0 tmp___36 ;
  int tmp___37 ;
  size_t___0 tmp___38 ;
  int tmp___39 ;
  size_t___0 tmp___40 ;
  int tmp___41 ;
  size_t___0 tmp___42 ;
  int tmp___43 ;
  size_t___0 tmp___44 ;
  int tmp___45 ;
  size_t___0 tmp___46 ;
  void *tmp___47 ;
  size_t___0 tmp___48 ;
  size_t___0 tmp___49 ;
  void *tmp___50 ;
  size_t___0 tmp___51 ;
  int tmp___52 ;
  size_t___0 tmp___53 ;
  int tmp___54 ;
  size_t___0 tmp___55 ;
  int tmp___56 ;
  size_t___0 tmp___57 ;
  int tmp___58 ;
  size_t___0 tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t___0 tmp___63 ;
  int tmp___64 ;
  size_t___0 tmp___65 ;
  int tmp___66 ;
  size_t___0 tmp___67 ;
  int tmp___68 ;
  size_t___0 tmp___69 ;
  int tmp___70 ;
  void *tmp___71 ;
  void *tmp___72 ;
  int tmp___73 ;
  size_t___0 tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  size_t___0 tmp___77 ;
  void *tmp___78 ;
  char *path___0 ;
  void *tmp___79 ;
  struct ignorefile *tmp___80 ;
  struct infofile *tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;

  {
#line 100
  dirname = (char **)((void *)0);
#line 101
  j = 0;
#line 101
  p = 0;
#line 101
  q = 0;
#line 102
  outfilename = (char *)((void *)0);
#line 106
  gflag = (bool )0;
#line 106
  uflag = gflag;
#line 106
  Fflag = uflag;
#line 106
  sflag = Fflag;
#line 106
  pflag = sflag;
#line 106
  lflag = pflag;
#line 106
  fflag = lflag;
#line 106
  dflag = fflag;
#line 106
  aflag = dflag;
#line 107
  cflag = (bool )0;
#line 107
  siflag = cflag;
#line 107
  Hflag = siflag;
#line 107
  hflag = Hflag;
#line 107
  Rflag = hflag;
#line 107
  Qflag = Rflag;
#line 107
  Nflag = Qflag;
#line 107
  qflag = Nflag;
#line 107
  Dflag = qflag;
#line 109
  reverse = (bool )0;
#line 109
  nolinks = reverse;
#line 109
  noreport = nolinks;
#line 109
  xdev = noreport;
#line 109
  nocolor = xdev;
#line 109
  force_color = nocolor;
#line 109
  noindent = force_color;
#line 111
  Jflag = (bool )0;
#line 111
  Xflag = Jflag;
#line 111
  devflag = Xflag;
#line 111
  inodeflag = devflag;
#line 111
  matchdirs = inodeflag;
#line 111
  ignorecase = matchdirs;
#line 112
  gitignore = (bool )0;
#line 112
  metafirst = gitignore;
#line 112
  pruneflag = metafirst;
#line 112
  duflag = pruneflag;
#line 114
  flimit = 0;
#line 115
  maxdirs = 4096;
#line 115
  tmp = xmalloc(sizeof(int ) * (unsigned long )maxdirs);
#line 115
  dirs = (int *)tmp;
#line 116
  memset((void *)dirs, 0, sizeof(int ) * (unsigned long )maxdirs);
#line 117
  *(dirs + 0) = 0;
#line 118
  Level = -1;
#line 120
  setlocale(0, (char const   *)"");
#line 121
  setlocale(3, (char const   *)"");
#line 123
  charset = getcharset();
#line 124
  if ((unsigned long )charset == (unsigned long )((void *)0)) {
#line 124
    tmp___0 = nl_langinfo(14);
#line 124
    tmp___1 = strcmp((char const   *)tmp___0, (char const   *)"UTF-8");
#line 124
    if (tmp___1 == 0) {
#line 126
      charset = (char const   *)"UTF-8";
    } else {
#line 124
      tmp___2 = nl_langinfo(14);
#line 124
      tmp___3 = strcmp((char const   *)tmp___2, (char const   *)"utf8");
#line 124
      if (tmp___3 == 0) {
#line 126
        charset = (char const   *)"UTF-8";
      }
    }
  }
#line 129
  __constr_expr_0.intro = & null_intro;
#line 129
  __constr_expr_0.outtro = & null_outtro;
#line 129
  __constr_expr_0.printinfo = & unix_printinfo;
#line 129
  __constr_expr_0.printfile = & unix_printfile;
#line 129
  __constr_expr_0.error = & unix_error;
#line 129
  __constr_expr_0.newline = & unix_newline;
#line 129
  __constr_expr_0.close = & null_close;
#line 129
  __constr_expr_0.report = & unix_report;
#line 129
  lc = __constr_expr_0;
#line 135
  tmp___4 = __ctype_get_mb_cur_max();
#line 135
  mb_cur_max = (int )tmp___4;
#line 158
  memset((void *)(utable), 0, sizeof(utable));
#line 159
  memset((void *)(gtable), 0, sizeof(gtable));
#line 160
  memset((void *)(itable), 0, sizeof(itable));
#line 162
  optf = 1;
#line 163
  i = 1;
#line 163
  n = i;
#line 163
  while (i < argc) {
#line 164
    n ++;
#line 165
    if (optf) {
#line 165
      if ((int )*(*(argv + i) + 0) == 45) {
#line 165
        if (*(*(argv + i) + 1)) {
#line 166
          j = 1;
#line 166
          while (*(*(argv + i) + j)) {
#line 167
            switch ((int )*(*(argv + i) + j)) {
            case 78: 
#line 169
            Nflag = (bool )1;
#line 170
            break;
            case 113: 
#line 172
            qflag = (bool )1;
#line 173
            break;
            case 81: 
#line 175
            Qflag = (bool )1;
#line 176
            break;
            case 100: 
#line 178
            dflag = (bool )1;
#line 179
            break;
            case 108: 
#line 181
            lflag = (bool )1;
#line 182
            break;
            case 115: 
#line 184
            sflag = (bool )1;
#line 185
            break;
            case 104: 
#line 187
            hflag = (bool )1;
#line 188
            sflag = (bool )1;
#line 189
            break;
            case 117: 
#line 191
            uflag = (bool )1;
#line 192
            break;
            case 103: 
#line 194
            gflag = (bool )1;
#line 195
            break;
            case 102: 
#line 197
            fflag = (bool )1;
#line 198
            break;
            case 70: 
#line 200
            Fflag = (bool )1;
#line 201
            break;
            case 97: 
#line 203
            aflag = (bool )1;
#line 204
            break;
            case 112: 
#line 206
            pflag = (bool )1;
#line 207
            break;
            case 105: 
#line 209
            noindent = (bool )1;
#line 210
            _nl = "";
#line 211
            break;
            case 67: 
#line 213
            force_color = (bool )1;
#line 214
            break;
            case 110: 
#line 216
            nocolor = (bool )1;
#line 217
            break;
            case 120: 
#line 219
            xdev = (bool )1;
#line 220
            break;
            case 80: 
#line 222
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
#line 223
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to -P option.\n");
#line 224
              exit(1);
            }
#line 226
            if (pattern >= maxpattern - 1) {
#line 227
              maxpattern += 10;
#line 227
              tmp___5 = xrealloc((void *)patterns, sizeof(char *) * (unsigned long )maxpattern);
#line 227
              patterns = (char **)tmp___5;
            }
#line 228
            tmp___6 = pattern;
#line 228
            pattern ++;
#line 228
            tmp___7 = n;
#line 228
            n ++;
#line 228
            *(patterns + tmp___6) = *(argv + tmp___7);
#line 229
            *(patterns + pattern) = (char *)((void *)0);
#line 230
            break;
            case 73: 
#line 232
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
#line 233
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to -I option.\n");
#line 234
              exit(1);
            }
#line 236
            if (ipattern >= maxipattern - 1) {
#line 237
              maxipattern += 10;
#line 237
              tmp___8 = xrealloc((void *)ipatterns, sizeof(char *) * (unsigned long )maxipattern);
#line 237
              ipatterns = (char **)tmp___8;
            }
#line 239
            tmp___9 = ipattern;
#line 239
            ipattern ++;
#line 239
            tmp___10 = n;
#line 239
            n ++;
#line 239
            *(ipatterns + tmp___9) = *(argv + tmp___10);
#line 240
            *(ipatterns + ipattern) = (char *)((void *)0);
#line 241
            break;
            case 65: 
#line 243
            ansilines = (bool )1;
#line 244
            break;
            case 83: 
#line 246
            charset = (char const   *)"IBM437";
#line 247
            break;
            case 68: 
#line 249
            Dflag = (bool )1;
#line 250
            break;
            case 116: 
#line 252
            basesort = (int (*)())(& mtimesort);
#line 253
            break;
            case 99: 
#line 255
            basesort = (int (*)())(& ctimesort);
#line 256
            cflag = (bool )1;
#line 257
            break;
            case 114: 
#line 259
            reverse = (bool )1;
#line 260
            break;
            case 118: 
#line 262
            basesort = (int (*)())(& versort);
#line 263
            break;
            case 85: 
#line 265
            basesort = (int (*)())((void *)0);
#line 266
            break;
            case 88: 
#line 268
            Xflag = (bool )1;
#line 269
            Jflag = (bool )0;
#line 269
            Hflag = Jflag;
#line 270
            __constr_expr_1.intro = & xml_intro;
#line 270
            __constr_expr_1.outtro = & xml_outtro;
#line 270
            __constr_expr_1.printinfo = & xml_printinfo;
#line 270
            __constr_expr_1.printfile = & xml_printfile;
#line 270
            __constr_expr_1.error = & xml_error;
#line 270
            __constr_expr_1.newline = & xml_newline;
#line 270
            __constr_expr_1.close = & xml_close;
#line 270
            __constr_expr_1.report = & xml_report;
#line 270
            lc = __constr_expr_1;
#line 273
            break;
            case 74: 
#line 275
            Jflag = (bool )1;
#line 276
            Hflag = (bool )0;
#line 276
            Xflag = Hflag;
#line 277
            __constr_expr_2.intro = & json_intro;
#line 277
            __constr_expr_2.outtro = & json_outtro;
#line 277
            __constr_expr_2.printinfo = & json_printinfo;
#line 277
            __constr_expr_2.printfile = & json_printfile;
#line 277
            __constr_expr_2.error = & json_error;
#line 277
            __constr_expr_2.newline = & json_newline;
#line 277
            __constr_expr_2.close = & json_close;
#line 277
            __constr_expr_2.report = & json_report;
#line 277
            lc = __constr_expr_2;
#line 280
            break;
            case 72: 
#line 282
            Hflag = (bool )1;
#line 283
            Jflag = (bool )0;
#line 283
            Xflag = Jflag;
#line 284
            __constr_expr_3.intro = & html_intro;
#line 284
            __constr_expr_3.outtro = & html_outtro;
#line 284
            __constr_expr_3.printinfo = & html_printinfo;
#line 284
            __constr_expr_3.printfile = & html_printfile;
#line 284
            __constr_expr_3.error = & html_error;
#line 284
            __constr_expr_3.newline = & html_newline;
#line 284
            __constr_expr_3.close = & html_close;
#line 284
            __constr_expr_3.report = & html_report;
#line 284
            lc = __constr_expr_3;
#line 287
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
#line 288
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to -H option.\n");
#line 289
              exit(1);
            }
#line 291
            tmp___11 = n;
#line 291
            n ++;
#line 291
            host = *(argv + tmp___11);
#line 292
            sp = "&nbsp;";
#line 293
            break;
            case 84: 
#line 295
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
#line 296
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to -T option.\n");
#line 297
              exit(1);
            }
#line 299
            tmp___12 = n;
#line 299
            n ++;
#line 299
            title = *(argv + tmp___12);
#line 300
            break;
            case 82: 
#line 302
            Rflag = (bool )1;
#line 303
            break;
            case 76: 
#line 305
            tmp___13 = n;
#line 305
            n ++;
#line 305
            sLevel = *(argv + tmp___13);
#line 305
            if ((unsigned long )sLevel == (unsigned long )((void *)0)) {
#line 306
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: Missing argument to -L option.\n");
#line 307
              exit(1);
            }
#line 309
            tmp___14 = strtoul((char const   * __restrict  )sLevel, (char ** __restrict  )((void *)0),
                               0);
#line 309
            Level = (int )(tmp___14 - 1UL);
#line 310
            if (Level < 0) {
#line 311
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: Invalid level, must be greater than 0.\n");
#line 312
              exit(1);
            }
#line 314
            break;
            case 111: 
#line 316
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
#line 317
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to -o option.\n");
#line 318
              exit(1);
            }
#line 320
            tmp___15 = n;
#line 320
            n ++;
#line 320
            outfilename = *(argv + tmp___15);
#line 321
            break;
            case 45: 
#line 323
            if (j == 1) {
#line 324
              tmp___16 = strcmp((char const   *)"--", (char const   *)*(argv + i));
#line 324
              if (! tmp___16) {
#line 325
                optf = 0;
#line 326
                break;
              }
#line 328
              tmp___17 = strcmp((char const   *)"--help", (char const   *)*(argv + i));
#line 328
              if (! tmp___17) {
#line 329
                usage(2);
#line 330
                exit(0);
              }
#line 332
              tmp___19 = strcmp((char const   *)"--version", (char const   *)*(argv + i));
#line 332
              if (! tmp___19) {
#line 333
                v = version + 12;
#line 334
                tmp___18 = strlen((char const   *)v);
#line 334
                printf((char const   * __restrict  )"%.*s\n", (int )tmp___18 - 1,
                       v);
#line 335
                exit(0);
              }
#line 337
              tmp___21 = strcmp((char const   *)"--inodes", (char const   *)*(argv + i));
#line 337
              if (! tmp___21) {
#line 338
                tmp___20 = strlen((char const   *)*(argv + i));
#line 338
                j = (int )(tmp___20 - 1UL);
#line 339
                inodeflag = (bool )1;
#line 340
                break;
              }
#line 342
              tmp___23 = strcmp((char const   *)"--device", (char const   *)*(argv + i));
#line 342
              if (! tmp___23) {
#line 343
                tmp___22 = strlen((char const   *)*(argv + i));
#line 343
                j = (int )(tmp___22 - 1UL);
#line 344
                devflag = (bool )1;
#line 345
                break;
              }
#line 347
              tmp___25 = strcmp((char const   *)"--noreport", (char const   *)*(argv + i));
#line 347
              if (! tmp___25) {
#line 348
                tmp___24 = strlen((char const   *)*(argv + i));
#line 348
                j = (int )(tmp___24 - 1UL);
#line 349
                noreport = (bool )1;
#line 350
                break;
              }
#line 352
              tmp___27 = strcmp((char const   *)"--nolinks", (char const   *)*(argv + i));
#line 352
              if (! tmp___27) {
#line 353
                tmp___26 = strlen((char const   *)*(argv + i));
#line 353
                j = (int )(tmp___26 - 1UL);
#line 354
                nolinks = (bool )1;
#line 355
                break;
              }
#line 357
              tmp___29 = strcmp((char const   *)"--dirsfirst", (char const   *)*(argv + i));
#line 357
              if (! tmp___29) {
#line 358
                tmp___28 = strlen((char const   *)*(argv + i));
#line 358
                j = (int )(tmp___28 - 1UL);
#line 359
                topsort = (int (*)())(& dirsfirst);
#line 360
                break;
              }
#line 362
              tmp___31 = strcmp((char const   *)"--filesfirst", (char const   *)*(argv + i));
#line 362
              if (! tmp___31) {
#line 363
                tmp___30 = strlen((char const   *)*(argv + i));
#line 363
                j = (int )(tmp___30 - 1UL);
#line 364
                topsort = (int (*)())(& filesfirst);
#line 365
                break;
              }
#line 367
              tmp___35 = strncmp((char const   *)"--filelimit", (char const   *)*(argv + i),
                                 (size_t___0 )11);
#line 367
              if (! tmp___35) {
#line 368
                j = 11;
#line 369
                if ((int )*(*(argv + i) + 11) == 61) {
#line 370
                  if (*(*(argv + i) + 12)) {
#line 371
                    flimit = atoi((char const   *)(*(argv + i) + 12));
#line 372
                    tmp___32 = strlen((char const   *)*(argv + i));
#line 372
                    j = (int )(tmp___32 - 1UL);
#line 373
                    break;
                  } else {
#line 375
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --filelimit=\n");
#line 376
                    exit(1);
                  }
                }
#line 379
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
#line 380
                  tmp___33 = n;
#line 380
                  n ++;
#line 380
                  flimit = atoi((char const   *)*(argv + tmp___33));
#line 381
                  tmp___34 = strlen((char const   *)*(argv + i));
#line 381
                  j = (int )(tmp___34 - 1UL);
                } else {
#line 383
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --filelimit\n");
#line 384
                  exit(1);
                }
#line 386
                break;
              }
#line 388
              tmp___39 = strncmp((char const   *)"--charset", (char const   *)*(argv + i),
                                 (size_t___0 )9);
#line 388
              if (! tmp___39) {
#line 389
                j = 9;
#line 390
                if ((int )*(*(argv + i) + j) == 61) {
#line 391
                  charset = (char const   *)(*(argv + i) + 10);
#line 391
                  if (*charset) {
#line 392
                    tmp___36 = strlen((char const   *)*(argv + i));
#line 392
                    j = (int )(tmp___36 - 1UL);
#line 393
                    break;
                  } else {
#line 395
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --charset=\n");
#line 396
                    exit(1);
                  }
                }
#line 399
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
#line 400
                  tmp___37 = n;
#line 400
                  n ++;
#line 400
                  charset = (char const   *)*(argv + tmp___37);
#line 401
                  tmp___38 = strlen((char const   *)*(argv + i));
#line 401
                  j = (int )(tmp___38 - 1UL);
                } else {
#line 403
                  initlinedraw(1);
#line 404
                  exit(1);
                }
#line 406
                break;
              }
#line 408
              tmp___41 = strncmp((char const   *)"--si", (char const   *)*(argv + i),
                                 (size_t___0 )4);
#line 408
              if (! tmp___41) {
#line 409
                tmp___40 = strlen((char const   *)*(argv + i));
#line 409
                j = (int )(tmp___40 - 1UL);
#line 410
                sflag = (bool )1;
#line 411
                hflag = (bool )1;
#line 412
                siflag = (bool )1;
#line 413
                break;
              }
#line 415
              tmp___43 = strncmp((char const   *)"--du", (char const   *)*(argv + i),
                                 (size_t___0 )4);
#line 415
              if (! tmp___43) {
#line 416
                tmp___42 = strlen((char const   *)*(argv + i));
#line 416
                j = (int )(tmp___42 - 1UL);
#line 417
                sflag = (bool )1;
#line 418
                duflag = (bool )1;
#line 419
                break;
              }
#line 421
              tmp___45 = strncmp((char const   *)"--prune", (char const   *)*(argv + i),
                                 (size_t___0 )7);
#line 421
              if (! tmp___45) {
#line 422
                tmp___44 = strlen((char const   *)*(argv + i));
#line 422
                j = (int )(tmp___44 - 1UL);
#line 423
                pruneflag = (bool )1;
#line 424
                break;
              }
#line 426
              tmp___52 = strncmp((char const   *)"--timefmt", (char const   *)*(argv + i),
                                 (size_t___0 )9);
#line 426
              if (! tmp___52) {
#line 427
                j = 9;
#line 428
                if ((int )*(*(argv + i) + j) == 61) {
#line 429
                  j ++;
#line 429
                  if (*(*(argv + i) + j)) {
#line 430
                    tmp___46 = strlen((char const   *)(*(argv + i) + j));
#line 430
                    tmp___47 = xmalloc(tmp___46 + 1UL);
#line 430
                    timefmt = strcpy((char * __restrict  )tmp___47, (char const   * __restrict  )(*(argv + i) + j));
#line 431
                    tmp___48 = strlen((char const   *)*(argv + i));
#line 431
                    j = (int )(tmp___48 - 1UL);
#line 432
                    break;
                  } else {
#line 434
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --timefmt=\n");
#line 435
                    exit(1);
                  }
                } else
#line 437
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
#line 438
                  tmp___49 = strlen((char const   *)*(argv + n));
#line 438
                  tmp___50 = xmalloc(tmp___49 + 1UL);
#line 438
                  timefmt = strcpy((char * __restrict  )tmp___50, (char const   * __restrict  )*(argv + n));
#line 439
                  n ++;
#line 440
                  tmp___51 = strlen((char const   *)*(argv + i));
#line 440
                  j = (int )(tmp___51 - 1UL);
                } else {
#line 442
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --timefmt\n");
#line 443
                  exit(1);
                }
#line 445
                Dflag = (bool )1;
#line 446
                break;
              }
#line 448
              tmp___54 = strncmp((char const   *)"--ignore-case", (char const   *)*(argv + i),
                                 (size_t___0 )13);
#line 448
              if (! tmp___54) {
#line 449
                tmp___53 = strlen((char const   *)*(argv + i));
#line 449
                j = (int )(tmp___53 - 1UL);
#line 450
                ignorecase = (bool )1;
#line 451
                break;
              }
#line 453
              tmp___56 = strncmp((char const   *)"--matchdirs", (char const   *)*(argv + i),
                                 (size_t___0 )11);
#line 453
              if (! tmp___56) {
#line 454
                tmp___55 = strlen((char const   *)*(argv + i));
#line 454
                j = (int )(tmp___55 - 1UL);
#line 455
                matchdirs = (bool )1;
#line 456
                break;
              }
#line 458
              tmp___62 = strncmp((char const   *)"--sort", (char const   *)*(argv + i),
                                 (size_t___0 )6);
#line 458
              if (! tmp___62) {
#line 459
                j = 6;
#line 460
                if ((int )*(*(argv + i) + j) == 61) {
#line 461
                  j ++;
#line 461
                  if (*(*(argv + i) + j)) {
#line 462
                    stmp = *(argv + i) + j;
#line 463
                    tmp___57 = strlen((char const   *)*(argv + i));
#line 463
                    j = (int )(tmp___57 - 1UL);
                  } else {
#line 465
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --sort=\n");
#line 466
                    exit(1);
                  }
                } else
#line 468
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
#line 469
                  tmp___58 = n;
#line 469
                  n ++;
#line 469
                  stmp = *(argv + tmp___58);
#line 470
                  tmp___59 = strlen((char const   *)*(argv + i));
#line 470
                  j = (int )(tmp___59 - 1UL);
                } else {
#line 472
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: missing argument to --sort\n");
#line 473
                  exit(1);
                }
#line 475
                basesort = (int (*)())((void *)0);
#line 476
                k = 0;
#line 476
                while (sorts[k].name) {
#line 477
                  tmp___60 = strcasecmp((char const   *)sorts[k].name, (char const   *)stmp);
#line 477
                  if (tmp___60 == 0) {
#line 478
                    basesort = sorts[k].cmpfunc;
#line 479
                    break;
                  }
#line 476
                  k ++;
                }
#line 482
                if ((unsigned long )basesort == (unsigned long )((void *)0)) {
#line 483
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: sort type \'%s\' not valid, should be one of: ",
                          stmp);
#line 486
                  k = 0;
#line 486
                  while (sorts[k].name) {
#line 487
                    if (sorts[k + 1].name) {
#line 487
                      tmp___61 = ',';
                    } else {
#line 487
                      tmp___61 = '\n';
                    }
#line 487
                    printf((char const   * __restrict  )"%s%c", sorts[k].name, tmp___61);
#line 486
                    k ++;
                  }
#line 488
                  exit(1);
                }
#line 490
                break;
              }
#line 492
              tmp___64 = strncmp((char const   *)"--fromfile", (char const   *)*(argv + i),
                                 (size_t___0 )10);
#line 492
              if (! tmp___64) {
#line 493
                tmp___63 = strlen((char const   *)*(argv + i));
#line 493
                j = (int )(tmp___63 - 1UL);
#line 494
                fromfile = (bool )1;
#line 495
                getfulltree = & file_getfulltree;
#line 496
                break;
              }
#line 498
              tmp___66 = strncmp((char const   *)"--metafirst", (char const   *)*(argv + i),
                                 (size_t___0 )11);
#line 498
              if (! tmp___66) {
#line 499
                tmp___65 = strlen((char const   *)*(argv + i));
#line 499
                j = (int )(tmp___65 - 1UL);
#line 500
                metafirst = (bool )1;
#line 501
                break;
              }
#line 503
              tmp___68 = strncmp((char const   *)"--gitignore", (char const   *)*(argv + i),
                                 (size_t___0 )11);
#line 503
              if (! tmp___68) {
#line 504
                tmp___67 = strlen((char const   *)*(argv + i));
#line 504
                j = (int )(tmp___67 - 1UL);
#line 505
                gitignore = (bool )1;
#line 506
                break;
              }
#line 508
              tmp___70 = strncmp((char const   *)"--info", (char const   *)*(argv + i),
                                 (size_t___0 )6);
#line 508
              if (! tmp___70) {
#line 509
                tmp___69 = strlen((char const   *)*(argv + i));
#line 509
                j = (int )(tmp___69 - 1UL);
#line 510
                showinfo = (bool )1;
#line 511
                break;
              }
#line 513
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: Invalid argument `%s\'.\n",
                      *(argv + i));
#line 514
              usage(1);
#line 515
              exit(1);
            }
            default: 
#line 518
            printf((char const   * __restrict  )"here i = %d, n = %d\n", i, n);
#line 519
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: Invalid argument -`%c\'.\n",
                    (int )*(*(argv + i) + j));
#line 520
            usage(1);
#line 521
            exit(1);
#line 522
            break;
            }
#line 166
            j ++;
          }
        } else {
#line 165
          goto _L___0;
        }
      } else {
#line 165
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 526
      if (! dirname) {
#line 527
        q = 30;
#line 527
        tmp___71 = xmalloc(sizeof(char *) * (unsigned long )q);
#line 527
        dirname = (char **)tmp___71;
      } else
#line 528
      if (p == q - 2) {
#line 529
        q += 20;
#line 529
        tmp___72 = xrealloc((void *)dirname, sizeof(char *) * (unsigned long )q);
#line 529
        dirname = (char **)tmp___72;
      }
#line 530
      tmp___73 = p;
#line 530
      p ++;
#line 530
      tmp___74 = strlen((char const   *)*(argv + i));
#line 530
      tmp___75 = xmalloc(tmp___74 + 1UL);
#line 530
      *(dirname + tmp___73) = strcpy((char * __restrict  )tmp___75, (char const   * __restrict  )*(argv + i));
    }
#line 163
    i = n;
  }
#line 533
  if (p) {
#line 534
    *(dirname + p) = (char *)((void *)0);
  }
#line 536
  setoutput(outfilename);
#line 538
  parse_dir_colors();
#line 539
  initlinedraw(0);
#line 542
  if ((unsigned long )dirname == (unsigned long )((void *)0)) {
#line 543
    tmp___76 = xmalloc(sizeof(char *) * 2UL);
#line 543
    dirname = (char **)tmp___76;
#line 544
    tmp___77 = strlen((char const   *)".");
#line 544
    tmp___78 = xmalloc(tmp___77 + 1UL);
#line 544
    *(dirname + 0) = strcpy((char * __restrict  )tmp___78, (char const   * __restrict  )".");
#line 545
    *(dirname + 1) = (char *)((void *)0);
  }
#line 547
  if ((unsigned long )topsort == (unsigned long )((void *)0)) {
#line 548
    topsort = basesort;
  }
#line 549
  if (timefmt) {
#line 550
    setlocale(2, (char const   *)"");
  }
#line 551
  if (dflag) {
#line 552
    pruneflag = (bool )0;
  }
#line 553
  if (Rflag) {
#line 553
    if (Level == -1) {
#line 554
      Rflag = (bool )0;
    }
  }
#line 557
  if (gitignore) {
#line 557
    stmp = getenv((char const   *)"GIT_DIR");
#line 557
    if (stmp) {
#line 558
      tmp___79 = xmalloc((size_t___0 )4096);
#line 558
      path___0 = (char *)tmp___79;
#line 559
      snprintf((char * __restrict  )path___0, (size_t___0 )4096, (char const   * __restrict  )"%s/info/exclude",
               stmp);
#line 560
      tmp___80 = new_ignorefile(path___0);
#line 560
      push_filterstack(tmp___80);
#line 561
      free((void *)path___0);
    }
  }
#line 563
  if (showinfo) {
#line 564
    tmp___81 = new_infofile("/usr/share/finfo/global_info");
#line 564
    push_infostack(tmp___81);
  }
#line 567
  if (duflag) {
#line 567
    tmp___82 = 1;
  } else
#line 567
  if (pruneflag) {
#line 567
    tmp___82 = 1;
  } else
#line 567
  if (matchdirs) {
#line 567
    tmp___82 = 1;
  } else
#line 567
  if (fromfile) {
#line 567
    tmp___82 = 1;
  } else {
#line 567
    tmp___82 = 0;
  }
#line 567
  needfulltree = (bool )tmp___82;
#line 569
  emit_tree(dirname, needfulltree);
#line 571
  if ((unsigned long )outfilename != (unsigned long )((void *)0)) {
#line 572
    fclose(outfile);
  }
#line 574
  if (errors) {
#line 574
    tmp___83 = 2;
  } else {
#line 574
    tmp___83 = 0;
  }
#line 574
  return (tmp___83);
}
}
#line 577 "../tree.c"
void setoutput(char *filename ) 
{ 


  {
#line 578
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 582
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
#line 583
      outfile = (FILE *)stdout;
    }
  } else {
#line 589
    outfile = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
#line 591
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
#line 592
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: invalid filename \'%s\'\n",
              filename);
#line 593
      exit(1);
    }
  }
#line 596
  return;
}
}
#line 598 "../tree.c"
void usage(int n ) 
{ 
  FILE *tmp ;

  {
#line 603
  if (n < 2) {
#line 603
    tmp = stderr;
  } else {
#line 603
    tmp = stdout;
  }
#line 603
  fprintf((FILE * __restrict  )tmp, (char const   * __restrict  )"usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-L level [-R]] [-H  baseHREF]\n\t[-T title] [-o filename] [-P pattern] [-I pattern] [--gitignore]\n\t[--matchdirs] [--metafirst] [--ignore-case] [--nolinks] [--inodes]\n\t[--device] [--sort[=]<name>] [--dirsfirst] [--filesfirst]\n\t[--filelimit #] [--si] [--du] [--prune] [--charset X]\n\t[--timefmt[=]format] [--fromfile] [--noreport] [--version] [--help]\n\t[--] [directory ...]\n");
#line 614
  if (n < 2) {
#line 615
    return;
  }
#line 616
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"  ------- Listing options -------\n  -a            All files are listed.\n  -d            List directories only.\n  -l            Follow symbolic links like directories.\n  -f            Print the full path prefix for each file.\n  -x            Stay on current filesystem only.\n  -L level      Descend only level directories deep.\n  -R            Rerun tree when max dir level reached.\n  -P pattern    List only those files that match the pattern given.\n  -I pattern    Do not list files that match the given pattern.\n  --gitignore   Filter by using .gitignore files.\n  --ignore-case Ignore case when pattern matching.\n  --matchdirs   Include directory names in -P pattern matching.\n  --metafirst   Print meta-data at the beginning of each line.\n  --prune       Prune empty directories from the output.\n  --info        Print information about files found in .info files.\n  --noreport    Turn off file/directory count at end of tree listing.\n  --charset X   Use charset X for terminal/HTML and indentation line output.\n  --filelimit # Do not descend dirs with more than # files in them.\n  -o filename   Output to file instead of stdout.\n  ------- File options -------\n  -q            Print non-printable characters as \'?\'.\n  -N            Print non-printable characters as is.\n  -Q            Quote filenames with double quotes.\n  -p            Print the protections for each file.\n  -u            Displays file owner or UID number.\n  -g            Displays file group owner or GID number.\n  -s            Print the size in bytes of each file.\n  -h            Print the size in a more human readable way.\n  --si          Like -h, but use in SI units (powers of 1000).\n  --du          Compute size of directories by their contents.\n  -D            Print the date of last modification or (-c) status change.\n  --timefmt <f> Print and format time according to the format <f>.\n  -F            Appends \'/\', \'=\', \'*\', \'@\', \'|\' or \'>\' as per ls -F.\n  --inodes      Print inode number of each file.\n  --device      Print device ID number to which each file belongs.\n  ------- Sorting options -------\n  -v            Sort files alphanumerically by version.\n  -t            Sort files by last modification time.\n  -c            Sort files by last status change time.\n  -U            Leave files unsorted.\n  -r            Reverse the order of the sort.\n  --dirsfirst   List directories before files (-U disables).\n  --filesfirst  List files before directories (-U disables).\n  --sort X      Select sort: name,version,size,mtime,ctime.\n  ------- Graphics options -------\n  -i            Don\'t print indentation lines.\n  -A            Print ANSI lines graphic indentation lines.\n  -S            Print with CP437 (console) graphics indentation lines.\n  -n            Turn colorization off always (-C overrides).\n  -C            Turn colorization on always.\n  ------- XML/HTML/JSON options -------\n  -X            Prints out an XML representation of the tree.\n  -J            Prints out an JSON representation of the tree.\n  -H baseHREF   Prints out HTML format with baseHREF as top directory.\n  -T string     Replace the default HTML title and H1 header with string.\n  --nolinks     Turn off hyperlinks in HTML output.\n  ------- Input options -------\n  --fromfile    Reads paths from files (.=stdin)\n  ------- Miscellaneous options -------\n  --version     Print version and exit.\n  --help        Print usage and this help message and exit.\n  --            Options processing terminator.\n");
#line 684
  exit(0);
}
}
#line 690 "../tree.c"
int patignore(char *name , int isdir ) 
{ 
  int i ;
  int tmp ;

  {
#line 691
  i = 0;
#line 691
  while (i < ipattern) {
#line 692
    tmp = patmatch(name, *(ipatterns + i), isdir);
#line 692
    if (tmp) {
#line 693
      return (1);
    }
#line 691
    i ++;
  }
#line 694
  return (0);
}
}
#line 700 "../tree.c"
int patinclude(char *name , int isdir ) 
{ 
  int i ;
  int tmp ;

  {
#line 702
  i = 0;
#line 702
  while (i < pattern) {
#line 703
    tmp = patmatch(name, *(patterns + i), isdir);
#line 703
    if (tmp) {
#line 705
      return (1);
    }
#line 702
    i ++;
  }
#line 708
  return (0);
}
}
#line 716
struct _info *getinfo(char *name , char *path___0 ) ;
#line 716 "../tree.c"
static char *lbuf  =    (char *)((void *)0);
#line 717 "../tree.c"
static int lbufsize  =    0;
#line 715 "../tree.c"
struct _info *getinfo(char *name , char *path___0 ) 
{ 
  struct _info *ent ;
  struct stat st ;
  struct stat lst ;
  int len ;
  int rs ;
  void *tmp ;
  int tmp___0 ;
  int isdir ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t___0 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  size_t___0 tmp___10 ;
  void *tmp___11 ;
  ssize_t tmp___12 ;

  {
#line 722
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
#line 723
    lbufsize = 4096;
#line 723
    tmp = xmalloc((size_t___0 )lbufsize);
#line 723
    lbuf = (char *)tmp;
  }
#line 725
  tmp___0 = lstat((char const   * __restrict  )path___0, (struct stat * __restrict  )(& lst));
#line 725
  if (tmp___0 < 0) {
#line 726
    return ((struct _info *)((void *)0));
  }
#line 728
  if ((lst.st_mode & 61440U) == 40960U) {
#line 729
    rs = stat((char const   * __restrict  )path___0, (struct stat * __restrict  )(& st));
#line 729
    if (rs < 0) {
#line 730
      memset((void *)(& st), 0, sizeof(st));
    }
  } else {
#line 732
    rs = 0;
#line 733
    st.st_mode = lst.st_mode;
#line 734
    st.st_dev = lst.st_dev;
#line 735
    st.st_ino = lst.st_ino;
  }
#line 738
  isdir = (st.st_mode & 61440U) == 16384U;
#line 741
  if (gitignore) {
#line 741
    tmp___1 = filtercheck(path___0, name, isdir);
#line 741
    if (tmp___1) {
#line 742
      return ((struct _info *)((void *)0));
    }
  }
#line 744
  if ((lst.st_mode & 61440U) != 16384U) {
#line 744
    if (lflag) {
#line 744
      if (! ((st.st_mode & 61440U) == 16384U)) {
#line 744
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 746
    if (pattern) {
#line 746
      tmp___2 = patinclude(name, isdir);
#line 746
      if (! tmp___2) {
#line 747
        return ((struct _info *)((void *)0));
      }
    }
  }
#line 749
  if (ipattern) {
#line 749
    tmp___3 = patignore(name, isdir);
#line 749
    if (tmp___3) {
#line 750
      return ((struct _info *)((void *)0));
    }
  }
#line 753
  if (dflag) {
#line 753
    if ((st.st_mode & 61440U) != 16384U) {
#line 754
      return ((struct _info *)((void *)0));
    }
  }
#line 760
  tmp___4 = xmalloc(sizeof(struct _info ));
#line 760
  ent = (struct _info *)tmp___4;
#line 761
  memset((void *)ent, 0, sizeof(struct _info ));
#line 763
  tmp___5 = strlen((char const   *)name);
#line 763
  tmp___6 = xmalloc(tmp___5 + 1UL);
#line 763
  ent->name = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )name);
#line 768
  ent->mode = lst.st_mode;
#line 769
  ent->uid = lst.st_uid;
#line 770
  ent->gid = lst.st_gid;
#line 771
  ent->size = lst.st_size;
#line 772
  ent->dev = st.st_dev;
#line 773
  ent->inode = st.st_ino;
#line 774
  ent->ldev = lst.st_dev;
#line 775
  ent->linode = lst.st_ino;
#line 776
  ent->lnk = (char *)((void *)0);
#line 777
  ent->orphan = (bool )0;
#line 778
  ent->err = (char *)((void *)0);
#line 779
  ent->child = (struct _info **)((void *)0);
#line 781
  ent->atime = lst.st_atim.tv_sec;
#line 782
  ent->ctime = lst.st_ctim.tv_sec;
#line 783
  ent->mtime = lst.st_mtim.tv_sec;
#line 790
  ent->isdir = (bool )isdir;
#line 791
  ent->issok = (bool )((st.st_mode & 61440U) == 49152U);
#line 792
  ent->isfifo = (bool )((st.st_mode & 61440U) == 4096U);
#line 793
  if (st.st_mode & 73U) {
#line 793
    ent->isexe = (bool )1;
  } else {
#line 793
    ent->isexe = (bool )0;
  }
#line 795
  if ((lst.st_mode & 61440U) == 40960U) {
#line 796
    if (lst.st_size + 1LL > (off_t )lbufsize) {
#line 797
      lbufsize = (int )(lst.st_size + 8192LL);
#line 797
      tmp___7 = xrealloc((void *)lbuf, (size_t___0 )lbufsize);
#line 797
      lbuf = (char *)tmp___7;
    }
#line 798
    tmp___12 = readlink((char const   * __restrict  )path___0, (char * __restrict  )lbuf,
                        (size_t___0 )(lbufsize - 1));
#line 798
    len = (int )tmp___12;
#line 798
    if (len < 0) {
#line 799
      tmp___8 = strlen((char const   *)"[Error reading symbolic link information]");
#line 799
      tmp___9 = xmalloc(tmp___8 + 1UL);
#line 799
      ent->lnk = strcpy((char * __restrict  )tmp___9, (char const   * __restrict  )"[Error reading symbolic link information]");
#line 800
      ent->isdir = (bool )0;
#line 801
      ent->lnkmode = st.st_mode;
    } else {
#line 803
      *(lbuf + len) = (char)0;
#line 804
      tmp___10 = strlen((char const   *)lbuf);
#line 804
      tmp___11 = xmalloc(tmp___10 + 1UL);
#line 804
      ent->lnk = strcpy((char * __restrict  )tmp___11, (char const   * __restrict  )lbuf);
#line 805
      if (rs < 0) {
#line 806
        ent->orphan = (bool )1;
      }
#line 807
      ent->lnkmode = st.st_mode;
    }
  }
#line 812
  ent->comment = (char **)((void *)0);
#line 814
  return (ent);
}
}
#line 819 "../tree.c"
static char *path  =    (char *)((void *)0);
#line 820 "../tree.c"
static long pathsize  ;
#line 817 "../tree.c"
struct _info **read_dir(char *dir , int *n , int infotop ) 
{ 
  struct comment *com ;
  struct _info **dl ;
  struct _info *info___1 ;
  struct dirent *ent ;
  DIR *d ;
  int ne ;
  int p ;
  int i ;
  int es ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t___0 tmp___6 ;
  size_t___0 tmp___7 ;
  void *tmp___8 ;
  size_t___0 tmp___9 ;
  size_t___0 tmp___10 ;
  void *tmp___11 ;
  size_t___0 tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  struct dirent *tmp___16 ;
  int tmp___17 ;

  {
#line 824
  p = 0;
#line 825
  tmp = strlen((char const   *)dir);
#line 825
  es = (int )*(dir + (tmp - 1UL)) == 47;
#line 827
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 828
    tmp___0 = strlen((char const   *)dir);
#line 828
    pathsize = (long )(tmp___0 + 4096UL);
#line 828
    tmp___1 = xmalloc((size_t___0 )pathsize);
#line 828
    path = (char *)tmp___1;
  }
#line 831
  *n = -1;
#line 832
  d = opendir((char const   *)dir);
#line 832
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 833
    return ((struct _info **)((void *)0));
  }
#line 835
  ne = 30;
#line 835
  tmp___2 = xmalloc(sizeof(struct _info *) * (unsigned long )ne);
#line 835
  dl = (struct _info **)tmp___2;
#line 837
  while (1) {
#line 837
    tmp___16 = readdir(d);
#line 837
    ent = tmp___16;
#line 837
    if (! ent) {
#line 837
      break;
    }
#line 838
    tmp___3 = strcmp((char const   *)"..", (char const   *)(ent->d_name));
#line 838
    if (tmp___3) {
#line 838
      tmp___4 = strcmp((char const   *)".", (char const   *)(ent->d_name));
#line 838
      if (! tmp___4) {
#line 839
        continue;
      }
    } else {
#line 839
      continue;
    }
#line 840
    if (Hflag) {
#line 840
      tmp___5 = strcmp((char const   *)(ent->d_name), (char const   *)"00Tree.html");
#line 840
      if (! tmp___5) {
#line 841
        continue;
      }
    }
#line 842
    if (! aflag) {
#line 842
      if ((int )ent->d_name[0] == 46) {
#line 843
        continue;
      }
    }
#line 845
    tmp___9 = strlen((char const   *)dir);
#line 845
    tmp___10 = strlen((char const   *)(ent->d_name));
#line 845
    if ((tmp___9 + tmp___10) + 2UL > (size_t___0 )pathsize) {
#line 846
      tmp___6 = strlen((char const   *)dir);
#line 846
      tmp___7 = strlen((char const   *)(ent->d_name));
#line 846
      pathsize = (long )((tmp___6 + tmp___7) + 4096UL);
#line 846
      tmp___8 = xrealloc((void *)path, (size_t___0 )pathsize);
#line 846
      path = (char *)tmp___8;
    }
#line 848
    if (es) {
#line 849
      sprintf((char * __restrict  )path, (char const   * __restrict  )"%s%s", dir,
              ent->d_name);
    } else {
#line 851
      sprintf((char * __restrict  )path, (char const   * __restrict  )"%s/%s", dir,
              ent->d_name);
    }
#line 853
    info___1 = getinfo(ent->d_name, path);
#line 854
    if (info___1) {
#line 855
      if (showinfo) {
#line 855
        com = infocheck(path, ent->d_name, infotop, (int )info___1->isdir);
#line 855
        if (com) {
#line 857
          i = 0;
#line 857
          while ((unsigned long )*(com->desc + i) != (unsigned long )((void *)0)) {
#line 857
            i ++;
          }
#line 859
          tmp___11 = xmalloc(sizeof(char *) * (unsigned long )(i + 1));
#line 859
          info___1->comment = (char **)tmp___11;
#line 860
          i = 0;
#line 860
          while ((unsigned long )*(com->desc + i) != (unsigned long )((void *)0)) {
#line 861
            tmp___12 = strlen((char const   *)*(com->desc + i));
#line 861
            tmp___13 = xmalloc(tmp___12 + 1UL);
#line 861
            *(info___1->comment + i) = strcpy((char * __restrict  )tmp___13, (char const   * __restrict  )*(com->desc + i));
#line 860
            i ++;
          }
#line 862
          *(info___1->comment + i) = (char *)((void *)0);
        }
      }
#line 864
      if (p == ne - 1) {
#line 865
        ne += 20;
#line 865
        tmp___14 = xrealloc((void *)dl, sizeof(struct _info *) * (unsigned long )ne);
#line 865
        dl = (struct _info **)tmp___14;
      }
#line 867
      tmp___15 = p;
#line 867
      p ++;
#line 867
      *(dl + tmp___15) = info___1;
    }
  }
#line 870
  closedir(d);
#line 872
  tmp___17 = p;
#line 872
  *n = tmp___17;
#line 872
  if (tmp___17 == 0) {
#line 873
    free((void *)dl);
#line 874
    return ((struct _info **)((void *)0));
  }
#line 877
  *(dl + p) = (struct _info *)((void *)0);
#line 878
  return (dl);
}
}
#line 881 "../tree.c"
void push_files(char *dir , struct ignorefile **ig , struct infofile **inf ) 
{ 


  {
#line 882
  if (gitignore) {
#line 883
    *ig = new_ignorefile(dir);
#line 884
    if ((unsigned long )*ig != (unsigned long )((void *)0)) {
#line 885
      push_filterstack(*ig);
    }
  }
#line 887
  if (showinfo) {
#line 888
    *inf = new_infofile(dir);
#line 889
    if ((unsigned long )*inf != (unsigned long )((void *)0)) {
#line 890
      push_infostack(*inf);
    }
  }
#line 892
  return;
}
}
#line 898 "../tree.c"
struct _info **unix_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) 
{ 
  char *path___0 ;
  long pathsize___0 ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **dir ;
  struct _info **sav ;
  struct _info **p ;
  struct _info *sp___0 ;
  struct stat sb ;
  int n ;
  u_long lev_tmp ;
  int tmp_pattern ;
  char *start_rel_path ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t___0 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  size_t___0 tmp___10 ;
  size_t___0 tmp___11 ;
  void *tmp___12 ;
  size_t___0 tmp___13 ;
  size_t___0 tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t___0 tmp___17 ;
  size_t___0 tmp___18 ;
  void *tmp___19 ;
  size_t___0 tmp___20 ;
  size_t___0 tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 901
  pathsize___0 = 0L;
#line 902
  ig = (struct ignorefile *)((void *)0);
#line 903
  inf = (struct infofile *)((void *)0);
#line 908
  tmp_pattern = 0;
#line 911
  *err = (char *)((void *)0);
#line 912
  if (Level >= 0) {
#line 912
    if (lev > (u_long )Level) {
#line 913
      return ((struct _info **)((void *)0));
    }
  }
#line 914
  if (xdev) {
#line 914
    if (lev == 0UL) {
#line 915
      stat((char const   * __restrict  )d, (struct stat * __restrict  )(& sb));
#line 916
      dev = sb.st_dev;
    }
  }
#line 919
  if (matchdirs) {
#line 919
    if (pattern) {
#line 920
      lev_tmp = lev;
#line 921
      tmp = strlen((char const   *)d);
#line 921
      start_rel_path = d + tmp;
#line 922
      tmp___0 = strlen((char const   *)d);
#line 922
      start_rel_path = d + tmp___0;
#line 922
      while ((unsigned long )start_rel_path != (unsigned long )d) {
#line 924
        if ((int )*start_rel_path == 47) {
#line 925
          lev_tmp --;
        }
#line 926
        if (lev_tmp <= 0UL) {
#line 927
          if (*start_rel_path) {
#line 928
            start_rel_path ++;
          }
#line 929
          break;
        }
#line 922
        start_rel_path --;
      }
#line 932
      if (*start_rel_path) {
#line 932
        tmp___1 = patinclude(start_rel_path, 1);
#line 932
        if (tmp___1) {
#line 933
          tmp_pattern = pattern;
#line 934
          pattern = 0;
        }
      }
    }
  }
#line 938
  push_files(d, & ig, & inf);
#line 940
  dir = read_dir(d, & n, (unsigned long )inf != (unsigned long )((void *)0));
#line 940
  sav = dir;
#line 941
  if (tmp_pattern) {
#line 942
    pattern = tmp_pattern;
#line 943
    tmp_pattern = 0;
  }
#line 945
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 945
    if (n) {
#line 946
      tmp___2 = strlen((char const   *)"error opening dir");
#line 946
      tmp___3 = xmalloc(tmp___2 + 1UL);
#line 946
      *err = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )"error opening dir");
#line 947
      errors ++;
#line 948
      return ((struct _info **)((void *)0));
    }
  }
#line 950
  if (n == 0) {
#line 951
    if ((unsigned long )sav != (unsigned long )((void *)0)) {
#line 952
      free_dir(sav);
    }
#line 953
    return ((struct _info **)((void *)0));
  }
#line 955
  pathsize___0 = 4096L;
#line 955
  tmp___4 = xmalloc((size_t___0 )pathsize___0);
#line 955
  path___0 = (char *)tmp___4;
#line 957
  if (flimit > 0) {
#line 957
    if (n > flimit) {
#line 958
      sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%d entries exceeds filelimit, not opening dir",
              n);
#line 959
      tmp___5 = strlen((char const   *)path___0);
#line 959
      tmp___6 = xmalloc(tmp___5 + 1UL);
#line 959
      *err = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )path___0);
#line 960
      free_dir(sav);
#line 961
      free((void *)path___0);
#line 962
      return ((struct _info **)((void *)0));
    }
  }
#line 965
  if (lev >= (u_long )(maxdirs - 1)) {
#line 966
    maxdirs += 1024;
#line 966
    tmp___7 = xrealloc((void *)dirs, sizeof(int ) * (unsigned long )maxdirs);
#line 966
    dirs = (int *)tmp___7;
  }
#line 969
  while (*dir) {
#line 970
    if ((*dir)->isdir) {
#line 970
      if (xdev) {
#line 970
        if (! (dev != (*dir)->dev)) {
#line 970
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 971
        if ((*dir)->lnk) {
#line 972
          if (lflag) {
#line 973
            tmp___16 = findino((*dir)->inode, (*dir)->dev);
#line 973
            if (tmp___16) {
#line 974
              tmp___8 = strlen((char const   *)"recursive, not followed");
#line 974
              tmp___9 = xmalloc(tmp___8 + 1UL);
#line 974
              (*dir)->err = strcpy((char * __restrict  )tmp___9, (char const   * __restrict  )"recursive, not followed");
            } else {
#line 976
              saveino((*dir)->inode, (*dir)->dev);
#line 977
              if ((int )*((*dir)->lnk) == 47) {
#line 978
                (*dir)->child = unix_getfulltree((*dir)->lnk, lev + 1UL, dev, & (*dir)->size,
                                                 & (*dir)->err);
              } else {
#line 981
                tmp___13 = strlen((char const   *)d);
#line 981
                tmp___14 = strlen((char const   *)(*dir)->lnk);
#line 981
                if ((tmp___13 + tmp___14) + 2UL > (size_t___0 )pathsize___0) {
#line 982
                  tmp___10 = strlen((char const   *)d);
#line 982
                  tmp___11 = strlen((char const   *)(*dir)->name);
#line 982
                  pathsize___0 = (long )((tmp___10 + tmp___11) + 1024UL);
#line 982
                  tmp___12 = xrealloc((void *)path___0, (size_t___0 )pathsize___0);
#line 982
                  path___0 = (char *)tmp___12;
                }
#line 984
                if (fflag) {
#line 984
                  tmp___15 = strcmp((char const   *)d, (char const   *)"/");
#line 984
                  if (tmp___15) {
#line 987
                    sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s",
                            d, (*dir)->lnk);
                  } else {
#line 985
                    sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s%s",
                            d, (*dir)->lnk);
                  }
                } else {
#line 987
                  sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s",
                          d, (*dir)->lnk);
                }
#line 988
                (*dir)->child = unix_getfulltree(path___0, lev + 1UL, dev, & (*dir)->size,
                                                 & (*dir)->err);
              }
            }
          }
        } else {
#line 994
          tmp___20 = strlen((char const   *)d);
#line 994
          tmp___21 = strlen((char const   *)(*dir)->name);
#line 994
          if ((tmp___20 + tmp___21) + 2UL > (size_t___0 )pathsize___0) {
#line 995
            tmp___17 = strlen((char const   *)d);
#line 995
            tmp___18 = strlen((char const   *)(*dir)->name);
#line 995
            pathsize___0 = (long )((tmp___17 + tmp___18) + 1024UL);
#line 995
            tmp___19 = xrealloc((void *)path___0, (size_t___0 )pathsize___0);
#line 995
            path___0 = (char *)tmp___19;
          }
#line 997
          if (fflag) {
#line 997
            tmp___22 = strcmp((char const   *)d, (char const   *)"/");
#line 997
            if (tmp___22) {
#line 1000
              sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s",
                      d, (*dir)->name);
            } else {
#line 998
              sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s%s",
                      d, (*dir)->name);
            }
          } else {
#line 1000
            sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s",
                    d, (*dir)->name);
          }
#line 1001
          saveino((*dir)->inode, (*dir)->dev);
#line 1002
          (*dir)->child = unix_getfulltree(path___0, lev + 1UL, dev, & (*dir)->size,
                                           & (*dir)->err);
        }
#line 1006
        if (pruneflag) {
#line 1006
          if ((unsigned long )(*dir)->child == (unsigned long )((void *)0)) {
#line 1006
            if (matchdirs) {
#line 1006
              if (pattern) {
#line 1006
                tmp___23 = patinclude((*dir)->name, (int )(*dir)->isdir);
#line 1006
                if (! tmp___23) {
#line 1006
                  goto _L___0;
                }
              } else {
#line 1006
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 1008
              sp___0 = *dir;
#line 1009
              p = dir;
#line 1009
              while (*p) {
#line 1010
                *p = *(p + 1);
#line 1009
                p ++;
              }
#line 1011
              n --;
#line 1012
              free((void *)sp___0->name);
#line 1013
              if (sp___0->lnk) {
#line 1014
                free((void *)sp___0->lnk);
              }
#line 1015
              free((void *)sp___0);
#line 1016
              continue;
            }
          }
        }
      }
    }
#line 1019
    if (duflag) {
#line 1020
      *size += (*dir)->size;
    }
#line 1021
    dir ++;
  }
#line 1025
  if (topsort) {
#line 1026
    qsort((void *)sav, (size_t )n, sizeof(struct _info *), (int (*)(void const   * ,
                                                                    void const   * ))topsort);
  }
#line 1028
  free((void *)path___0);
#line 1029
  if (n == 0) {
#line 1030
    free_dir(sav);
#line 1031
    return ((struct _info **)((void *)0));
  }
#line 1033
  if ((unsigned long )ig != (unsigned long )((void *)0)) {
#line 1034
    pop_filterstack();
  }
#line 1035
  if ((unsigned long )inf != (unsigned long )((void *)0)) {
#line 1036
    pop_infostack();
  }
#line 1037
  return (sav);
}
}
#line 1043 "../tree.c"
int filesfirst(struct _info **a , struct _info **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1044
  if ((unsigned int )(*a)->isdir != (unsigned int )(*b)->isdir) {
#line 1045
    if ((*a)->isdir) {
#line 1045
      tmp = 1;
    } else {
#line 1045
      tmp = -1;
    }
#line 1045
    return (tmp);
  }
#line 1047
  tmp___0 = (*basesort)(a, b);
#line 1047
  return (tmp___0);
}
}
#line 1050 "../tree.c"
int dirsfirst(struct _info **a , struct _info **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1051
  if ((unsigned int )(*a)->isdir != (unsigned int )(*b)->isdir) {
#line 1052
    if ((*a)->isdir) {
#line 1052
      tmp = -1;
    } else {
#line 1052
      tmp = 1;
    }
#line 1052
    return (tmp);
  }
#line 1054
  tmp___0 = (*basesort)(a, b);
#line 1054
  return (tmp___0);
}
}
#line 1058 "../tree.c"
int alnumsort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;

  {
#line 1059
  tmp = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
#line 1059
  v = tmp;
#line 1060
  if (reverse) {
#line 1060
    tmp___0 = - v;
  } else {
#line 1060
    tmp___0 = v;
  }
#line 1060
  return (tmp___0);
}
}
#line 1063 "../tree.c"
int versort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;

  {
#line 1064
  tmp = strverscmp((char const   *)(*a)->name, (char const   *)(*b)->name);
#line 1064
  v = tmp;
#line 1065
  if (reverse) {
#line 1065
    tmp___0 = - v;
  } else {
#line 1065
    tmp___0 = v;
  }
#line 1065
  return (tmp___0);
}
}
#line 1068 "../tree.c"
int mtimesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1071
  if ((*a)->mtime == (*b)->mtime) {
#line 1072
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
#line 1073
    if (reverse) {
#line 1073
      tmp = - v;
    } else {
#line 1073
      tmp = v;
    }
#line 1073
    return (tmp);
  }
#line 1075
  if ((*a)->mtime == (*b)->mtime) {
#line 1075
    v = 0;
  } else {
#line 1075
    if ((*a)->mtime < (*b)->mtime) {
#line 1075
      tmp___0 = -1;
    } else {
#line 1075
      tmp___0 = 1;
    }
#line 1075
    v = tmp___0;
  }
#line 1076
  if (reverse) {
#line 1076
    tmp___1 = - v;
  } else {
#line 1076
    tmp___1 = v;
  }
#line 1076
  return (tmp___1);
}
}
#line 1079 "../tree.c"
int ctimesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1082
  if ((*a)->ctime == (*b)->ctime) {
#line 1083
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
#line 1084
    if (reverse) {
#line 1084
      tmp = - v;
    } else {
#line 1084
      tmp = v;
    }
#line 1084
    return (tmp);
  }
#line 1086
  if ((*a)->ctime == (*b)->ctime) {
#line 1086
    v = 0;
  } else {
#line 1086
    if ((*a)->ctime < (*b)->ctime) {
#line 1086
      tmp___0 = -1;
    } else {
#line 1086
      tmp___0 = 1;
    }
#line 1086
    v = tmp___0;
  }
#line 1087
  if (reverse) {
#line 1087
    tmp___1 = - v;
  } else {
#line 1087
    tmp___1 = v;
  }
#line 1087
  return (tmp___1);
}
}
#line 1090 "../tree.c"
int sizecmp(off_t a , off_t b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1090
  if (a == b) {
#line 1090
    tmp___0 = 0;
  } else {
#line 1090
    if (a < b) {
#line 1090
      tmp = 1;
    } else {
#line 1090
      tmp = -1;
    }
#line 1090
    tmp___0 = tmp;
  }
#line 1090
  return (tmp___0);
}
}
#line 1092 "../tree.c"
int fsizesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;

  {
#line 1093
  tmp = sizecmp((*a)->size, (*b)->size);
#line 1093
  v = tmp;
#line 1094
  if (v == 0) {
#line 1095
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
  }
#line 1096
  if (reverse) {
#line 1096
    tmp___0 = - v;
  } else {
#line 1096
    tmp___0 = v;
  }
#line 1096
  return (tmp___0);
}
}
#line 1099 "../tree.c"
void *xmalloc(size_t___0 size ) 
{ 
  register void *value ;
  void *tmp ;

  {
#line 1100
  tmp = malloc(size);
#line 1100
  value = tmp;
#line 1101
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1102
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: virtual memory exhausted.\n");
#line 1103
    exit(1);
  }
#line 1105
  return (value);
}
}
#line 1108 "../tree.c"
void *xrealloc(void *ptr , size_t___0 size ) 
{ 
  register void *value ;
  void *tmp ;

  {
#line 1109
  tmp = realloc(ptr, size);
#line 1109
  value = tmp;
#line 1110
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1111
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"tree: virtual memory exhausted.\n");
#line 1112
    exit(1);
  }
#line 1114
  return (value);
}
}
#line 1117 "../tree.c"
void free_dir(struct _info **d ) 
{ 
  int i ;

  {
#line 1120
  i = 0;
#line 1120
  while (*(d + i)) {
#line 1121
    free((void *)(*(d + i))->name);
#line 1122
    if ((*(d + i))->lnk) {
#line 1123
      free((void *)(*(d + i))->lnk);
    }
#line 1124
    free((void *)*(d + i));
#line 1120
    i ++;
  }
#line 1126
  free((void *)d);
#line 1127
  return;
}
}
#line 1129 "../tree.c"
char *gnu_getcwd(void) 
{ 
  int size ;
  char *buffer ;
  void *tmp ;
  char *value ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 1130
  size = 100;
#line 1131
  tmp = xmalloc((size_t___0 )size);
#line 1131
  buffer = (char *)tmp;
#line 1133
  while (1) {
#line 1134
    tmp___0 = getcwd(buffer, (size_t___0 )size);
#line 1134
    value = tmp___0;
#line 1135
    if ((unsigned long )value != (unsigned long )((char *)0)) {
#line 1136
      return (buffer);
    }
#line 1137
    size *= 2;
#line 1138
    free((void *)buffer);
#line 1139
    tmp___1 = xmalloc((size_t___0 )size);
#line 1139
    buffer = (char *)tmp___1;
  }
}
}
#line 1143 "../tree.c"
__inline static char cond_lower(char c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1143
  if (ignorecase) {
#line 1143
    tmp = tolower((int )c);
#line 1143
    tmp___0 = tmp;
  } else {
#line 1143
    tmp___0 = (int )c;
  }
#line 1143
  return ((char )tmp___0);
}
}
#line 1154 "../tree.c"
int patmatch(char *buf___1 , char *pat , int isdir ) 
{ 
  int match ;
  int m ;
  int n ;
  char *bar ;
  char *tmp ;
  char pprev ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  int f ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char tmp___10 ;
  char tmp___11 ;
  char *tmp___12 ;

  {
#line 1155
  match = 1;
#line 1156
  tmp = strchr((char const   *)pat, '|');
#line 1156
  bar = tmp;
#line 1157
  pprev = (char)0;
#line 1160
  if (bar) {
#line 1162
    if ((unsigned long )bar == (unsigned long )pat) {
#line 1163
      return (-1);
    } else
#line 1162
    if (! *(bar + 1)) {
#line 1163
      return (-1);
    }
#line 1166
    *bar = (char )'\000';
#line 1167
    match = patmatch(buf___1, pat, isdir);
#line 1168
    if (! match) {
#line 1169
      match = patmatch(buf___1, bar + 1, isdir);
    }
#line 1172
    *bar = (char )'|';
#line 1173
    return (match);
  }
#line 1177
  while (1) {
#line 1177
    if (*pat) {
#line 1177
      if (! match) {
#line 1177
        break;
      }
    } else {
#line 1177
      break;
    }
#line 1178
    switch ((int )*pat) {
    case 91: 
#line 1180
    pat ++;
#line 1181
    if ((int )*pat != 94) {
#line 1182
      n = 1;
#line 1183
      match = 0;
    } else {
#line 1185
      pat ++;
#line 1186
      n = 0;
    }
#line 1188
    while ((int )*pat != 93) {
#line 1189
      if ((int )*pat == 92) {
#line 1190
        pat ++;
      }
#line 1191
      if (! *pat) {
#line 1192
        return (-1);
      }
#line 1193
      if ((int )*(pat + 1) == 45) {
#line 1194
        m = (int )*pat;
#line 1195
        pat += 2;
#line 1196
        if ((int )*pat == 92) {
#line 1196
          if (*pat) {
#line 1197
            pat ++;
          }
        }
#line 1198
        tmp___0 = cond_lower(*buf___1);
#line 1198
        tmp___1 = cond_lower((char )m);
#line 1198
        if ((int )tmp___0 >= (int )tmp___1) {
#line 1198
          tmp___2 = cond_lower(*buf___1);
#line 1198
          tmp___3 = cond_lower(*pat);
#line 1198
          if ((int )tmp___2 <= (int )tmp___3) {
#line 1200
            match = n;
          }
        }
#line 1201
        if (! *pat) {
#line 1202
          pat --;
        }
      } else {
#line 1203
        tmp___4 = cond_lower(*buf___1);
#line 1203
        tmp___5 = cond_lower(*pat);
#line 1203
        if ((int )tmp___4 == (int )tmp___5) {
#line 1204
          match = n;
        }
      }
#line 1205
      pat ++;
    }
#line 1207
    buf___1 ++;
#line 1208
    break;
    case 42: 
#line 1210
    pat ++;
#line 1211
    if (! *pat) {
#line 1212
      tmp___6 = strchr((char const   *)buf___1, '/');
#line 1212
      f = (unsigned long )tmp___6 == (unsigned long )((void *)0);
#line 1214
      return (f);
    }
#line 1216
    match = 0;
#line 1218
    if ((int )*pat == 42) {
#line 1219
      pat ++;
#line 1220
      if (! *pat) {
#line 1221
        return (1);
      }
#line 1223
      while (1) {
#line 1223
        if (*buf___1) {
#line 1223
          match = patmatch(buf___1, pat, isdir);
#line 1223
          if (match) {
#line 1223
            break;
          }
        } else {
#line 1223
          break;
        }
#line 1225
        if ((int )pprev == 47) {
#line 1225
          if ((int )*pat == 47) {
#line 1225
            if (*(pat + 1)) {
#line 1225
              match = patmatch(buf___1, pat + 1, isdir);
#line 1225
              if (match) {
#line 1227
                return (match);
              }
            }
          }
        }
#line 1228
        buf___1 ++;
#line 1229
        while (1) {
#line 1229
          if (*buf___1) {
#line 1229
            if (! ((int )*buf___1 != 47)) {
#line 1229
              break;
            }
          } else {
#line 1229
            break;
          }
#line 1230
          buf___1 ++;
        }
      }
    } else {
#line 1234
      while (1) {
#line 1234
        if (*buf___1) {
#line 1234
          tmp___7 = buf___1;
#line 1234
          buf___1 ++;
#line 1234
          match = patmatch(tmp___7, pat, isdir);
#line 1234
          if (match) {
#line 1234
            break;
          }
        } else {
#line 1234
          break;
        }
#line 1235
        if ((int )*buf___1 == 47) {
#line 1236
          break;
        }
      }
    }
#line 1240
    if (! match) {
#line 1240
      if (! *buf___1) {
#line 1241
        match = patmatch(buf___1, pat, isdir);
      } else
#line 1240
      if ((int )*buf___1 == 47) {
#line 1241
        match = patmatch(buf___1, pat, isdir);
      }
    }
#line 1242
    return (match);
    case 63: 
#line 1244
    if (! *buf___1) {
#line 1245
      return (0);
    }
#line 1246
    buf___1 ++;
#line 1247
    break;
    case 47: 
#line 1249
    if (! *(pat + 1)) {
#line 1249
      if (! *buf___1) {
#line 1250
        return (isdir);
      }
    }
#line 1251
    tmp___8 = buf___1;
#line 1251
    buf___1 ++;
#line 1251
    match = (int )*tmp___8 == (int )*pat;
#line 1252
    break;
    case 92: 
#line 1254
    if (*pat) {
#line 1255
      pat ++;
    }
    default: 
#line 1257
    tmp___9 = buf___1;
#line 1257
    buf___1 ++;
#line 1257
    tmp___10 = cond_lower(*tmp___9);
#line 1257
    tmp___11 = cond_lower(*pat);
#line 1257
    match = (int )tmp___10 == (int )tmp___11;
#line 1258
    break;
    }
#line 1260
    tmp___12 = pat;
#line 1260
    pat ++;
#line 1260
    pprev = *tmp___12;
#line 1261
    if (match < 1) {
#line 1262
      return (match);
    }
  }
#line 1264
  if (! *buf___1) {
#line 1265
    return (match);
  }
#line 1266
  return (0);
}
}
#line 1273 "../tree.c"
void indent(int maxlevel ) 
{ 
  int i ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1276
  if (ansilines) {
#line 1277
    if (*(dirs + 1)) {
#line 1278
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\033(0");
    }
#line 1279
    i = 1;
#line 1279
    while (1) {
#line 1279
      if (i <= maxlevel) {
#line 1279
        if (! *(dirs + i)) {
#line 1279
          break;
        }
      } else {
#line 1279
        break;
      }
#line 1280
      if (*(dirs + (i + 1))) {
#line 1281
        if (*(dirs + i) == 1) {
#line 1282
          fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"x   ");
        } else {
#line 1284
          printf((char const   * __restrict  )"    ");
        }
      } else
#line 1286
      if (*(dirs + i) == 1) {
#line 1287
        fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"tqq ");
      } else {
#line 1289
        fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"mqq ");
      }
#line 1279
      i ++;
    }
#line 1292
    if (*(dirs + 1)) {
#line 1293
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\033(B");
    }
  } else {
#line 1295
    if (Hflag) {
#line 1296
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\t");
    }
#line 1297
    i = 1;
#line 1297
    while (1) {
#line 1297
      if (i <= maxlevel) {
#line 1297
        if (! *(dirs + i)) {
#line 1297
          break;
        }
      } else {
#line 1297
        break;
      }
#line 1298
      if (*(dirs + (i + 1))) {
#line 1298
        if (*(dirs + i) == 1) {
#line 1298
          tmp___0 = (char const   *)linedraw->vert;
        } else {
#line 1298
          if (Hflag) {
#line 1298
            tmp = "&nbsp;&nbsp;&nbsp;";
          } else {
#line 1298
            tmp = "   ";
          }
#line 1298
          tmp___0 = (char const   *)tmp;
        }
#line 1298
        tmp___2 = tmp___0;
      } else {
#line 1298
        if (*(dirs + i) == 1) {
#line 1298
          tmp___1 = linedraw->vert_left;
        } else {
#line 1298
          tmp___1 = linedraw->corner;
        }
#line 1298
        tmp___2 = (char const   *)tmp___1;
      }
#line 1298
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s ", tmp___2);
#line 1297
      i ++;
    }
  }
#line 1305
  return;
}
}
#line 1322 "../tree.c"
static char buf[11]  ;
#line 1322 "../tree.c"
static char perms[10]  = 
#line 1322
  {      (char )'r',      (char )'w',      (char )'x',      (char )'r', 
        (char )'w',      (char )'x',      (char )'r',      (char )'w', 
        (char )'x',      (char )'\000'};
#line 1310 "../tree.c"
char *prot(mode_t m ) 
{ 
  int i ;
  int b ;

  {
#line 1325
  i = 0;
#line 1325
  while (1) {
#line 1325
    if (ifmt[i]) {
#line 1325
      if (! ((m & 61440U) != (unsigned int )ifmt[i])) {
#line 1325
        break;
      }
    } else {
#line 1325
      break;
    }
#line 1325
    i ++;
  }
#line 1327
  buf[0] = (char )fmt[i];
#line 1333
  b = 0400;
#line 1333
  i = 0;
#line 1333
  while (i < 9) {
#line 1334
    if (m & (unsigned int )b) {
#line 1334
      buf[i + 1] = perms[i];
    } else {
#line 1334
      buf[i + 1] = (char )'-';
    }
#line 1333
    b >>= 1;
#line 1333
    i ++;
  }
#line 1335
  if (m & 2048U) {
#line 1336
    if ((int )buf[3] == 45) {
#line 1336
      buf[3] = (char )'S';
    } else {
#line 1336
      buf[3] = (char )'s';
    }
  }
#line 1337
  if (m & 1024U) {
#line 1338
    if ((int )buf[6] == 45) {
#line 1338
      buf[6] = (char )'S';
    } else {
#line 1338
      buf[6] = (char )'s';
    }
  }
#line 1339
  if (m & 512U) {
#line 1340
    if ((int )buf[9] == 45) {
#line 1340
      buf[9] = (char )'T';
    } else {
#line 1340
      buf[9] = (char )'t';
    }
  }
#line 1342
  buf[10] = (char)0;
#line 1344
  return (buf);
}
}
#line 1350 "../tree.c"
static char buf___0[256]  ;
#line 1349 "../tree.c"
char *do_date(time_t t ) 
{ 
  struct tm *tm ;
  time_t c ;
  time_t tmp ;

  {
#line 1353
  tm = localtime((time_t const   *)(& t));
#line 1355
  if (timefmt) {
#line 1356
    strftime((char * __restrict  )(buf___0), (size_t___0 )255, (char const   * __restrict  )timefmt,
             (struct tm  const  * __restrict  )tm);
#line 1357
    buf___0[255] = (char)0;
  } else {
#line 1359
    tmp = time((time_t *)0);
#line 1359
    c = tmp;
#line 1361
    if (t > c) {
#line 1362
      strftime((char * __restrict  )(buf___0), (size_t___0 )255, (char const   * __restrict  )"%b %e  %Y",
               (struct tm  const  * __restrict  )tm);
    } else
#line 1361
    if (t + 16070400LL < c) {
#line 1362
      strftime((char * __restrict  )(buf___0), (size_t___0 )255, (char const   * __restrict  )"%b %e  %Y",
               (struct tm  const  * __restrict  )tm);
    } else {
#line 1364
      strftime((char * __restrict  )(buf___0), (size_t___0 )255, (char const   * __restrict  )"%b %e %R",
               (struct tm  const  * __restrict  )tm);
    }
  }
#line 1366
  return (buf___0);
}
}
#line 1372 "../tree.c"
void printit(char *s ) 
{ 
  int c ;
  wchar_t___0 *ws ;
  wchar_t___0 *tp ;
  size_t___0 tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 1375
  if (Nflag) {
#line 1376
    if (Qflag) {
#line 1377
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\"%s\"",
              s);
    } else {
#line 1379
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s", s);
    }
#line 1380
    return;
  }
#line 1382
  if (mb_cur_max > 1) {
#line 1384
    tmp = strlen((char const   *)s);
#line 1384
    c = (int )(tmp + 1UL);
#line 1384
    tmp___0 = xmalloc(sizeof(wchar_t___0 ) * (unsigned long )c);
#line 1384
    ws = (wchar_t___0 *)tmp___0;
#line 1385
    tmp___2 = mbstowcs((wchar_t * __restrict  )ws, (char const   * __restrict  )s,
                       (size_t )c);
#line 1385
    if (tmp___2 != 18446744073709551615UL) {
#line 1386
      if (Qflag) {
#line 1387
        putc('\"', outfile);
      }
#line 1388
      tp = ws;
#line 1388
      while (1) {
#line 1388
        if (*tp) {
#line 1388
          if (! (c > 1)) {
#line 1388
            break;
          }
        } else {
#line 1388
          break;
        }
#line 1389
        tmp___1 = iswprint((wint_t )*tp);
#line 1389
        if (tmp___1) {
#line 1390
          fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%lc",
                  (wint_t )*tp);
        } else
#line 1392
        if (qflag) {
#line 1393
          putc('?', outfile);
        } else {
#line 1395
          fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\\%03o",
                  (unsigned int )*tp);
        }
#line 1388
        tp ++;
#line 1388
        c --;
      }
#line 1398
      if (Qflag) {
#line 1399
        putc('\"', outfile);
      }
#line 1400
      free((void *)ws);
#line 1401
      return;
    }
#line 1403
    free((void *)ws);
  }
#line 1405
  if (Qflag) {
#line 1406
    putc('\"', outfile);
  }
#line 1407
  while (*s) {
#line 1408
    c = (int )((unsigned char )*s);
#line 1416
    if (c >= 7) {
#line 1416
      if (c <= 13) {
#line 1416
        goto _L;
      } else {
#line 1416
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1416
    if (c == 92) {
#line 1416
      goto _L;
    } else
#line 1416
    if (c == 34) {
#line 1416
      if (Qflag) {
#line 1416
        goto _L;
      } else {
#line 1416
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1416
    if (c == 32) {
#line 1416
      if (! Qflag) {
        _L: /* CIL Label */ 
#line 1418
        putc('\\', outfile);
#line 1419
        if (c > 13) {
#line 1420
          putc(c, outfile);
        } else {
#line 1422
          putc((int )*("abtnvfr" + (c - 7)), outfile);
        }
      } else {
#line 1416
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1423
      tmp___3 = isprint(c);
#line 1423
      if (tmp___3) {
#line 1424
        putc(c, outfile);
      } else
#line 1426
      if (qflag) {
#line 1427
        if (mb_cur_max > 1) {
#line 1427
          if (c > 127) {
#line 1428
            putc(c, outfile);
          } else {
#line 1430
            putc('?', outfile);
          }
        } else {
#line 1430
          putc('?', outfile);
        }
      } else {
#line 1432
        fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\\%03o",
                c);
      }
    }
#line 1407
    s ++;
  }
#line 1435
  if (Qflag) {
#line 1436
    putc('\"', outfile);
  }
#line 1437
  return;
}
}
#line 1440 "../tree.c"
static char *iec_unit  =    "BKMGTPEZY";
#line 1440 "../tree.c"
static char *si_unit  =    "dkMGTPEZY";
#line 1439 "../tree.c"
int psize(char *buf___1 , off_t size ) 
{ 
  char *unit ;
  char *tmp ;
  int idx ;
  int usize ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1441
  if (siflag) {
#line 1441
    tmp = si_unit;
  } else {
#line 1441
    tmp = iec_unit;
  }
#line 1441
  unit = tmp;
#line 1442
  if (siflag) {
#line 1442
    tmp___0 = 1000;
  } else {
#line 1442
    tmp___0 = 1024;
  }
#line 1442
  usize = tmp___0;
#line 1444
  if (hflag) {
#line 1444
    goto _L;
  } else
#line 1444
  if (siflag) {
    _L: /* CIL Label */ 
#line 1445
    if (size < (off_t )usize) {
#line 1445
      idx = 0;
    } else {
#line 1445
      idx = 1;
    }
#line 1445
    while (size >= (off_t )(usize * usize)) {
#line 1445
      idx ++;
#line 1445
      size /= (off_t )usize;
    }
#line 1448
    if (! idx) {
#line 1449
      tmp___1 = sprintf((char * __restrict  )buf___1, (char const   * __restrict  )" %4d",
                        (int )size);
#line 1449
      return (tmp___1);
    } else {
#line 1451
      if (size / (off_t )usize >= 10LL) {
#line 1451
        tmp___2 = " %3.0f%c";
      } else {
#line 1451
        tmp___2 = " %3.1f%c";
      }
#line 1451
      tmp___3 = sprintf((char * __restrict  )buf___1, (char const   * __restrict  )tmp___2,
                        (double )((float )size / (float )usize), (int )*(unit + idx));
#line 1451
      return (tmp___3);
    }
  } else {
#line 1454
    if (sizeof(off_t ) == sizeof(long long )) {
#line 1454
      tmp___4 = " %11lld";
    } else {
#line 1454
      tmp___4 = " %9lld";
    }
#line 1454
    tmp___5 = sprintf((char * __restrict  )buf___1, (char const   * __restrict  )tmp___4,
                      size);
#line 1454
    return (tmp___5);
  }
}
}
#line 1459 "../tree.c"
char Ftype(mode_t mode ) 
{ 
  int m ;

  {
#line 1460
  m = (int )(mode & 61440U);
#line 1461
  if (! dflag) {
#line 1461
    if (m == 0040000) {
#line 1462
      return ((char )'/');
    } else {
#line 1461
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1463
  if (m == 0140000) {
#line 1464
    return ((char )'=');
  } else
#line 1465
  if (m == 0010000) {
#line 1466
    return ((char )'|');
  } else
#line 1467
  if (m == 0120000) {
#line 1468
    return ((char )'@');
  } else
#line 1473
  if (m == 0100000) {
#line 1473
    if (mode & 73U) {
#line 1474
      return ((char )'*');
    }
  }
#line 1475
  return ((char)0);
}
}
#line 1479 "../tree.c"
static struct _info info  ;
#line 1478 "../tree.c"
struct _info *stat2info(struct stat *st ) 
{ 


  {
#line 1481
  info.linode = st->st_ino;
#line 1482
  info.ldev = st->st_dev;
#line 1486
  info.mode = st->st_mode;
#line 1487
  info.uid = st->st_uid;
#line 1488
  info.gid = st->st_gid;
#line 1489
  info.size = st->st_size;
#line 1490
  info.atime = st->st_atim.tv_sec;
#line 1491
  info.ctime = st->st_ctim.tv_sec;
#line 1492
  info.mtime = st->st_mtim.tv_sec;
#line 1494
  info.isdir = (bool )((st->st_mode & 61440U) == 16384U);
#line 1495
  info.issok = (bool )((st->st_mode & 61440U) == 49152U);
#line 1496
  info.isfifo = (bool )((st->st_mode & 61440U) == 4096U);
#line 1497
  if (st->st_mode & 73U) {
#line 1497
    info.isexe = (bool )1;
  } else {
#line 1497
    info.isexe = (bool )0;
  }
#line 1499
  return (& info);
}
}
#line 1502 "../tree.c"
char *fillinfo(char *buf___1 , struct _info *ent ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 1504
  n = 0;
#line 1504
  *(buf___1 + n) = (char)0;
#line 1509
  if (inodeflag) {
#line 1510
    tmp = sprintf((char * __restrict  )buf___1, (char const   * __restrict  )" %7ld",
                  (long )ent->linode);
#line 1510
    n += tmp;
  }
#line 1512
  if (devflag) {
#line 1513
    tmp___0 = sprintf((char * __restrict  )(buf___1 + n), (char const   * __restrict  )" %3d",
                      (int )ent->ldev);
#line 1513
    n += tmp___0;
  }
#line 1518
  if (pflag) {
#line 1519
    tmp___1 = prot(ent->mode);
#line 1519
    tmp___2 = sprintf((char * __restrict  )(buf___1 + n), (char const   * __restrict  )" %s",
                      tmp___1);
#line 1519
    n += tmp___2;
  }
#line 1521
  if (uflag) {
#line 1522
    tmp___3 = uidtoname(ent->uid);
#line 1522
    tmp___4 = sprintf((char * __restrict  )(buf___1 + n), (char const   * __restrict  )" %-8.32s",
                      tmp___3);
#line 1522
    n += tmp___4;
  }
#line 1523
  if (gflag) {
#line 1524
    tmp___5 = gidtoname(ent->gid);
#line 1524
    tmp___6 = sprintf((char * __restrict  )(buf___1 + n), (char const   * __restrict  )" %-8.32s",
                      tmp___5);
#line 1524
    n += tmp___6;
  }
#line 1525
  if (sflag) {
#line 1526
    tmp___7 = psize(buf___1 + n, ent->size);
#line 1526
    n += tmp___7;
  }
#line 1527
  if (Dflag) {
#line 1528
    if (cflag) {
#line 1528
      tmp___8 = ent->ctime;
    } else {
#line 1528
      tmp___8 = ent->mtime;
    }
#line 1528
    tmp___9 = do_date(tmp___8);
#line 1528
    tmp___10 = sprintf((char * __restrict  )(buf___1 + n), (char const   * __restrict  )" %s",
                       tmp___9);
#line 1528
    n += tmp___10;
  }
#line 1530
  if ((int )*(buf___1 + 0) == 32) {
#line 1531
    *(buf___1 + 0) = (char )'[';
#line 1532
    sprintf((char * __restrict  )(buf___1 + n), (char const   * __restrict  )"]");
  }
#line 1535
  return (buf___1);
}
}
#line 1 "cil-1mxVkRBy.o"
#pragma merger("0","/tmp/cil-w3mnZ5pV.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 27 "../unix.c"
static char info___0[512]  = {      (char)0};
#line 29 "../unix.c"
int unix_printinfo(char *dirname , struct _info *file , int level ) 
{ 


  {
#line 31
  fillinfo(info___0, file);
#line 32
  if (metafirst) {
#line 33
    if ((int )info___0[0] == 91) {
#line 33
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s  ", info___0);
    }
#line 34
    if (! noindent) {
#line 34
      indent(level);
    }
  } else {
#line 36
    if (! noindent) {
#line 36
      indent(level);
    }
#line 37
    if ((int )info___0[0] == 91) {
#line 37
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s  ", info___0);
    }
  }
#line 39
  return (0);
}
}
#line 42 "../unix.c"
int unix_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int colored ;
  int c ;
  char tmp ;
  char tmp___0 ;

  {
#line 44
  colored = 0;
#line 46
  if (file) {
#line 46
    if (colorize) {
#line 47
      if (file->lnk) {
#line 47
        if (linktargetcolor) {
#line 47
          colored = color((u_short )file->lnkmode, file->name, file->orphan, (bool )0);
        } else {
#line 48
          colored = color((u_short )file->mode, file->name, file->orphan, (bool )0);
        }
      } else {
#line 48
        colored = color((u_short )file->mode, file->name, file->orphan, (bool )0);
      }
    }
  }
#line 51
  printit(filename);
#line 53
  if (colored) {
#line 53
    endcolor();
  }
#line 55
  if (file) {
#line 56
    if (Fflag) {
#line 56
      if (! file->lnk) {
#line 57
        tmp = Ftype(file->mode);
#line 57
        c = (int )tmp;
#line 57
        if (c) {
#line 57
          fputc(c, outfile);
        }
      }
    }
#line 60
    if (file->lnk) {
#line 61
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" -> ");
#line 62
      if (colorize) {
#line 62
        colored = color((u_short )file->lnkmode, file->lnk, file->orphan, (bool )1);
      }
#line 63
      printit(file->lnk);
#line 64
      if (colored) {
#line 64
        endcolor();
      }
#line 65
      if (Fflag) {
#line 66
        tmp___0 = Ftype(file->lnkmode);
#line 66
        c = (int )tmp___0;
#line 66
        if (c) {
#line 66
          fputc(c, outfile);
        }
      }
    }
  }
#line 70
  return (0);
}
}
#line 73 "../unix.c"
int unix_error(char *error ) 
{ 


  {
#line 75
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"  [%s]", error);
#line 76
  return (0);
}
}
#line 79 "../unix.c"
void unix_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  int infosize ;
  int line ;
  int lines ;
  size_t___0 tmp ;

  {
#line 81
  if (postdir <= 0) {
#line 81
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\n");
  }
#line 82
  if (file) {
#line 82
    if (file->comment) {
#line 83
      infosize = 0;
#line 84
      if (metafirst) {
#line 84
        if ((int )info___0[0] == 91) {
#line 84
          tmp = strlen((char const   *)(info___0));
#line 84
          infosize = (int )(tmp + 2UL);
        } else {
#line 84
          infosize = 0;
        }
      }
#line 86
      lines = 0;
#line 86
      while (*(file->comment + lines)) {
#line 86
        lines ++;
      }
#line 87
      *(dirs + (level + 1)) = 1;
#line 88
      line = 0;
#line 88
      while (line < lines) {
#line 89
        if (metafirst) {
#line 90
          printf((char const   * __restrict  )"%*s", infosize, "");
        }
#line 92
        indent(level);
#line 93
        printcomment(line, lines, *(file->comment + line));
#line 88
        line ++;
      }
#line 95
      *(dirs + (level + 1)) = 0;
    }
  }
#line 97
  return;
}
}
#line 99 "../unix.c"
void unix_report(struct totals tot ) 
{ 
  char buf___1[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 103
  fputc('\n', outfile);
#line 104
  if (duflag) {
#line 105
    psize(buf___1, tot.size);
#line 106
    if (hflag) {
#line 106
      tmp = "";
    } else
#line 106
    if (siflag) {
#line 106
      tmp = "";
    } else {
#line 106
      tmp = " bytes";
    }
#line 106
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s%s used in ",
            buf___1, tmp);
  }
#line 108
  if (dflag) {
#line 109
    if (tot.dirs == 1UL) {
#line 109
      tmp___0 = "y";
    } else {
#line 109
      tmp___0 = "ies";
    }
#line 109
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%ld director%s\n",
            tot.dirs, tmp___0);
  } else {
#line 111
    if (tot.files == 1UL) {
#line 111
      tmp___1 = "";
    } else {
#line 111
      tmp___1 = "s";
    }
#line 111
    if (tot.dirs == 1UL) {
#line 111
      tmp___2 = "y";
    } else {
#line 111
      tmp___2 = "ies";
    }
#line 111
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%ld director%s, %ld file%s\n",
            tot.dirs, tmp___2, tot.files, tmp___1);
  }
#line 112
  return;
}
}
#line 1 "cil-7FjmPpWm.o"
#pragma merger("0","/tmp/cil-XGpO47Sf.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1")
#line 59 "../xml.c"
void xml_indent(int maxlevel ) 
{ 
  int i ;

  {
#line 63
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"  ");
#line 64
  i = 0;
#line 64
  while (i < maxlevel) {
#line 65
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"  ");
#line 64
    i ++;
  }
#line 66
  return;
}
}
#line 68 "../xml.c"
void xml_fillinfo(struct _info *ent ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  time_t tmp___2 ;
  char *tmp___3 ;

  {
#line 73
  if (inodeflag) {
#line 73
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" inode=\"%ld\"",
            (long )ent->inode);
  }
#line 75
  if (devflag) {
#line 75
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" dev=\"%d\"",
            (int )ent->dev);
  }
#line 79
  if (pflag) {
#line 79
    tmp = prot(ent->mode);
#line 79
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" mode=\"%04o\" prot=\"%s\"",
            ent->mode & 4095U, tmp);
  }
#line 81
  if (uflag) {
#line 81
    tmp___0 = uidtoname(ent->uid);
#line 81
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" user=\"%s\"",
            tmp___0);
  }
#line 82
  if (gflag) {
#line 82
    tmp___1 = gidtoname(ent->gid);
#line 82
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" group=\"%s\"",
            tmp___1);
  }
#line 83
  if (sflag) {
#line 83
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" size=\"%lld\"",
            ent->size);
  }
#line 84
  if (Dflag) {
#line 84
    if (cflag) {
#line 84
      tmp___2 = ent->ctime;
    } else {
#line 84
      tmp___2 = ent->mtime;
    }
#line 84
    tmp___3 = do_date(tmp___2);
#line 84
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" time=\"%s\"",
            tmp___3);
  }
#line 85
  return;
}
}
#line 87 "../xml.c"
void xml_intro(void) 
{ 


  {
#line 91
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<?xml version=\"1.0\"");
#line 92
  if (charset) {
#line 92
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" encoding=\"%s\"",
            charset);
  }
#line 93
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"?>%s<tree>%s",
          _nl, _nl);
#line 94
  return;
}
}
#line 96 "../xml.c"
void xml_outtro(void) 
{ 


  {
#line 98
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"</tree>\n");
#line 99
  return;
}
}
#line 101 "../xml.c"
int xml_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  mode_t mt ;
  int t ;
  char const   *tmp ;

  {
#line 106
  if (! noindent) {
#line 106
    xml_indent(level);
  }
#line 108
  if (file->lnk) {
#line 108
    mt = file->mode & 61440U;
  } else {
#line 109
    mt = file->mode & 61440U;
  }
#line 111
  t = 0;
#line 111
  while (ifmt[t]) {
#line 112
    if ((mode_t )ifmt[t] == mt) {
#line 112
      break;
    }
#line 111
    t ++;
  }
#line 113
  tmp = ftype[t];
#line 113
  file->tag = tmp;
#line 113
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<%s", tmp);
#line 115
  return (0);
}
}
#line 118 "../xml.c"
int xml_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int t ;
  int mt ;
  int i ;

  {
#line 122
  if (file) {
#line 123
    if (file->lnk) {
#line 123
      mt = (int )(file->mode & 61440U);
    } else {
#line 124
      mt = (int )(file->mode & 61440U);
    }
  } else {
#line 125
    mt = 0;
  }
#line 126
  t = 0;
#line 126
  while (ifmt[t]) {
#line 127
    if (ifmt[t] == (int const   )mt) {
#line 127
      break;
    }
#line 126
    t ++;
  }
#line 128
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<%s", ftype[t]);
#line 130
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" name=\"");
#line 131
  html_encode(outfile, filename);
#line 132
  fputc('\"', outfile);
#line 134
  if (file) {
#line 134
    if (file->comment) {
#line 135
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" info=\"");
#line 136
      i = 0;
#line 136
      while (*(file->comment + i)) {
#line 137
        html_encode(outfile, *(file->comment + i));
#line 138
        if (*(file->comment + (i + 1))) {
#line 138
          fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\n");
        }
#line 136
        i ++;
      }
#line 140
      fputc('\"', outfile);
    }
  }
#line 143
  if (file) {
#line 143
    if (file->lnk) {
#line 144
      fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )" target=\"");
#line 145
      html_encode(outfile, file->lnk);
#line 146
      fputc('\"', outfile);
    }
  }
#line 148
  if (file) {
#line 148
    xml_fillinfo(file);
  }
#line 149
  fputc('>', outfile);
#line 151
  return (1);
}
}
#line 154 "../xml.c"
int xml_error(char *error ) 
{ 


  {
#line 156
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"<error>%s</error>",
          error);
#line 158
  return (0);
}
}
#line 161 "../xml.c"
void xml_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 


  {
#line 163
  if (postdir >= 0) {
#line 163
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"\n");
  }
#line 164
  return;
}
}
#line 166 "../xml.c"
void xml_close(struct _info *file , int level , int needcomma ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 168
  if (! noindent) {
#line 168
    if (level >= 0) {
#line 168
      xml_indent(level - 1);
    }
  }
#line 169
  if (noindent) {
#line 169
    tmp = "";
  } else {
#line 169
    tmp = "\n";
  }
#line 169
  if (file) {
#line 169
    tmp___0 = file->tag;
  } else {
#line 169
    tmp___0 = (char const   *)"unknown";
  }
#line 169
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"</%s>%s", tmp___0,
          tmp);
#line 170
  return;
}
}
#line 173 "../xml.c"
void xml_report(struct totals tot ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 177
  if (noindent) {
#line 177
    tmp = "";
  } else {
#line 177
    tmp = "  ";
  }
#line 177
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s<report>%s",
          tmp, _nl);
#line 178
  if (duflag) {
#line 178
    if (noindent) {
#line 178
      tmp___0 = "";
    } else {
#line 178
      tmp___0 = "    ";
    }
#line 178
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s<size>%lld</size>%s",
            tmp___0, tot.size, _nl);
  }
#line 179
  if (noindent) {
#line 179
    tmp___1 = "";
  } else {
#line 179
    tmp___1 = "    ";
  }
#line 179
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s<directories>%ld</directories>%s",
          tmp___1, tot.dirs, _nl);
#line 180
  if (! dflag) {
#line 180
    if (noindent) {
#line 180
      tmp___2 = "";
    } else {
#line 180
      tmp___2 = "    ";
    }
#line 180
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s<files>%ld</files>%s",
            tmp___2, tot.files, _nl);
  }
#line 181
  if (noindent) {
#line 181
    tmp___3 = "";
  } else {
#line 181
    tmp___3 = "  ";
  }
#line 181
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%s</report>%s",
          tmp___3, _nl);
#line 182
  return;
}
}
