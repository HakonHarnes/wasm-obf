
/* Generated by Tigress v3.2 (https://tigress.wtf), 08:48:32-2023/04/23 */


/*
BEGIN-UNIVERSE
{
  "Not added to universe": [
    "__sync_and_and_fetch", "__sync_fetch_and_or", "__atomic_or_fetch",
    "__atomic_nand_fetch_8", "__atomic_fetch_and", "__atomic_xor_fetch_16",
    "__atomic_fetch_nand_16", "__atomic_sub_fetch_1", "__atomic_fetch_or",
    "__sync_synchronize", "__sync_or_and_fetch", "__atomic_nand_fetch_4",
    "__atomic_sub_fetch_4", "__atomic_compare_exchange_n",
    "__sync_add_and_fetch", "__atomic_signal_fence", "__atomic_fetch_nand_1",
    "__atomic_and_fetch_16", "__sync_fetch_and_nand", "__atomic_xor_fetch_8",
    "__atomic_xor_fetch_2", "__atomic_thread_fence", "__atomic_store_16",
    "__atomic_fetch_and_8", "__atomic_and_fetch_2", "__atomic_test_and_set",
    "__atomic_fetch_add_8", "__atomic_fetch_nand", "__atomic_exchange_16",
    "__atomic_clear", "__atomic_store", "__atomic_add_fetch_2",
    "__atomic_fetch_xor_1", "__atomic_and_fetch",
    "__atomic_compare_exchange_4", "__sync_sub_and_fetch",
    "__sync_nand_and_fetch", "__atomic_load_16", "__atomic_always_lock_free",
    "__atomic_nand_fetch_16", "__sync_xor_and_fetch", "__atomic_fetch_xor_8",
    "__atomic_exchange_8", "__atomic_exchange_1", "__sync_fetch_and_and",
    "__atomic_feraiseexcept", "__atomic_and_fetch_4", "__atomic_or_fetch_8",
    "__atomic_or_fetch_4", "__atomic_or_fetch_1", "__atomic_fetch_and_2",
    "__sync_lock_release", "__atomic_fetch_nand_8", "__atomic_fetch_add",
    "__atomic_nand_fetch_1", "__atomic_fetch_nand_2", "__atomic_load_n",
    "__atomic_compare_exchange_16", "__atomic_exchange_n",
    "__atomic_fetch_or_1", "__atomic_fetch_or_8", "__atomic_fetch_add_1",
    "__atomic_fetch_sub_1", "__atomic_fetch_or_4", "__atomic_load_2",
    "__atomic_store_2", "__atomic_exchange_4", "__sync_fetch_and_xor",
    "__atomic_fetch_sub_4", "__atomic_fetch_and_4",
    "__atomic_compare_exchange", "__atomic_load_1",
    "__atomic_compare_exchange_1", "__atomic_fetch_xor_2", "__atomic_load",
    "__atomic_or_fetch_16", "__atomic_add_fetch_16",
    "__sync_val_compare_and_swap", "__atomic_store_4",
    "__atomic_fetch_and_1", "__atomic_fetch_nand_4", "__atomic_fetch_add_16",
    "__atomic_compare_exchange_2", "__atomic_exchange",
    "__atomic_sub_fetch_8", "__atomic_fetch_sub_16", "__atomic_exchange_2",
    "__atomic_sub_fetch_2", "__atomic_fetch_xor_16", "__atomic_fetch_or_16",
    "__atomic_load_4", "__atomic_store_n", "__atomic_fetch_add_4",
    "__atomic_nand_fetch_2", "__sync_lock_test_and_set",
    "__atomic_sub_fetch", "__atomic_fetch_and_16",
    "__atomic_compare_exchange_8", "__atomic_nand_fetch", "__atomic_load_8",
    "__atomic_xor_fetch_4", "__atomic_fetch_sub_2", "__atomic_add_fetch",
    "__atomic_store_8", "__atomic_xor_fetch", "__sync_fetch_and_add",
    "__atomic_or_fetch_2", "__atomic_add_fetch_1", "__atomic_fetch_xor",
    "__atomic_add_fetch_8", "__atomic_fetch_xor_4", "__atomic_fetch_sub_8",
    "__sync_bool_compare_and_swap", "__atomic_and_fetch_1",
    "__atomic_store_1", "__atomic_xor_fetch_1", "__atomic_fetch_or_2",
    "__atomic_sub_fetch_16", "__sync_fetch_and_sub", "__atomic_fetch_add_2",
    "__atomic_is_lock_free", "__atomic_and_fetch_8", "__atomic_fetch_sub",
    "__atomic_add_fetch_4", "xmalloc", "xrealloc", "parse_dir_colors",
    "color", "endcolor", "getcharset", "initlinedraw", "split", "cmd",
    "outfile", "charset", "patignore", "patinclude", "file_getfulltree",
    "pattern", "ipattern", "topsort", "file_comment", "file_pathsep",
    "nextpc", "patmatch", "gittrim", "new_pattern", "filtercheck",
    "new_ignorefile", "push_filterstack", "pop_filterstack", "uidtoname",
    "gidtoname", "findino", "saveino", "indent", "psize", "fillinfo",
    "html_intro", "html_outtro", "html_printinfo", "html_printfile",
    "html_error", "html_newline", "html_close", "html_report", "html_encode",
    "version", "hversion", "host", "sp", "title", "new_infofile",
    "push_infostack", "pop_infostack", "infocheck", "printcomment", "prot",
    "do_date", "json_indent", "json_fillinfo", "json_intro", "json_outtro",
    "json_printinfo", "json_printfile", "json_error", "json_newline",
    "json_close", "json_report", "ifmt", "ftype", "_nl", "setoutput",
    "push_files", "read_dir", "free_dir", "stat2info", "null_intro",
    "null_outtro", "null_close", "emit_tree", "listdir", "getfulltree",
    "strverscmp", "usage", "unix_getfulltree", "filesfirst", "dirsfirst",
    "alnumsort", "versort", "mtimesort", "ctimesort", "sizecmp", "fsizesort",
    "gnu_getcwd", "printit", "Ftype", "unix_printinfo", "unix_printfile",
    "unix_error", "unix_newline", "unix_report", "xml_intro", "xml_outtro",
    "xml_printinfo", "xml_printfile", "xml_error", "xml_newline",
    "xml_close", "xml_report", "getinfo"
  ],
  "Transformations": [
    { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xrealloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_report" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_printinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_printfile" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_outtro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_newline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_intro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_indent" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_fillinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_error" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xml_close" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "xmalloc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "versort" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "usage" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "url_encode" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "unix_report" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "unix_printinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "unix_printfile" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "unix_newline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "unix_getfulltree" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "unix_error" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "uidtoname" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "strverscmp" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "stat2info" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "split" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "sizecmp" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "setoutput" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "search" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "saveino" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "read_dir" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "push_infostack" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "push_filterstack" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "push_files" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "psize" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "prot" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "printit" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "printcomment" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "print_color" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "pop_infostack" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "pop_filterstack" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "patmatch" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "patinclude" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "patignore" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "parse_dir_colors" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "null_outtro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "null_intro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "null_close" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "nextpc" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "newent" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "new_pattern" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "new_infofile" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "new_ignorefile" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "new_comment" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "mtimesort" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "listdir" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_report" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_printinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_printfile" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_outtro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_newline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_intro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_indent" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_fillinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_error" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_encode" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "json_close" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "initlinedraw" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "infocheck" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "indent" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_report" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_printinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_printfile" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_print" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_outtro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_newline" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_intro" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_error" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_encode" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "html_close" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gnu_getcwd" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gittrim" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "gidtoname" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "getinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "getcharset" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "fsizesort" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "freefiletree" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "free_dir" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "fprune" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "findino" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "filtercheck" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "fillinfo" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "filesfirst" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "file_getfulltree" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "endcolor" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "emit_tree" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "do_date" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "dirsfirst" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "ctimesort" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cond_lower" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "color" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "cmd" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "class" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "alnumsort" ]
    } }, { "TransformationNumber": 1, "TransformationKind": "Flatten",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "Ftype" ]
    } }, { "TransformationNumber": 0, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ],
      "New Global Variables": {
        "_global_envp": "FUN: '_global_envp_i$nit'",
        "_global_argv": "FUN: '_global_argv_i$nit'",
        "_global_argc": "FUN: '_global_argc_i$nit'"
      }
    } }, { "TransformationNumber": -1, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "New Functions": [
        "xml_report", "xml_close", "xml_newline", "xml_error",
        "xml_printfile", "xml_printinfo", "xml_outtro", "xml_intro",
        "xml_fillinfo", "xml_indent", "unix_report", "unix_newline",
        "unix_error", "unix_printfile", "unix_printinfo", "fillinfo",
        "stat2info", "Ftype", "psize", "printit", "do_date", "prot",
        "indent", "patmatch", "cond_lower", "gnu_getcwd", "free_dir",
        "xrealloc", "xmalloc", "fsizesort", "sizecmp", "ctimesort",
        "mtimesort", "versort", "alnumsort", "dirsfirst", "filesfirst",
        "unix_getfulltree", "push_files", "read_dir", "getinfo",
        "patinclude", "patignore", "usage", "setoutput", "main",
        "strverscmp", "listdir", "emit_tree", "null_close", "null_outtro",
        "null_intro", "json_report", "json_close", "json_newline",
        "json_error", "json_printfile", "json_printinfo", "json_outtro",
        "json_intro", "json_fillinfo", "json_indent", "json_encode",
        "printcomment", "infocheck", "pop_infostack", "push_infostack",
        "new_infofile", "new_comment", "html_report", "html_close",
        "html_newline", "html_error", "html_printfile", "html_printinfo",
        "html_print", "html_outtro", "html_intro", "url_encode",
        "html_encode", "class", "findino", "saveino", "gidtoname",
        "uidtoname", "filtercheck", "pop_filterstack", "push_filterstack",
        "new_ignorefile", "new_pattern", "gittrim", "file_getfulltree",
        "fprune", "freefiletree", "search", "newent", "nextpc",
        "initlinedraw", "getcharset", "color", "endcolor", "print_color",
        "cmd", "split", "parse_dir_colors"
      ],
      "New Global Variables": {
        "info___0": "FUN: 'info___0_i$nit'",
        "info": "None",
        "si_unit": "FUN: 'si_unit_i$nit'",
        "iec_unit": "FUN: 'iec_unit_i$nit'",
        "buf___0": "None",
        "perms": "FUN: 'perms_i$nit'",
        "buf": "None",
        "pathsize": "None",
        "path": "FUN: 'path_i$nit'",
        "lbufsize": "FUN: 'lbufsize_i$nit'",
        "lbuf": "FUN: 'lbuf_i$nit'",
        "sorts": "FUN: 'sorts_i$nit'",
        "ftype": "FUN: 'ftype_i$nit'",
        "fmt": "FUN: 'fmt_i$nit'",
        "ifmt": "FUN: 'ifmt_i$nit'",
        "mb_cur_max": "None",
        "maxdirs": "None",
        "outfile": "FUN: 'outfile_i$nit'",
        "curdir": "None",
        "sLevel": "None",
        "topsort": "FUN: 'topsort_i$nit'",
        "basesort": "FUN: 'basesort_i$nit'",
        "getfulltree": "FUN: 'getfulltree_i$nit'",
        "charset": "FUN: 'charset_i$nit'",
        "timefmt": "FUN: 'timefmt_i$nit'",
        "file_pathsep": "FUN: 'file_pathsep_i$nit'",
        "file_comment": "FUN: 'file_comment_i$nit'",
        "_nl": "FUN: '_nl_i$nit'",
        "sp": "FUN: 'sp_i$nit'",
        "title": "FUN: 'title_i$nit'",
        "host": "FUN: 'host_i$nit'",
        "ipatterns": "FUN: 'ipatterns_i$nit'",
        "patterns": "FUN: 'patterns_i$nit'",
        "maxipattern": "FUN: 'maxipattern_i$nit'",
        "ipattern": "FUN: 'ipattern_i$nit'",
        "maxpattern": "FUN: 'maxpattern_i$nit'",
        "pattern": "FUN: 'pattern_i$nit'",
        "reverse": "None",
        "showinfo": "None",
        "gitignore": "None",
        "fromfile": "None",
        "ignorecase": "None",
        "Xflag": "None",
        "Qflag": "None",
        "Nflag": "None",
        "qflag": "None",
        "Fflag": "None",
        "hversion": "FUN: 'hversion_i$nit'",
        "version": "FUN: 'version_i$nit'",
        "result_type": "FUN: 'result_type_i$nit'",
        "next_state": "FUN: 'next_state_i$nit'",
        "lc": "None",
        "errbuf": "None",
        "errors": "None",
        "dirs": "None",
        "Level": "None",
        "flimit": "None",
        "xdev": "None",
        "noreport": "None",
        "Jflag": "None",
        "Rflag": "None",
        "fflag": "None",
        "lflag": "None",
        "cflag": "None",
        "devflag": "None",
        "inodeflag": "None",
        "Dflag": "None",
        "gflag": "None",
        "uflag": "None",
        "sflag": "None",
        "pflag": "None",
        "infostack": "FUN: 'infostack_i$nit'",
        "htmldirlen": "FUN: 'htmldirlen_i$nit'",
        "metafirst": "None",
        "nolinks": "None",
        "noindent": "None",
        "siflag": "None",
        "hflag": "None",
        "duflag": "None",
        "itable": "None",
        "utable": "None",
        "gtable": "None",
        "fpattern": "None",
        "filterstack": "FUN: 'filterstack_i$nit'",
        "prev": "FUN: 'prev_i$nit'",
        "matchdirs": "None",
        "pruneflag": "None",
        "aflag": "None",
        "dflag": "None",
        "cstable": "FUN: 'cstable_i$nit'",
        "windows": "FUN: 'windows_i$nit'",
        "koi8ru": "FUN: 'koi8ru_i$nit'",
        "viscii": "FUN: 'viscii_i$nit'",
        "big5": "FUN: 'big5_i$nit'",
        "utf8": "FUN: 'utf8_i$nit'",
        "gb": "FUN: 'gb_i$nit'",
        "ibm_gr": "FUN: 'ibm_gr_i$nit'",
        "ibm_ps2": "FUN: 'ibm_ps2_i$nit'",
        "ibm_pc": "FUN: 'ibm_pc_i$nit'",
        "iso2022jp": "FUN: 'iso2022jp_i$nit'",
        "euc_kr": "FUN: 'euc_kr_i$nit'",
        "euc_jp": "FUN: 'euc_jp_i$nit'",
        "shift_jis": "FUN: 'shift_jis_i$nit'",
        "iso8859_789": "FUN: 'iso8859_789_i$nit'",
        "latin1_3": "FUN: 'latin1_3_i$nit'",
        "cmds": "FUN: 'cmds_i$nit'",
        "nocolor": "None",
        "force_color": "None",
        "Hflag": "None",
        "linedraw": "None",
        "ext": "FUN: 'ext_i$nit'",
        "colortable": "None",
        "vgacolor": "FUN: 'vgacolor_i$nit'",
        "color_code": "FUN: 'color_code_i$nit'",
        "istty": "None",
        "termmatch": "FUN: 'termmatch_i$nit'",
        "term": "None",
        "linktargetcolor": "FUN: 'linktargetcolor_i$nit'",
        "ansilines": "FUN: 'ansilines_i$nit'",
        "colorize": "FUN: 'colorize_i$nit'"
      },
      "New Externs": [
        "__builtin_va_copy", "__builtin_frob_return_address",
        "__builtin_popcountll", "__builtin_atanf", "__builtin_ia32_addps",
        "__builtin_strcspn", "__builtin_asinf", "__builtin_ia32_maxps",
        "__builtin_ia32_unpckhps", "__builtin_acos",
        "__builtin___sprintf_chk", "__builtin_cosh", "__builtin_tanhf",
        "__builtin_mempcpy", "__builtin_sqrtl", "__builtin_parity",
        "__builtin_coshl", "__builtin_cosl", "__builtin_cosf",
        "__builtin_acosl", "__builtin___mempcpy_chk", "__builtin_clz",
        "__builtin_log10", "__builtin___strcat_chk", "__builtin_modff",
        "__builtin_sin", "__builtin_frexp", "__builtin_acosf",
        "__builtin_sinhl", "__builtin___stpcpy_chk", "__builtin_fabs",
        "__builtin_va_start", "__builtin_bswap16", "__builtin_ctz",
        "__builtin_strpbrk", "__builtin_strcpy", "__builtin_sqrt",
        "__builtin_next_arg", "__builtin_log10f", "__builtin_fabsl",
        "__builtin_floorl", "__builtin_floorf", "__builtin_memcpy",
        "__builtin_ia32_subps", "__builtin_parityll", "__builtin_va_end",
        "__builtin_bzero", "__builtin_strncmp", "__builtin___vsprintf_chk",
        "__builtin_sqrtf", "__builtin_nans", "__builtin_exp",
        "__builtin_strcmp", "__builtin_ldexpf", "__builtin_powif",
        "__builtin_log10l", "__builtin___memmove_chk",
        "__builtin_return_address", "__builtin_fabsf",
        "__builtin_object_size", "__builtin_alloca",
        "__builtin_va_arg_pack_len", "__builtin_tanl", "__builtin_modfl",
        "__builtin_stpcpy", "__builtin_sinl", "__builtin_asin",
        "__builtin_sinhf", "__builtin_ctzl", "__builtin_tanhl",
        "__builtin_bswap64", "__builtin_ia32_mulps", "__builtin_tan",
        "__builtin_strncpy", "__builtin_inff", "__builtin___memset_chk",
        "__builtin_huge_val", "__builtin_clzl", "__builtin_frexpf",
        "__builtin_fmodl", "__builtin_atan", "__builtin___fprintf_chk",
        "__builtin_ceilf", "__builtin_return", "__builtin_asinl",
        "__builtin_ffsll", "__builtin_va_arg_pack",
        "__builtin___strncpy_chk", "__builtin_powi", "__builtin_strchr",
        "__builtin___strncat_chk", "__builtin_huge_vall", "__builtin_ffsl",
        "__builtin___vprintf_chk", "__builtin_ia32_unpcklps",
        "__builtin_strncat", "__builtin_ctzll", "__builtin_stdarg_start",
        "__builtin_frexpl", "__builtin_tanf", "__builtin_logl",
        "__builtin_va_arg", "__builtin_expect", "__builtin___printf_chk",
        "__builtin___vfprintf_chk", "__builtin_prefetch", "__builtin_nansl",
        "__builtin_fmod", "__builtin_tanh", "__builtin_unreachable",
        "__builtin_ldexpl", "__builtin_apply", "__builtin_sinf",
        "__builtin_ceil", "__builtin_powil", "__builtin_expl",
        "__builtin_constant_p", "__builtin_log", "__builtin_expf",
        "__builtin_types_compatible_p", "__builtin_atan2l",
        "__builtin_apply_args", "__builtin_logf", "__builtin_strlen",
        "__builtin_ffs", "__builtin_inf", "__builtin___memcpy_chk",
        "__builtin_trap", "__builtin_parityl", "__builtin_strspn",
        "__builtin_varargs_start", "__builtin_nan",
        "__builtin___snprintf_chk", "__builtin_atanl", "__builtin_clzll",
        "__builtin_huge_valf", "__builtin_coshf", "__builtin_nansf",
        "__builtin___vsnprintf_chk", "__builtin_nanf", "__builtin_atan2",
        "__builtin_popcountl", "__builtin_ceill", "__builtin___strcpy_chk",
        "__builtin_floor", "__builtin_cos", "__builtin_memset",
        "__builtin_nanl", "__builtin_atan2f", "__builtin_popcount",
        "__builtin_sinh", "__builtin_bcopy", "__builtin_extract_return_addr",
        "__builtin_bswap32", "__builtin_ldexp", "__builtin_infl",
        "__builtin_fmodf", "__builtin_frame_address", "getloadavg", "atoi",
        "atol", "atoll", "atof", "strtof", "strtod", "strtold", "strtol",
        "strtoul", "strtoll", "strtoull", "rand", "srand", "malloc",
        "calloc", "realloc", "free", "aligned_alloc", "abort", "atexit",
        "exit", "_Exit", "at_quick_exit", "quick_exit", "getenv", "system",
        "bsearch", "qsort", "abs", "labs", "llabs", "div", "ldiv", "lldiv",
        "mblen", "mbtowc", "wctomb", "mbstowcs", "wcstombs",
        "__ctype_get_mb_cur_max", "posix_memalign", "setenv", "unsetenv",
        "mkstemp", "mkostemp", "mkdtemp", "getsubopt", "rand_r", "realpath",
        "random", "srandom", "initstate", "setstate", "putenv",
        "posix_openpt", "grantpt", "unlockpt", "ptsname", "l64a", "a64l",
        "setkey", "drand48", "erand48", "lrand48", "nrand48", "mrand48",
        "jrand48", "srand48", "seed48", "lcong48", "alloca", "mktemp",
        "mkstemps", "mkostemps", "valloc", "memalign", "clearenv",
        "reallocarray", "qsort_r", "stderr", "fputs", "fprintf", "sprintf",
        "strcpy", "strcmp", "strtok", "strlen", "strcasecmp", "isatty",
        "stdin", "fopen", "fclose", "fgets", "memset", "strchr", "isspace",
        "snprintf", "getpwuid", "getgrgid", "fputc", "putc", "isprint",
        "memcpy", "lstat", "isdigit", "stdout", "printf", "time", "strftime",
        "localtime", "strncmp", "strcoll", "stat", "closedir", "opendir",
        "readdir", "tolower", "readlink", "getcwd", "setlocale",
        "nl_langinfo", "iswprint"
      ],
      "New Types": [
        "sorts", "wint_t", "nl_item", "DIR", "__dirstream", "dirent", "tm",
        "ssize_t", "wchar_t___1", "wchar_t___0", "listingcalls", "stat",
        "blkcnt_t", "blksize_t", "nlink_t", "timespec", "infofile",
        "comment", "totals", "u_int", "u_char", "inotable", "xtable",
        "group", "passwd", "ignorefile", "pattern", "_info", "u_long",
        "gid_t", "uid_t", "dev_t", "ino_t", "mode_t", "time_t", "off_t",
        "size_t___1", "__anonstruct_cmds_476363767", "linedraw",
        "extensions", "colortable", "bool", "__anonenum_bool_753424039",
        "u_short", "FILE", "_IO_FILE", "size_t___0", "lldiv_t",
        "__anonstruct_lldiv_t_989260392", "ldiv_t",
        "__anonstruct_ldiv_t_721778306", "div_t",
        "__anonstruct_div_t_109580352", "size_t", "wchar_t"
      ],
      "New Texts/Asms/Pragmas": [
        "Pragma", "Pragma", "Pragma", "Pragma", "Pragma", "Pragma", "Pragma",
        "Pragma", "Pragma", "Pragma", "Pragma", "Pragma"
      ]
    } }
  ]
}
END-UNIVERSE
*/

/* #pragma merger("0","/tmp/cil-w3mnZ5pV.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-P_5uu9MH.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-XGpO47Sf.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-mQfoqFRQ.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-0dBnSK4d.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Hu4juU2I.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-BMi3HdqY.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-0A5qHwSS.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-P_2dvFnt.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Voeg1cNE.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Rb_dOvMG.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Z0JqcW8b.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */

/* BEGIN STRUCT-DECL __dirstream LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */
struct __dirstream ;
/* END STRUCT-DECL __dirstream LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */

/* BEGIN STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
struct _IO_FILE ;
/* END STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN STRUCT-DECL timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */
struct timespec ;
/* END STRUCT-DECL timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */

/* BEGIN STRUCT-DECL dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */
struct dirent ;
/* END STRUCT-DECL dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */

/* BEGIN STRUCT-DECL pattern LOC=../tree.h:164 */
struct pattern ;
/* END STRUCT-DECL pattern LOC=../tree.h:164 */

/* BEGIN STRUCT-DECL group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */
struct group ;
/* END STRUCT-DECL group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */

/* BEGIN STRUCT-DECL __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
struct __anonstruct_lldiv_t_989260392 ;
/* END STRUCT-DECL __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN STRUCT-DECL passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */
struct passwd ;
/* END STRUCT-DECL passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */

/* BEGIN STRUCT-DECL inotable LOC=../tree.h:139 */
struct inotable ;
/* END STRUCT-DECL inotable LOC=../tree.h:139 */

/* BEGIN STRUCT-DECL _info LOC=../tree.h:91 */
struct _info ;
/* END STRUCT-DECL _info LOC=../tree.h:91 */

/* BEGIN STRUCT-DECL tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */
struct tm ;
/* END STRUCT-DECL tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */

/* BEGIN STRUCT-DECL infofile LOC=../tree.h:183 */
struct infofile ;
/* END STRUCT-DECL infofile LOC=../tree.h:183 */

/* BEGIN STRUCT-DECL listingcalls LOC=../tree.h:121 */
struct listingcalls ;
/* END STRUCT-DECL listingcalls LOC=../tree.h:121 */

/* BEGIN STRUCT-DECL __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
struct __anonstruct_ldiv_t_721778306 ;
/* END STRUCT-DECL __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN STRUCT-DECL colortable LOC=../tree.h:146 */
struct colortable ;
/* END STRUCT-DECL colortable LOC=../tree.h:146 */

/* BEGIN STRUCT-DECL __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
struct __anonstruct_div_t_109580352 ;
/* END STRUCT-DECL __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN STRUCT-DECL xtable LOC=../tree.h:134 */
struct xtable ;
/* END STRUCT-DECL xtable LOC=../tree.h:134 */

/* BEGIN STRUCT-DECL ignorefile LOC=../tree.h:170 */
struct ignorefile ;
/* END STRUCT-DECL ignorefile LOC=../tree.h:170 */

/* BEGIN STRUCT-DECL __anonstruct_cmds_476363767 LOC=../color.c:176 */
struct __anonstruct_cmds_476363767 ;
/* END STRUCT-DECL __anonstruct_cmds_476363767 LOC=../color.c:176 */

/* BEGIN ENUM-DECL __anonenum_bool_753424039 LOC=../tree.h:86 */
enum __anonenum_bool_753424039 ;
/* END ENUM-DECL __anonenum_bool_753424039 LOC=../tree.h:86 */

/* BEGIN STRUCT-DECL linedraw LOC=../tree.h:154 */
struct linedraw ;
/* END STRUCT-DECL linedraw LOC=../tree.h:154 */

/* BEGIN STRUCT-DECL extensions LOC=../tree.h:149 */
struct extensions ;
/* END STRUCT-DECL extensions LOC=../tree.h:149 */

/* BEGIN STRUCT-DECL comment LOC=../tree.h:177 */
struct comment ;
/* END STRUCT-DECL comment LOC=../tree.h:177 */

/* BEGIN STRUCT-DECL stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */
struct stat ;
/* END STRUCT-DECL stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */

/* BEGIN STRUCT-DECL totals LOC=../tree.h:116 */
struct totals ;
/* END STRUCT-DECL totals LOC=../tree.h:116 */

/* BEGIN STRUCT-DECL sorts LOC=../tree.c:83 */
struct sorts ;
/* END STRUCT-DECL sorts LOC=../tree.c:83 */

/* BEGIN FUNCTION-DECL __builtin_strchr LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* END FUNCTION-DECL __builtin_strchr LOC=BUILTIN */

/* BEGIN TYPEDEF u_int LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:66 */
typedef unsigned int u_int;
/* END TYPEDEF u_int LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:66 */

/* BEGIN FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */
extern int isdigit(int  ) ;
/* END FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */

/* BEGIN FUNCTION-DECL __builtin_ctz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ctz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:132 */
extern long mrand48(void) ;
/* END FUNCTION-DECL-EXTERN mrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:132 */

/* BEGIN TYPEDEF ino_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:246 */
typedef unsigned long long ino_t;
/* END TYPEDEF ino_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:246 */

/* BEGIN FUNCTION-DECL __builtin_acosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_acosf LOC=BUILTIN */

/* BEGIN TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
typedef struct _IO_FILE FILE;
/* END TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN FUNCTION-DECL-EXTERN putc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:108 */
extern int putc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN putc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:108 */

/* BEGIN TYPEDEF gid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:333 */
typedef unsigned int gid_t;
/* END TYPEDEF gid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:333 */

/* BEGIN FUNCTION-DECL gidtoname LOC=UNKNOWN */
char *gidtoname(gid_t gid ) ;
/* END FUNCTION-DECL gidtoname LOC=UNKNOWN */

/* BEGIN TYPEDEF blksize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:256 */
typedef int blksize_t;
/* END TYPEDEF blksize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:256 */

/* BEGIN FUNCTION-DECL __builtin_sinh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* END FUNCTION-DECL __builtin_sinh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_newline LOC=UNKNOWN */
void html_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL html_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL mtimesort LOC=UNKNOWN */
int mtimesort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL mtimesort LOC=UNKNOWN */

/* BEGIN TYPEDEF DIR LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */
typedef struct __dirstream DIR;
/* END TYPEDEF DIR LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */

/* BEGIN STRUCT linedraw LOC=../tree.h:154 */
struct linedraw {
   char **name ;
   char *vert ;
   char *vert_left ;
   char *corner ;
   char *copy ;
   char *ctop ;
   char *cbot ;
   char *cmid ;
   char *cext ;
   char *csingle ;
};
/* END STRUCT linedraw LOC=../tree.h:154 */

/* BEGIN FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* END FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */
extern int fputs(char const   * , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */

/* BEGIN TYPEDEF nlink_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:236 */
typedef unsigned long nlink_t;
/* END TYPEDEF nlink_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:236 */

/* BEGIN FUNCTION-DECL-EXTERN __ctype_get_mb_cur_max LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:81 */
extern unsigned long __ctype_get_mb_cur_max(void) ;
/* END FUNCTION-DECL-EXTERN __ctype_get_mb_cur_max LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:81 */

/* BEGIN FUNCTION-DECL versort LOC=UNKNOWN */
int versort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL versort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_acos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* END FUNCTION-DECL __builtin_acos LOC=BUILTIN */

/* BEGIN ENUM __anonenum_bool_753424039 LOC=../tree.h:86 */
enum __anonenum_bool_753424039 {
    FALSE = 0,
    TRUE = 1
} ;
/* END ENUM __anonenum_bool_753424039 LOC=../tree.h:86 */

/* BEGIN TYPEDEF bool LOC=../tree.h:86 */
typedef enum __anonenum_bool_753424039 bool;
/* END TYPEDEF bool LOC=../tree.h:86 */

/* BEGIN VARIABLE-DEF matchdirs LOC=UNKNOWN */
bool matchdirs  ;
/* END VARIABLE-DEF matchdirs LOC=UNKNOWN */

/* BEGIN TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */
typedef long long off_t;
/* END TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */

/* BEGIN TYPEDEF u_long LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:67 */
typedef unsigned long u_long;
/* END TYPEDEF u_long LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:67 */

/* BEGIN STRUCT totals LOC=../tree.h:116 */
struct totals {
   u_long files ;
   u_long dirs ;
   off_t size ;
};
/* END STRUCT totals LOC=../tree.h:116 */

/* BEGIN VARIABLE-DEF vgacolor LOC=UNKNOWN */
char *vgacolor[18]  ;
/* END VARIABLE-DEF vgacolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN abort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:46 */
extern void abort(void) ;
/* END FUNCTION-DECL-EXTERN abort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:46 */

/* BEGIN FUNCTION-DECL-EXTERN getloadavg LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h:8 */
extern int getloadavg(double *loadavg , int nelem ) ;
/* END FUNCTION-DECL-EXTERN getloadavg LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h:8 */

/* BEGIN VARIABLE-DEF pathsize LOC=UNKNOWN */
static long pathsize  ;
/* END VARIABLE-DEF pathsize LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL pop_filterstack LOC=UNKNOWN */
struct ignorefile *pop_filterstack(void) ;
/* END FUNCTION-DECL pop_filterstack LOC=UNKNOWN */

/* BEGIN STRUCT sorts LOC=../tree.c:83 */
struct sorts {
   char *name ;
   int (*cmpfunc)() ;
};
/* END STRUCT sorts LOC=../tree.c:83 */

/* BEGIN VARIABLE-DEF result_type LOC=UNKNOWN */
static int result_type[60]  ;
/* END VARIABLE-DEF result_type LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN at_quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:50 */
extern int at_quick_exit(void (*)(void) ) ;
/* END FUNCTION-DECL-EXTERN at_quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:50 */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */

/* BEGIN VARIABLE-DEF term LOC=UNKNOWN */
char *term  ;
/* END VARIABLE-DEF term LOC=UNKNOWN */

/* BEGIN STRUCT tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
/* END STRUCT tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */

/* BEGIN FUNCTION-DECL xml_outtro LOC=UNKNOWN */
void xml_outtro(void) ;
/* END FUNCTION-DECL xml_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */

/* BEGIN STRUCT group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */
struct group {
   char *gr_name ;
   char *gr_passwd ;
   gid_t gr_gid ;
   char **gr_mem ;
};
/* END STRUCT group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */

/* BEGIN FUNCTION-DECL newent LOC=UNKNOWN */
struct _info *newent(char *name ) ;
/* END FUNCTION-DECL newent LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF fromfile LOC=UNKNOWN */
bool fromfile  ;
/* END VARIABLE-DEF fromfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strcasecmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h:29 */
extern int strcasecmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcasecmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h:29 */

/* BEGIN FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF patterns LOC=UNKNOWN */
char **patterns  ;
/* END VARIABLE-DEF patterns LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN closedir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:24 */
extern int closedir(DIR * ) ;
/* END FUNCTION-DECL-EXTERN closedir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:24 */

/* BEGIN VARIABLE-DEF charset LOC=UNKNOWN */
char *charset  ;
/* END VARIABLE-DEF charset LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN ptsname LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:124 */
extern char *ptsname(int  ) ;
/* END FUNCTION-DECL-EXTERN ptsname LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:124 */

/* BEGIN FUNCTION-DECL __builtin_asin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* END FUNCTION-DECL __builtin_asin LOC=BUILTIN */

/* BEGIN TYPEDEF dev_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:251 */
typedef unsigned int dev_t;
/* END TYPEDEF dev_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:251 */

/* BEGIN FUNCTION-DECL listdir LOC=UNKNOWN */
struct totals listdir(char *dirname , struct _info **dir , int lev , dev_t dev , bool hasfulltree ) ;
/* END FUNCTION-DECL listdir LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_object_size LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* END FUNCTION-DECL __builtin_object_size LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN rand_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:108 */
extern int rand_r(unsigned int * ) ;
/* END FUNCTION-DECL-EXTERN rand_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:108 */

/* BEGIN TYPEDEF time_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:81 */
typedef long long time_t;
/* END TYPEDEF time_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:81 */

/* BEGIN FUNCTION-DECL-EXTERN time LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:55 */
extern time_t time(time_t * ) ;
/* END FUNCTION-DECL-EXTERN time LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:55 */

/* BEGIN FUNCTION-DECL __builtin_asinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_asinf LOC=BUILTIN */

/* BEGIN STRUCT pattern LOC=../tree.h:164 */
struct pattern {
   char *pattern ;
   int relative ;
   struct pattern *next ;
};
/* END STRUCT pattern LOC=../tree.h:164 */

/* BEGIN FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */
extern int tolower(int  ) ;
/* END FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */

/* BEGIN FUNCTION-DECL __builtin_coshl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_coshl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN malloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:40 */
extern void *malloc(unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN malloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:40 */

/* BEGIN FUNCTION-DECL __builtin_tan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* END FUNCTION-DECL __builtin_tan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN atoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:25 */
extern long long atoll(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:25 */

/* BEGIN FUNCTION-DECL fprune LOC=UNKNOWN */
struct _info **fprune(struct _info *head , bool matched , bool root ) ;
/* END FUNCTION-DECL fprune LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF viscii LOC=UNKNOWN */
static char *viscii[3]  ;
/* END VARIABLE-DEF viscii LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL filtercheck LOC=UNKNOWN */
int filtercheck(char *path___0 , char *name , int isdir ) ;
/* END FUNCTION-DECL filtercheck LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN realpath LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:115 */
extern char *realpath(char const   * __restrict   , char * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN realpath LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:115 */

/* BEGIN TYPEDEF ldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
typedef struct __anonstruct_ldiv_t_721778306 ldiv_t;
/* END TYPEDEF ldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN FUNCTION-DECL printcomment LOC=UNKNOWN */
void printcomment(int line , int lines , char *s ) ;
/* END FUNCTION-DECL printcomment LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL new_pattern LOC=UNKNOWN */
struct pattern *new_pattern(char *pattern___0 ) ;
/* END FUNCTION-DECL new_pattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* END FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */

/* BEGIN TYPEDEF lldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
typedef struct __anonstruct_lldiv_t_989260392 lldiv_t;
/* END TYPEDEF lldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* END FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */

/* BEGIN VARIABLE-DEF host LOC=UNKNOWN */
char *host  ;
/* END VARIABLE-DEF host LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */

/* BEGIN VARIABLE-DEF lbuf LOC=UNKNOWN */
static char *lbuf  ;
/* END VARIABLE-DEF lbuf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:53 */
extern char *getenv(char const   * ) ;
/* END FUNCTION-DECL-EXTERN getenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:53 */

/* BEGIN FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* END FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */

/* BEGIN VARIABLE-DEF iec_unit LOC=UNKNOWN */
static char *iec_unit  ;
/* END VARIABLE-DEF iec_unit LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */
extern int isspace(int  ) ;
/* END FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */

/* BEGIN TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:46 */
typedef unsigned long size_t___0;
/* END TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:46 */

/* BEGIN FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */
extern size_t___0 strlen(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */

/* BEGIN FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF iso8859_789 LOC=UNKNOWN */
static char *iso8859_789[22]  ;
/* END VARIABLE-DEF iso8859_789 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF utable LOC=UNKNOWN */
struct xtable *utable[256]  ;
/* END VARIABLE-DEF utable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_coshf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* END FUNCTION-DECL __builtin_coshf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN clearenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:147 */
extern int clearenv(void) ;
/* END FUNCTION-DECL-EXTERN clearenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:147 */

/* BEGIN VARIABLE-DEF getfulltree LOC=UNKNOWN */
struct _info **(*getfulltree)(char *d , u_long lev , dev_t dev , off_t *size , char **err )  ;
/* END VARIABLE-DEF getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF maxpattern LOC=UNKNOWN */
int maxpattern  ;
/* END VARIABLE-DEF maxpattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floor LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* END FUNCTION-DECL __builtin_floor LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_modfl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* END FUNCTION-DECL __builtin_modfl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN erand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:129 */
extern double erand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN erand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:129 */

/* BEGIN FUNCTION-DECL-EXTERN sprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:121 */
extern int sprintf(char * , char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN sprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:121 */

/* BEGIN FUNCTION-DECL __builtin_infl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* END FUNCTION-DECL __builtin_infl LOC=BUILTIN */

/* BEGIN VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */
extern FILE *stdout ;
/* END VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */

/* BEGIN FUNCTION-DECL-EXTERN exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:48 */
extern void exit(int  ) ;
/* END FUNCTION-DECL-EXTERN exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:48 */

/* BEGIN FUNCTION-DECL __builtin_expf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* END FUNCTION-DECL __builtin_expf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_printfile LOC=UNKNOWN */
int html_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL html_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ffs LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ffs LOC=BUILTIN */

/* BEGIN VARIABLE-DEF curdir LOC=UNKNOWN */
char *curdir  ;
/* END VARIABLE-DEF curdir LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getcwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:92 */
extern char *getcwd(char * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN getcwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:92 */

/* BEGIN FUNCTION-DECL-EXTERN abs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:60 */
extern int abs(int  ) ;
/* END FUNCTION-DECL-EXTERN abs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:60 */

/* BEGIN TYPEDEF size_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t;
/* END TYPEDEF size_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN TYPEDEF wchar_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:38 */
typedef int wchar_t;
/* END TYPEDEF wchar_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:38 */

/* BEGIN FUNCTION-DECL-EXTERN mbtowc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:73 */
extern int mbtowc(wchar_t * __restrict   , char const   * __restrict   , size_t  ) ;
/* END FUNCTION-DECL-EXTERN mbtowc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:73 */

/* BEGIN FUNCTION-DECL initlinedraw LOC=UNKNOWN */
void initlinedraw(int flag ) ;
/* END FUNCTION-DECL initlinedraw LOC=UNKNOWN */

/* BEGIN TYPEDEF ssize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:154 */
typedef long ssize_t;
/* END TYPEDEF ssize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:154 */

/* BEGIN FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN labs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:61 */
extern long labs(long  ) ;
/* END FUNCTION-DECL-EXTERN labs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:61 */

/* BEGIN STRUCT timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
/* END STRUCT timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */

/* BEGIN TYPEDEF blkcnt_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:261 */
typedef int blkcnt_t;
/* END TYPEDEF blkcnt_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:261 */

/* BEGIN TYPEDEF mode_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:231 */
typedef unsigned int mode_t;
/* END TYPEDEF mode_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:231 */

/* BEGIN TYPEDEF uid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:328 */
typedef unsigned int uid_t;
/* END TYPEDEF uid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:328 */

/* BEGIN STRUCT stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */
struct stat {
   dev_t st_dev ;
   int __st_dev_padding ;
   long __st_ino_truncated ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   int __st_rdev_padding ;
   off_t st_size ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   ino_t st_ino ;
};
/* END STRUCT stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */

/* BEGIN VARIABLE-DEF ftype LOC=UNKNOWN */
char *ftype[9]  ;
/* END VARIABLE-DEF ftype LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */

/* BEGIN STRUCT extensions LOC=../tree.h:149 */
struct extensions {
   char *ext ;
   char *term_flg ;
   char *CSS_name ;
   char *web_fg ;
   char *web_bg ;
   char *web_extattr ;
   struct extensions *nxt ;
};
/* END STRUCT extensions LOC=../tree.h:149 */

/* BEGIN VARIABLE-DEF xdev LOC=UNKNOWN */
bool xdev  ;
/* END VARIABLE-DEF xdev LOC=UNKNOWN */

/* BEGIN STRUCT listingcalls LOC=../tree.h:121 */
struct listingcalls {
   void (*intro)(void) ;
   void (*outtro)(void) ;
   int (*printinfo)(char *dirname , struct _info *file , int level ) ;
   int (*printfile)(char *dirname , char *filename , struct _info *file , int descend ) ;
   int (*error)(char *error ) ;
   void (*newline)(struct _info *file , int level , int postdir , int needcomma ) ;
   void (*close)(struct _info *file , int level , int needcomma ) ;
   void (*report)(struct totals tot ) ;
};
/* END STRUCT listingcalls LOC=../tree.h:121 */

/* BEGIN VARIABLE-DEF lc LOC=UNKNOWN */
struct listingcalls lc  ;
/* END VARIABLE-DEF lc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL new_comment LOC=UNKNOWN */
struct comment *new_comment(struct pattern *phead , char **line , int lines ) ;
/* END FUNCTION-DECL new_comment LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL unix_report LOC=UNKNOWN */
void unix_report(struct totals tot ) ;
/* END FUNCTION-DECL unix_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL class LOC=UNKNOWN */
char *class(struct _info *info___1 ) ;
/* END FUNCTION-DECL class LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN system LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:55 */
extern int system(char const   * ) ;
/* END FUNCTION-DECL-EXTERN system LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:55 */

/* BEGIN VARIABLE-DEF hflag LOC=UNKNOWN */
bool hflag  ;
/* END VARIABLE-DEF hflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF maxipattern LOC=UNKNOWN */
int maxipattern  ;
/* END VARIABLE-DEF maxipattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mkostemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:105 */
extern int mkostemp(char * , int  ) ;
/* END FUNCTION-DECL-EXTERN mkostemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:105 */

/* BEGIN FUNCTION-DECL cmd LOC=UNKNOWN */
int cmd(char *s ) ;
/* END FUNCTION-DECL cmd LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strtof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:28 */
extern float strtof(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:28 */

/* BEGIN FUNCTION-DECL __builtin_floorf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* END FUNCTION-DECL __builtin_floorf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF file_pathsep LOC=UNKNOWN */
char *file_pathsep  ;
/* END VARIABLE-DEF file_pathsep LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF flimit LOC=UNKNOWN */
int flimit  ;
/* END VARIABLE-DEF flimit LOC=UNKNOWN */

/* BEGIN STRUCT __anonstruct_cmds_476363767 LOC=../color.c:176 */
struct __anonstruct_cmds_476363767 {
   char *cmd ;
   char cmdnum ;
};
/* END STRUCT __anonstruct_cmds_476363767 LOC=../color.c:176 */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL prot LOC=UNKNOWN */
char *prot(mode_t m ) ;
/* END FUNCTION-DECL prot LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL saveino LOC=UNKNOWN */
void saveino(ino_t inode , dev_t device ) ;
/* END FUNCTION-DECL saveino LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL sizecmp LOC=UNKNOWN */
int sizecmp(off_t a , off_t b ) ;
/* END FUNCTION-DECL sizecmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */

/* BEGIN TYPEDEF u_char LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:64 */
typedef unsigned char u_char;
/* END TYPEDEF u_char LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:64 */

/* BEGIN FUNCTION-DECL do_date LOC=UNKNOWN */
char *do_date(time_t t ) ;
/* END FUNCTION-DECL do_date LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN setkey LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:127 */
extern void setkey(char const   * ) ;
/* END FUNCTION-DECL-EXTERN setkey LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:127 */

/* BEGIN FUNCTION-DECL-EXTERN isprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:17 */
extern int isprint(int  ) ;
/* END FUNCTION-DECL-EXTERN isprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:17 */

/* BEGIN FUNCTION-DECL json_intro LOC=UNKNOWN */
void json_intro(void) ;
/* END FUNCTION-DECL json_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strtoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:34 */
extern long long strtoll(char const   * __restrict   , char ** __restrict   , int  ) ;
/* END FUNCTION-DECL-EXTERN strtoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:34 */

/* BEGIN FUNCTION-DECL html_error LOC=UNKNOWN */
int html_error(char *error ) ;
/* END FUNCTION-DECL html_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL unix_error LOC=UNKNOWN */
int unix_error(char *error ) ;
/* END FUNCTION-DECL unix_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_powil LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* END FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _global_argv LOC=UNKNOWN */
char **_global_argv  ;
/* END VARIABLE-DEF _global_argv LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF Qflag LOC=UNKNOWN */
bool Qflag  ;
/* END VARIABLE-DEF Qflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN posix_memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:101 */
extern int posix_memalign(void ** , size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN posix_memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:101 */

/* BEGIN VARIABLE-DEF uflag LOC=UNKNOWN */
bool uflag  ;
/* END VARIABLE-DEF uflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF noreport LOC=UNKNOWN */
bool noreport  ;
/* END VARIABLE-DEF noreport LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN random LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:116 */
extern long random(void) ;
/* END FUNCTION-DECL-EXTERN random LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:116 */

/* BEGIN FUNCTION-DECL __builtin_nansf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF sorts LOC=UNKNOWN */
struct sorts sorts[6]  ;
/* END VARIABLE-DEF sorts LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF linktargetcolor LOC=UNKNOWN */
bool linktargetcolor  ;
/* END VARIABLE-DEF linktargetcolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _nl LOC=UNKNOWN */
char *_nl  ;
/* END VARIABLE-DEF _nl LOC=UNKNOWN */

/* BEGIN TYPEDEF nl_item LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/nl_types.h:11 */
typedef int nl_item;
/* END TYPEDEF nl_item LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/nl_types.h:11 */

/* BEGIN FUNCTION-DECL html_outtro LOC=UNKNOWN */
void html_outtro(void) ;
/* END FUNCTION-DECL html_outtro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF shift_jis LOC=UNKNOWN */
static char *shift_jis[4]  ;
/* END VARIABLE-DEF shift_jis LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF outfile LOC=UNKNOWN */
FILE *outfile  ;
/* END VARIABLE-DEF outfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN putenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:120 */
extern int putenv(char * ) ;
/* END FUNCTION-DECL-EXTERN putenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:120 */

/* BEGIN VARIABLE-DEF gtable LOC=UNKNOWN */
struct xtable *gtable[256]  ;
/* END VARIABLE-DEF gtable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_printfile LOC=UNKNOWN */
int json_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL json_printfile LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF koi8ru LOC=UNKNOWN */
static char *koi8ru[4]  ;
/* END VARIABLE-DEF koi8ru LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF timefmt LOC=UNKNOWN */
char *timefmt  ;
/* END VARIABLE-DEF timefmt LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF pflag LOC=UNKNOWN */
bool pflag  ;
/* END VARIABLE-DEF pflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* END FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN getsubopt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:107 */
extern int getsubopt(char ** , char * const  * , char ** ) ;
/* END FUNCTION-DECL-EXTERN getsubopt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:107 */

/* BEGIN FUNCTION-DECL unix_newline LOC=UNKNOWN */
void unix_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL unix_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */

/* BEGIN FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* END FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_asinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_asinl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Rflag LOC=UNKNOWN */
bool Rflag  ;
/* END VARIABLE-DEF Rflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ipattern LOC=UNKNOWN */
int ipattern  ;
/* END VARIABLE-DEF ipattern LOC=UNKNOWN */

/* BEGIN STRUCT infofile LOC=../tree.h:183 */
struct infofile {
   char *path ;
   struct comment *comments ;
   struct infofile *next ;
};
/* END STRUCT infofile LOC=../tree.h:183 */

/* BEGIN FUNCTION-DECL-EXTERN setstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:119 */
extern char *setstate(char * ) ;
/* END FUNCTION-DECL-EXTERN setstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:119 */

/* BEGIN FUNCTION-DECL json_encode LOC=UNKNOWN */
void json_encode(FILE *fd , char *s ) ;
/* END FUNCTION-DECL json_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */

/* BEGIN STRUCT dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */
struct dirent {
   ino_t d_ino ;
   off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
/* END STRUCT dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */

/* BEGIN FUNCTION-DECL freefiletree LOC=UNKNOWN */
void freefiletree(struct _info *ent ) ;
/* END FUNCTION-DECL freefiletree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_parityll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_parityll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN localtime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:60 */
extern struct tm *localtime(time_t const   * ) ;
/* END FUNCTION-DECL-EXTERN localtime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:60 */

/* BEGIN VARIABLE-DEF lflag LOC=UNKNOWN */
bool lflag  ;
/* END VARIABLE-DEF lflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN llabs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:62 */
extern long long llabs(long long  ) ;
/* END FUNCTION-DECL-EXTERN llabs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:62 */

/* BEGIN FUNCTION-DECL-EXTERN opendir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:26 */
extern DIR *opendir(char const   * ) ;
/* END FUNCTION-DECL-EXTERN opendir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:26 */

/* BEGIN FUNCTION-DECL gittrim LOC=UNKNOWN */
void gittrim(char *s ) ;
/* END FUNCTION-DECL gittrim LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_printinfo LOC=UNKNOWN */
int xml_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL xml_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL ctimesort LOC=UNKNOWN */
int ctimesort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL ctimesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strtoull LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:35 */
extern unsigned long long strtoull(char const   * __restrict   , char ** __restrict   ,
                                   int  ) ;
/* END FUNCTION-DECL-EXTERN strtoull LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:35 */

/* BEGIN FUNCTION-DECL push_filterstack LOC=UNKNOWN */
void push_filterstack(struct ignorefile *ig ) ;
/* END FUNCTION-DECL push_filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floorl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_floorl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF version LOC=UNKNOWN */
char *version  ;
/* END VARIABLE-DEF version LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */
extern FILE *stderr ;
/* END VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */

/* BEGIN VARIABLE-DEF noindent LOC=UNKNOWN */
bool noindent  ;
/* END VARIABLE-DEF noindent LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_popcount LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_popcount LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:70 */
extern lldiv_t lldiv(long long  , long long  ) ;
/* END FUNCTION-DECL-EXTERN lldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:70 */

/* BEGIN FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */
extern int strcmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */

/* BEGIN FUNCTION-DECL infocheck LOC=UNKNOWN */
struct comment *infocheck(char *path___0 , char *name , int top , int isdir ) ;
/* END FUNCTION-DECL infocheck LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL nextpc LOC=UNKNOWN */
char *nextpc(char **p , int *tok ) ;
/* END FUNCTION-DECL nextpc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN readdir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:27 */
extern struct dirent *readdir(DIR * ) ;
/* END FUNCTION-DECL-EXTERN readdir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:27 */

/* BEGIN FUNCTION-DECL push_infostack LOC=UNKNOWN */
void push_infostack(struct infofile *inf ) ;
/* END FUNCTION-DECL push_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_memset LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* END FUNCTION-DECL __builtin_memset LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN setlocale LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/locale.h:55 */
extern char *setlocale(int  , char const   * ) ;
/* END FUNCTION-DECL-EXTERN setlocale LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/locale.h:55 */

/* BEGIN STRUCT colortable LOC=../tree.h:146 */
struct colortable {
   char *term_flg ;
   char *CSS_name ;
   char *font_fg ;
   char *font_bg ;
};
/* END STRUCT colortable LOC=../tree.h:146 */

/* BEGIN VARIABLE-DEF colortable LOC=UNKNOWN */
struct colortable colortable[11]  ;
/* END VARIABLE-DEF colortable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN posix_openpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:121 */
extern int posix_openpt(int  ) ;
/* END FUNCTION-DECL-EXTERN posix_openpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:121 */

/* BEGIN FUNCTION-DECL json_outtro LOC=UNKNOWN */
void json_outtro(void) ;
/* END FUNCTION-DECL json_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* END FUNCTION-DECL __builtin_atan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL pop_infostack LOC=UNKNOWN */
struct infofile *pop_infostack(void) ;
/* END FUNCTION-DECL pop_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL dirsfirst LOC=UNKNOWN */
int dirsfirst(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL dirsfirst LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF duflag LOC=UNKNOWN */
bool duflag  ;
/* END VARIABLE-DEF duflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_powif LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powif LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strftime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:58 */
extern size_t___0 strftime(char * __restrict   , size_t___0  , char const   * __restrict   ,
                           struct tm  const  * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strftime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:58 */

/* BEGIN TYPEDEF div_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
typedef struct __anonstruct_div_t_109580352 div_t;
/* END TYPEDEF div_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN FUNCTION-DECL fsizesort LOC=UNKNOWN */
int fsizesort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL fsizesort LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF cmds LOC=UNKNOWN */
static struct __anonstruct_cmds_476363767 cmds[22]  ;
/* END VARIABLE-DEF cmds LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF topsort LOC=UNKNOWN */
int (*topsort)()  ;
/* END VARIABLE-DEF topsort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */
extern int printf(char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */

/* BEGIN VARIABLE-DEF devflag LOC=UNKNOWN */
bool devflag  ;
/* END VARIABLE-DEF devflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:130 */
extern long lrand48(void) ;
/* END FUNCTION-DECL-EXTERN lrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:130 */

/* BEGIN FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* END FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */

/* BEGIN VARIABLE-DEF buf LOC=UNKNOWN */
static char buf[11]  ;
/* END VARIABLE-DEF buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_clzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_clzll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */
/* compiler builtin: 
   long long __builtin_bswap64(long long  ) ;  */
/* END FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */

/* BEGIN VARIABLE-DEF path LOC=UNKNOWN */
static char *path  ;
/* END VARIABLE-DEF path LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF sp LOC=UNKNOWN */
char *sp  ;
/* END VARIABLE-DEF sp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_end LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_end LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtoul LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:33 */
extern unsigned long strtoul(char const   * __restrict   , char ** __restrict   ,
                             int  ) ;
/* END FUNCTION-DECL-EXTERN strtoul LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:33 */

/* BEGIN FUNCTION-DECL-EXTERN strcoll LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:42 */
extern int strcoll(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcoll LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:42 */

/* BEGIN FUNCTION-DECL strverscmp LOC=UNKNOWN */
int strverscmp(char const   *s1 , char const   *s2 ) ;
/* END FUNCTION-DECL strverscmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_exp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* END FUNCTION-DECL __builtin_exp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mktemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:141 */
extern char *mktemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mktemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:141 */

/* BEGIN VARIABLE-DEF sLevel LOC=UNKNOWN */
char *sLevel  ;
/* END VARIABLE-DEF sLevel LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN nrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:131 */
extern long nrand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN nrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:131 */

/* BEGIN FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN initstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:118 */
extern char *initstate(unsigned int  , char * , size_t  ) ;
/* END FUNCTION-DECL-EXTERN initstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:118 */

/* BEGIN FUNCTION-DECL html_intro LOC=UNKNOWN */
void html_intro(void) ;
/* END FUNCTION-DECL html_intro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF gflag LOC=UNKNOWN */
bool gflag  ;
/* END VARIABLE-DEF gflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stat2info LOC=UNKNOWN */
struct _info *stat2info(struct stat *st ) ;
/* END FUNCTION-DECL stat2info LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL print_color LOC=UNKNOWN */
int print_color(int color___0 ) ;
/* END FUNCTION-DECL print_color LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:51 */
extern void quick_exit(int  ) ;
/* END FUNCTION-DECL-EXTERN quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:51 */

/* BEGIN FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* END FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */

/* BEGIN TYPEDEF u_short LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:65 */
typedef unsigned short u_short;
/* END TYPEDEF u_short LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:65 */

/* BEGIN STRUCT ignorefile LOC=../tree.h:170 */
struct ignorefile {
   char *path ;
   struct pattern *remove ;
   struct pattern *reverse ;
   struct ignorefile *next ;
};
/* END STRUCT ignorefile LOC=../tree.h:170 */

/* BEGIN FUNCTION-DECL-EXTERN _Exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:49 */
extern void _Exit(int  ) ;
/* END FUNCTION-DECL-EXTERN _Exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:49 */

/* BEGIN VARIABLE-DEF info___0 LOC=UNKNOWN */
static char info___0[512]  ;
/* END VARIABLE-DEF info___0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_error LOC=UNKNOWN */
int json_error(char *error ) ;
/* END FUNCTION-DECL json_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN srand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:134 */
extern void srand48(long  ) ;
/* END FUNCTION-DECL-EXTERN srand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:134 */

/* BEGIN VARIABLE-DEF inodeflag LOC=UNKNOWN */
bool inodeflag  ;
/* END VARIABLE-DEF inodeflag LOC=UNKNOWN */

/* BEGIN STRUCT inotable LOC=../tree.h:139 */
struct inotable {
   ino_t inode ;
   dev_t device ;
   struct inotable *nxt ;
};
/* END STRUCT inotable LOC=../tree.h:139 */

/* BEGIN STRUCT passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   uid_t pw_uid ;
   gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
/* END STRUCT passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */

/* BEGIN FUNCTION-DECL __builtin_powi LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powi LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_logf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* END FUNCTION-DECL __builtin_logf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_expect LOC=BUILTIN */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* END FUNCTION-DECL __builtin_expect LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Fflag LOC=UNKNOWN */
bool Fflag  ;
/* END VARIABLE-DEF Fflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_printinfo LOC=UNKNOWN */
int json_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL json_printinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF windows LOC=UNKNOWN */
static char *windows[13]  ;
/* END VARIABLE-DEF windows LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_inf LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* END FUNCTION-DECL __builtin_inf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */

/* BEGIN VARIABLE-DEF linedraw LOC=UNKNOWN */
struct linedraw *linedraw  ;
/* END VARIABLE-DEF linedraw LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atoi LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:23 */
extern int atoi(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atoi LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:23 */

/* BEGIN FUNCTION-DECL __builtin_modff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* END FUNCTION-DECL __builtin_modff LOC=BUILTIN */

/* BEGIN VARIABLE-DEF colorize LOC=UNKNOWN */
bool colorize  ;
/* END VARIABLE-DEF colorize LOC=UNKNOWN */

/* BEGIN TYPEDEF wint_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:51 */
typedef unsigned int wint_t;
/* END TYPEDEF wint_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:51 */

/* BEGIN FUNCTION-DECL setoutput LOC=UNKNOWN */
void setoutput(char *filename ) ;
/* END FUNCTION-DECL setoutput LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */
extern int fputc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */

/* BEGIN FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_acosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_acosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL xml_printfile LOC=UNKNOWN */
int xml_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL xml_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN qsort_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:151 */
extern void qsort_r(void * , size_t  , size_t  , int (*)(void const   * , void const   * ,
                                                         void * ) , void * ) ;
/* END FUNCTION-DECL-EXTERN qsort_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:151 */

/* BEGIN VARIABLE-DEF errors LOC=UNKNOWN */
int errors  ;
/* END VARIABLE-DEF errors LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF fpattern LOC=UNKNOWN */
static char fpattern[4096]  ;
/* END VARIABLE-DEF fpattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL html_print LOC=UNKNOWN */
void html_print(char *s ) ;
/* END FUNCTION-DECL html_print LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lcong48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:136 */
extern void lcong48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN lcong48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:136 */

/* BEGIN VARIABLE-DEF big5 LOC=UNKNOWN */
static char *big5[3]  ;
/* END VARIABLE-DEF big5 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_argc LOC=UNKNOWN */
int _global_argc  ;
/* END VARIABLE-DEF _global_argc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_trap LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* END FUNCTION-DECL __builtin_trap LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* END FUNCTION-DECL __builtin_cosh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* END FUNCTION-DECL __builtin_log10f LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mkstemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:104 */
extern int mkstemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mkstemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:104 */

/* BEGIN FUNCTION-DECL getinfo LOC=UNKNOWN */
struct _info *getinfo(char *name , char *path___0 ) ;
/* END FUNCTION-DECL getinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
struct __anonstruct_div_t_109580352 {
   int quot ;
   int rem ;
};
/* END STRUCT __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN FUNCTION-DECL-EXTERN a64l LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:126 */
extern long a64l(char const   * ) ;
/* END FUNCTION-DECL-EXTERN a64l LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:126 */

/* BEGIN FUNCTION-DECL parse_dir_colors LOC=UNKNOWN */
void parse_dir_colors(void) ;
/* END FUNCTION-DECL parse_dir_colors LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mkostemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:143 */
extern int mkostemps(char * , int  , int  ) ;
/* END FUNCTION-DECL-EXTERN mkostemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:143 */

/* BEGIN FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */
extern int fprintf(FILE * , char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */

/* BEGIN FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */

/* BEGIN STRUCT comment LOC=../tree.h:177 */
struct comment {
   struct pattern *pattern ;
   char **desc ;
   struct comment *next ;
};
/* END STRUCT comment LOC=../tree.h:177 */

/* BEGIN FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Xflag LOC=UNKNOWN */
bool Xflag  ;
/* END VARIABLE-DEF Xflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_parity LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_parity LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN setenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:102 */
extern int setenv(char const   * , char const   * , int  ) ;
/* END FUNCTION-DECL-EXTERN setenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:102 */

/* BEGIN FUNCTION-DECL-EXTERN strtod LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:29 */
extern double strtod(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtod LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:29 */

/* BEGIN FUNCTION-DECL __builtin_cosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_cosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL xml_intro LOC=UNKNOWN */
void xml_intro(void) ;
/* END FUNCTION-DECL xml_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN nl_langinfo LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/langinfo.h:91 */
extern char *nl_langinfo(nl_item  ) ;
/* END FUNCTION-DECL-EXTERN nl_langinfo LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/langinfo.h:91 */

/* BEGIN FUNCTION-DECL cond_lower LOC=UNKNOWN */
__inline static char cond_lower(char c ) ;
/* END FUNCTION-DECL cond_lower LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF iso2022jp LOC=UNKNOWN */
static char *iso2022jp[5]  ;
/* END VARIABLE-DEF iso2022jp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */

/* BEGIN FUNCTION-DECL findino LOC=UNKNOWN */
int findino(ino_t inode , dev_t device ) ;
/* END FUNCTION-DECL findino LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:73 */
extern int stat(char const   * __restrict   , struct stat * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:73 */

/* BEGIN FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lstat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:75 */
extern int lstat(char const   * , struct stat * ) ;
/* END FUNCTION-DECL-EXTERN lstat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:75 */

/* BEGIN FUNCTION-DECL __builtin_inff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* END FUNCTION-DECL __builtin_inff LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN unsetenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:103 */
extern int unsetenv(char const   * ) ;
/* END FUNCTION-DECL-EXTERN unsetenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:103 */

/* BEGIN VARIABLE-DEF showinfo LOC=UNKNOWN */
bool showinfo  ;
/* END VARIABLE-DEF showinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF errbuf LOC=UNKNOWN */
static char errbuf[256]  ;
/* END VARIABLE-DEF errbuf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */
extern int isatty(int  ) ;
/* END FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */

/* BEGIN FUNCTION-DECL getcharset LOC=UNKNOWN */
char const   *getcharset(void) ;
/* END FUNCTION-DECL getcharset LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN wcstombs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:76 */
extern size_t wcstombs(char * __restrict   , wchar_t const   * __restrict   , size_t  ) ;
/* END FUNCTION-DECL-EXTERN wcstombs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:76 */

/* BEGIN FUNCTION-DECL-EXTERN atol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:24 */
extern long atol(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:24 */

/* BEGIN VARIABLE-DEF pruneflag LOC=UNKNOWN */
bool pruneflag  ;
/* END VARIABLE-DEF pruneflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mbstowcs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:75 */
extern unsigned long mbstowcs(int * __restrict   , char const   * __restrict   , unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN mbstowcs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:75 */

/* BEGIN FUNCTION-DECL-EXTERN mkstemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:142 */
extern int mkstemps(char * , int  ) ;
/* END FUNCTION-DECL-EXTERN mkstemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:142 */

/* BEGIN VARIABLE-DEF Hflag LOC=UNKNOWN */
bool Hflag  ;
/* END VARIABLE-DEF Hflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF cflag LOC=UNKNOWN */
bool cflag  ;
/* END VARIABLE-DEF cflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL fillinfo LOC=UNKNOWN */
char *fillinfo(char *buf___1 , struct _info *ent ) ;
/* END FUNCTION-DECL fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_indent LOC=UNKNOWN */
void xml_indent(int maxlevel ) ;
/* END FUNCTION-DECL xml_indent LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF hversion LOC=UNKNOWN */
char *hversion  ;
/* END VARIABLE-DEF hversion LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN l64a LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:125 */
extern char *l64a(long  ) ;
/* END FUNCTION-DECL-EXTERN l64a LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:125 */

/* BEGIN FUNCTION-DECL unix_printinfo LOC=UNKNOWN */
int unix_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL unix_printinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF latin1_3 LOC=UNKNOWN */
static char *latin1_3[15]  ;
/* END VARIABLE-DEF latin1_3 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF nolinks LOC=UNKNOWN */
bool nolinks  ;
/* END VARIABLE-DEF nolinks LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF euc_jp LOC=UNKNOWN */
static char *euc_jp[4]  ;
/* END VARIABLE-DEF euc_jp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL color LOC=UNKNOWN */
int color(u_short mode , char *name , bool orphan , bool islink ) ;
/* END FUNCTION-DECL color LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_newline LOC=UNKNOWN */
void json_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL json_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL read_dir LOC=UNKNOWN */
struct _info **read_dir(char *dir , int *n , int infotop ) ;
/* END FUNCTION-DECL read_dir LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_report LOC=UNKNOWN */
void json_report(struct totals tot ) ;
/* END FUNCTION-DECL json_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL new_ignorefile LOC=UNKNOWN */
struct ignorefile *new_ignorefile(char *path___0 ) ;
/* END FUNCTION-DECL new_ignorefile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */
extern int strncmp(char const   * , char const   * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */

/* BEGIN VARIABLE-DEF Dflag LOC=UNKNOWN */
bool Dflag  ;
/* END VARIABLE-DEF Dflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* END FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN realloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:42 */
extern void *realloc(void * , unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN realloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:42 */

/* BEGIN FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */

/* BEGIN TYPEDEF wchar_t___1 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:74 */
typedef int wchar_t___1;
/* END TYPEDEF wchar_t___1 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:74 */

/* BEGIN VARIABLE-DEF qflag LOC=UNKNOWN */
bool qflag  ;
/* END VARIABLE-DEF qflag LOC=UNKNOWN */

/* BEGIN TYPEDEF size_t___1 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t___1;
/* END TYPEDEF size_t___1 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN FUNCTION-DECL-EXTERN grantpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:122 */
extern int grantpt(int  ) ;
/* END FUNCTION-DECL-EXTERN grantpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:122 */

/* BEGIN FUNCTION-DECL json_indent LOC=UNKNOWN */
void json_indent(int maxlevel ) ;
/* END FUNCTION-DECL json_indent LOC=UNKNOWN */

/* BEGIN STRUCT _info LOC=../tree.h:91 */
struct _info {
   char *name ;
   char *lnk ;
   bool isdir ;
   bool issok ;
   bool isfifo ;
   bool isexe ;
   bool orphan ;
   mode_t mode ;
   mode_t lnkmode ;
   uid_t uid ;
   gid_t gid ;
   off_t size ;
   time_t atime ;
   time_t ctime ;
   time_t mtime ;
   dev_t dev ;
   dev_t ldev ;
   ino_t inode ;
   ino_t linode ;
   char *err ;
   char *tag ;
   char **comment ;
   struct _info **child ;
   struct _info *next ;
   struct _info *tchild ;
};
/* END STRUCT _info LOC=../tree.h:91 */

/* BEGIN VARIABLE-DEF info LOC=UNKNOWN */
static struct _info info  ;
/* END VARIABLE-DEF info LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL json_fillinfo LOC=UNKNOWN */
void json_fillinfo(struct _info *ent ) ;
/* END FUNCTION-DECL json_fillinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF metafirst LOC=UNKNOWN */
bool metafirst  ;
/* END VARIABLE-DEF metafirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN jrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:133 */
extern long jrand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN jrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:133 */

/* BEGIN VARIABLE-DEF euc_kr LOC=UNKNOWN */
static char *euc_kr[3]  ;
/* END VARIABLE-DEF euc_kr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF gb LOC=UNKNOWN */
static char *gb[3]  ;
/* END VARIABLE-DEF gb LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* END FUNCTION-DECL __builtin_sin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN srand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:38 */
extern void srand(unsigned int  ) ;
/* END FUNCTION-DECL-EXTERN srand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:38 */

/* BEGIN FUNCTION-DECL uidtoname LOC=UNKNOWN */
char *uidtoname(uid_t uid ) ;
/* END FUNCTION-DECL uidtoname LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF buf___0 LOC=UNKNOWN */
static char buf___0[256]  ;
/* END VARIABLE-DEF buf___0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atexit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:47 */
extern int atexit(void (*)(void) ) ;
/* END FUNCTION-DECL-EXTERN atexit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:47 */

/* BEGIN FUNCTION-DECL-EXTERN fclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:82 */
extern int fclose(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:82 */

/* BEGIN FUNCTION-DECL-EXTERN strchr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:45 */
extern char *strchr(char const   * , int  ) ;
/* END FUNCTION-DECL-EXTERN strchr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:45 */

/* BEGIN VARIABLE-DEF fmt LOC=UNKNOWN */
char fmt[9]  ;
/* END VARIABLE-DEF fmt LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL endcolor LOC=UNKNOWN */
void endcolor(void) ;
/* END FUNCTION-DECL endcolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN qsort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:58 */
extern void qsort(void * , unsigned long  , unsigned long  , int (*)(void const   * ,
                                                                     void const   * ) ) ;
/* END FUNCTION-DECL-EXTERN qsort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:58 */

/* BEGIN FUNCTION-DECL __builtin_strncat LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncat LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:80 */
extern FILE *fopen(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN fopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:80 */

/* BEGIN FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabs LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* END FUNCTION-DECL __builtin_fabs LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mkdtemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:106 */
extern char *mkdtemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mkdtemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:106 */

/* BEGIN FUNCTION-DECL-EXTERN strtol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:32 */
extern long strtol(char const   * __restrict   , char ** __restrict   , int  ) ;
/* END FUNCTION-DECL-EXTERN strtol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:32 */

/* BEGIN VARIABLE-DEF force_color LOC=UNKNOWN */
bool force_color  ;
/* END VARIABLE-DEF force_color LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL filesfirst LOC=UNKNOWN */
int filesfirst(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL filesfirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL free_dir LOC=UNKNOWN */
void free_dir(struct _info **d ) ;
/* END FUNCTION-DECL free_dir LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF istty LOC=UNKNOWN */
char istty  ;
/* END VARIABLE-DEF istty LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL patmatch LOC=UNKNOWN */
int patmatch(char *buf___1 , char *pat , int isdir ) ;
/* END FUNCTION-DECL patmatch LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:26 */
extern double atof(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:26 */

/* BEGIN VARIABLE-DEF ignorecase LOC=UNKNOWN */
bool ignorecase  ;
/* END VARIABLE-DEF ignorecase LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL patignore LOC=UNKNOWN */
int patignore(char *name , int isdir ) ;
/* END FUNCTION-DECL patignore LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* END FUNCTION-DECL __builtin_tanh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
struct __anonstruct_ldiv_t_721778306 {
   long quot ;
   long rem ;
};
/* END STRUCT __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN FUNCTION-DECL-EXTERN readlink LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:74 */
extern ssize_t readlink(char const   * __restrict   , char * __restrict   , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN readlink LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:74 */

/* BEGIN FUNCTION-DECL unix_getfulltree LOC=UNKNOWN */
struct _info **unix_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) ;
/* END FUNCTION-DECL unix_getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_atanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_atanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL indent LOC=UNKNOWN */
void indent(int maxlevel ) ;
/* END FUNCTION-DECL indent LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_error LOC=UNKNOWN */
int xml_error(char *error ) ;
/* END FUNCTION-DECL xml_error LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF reverse LOC=UNKNOWN */
bool reverse  ;
/* END VARIABLE-DEF reverse LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL psize LOC=UNKNOWN */
int psize(char *buf___1 , off_t size ) ;
/* END FUNCTION-DECL psize LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL null_outtro LOC=UNKNOWN */
void null_outtro(void) ;
/* END FUNCTION-DECL null_outtro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF infostack LOC=UNKNOWN */
struct infofile *infostack  ;
/* END VARIABLE-DEF infostack LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF si_unit LOC=UNKNOWN */
static char *si_unit  ;
/* END VARIABLE-DEF si_unit LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL null_intro LOC=UNKNOWN */
void null_intro(void) ;
/* END FUNCTION-DECL null_intro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ibm_gr LOC=UNKNOWN */
static char *ibm_gr[6]  ;
/* END VARIABLE-DEF ibm_gr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* END FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nansl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL Ftype LOC=UNKNOWN */
char Ftype(mode_t mode ) ;
/* END FUNCTION-DECL Ftype LOC=UNKNOWN */

/* BEGIN STRUCT xtable LOC=../tree.h:134 */
struct xtable {
   unsigned int xid ;
   char *name ;
   struct xtable *nxt ;
};
/* END STRUCT xtable LOC=../tree.h:134 */

/* BEGIN FUNCTION-DECL __builtin_parityl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_parityl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN reallocarray LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:150 */
extern void *reallocarray(void * , size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN reallocarray LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:150 */

/* BEGIN FUNCTION-DECL __builtin_ceil LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* END FUNCTION-DECL __builtin_ceil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN seed48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:135 */
extern unsigned short *seed48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN seed48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:135 */

/* BEGIN FUNCTION-DECL __builtin_strlen LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strlen LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:111 */
extern char *fgets(char * , int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:111 */

/* BEGIN FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:33 */
extern char *strcpy(char * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:33 */

/* BEGIN FUNCTION-DECL new_infofile LOC=UNKNOWN */
struct infofile *new_infofile(char *path___0 ) ;
/* END FUNCTION-DECL new_infofile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL json_close LOC=UNKNOWN */
void json_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL json_close LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF utf8 LOC=UNKNOWN */
static char *utf8[3]  ;
/* END VARIABLE-DEF utf8 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_atanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL push_files LOC=UNKNOWN */
void push_files(char *dir , struct ignorefile **ig , struct infofile **inf ) ;
/* END FUNCTION-DECL push_files LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:145 */
extern void *memalign(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:145 */

/* BEGIN FUNCTION-DECL __builtin_fmod LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* END FUNCTION-DECL __builtin_fmod LOC=BUILTIN */

/* BEGIN VARIABLE-DEF cstable LOC=UNKNOWN */
static struct linedraw cstable[16]  ;
/* END VARIABLE-DEF cstable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strtold LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:30 */
extern long double strtold(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtold LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:30 */

/* BEGIN FUNCTION-DECL printit LOC=UNKNOWN */
void printit(char *s ) ;
/* END FUNCTION-DECL printit LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN bsearch LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:57 */
extern void *bsearch(void const   * , void const   * , size_t  , size_t  , int (*)(void const   * ,
                                                                                   void const   * ) ) ;
/* END FUNCTION-DECL-EXTERN bsearch LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:57 */

/* BEGIN FUNCTION-DECL-EXTERN div LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:68 */
extern div_t div(int  , int  ) ;
/* END FUNCTION-DECL-EXTERN div LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:68 */

/* BEGIN VARIABLE-DEF Nflag LOC=UNKNOWN */
bool Nflag  ;
/* END VARIABLE-DEF Nflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* END FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtok LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:52 */
extern char *strtok(char * __restrict   , char const   * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtok LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:52 */

/* BEGIN FUNCTION-DECL __builtin_tanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanl LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
struct __anonstruct_lldiv_t_989260392 {
   long long quot ;
   long long rem ;
};
/* END STRUCT __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN VARIABLE-DEF fflag LOC=UNKNOWN */
bool fflag  ;
/* END VARIABLE-DEF fflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL file_getfulltree LOC=UNKNOWN */
struct _info **file_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) ;
/* END FUNCTION-DECL file_getfulltree LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF file_comment LOC=UNKNOWN */
char *file_comment  ;
/* END VARIABLE-DEF file_comment LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xmalloc LOC=UNKNOWN */
void *xmalloc(size_t___0 size ) ;
/* END FUNCTION-DECL xmalloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_expl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_expl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* END FUNCTION-DECL __builtin_log10l LOC=BUILTIN */

/* BEGIN VARIABLE-DEF aflag LOC=UNKNOWN */
bool aflag  ;
/* END VARIABLE-DEF aflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* END FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Level LOC=UNKNOWN */
int Level  ;
/* END VARIABLE-DEF Level LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN snprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:122 */
extern int snprintf(char * , size_t___0  , char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN snprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:122 */

/* BEGIN FUNCTION-DECL alnumsort LOC=UNKNOWN */
int alnumsort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL alnumsort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_clz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_clz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bzero LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bzero LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nans LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nans LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mblen LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:72 */
extern int mblen(char const   * , size_t  ) ;
/* END FUNCTION-DECL-EXTERN mblen LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:72 */

/* BEGIN FUNCTION-DECL xrealloc LOC=UNKNOWN */
void *xrealloc(void *ptr , size_t___0 size ) ;
/* END FUNCTION-DECL xrealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_clzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_clzl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF lbufsize LOC=UNKNOWN */
static int lbufsize  ;
/* END VARIABLE-DEF lbufsize LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ceill LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* END FUNCTION-DECL __builtin_ceill LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_report LOC=UNKNOWN */
void html_report(struct totals tot ) ;
/* END FUNCTION-DECL html_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN aligned_alloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:44 */
extern void *aligned_alloc(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN aligned_alloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:44 */

/* BEGIN FUNCTION-DECL url_encode LOC=UNKNOWN */
void url_encode(FILE *fd , char *s ) ;
/* END FUNCTION-DECL url_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_return LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* END FUNCTION-DECL __builtin_return LOC=BUILTIN */

/* BEGIN FUNCTION-DECL split LOC=UNKNOWN */
char **split(char *str , char *delim , int *nwrds ) ;
/* END FUNCTION-DECL split LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL html_close LOC=UNKNOWN */
void html_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL html_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL null_close LOC=UNKNOWN */
void null_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL null_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN ldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:69 */
extern ldiv_t ldiv(long  , long  ) ;
/* END FUNCTION-DECL-EXTERN ldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:69 */

/* BEGIN FUNCTION-DECL unix_printfile LOC=UNKNOWN */
int unix_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL unix_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN calloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:41 */
extern void *calloc(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN calloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:41 */

/* BEGIN VARIABLE-DEF ibm_ps2 LOC=UNKNOWN */
static char *ibm_ps2[9]  ;
/* END VARIABLE-DEF ibm_ps2 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF perms LOC=UNKNOWN */
static char perms[10]  ;
/* END VARIABLE-DEF perms LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_envp LOC=UNKNOWN */
char **_global_envp  ;
/* END VARIABLE-DEF _global_envp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN valloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:144 */
extern void *valloc(size_t  ) ;
/* END FUNCTION-DECL-EXTERN valloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:144 */

/* BEGIN FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */

/* BEGIN VARIABLE-DEF gitignore LOC=UNKNOWN */
bool gitignore  ;
/* END VARIABLE-DEF gitignore LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ext LOC=UNKNOWN */
struct extensions *ext  ;
/* END VARIABLE-DEF ext LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_logl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_logl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF maxdirs LOC=UNKNOWN */
int maxdirs  ;
/* END VARIABLE-DEF maxdirs LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL gnu_getcwd LOC=UNKNOWN */
char *gnu_getcwd(void) ;
/* END FUNCTION-DECL gnu_getcwd LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_log LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* END FUNCTION-DECL __builtin_log LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* END FUNCTION-DECL __builtin_cos LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN free LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:43 */
extern void free(void * ) ;
/* END FUNCTION-DECL-EXTERN free LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:43 */

/* BEGIN FUNCTION-DECL-EXTERN alloca LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h:11 */
extern void *alloca(size_t  ) ;
/* END FUNCTION-DECL-EXTERN alloca LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h:11 */

/* BEGIN FUNCTION-DECL main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) ;
/* END FUNCTION-DECL main LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL emit_tree LOC=UNKNOWN */
void emit_tree(char **dirname , bool needfulltree ) ;
/* END FUNCTION-DECL emit_tree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */

/* BEGIN FUNCTION-DECL xml_newline LOC=UNKNOWN */
void xml_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL xml_newline LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF filterstack LOC=UNKNOWN */
struct ignorefile *filterstack  ;
/* END VARIABLE-DEF filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN wctomb LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:74 */
extern int wctomb(char * , wchar_t  ) ;
/* END FUNCTION-DECL-EXTERN wctomb LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:74 */

/* BEGIN VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */
extern FILE *stdin ;
/* END VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */

/* BEGIN VARIABLE-DEF dirs LOC=UNKNOWN */
int *dirs  ;
/* END VARIABLE-DEF dirs LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF sflag LOC=UNKNOWN */
bool sflag  ;
/* END VARIABLE-DEF sflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF siflag LOC=UNKNOWN */
bool siflag  ;
/* END VARIABLE-DEF siflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_fillinfo LOC=UNKNOWN */
void xml_fillinfo(struct _info *ent ) ;
/* END FUNCTION-DECL xml_fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN unlockpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:123 */
extern int unlockpt(int  ) ;
/* END FUNCTION-DECL-EXTERN unlockpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:123 */

/* BEGIN VARIABLE-DEF next_state LOC=UNKNOWN */
static unsigned int next_state[16]  ;
/* END VARIABLE-DEF next_state LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getgrgid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:26 */
extern struct group *getgrgid(gid_t  ) ;
/* END FUNCTION-DECL-EXTERN getgrgid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:26 */

/* BEGIN FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF color_code LOC=UNKNOWN */
char *color_code[26]  ;
/* END VARIABLE-DEF color_code LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF termmatch LOC=UNKNOWN */
char termmatch  ;
/* END VARIABLE-DEF termmatch LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* END FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_cosf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF title LOC=UNKNOWN */
char *title  ;
/* END VARIABLE-DEF title LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF dflag LOC=UNKNOWN */
bool dflag  ;
/* END VARIABLE-DEF dflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ifmt LOC=UNKNOWN */
int ifmt[8]  ;
/* END VARIABLE-DEF ifmt LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL html_printinfo LOC=UNKNOWN */
int html_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL html_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_close LOC=UNKNOWN */
void xml_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL xml_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getpwuid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:36 */
extern struct passwd *getpwuid(uid_t  ) ;
/* END FUNCTION-DECL-EXTERN getpwuid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:36 */

/* BEGIN FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_apply LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_apply LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_encode LOC=UNKNOWN */
void html_encode(FILE *fd , char *s ) ;
/* END FUNCTION-DECL html_encode LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ansilines LOC=UNKNOWN */
bool ansilines  ;
/* END VARIABLE-DEF ansilines LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN srandom LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:117 */
extern void srandom(unsigned int  ) ;
/* END FUNCTION-DECL-EXTERN srandom LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:117 */

/* BEGIN VARIABLE-DEF mb_cur_max LOC=UNKNOWN */
int mb_cur_max  ;
/* END VARIABLE-DEF mb_cur_max LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL usage LOC=UNKNOWN */
void usage(int n ) ;
/* END FUNCTION-DECL usage LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF basesort LOC=UNKNOWN */
int (*basesort)()  ;
/* END VARIABLE-DEF basesort LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF prev LOC=UNKNOWN */
static char prev  ;
/* END VARIABLE-DEF prev LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF pattern LOC=UNKNOWN */
int pattern  ;
/* END VARIABLE-DEF pattern LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF Jflag LOC=UNKNOWN */
bool Jflag  ;
/* END VARIABLE-DEF Jflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN rand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:37 */
extern int rand(void) ;
/* END FUNCTION-DECL-EXTERN rand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:37 */

/* BEGIN VARIABLE-DEF nocolor LOC=UNKNOWN */
bool nocolor  ;
/* END VARIABLE-DEF nocolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN iswprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/wchar.h:187 */
extern int iswprint(wint_t  ) ;
/* END FUNCTION-DECL-EXTERN iswprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/wchar.h:187 */

/* BEGIN FUNCTION-DECL-EXTERN drand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:128 */
extern double drand48(void) ;
/* END FUNCTION-DECL-EXTERN drand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:128 */

/* BEGIN FUNCTION-DECL __builtin_alloca LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_alloca LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */

/* BEGIN TYPEDEF wchar_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:38 */
typedef int wchar_t___0;
/* END TYPEDEF wchar_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:38 */

/* BEGIN FUNCTION-DECL patinclude LOC=UNKNOWN */
int patinclude(char *name , int isdir ) ;
/* END FUNCTION-DECL patinclude LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */
extern void *memset(void * , int  , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */

/* BEGIN VARIABLE-DEF itable LOC=UNKNOWN */
struct inotable *itable[256]  ;
/* END VARIABLE-DEF itable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_report LOC=UNKNOWN */
void xml_report(struct totals tot ) ;
/* END FUNCTION-DECL xml_report LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ipatterns LOC=UNKNOWN */
char **ipatterns  ;
/* END VARIABLE-DEF ipatterns LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF htmldirlen LOC=UNKNOWN */
int htmldirlen  ;
/* END VARIABLE-DEF htmldirlen LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_log10 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* END FUNCTION-DECL __builtin_log10 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL search LOC=UNKNOWN */
struct _info *search(struct _info **dir , char *name ) ;
/* END FUNCTION-DECL search LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ibm_pc LOC=UNKNOWN */
static char *ibm_pc[25]  ;
/* END VARIABLE-DEF ibm_pc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_newline LOC=UNKNOWN */
void html_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  unsigned int _1_html_newline_next ;

  {
  {
  _1_html_newline_next = 1U;
  }
  while (1) {
    switch (_1_html_newline_next) {
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<br>\n"));
    {
    _1_html_newline_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_outtro LOC=UNKNOWN */
void json_outtro(void) 
{ 
  char *tmp ;
  unsigned int _1_json_outtro_next ;

  {
  {
  _1_json_outtro_next = 2U;
  }
  while (1) {
    switch (_1_json_outtro_next) {
    case 4: ;
    return;
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s]\n"),
            tmp);
    {
    _1_json_outtro_next = 4U;
    }
    break;
    case 3: 
    tmp = _nl;
    {
    _1_json_outtro_next = 1U;
    }
    break;
    case 0: 
    tmp = (char *)"";
    {
    _1_json_outtro_next = 1U;
    }
    break;
    case 2: ;
    if (noindent) {
      {
      _1_json_outtro_next = 0U;
      }
    } else {
      {
      _1_json_outtro_next = 3U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF patmatch LOC=UNKNOWN */
int patmatch(char *buf___1 , char *pat , int isdir ) 
{ 
  int match ;
  int m ;
  int n ;
  char *bar ;
  char *tmp ;
  char pprev ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  int f ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char tmp___10 ;
  char tmp___11 ;
  char *tmp___12 ;
  unsigned int _1_patmatch_next ;

  {
  {
  _1_patmatch_next = 12U;
  }
  while (1) {
    switch (_1_patmatch_next) {
    case 18: 
    pat ++;
    n = 0;
    {
    _1_patmatch_next = 62U;
    }
    break;
    case 50: 
    tmp___12 = pat;
    pat ++;
    pprev = *tmp___12;
    {
    _1_patmatch_next = 42U;
    }
    break;
    case 80: ;
    if ((int )*buf___1 == 47) {
      {
      _1_patmatch_next = 2U;
      }
    } else {
      {
      _1_patmatch_next = 81U;
      }
    }
    break;
    case 104: 
    *bar = (char )'\000';
    match = patmatch(buf___1, pat, isdir);
    {
    _1_patmatch_next = 8U;
    }
    break;
    case 25: ;
    if ((unsigned long )bar == (unsigned long )pat) {
      {
      _1_patmatch_next = 45U;
      }
    } else {
      {
      _1_patmatch_next = 31U;
      }
    }
    break;
    case 49: ;
    if (bar) {
      {
      _1_patmatch_next = 25U;
      }
    } else {
      {
      _1_patmatch_next = 57U;
      }
    }
    break;
    case 52: 
    tmp___8 = buf___1;
    buf___1 ++;
    match = (int )*tmp___8 == (int )*pat;
    {
    _1_patmatch_next = 50U;
    }
    break;
    case 4: 
    n = 1;
    match = 0;
    {
    _1_patmatch_next = 62U;
    }
    break;
    case 30: 
    *bar = (char )'|';
    {
    _1_patmatch_next = 83U;
    }
    break;
    case 62: ;
    if ((int )*pat != 93) {
      {
      _1_patmatch_next = 53U;
      }
    } else {
      {
      _1_patmatch_next = 44U;
      }
    }
    break;
    case 102: ;
    if (*(pat + 1)) {
      {
      _1_patmatch_next = 90U;
      }
    } else {
      {
      _1_patmatch_next = 14U;
      }
    }
    break;
    case 106: ;
    if (! *buf___1) {
      {
      _1_patmatch_next = 28U;
      }
    } else {
      {
      _1_patmatch_next = 52U;
      }
    }
    break;
    case 14: 
    buf___1 ++;
    {
    _1_patmatch_next = 86U;
    }
    break;
    case 15: ;
    if (! *pat) {
      {
      _1_patmatch_next = 71U;
      }
    } else {
      {
      _1_patmatch_next = 75U;
      }
    }
    break;
    case 82: ;
    return (-1);
    break;
    case 89: ;
    if (match) {
      {
      _1_patmatch_next = 17U;
      }
    } else {
      {
      _1_patmatch_next = 14U;
      }
    }
    break;
    case 56: 
    match = n;
    {
    _1_patmatch_next = 7U;
    }
    break;
    case 79: ;
    return (f);
    break;
    case 31: ;
    if (! *(bar + 1)) {
      {
      _1_patmatch_next = 82U;
      }
    } else {
      {
      _1_patmatch_next = 104U;
      }
    }
    break;
    case 12: 
    match = 1;
    tmp = strchr((char const   *)pat, '|');
    bar = tmp;
    pprev = (char)0;
    {
    _1_patmatch_next = 49U;
    }
    break;
    case 101: ;
    if (*buf___1) {
      {
      _1_patmatch_next = 84U;
      }
    } else {
      {
      _1_patmatch_next = 11U;
      }
    }
    break;
    case 69: 
    tmp___4 = cond_lower(*buf___1);
    tmp___5 = cond_lower(*pat);
    {
    _1_patmatch_next = 55U;
    }
    break;
    case 8: ;
    if (! match) {
      {
      _1_patmatch_next = 1U;
      }
    } else {
      {
      _1_patmatch_next = 30U;
      }
    }
    break;
    case 96: 
    pat ++;
    {
    _1_patmatch_next = 58U;
    }
    break;
    case 45: ;
    return (-1);
    break;
    case 54: ;
    return (match);
    break;
    case 78: ;
    if ((int )*buf___1 == 47) {
      {
      _1_patmatch_next = 11U;
      }
    } else {
      {
      _1_patmatch_next = 46U;
      }
    }
    break;
    case 1: 
    match = patmatch(buf___1, bar + 1, isdir);
    {
    _1_patmatch_next = 30U;
    }
    break;
    case 81: ;
    return (match);
    break;
    case 77: 
    match = 0;
    {
    _1_patmatch_next = 10U;
    }
    break;
    case 16: 
    pat ++;
    {
    _1_patmatch_next = 0U;
    }
    break;
    case 24: ;
    if (! *buf___1) {
      {
      _1_patmatch_next = 34U;
      }
    } else {
      {
      _1_patmatch_next = 35U;
      }
    }
    break;
    case 94: ;
    return (0);
    break;
    case 36: 
    pat ++;
    {
    _1_patmatch_next = 15U;
    }
    break;
    case 76: 
    tmp___6 = strchr((char const   *)buf___1, '/');
    f = (unsigned long )tmp___6 == (unsigned long )((void *)0);
    {
    _1_patmatch_next = 79U;
    }
    break;
    case 57: ;
    if (*pat) {
      {
      _1_patmatch_next = 64U;
      }
    } else {
      {
      _1_patmatch_next = 5U;
      }
    }
    break;
    case 68: 
    match = patmatch(buf___1, pat, isdir);
    {
    _1_patmatch_next = 81U;
    }
    break;
    case 100: ;
    if (*pat) {
      {
      _1_patmatch_next = 29U;
      }
    } else {
      {
      _1_patmatch_next = 61U;
      }
    }
    break;
    case 26: 
    m = (int )*pat;
    pat += 2;
    {
    _1_patmatch_next = 22U;
    }
    break;
    case 105: ;
    if ((int )tmp___0 >= (int )tmp___1) {
      {
      _1_patmatch_next = 33U;
      }
    } else {
      {
      _1_patmatch_next = 51U;
      }
    }
    break;
    case 11: ;
    if (! match) {
      {
      _1_patmatch_next = 41U;
      }
    } else {
      {
      _1_patmatch_next = 81U;
      }
    }
    break;
    case 63: 
    tmp___0 = cond_lower(*buf___1);
    tmp___1 = cond_lower((char )m);
    {
    _1_patmatch_next = 105U;
    }
    break;
    case 51: ;
    if (! *pat) {
      {
      _1_patmatch_next = 87U;
      }
    } else {
      {
      _1_patmatch_next = 7U;
      }
    }
    break;
    case 32: 
    match = n;
    {
    _1_patmatch_next = 51U;
    }
    break;
    case 17: ;
    return (match);
    break;
    case 90: 
    match = patmatch(buf___1, pat + 1, isdir);
    {
    _1_patmatch_next = 89U;
    }
    break;
    case 40: 
    buf___1 ++;
    {
    _1_patmatch_next = 86U;
    }
    break;
    case 55: ;
    if ((int )tmp___4 == (int )tmp___5) {
      {
      _1_patmatch_next = 56U;
      }
    } else {
      {
      _1_patmatch_next = 7U;
      }
    }
    break;
    case 27: ;
    if (match) {
      {
      _1_patmatch_next = 11U;
      }
    } else {
      {
      _1_patmatch_next = 43U;
      }
    }
    break;
    case 38: 
    pat ++;
    {
    _1_patmatch_next = 47U;
    }
    break;
    case 61: 
    tmp___9 = buf___1;
    buf___1 ++;
    tmp___10 = cond_lower(*tmp___9);
    tmp___11 = cond_lower(*pat);
    match = (int )tmp___10 == (int )tmp___11;
    {
    _1_patmatch_next = 50U;
    }
    break;
    case 87: 
    pat --;
    {
    _1_patmatch_next = 7U;
    }
    break;
    case 58: ;
    if (! *pat) {
      {
      _1_patmatch_next = 76U;
      }
    } else {
      {
      _1_patmatch_next = 77U;
      }
    }
    break;
    case 84: 
    match = patmatch(buf___1, pat, isdir);
    {
    _1_patmatch_next = 27U;
    }
    break;
    case 34: ;
    return (0);
    break;
    case 74: ;
    if ((int )*pat == 47) {
      {
      _1_patmatch_next = 102U;
      }
    } else {
      {
      _1_patmatch_next = 14U;
      }
    }
    break;
    case 75: ;
    if ((int )*(pat + 1) == 45) {
      {
      _1_patmatch_next = 26U;
      }
    } else {
      {
      _1_patmatch_next = 69U;
      }
    }
    break;
    case 48: ;
    switch ((int )*pat) {
    case 91: 
    {
    _1_patmatch_next = 38U;
    }
    break;
    case 42: 
    {
    _1_patmatch_next = 96U;
    }
    break;
    case 63: 
    {
    _1_patmatch_next = 24U;
    }
    break;
    case 47: 
    {
    _1_patmatch_next = 20U;
    }
    break;
    case 92: 
    {
    _1_patmatch_next = 100U;
    }
    break;
    default: 
    {
    _1_patmatch_next = 61U;
    }
    break;
    }
    break;
    case 71: ;
    return (-1);
    break;
    case 22: ;
    if ((int )*pat == 92) {
      {
      _1_patmatch_next = 88U;
      }
    } else {
      {
      _1_patmatch_next = 63U;
      }
    }
    break;
    case 28: ;
    return (isdir);
    break;
    case 53: ;
    if ((int )*pat == 92) {
      {
      _1_patmatch_next = 36U;
      }
    } else {
      {
      _1_patmatch_next = 15U;
      }
    }
    break;
    case 65: ;
    if ((int )tmp___2 <= (int )tmp___3) {
      {
      _1_patmatch_next = 32U;
      }
    } else {
      {
      _1_patmatch_next = 51U;
      }
    }
    break;
    case 47: ;
    if ((int )*pat != 94) {
      {
      _1_patmatch_next = 4U;
      }
    } else {
      {
      _1_patmatch_next = 18U;
      }
    }
    break;
    case 73: ;
    return (1);
    break;
    case 44: 
    buf___1 ++;
    {
    _1_patmatch_next = 50U;
    }
    break;
    case 5: ;
    if (! *buf___1) {
      {
      _1_patmatch_next = 54U;
      }
    } else {
      {
      _1_patmatch_next = 94U;
      }
    }
    break;
    case 91: ;
    if (! ((int )*buf___1 != 47)) {
      {
      _1_patmatch_next = 101U;
      }
    } else {
      {
      _1_patmatch_next = 40U;
      }
    }
    break;
    case 97: ;
    return (match);
    break;
    case 99: 
    tmp___7 = buf___1;
    buf___1 ++;
    match = patmatch(tmp___7, pat, isdir);
    {
    _1_patmatch_next = 92U;
    }
    break;
    case 33: 
    tmp___2 = cond_lower(*buf___1);
    tmp___3 = cond_lower(*pat);
    {
    _1_patmatch_next = 65U;
    }
    break;
    case 37: 
    pat ++;
    {
    _1_patmatch_next = 63U;
    }
    break;
    case 64: ;
    if (! match) {
      {
      _1_patmatch_next = 5U;
      }
    } else {
      {
      _1_patmatch_next = 48U;
      }
    }
    break;
    case 41: ;
    if (! *buf___1) {
      {
      _1_patmatch_next = 68U;
      }
    } else {
      {
      _1_patmatch_next = 80U;
      }
    }
    break;
    case 92: ;
    if (match) {
      {
      _1_patmatch_next = 11U;
      }
    } else {
      {
      _1_patmatch_next = 78U;
      }
    }
    break;
    case 10: ;
    if ((int )*pat == 42) {
      {
      _1_patmatch_next = 16U;
      }
    } else {
      {
      _1_patmatch_next = 46U;
      }
    }
    break;
    case 42: ;
    if (match < 1) {
      {
      _1_patmatch_next = 97U;
      }
    } else {
      {
      _1_patmatch_next = 57U;
      }
    }
    break;
    case 0: ;
    if (! *pat) {
      {
      _1_patmatch_next = 73U;
      }
    } else {
      {
      _1_patmatch_next = 101U;
      }
    }
    break;
    case 46: ;
    if (*buf___1) {
      {
      _1_patmatch_next = 99U;
      }
    } else {
      {
      _1_patmatch_next = 11U;
      }
    }
    break;
    case 83: ;
    return (match);
    break;
    case 7: 
    pat ++;
    {
    _1_patmatch_next = 62U;
    }
    break;
    case 88: ;
    if (*pat) {
      {
      _1_patmatch_next = 37U;
      }
    } else {
      {
      _1_patmatch_next = 63U;
      }
    }
    break;
    case 35: 
    buf___1 ++;
    {
    _1_patmatch_next = 50U;
    }
    break;
    case 29: 
    pat ++;
    {
    _1_patmatch_next = 61U;
    }
    break;
    case 43: ;
    if ((int )pprev == 47) {
      {
      _1_patmatch_next = 74U;
      }
    } else {
      {
      _1_patmatch_next = 14U;
      }
    }
    break;
    case 86: ;
    if (*buf___1) {
      {
      _1_patmatch_next = 91U;
      }
    } else {
      {
      _1_patmatch_next = 101U;
      }
    }
    break;
    case 2: 
    match = patmatch(buf___1, pat, isdir);
    {
    _1_patmatch_next = 81U;
    }
    break;
    case 20: ;
    if (! *(pat + 1)) {
      {
      _1_patmatch_next = 106U;
      }
    } else {
      {
      _1_patmatch_next = 52U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF patmatch LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF listdir LOC=UNKNOWN */
struct totals listdir(char *dirname , struct _info **dir , int lev , dev_t dev , bool hasfulltree ) 
{ 
  struct totals tot ;
  struct totals subtotal ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **subdir ;
  int descend ;
  int htmldescend ;
  int found ;
  int n ;
  int dirlen ;
  size_t___0 tmp ;
  int pathlen ;
  int needsclosed ;
  char *path___0 ;
  char *newpath ;
  char *filename ;
  char *err ;
  int es ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  FILE *outsave ;
  char *paths[2] ;
  char *output ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  int *dirsave ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct totals addEndReturn36 ;
  unsigned int _1_listdir_next ;

  {
  {
  _1_listdir_next = 64U;
  }
  while (1) {
    switch (_1_listdir_next) {
    case 18: ;
    if (needsclosed) {
      {
      _1_listdir_next = 86U;
      }
    } else {
      {
      _1_listdir_next = 14U;
      }
    }
    break;
    case 50: ;
    if (! *(dir + 2)) {
      {
      _1_listdir_next = 12U;
      }
    } else {
      {
      _1_listdir_next = 41U;
      }
    }
    break;
    case 80: 
    err = errbuf;
    sprintf((char *)((char */* __restrict  */)err), (char const   *)((char const   */* __restrict  */)"%d entries exceeds filelimit, not opening dir"),
            n);
    errors ++;
    free_dir(subdir);
    subdir = (struct _info **)((void *)0);
    {
    _1_listdir_next = 6U;
    }
    break;
    case 25: 
    (*(lc.error))(err);
    {
    _1_listdir_next = 44U;
    }
    break;
    case 49: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
            dirname, (*dir)->name);
    {
    _1_listdir_next = 69U;
    }
    break;
    case 52: 
    tmp___6 = 1;
    {
    _1_listdir_next = 57U;
    }
    break;
    case 4: ;
    if (n) {
      {
      _1_listdir_next = 70U;
      }
    } else {
      {
      _1_listdir_next = 39U;
      }
    }
    break;
    case 30: 
    newpath = (*dir)->lnk;
    {
    _1_listdir_next = 76U;
    }
    break;
    case 62: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            dirname, (*dir)->lnk);
    {
    _1_listdir_next = 76U;
    }
    break;
    case 14: ;
    if (*(dir + 1)) {
      {
      _1_listdir_next = 50U;
      }
    } else {
      {
      _1_listdir_next = 41U;
      }
    }
    break;
    case 15: 
    *(dirs + lev) = 0;
    free((void *)path___0);
    {
    _1_listdir_next = 71U;
    }
    break;
    case 82: ;
    if ((int )*((*dir)->lnk) == 47) {
      {
      _1_listdir_next = 30U;
      }
    } else {
      {
      _1_listdir_next = 91U;
      }
    }
    break;
    case 89: 
    subdir = (*dir)->child;
    err = (*dir)->err;
    {
    _1_listdir_next = 6U;
    }
    break;
    case 56: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            dirname, (*dir)->name);
    {
    _1_listdir_next = 69U;
    }
    break;
    case 79: ;
    if (subdir) {
      {
      _1_listdir_next = 19U;
      }
    } else {
      {
      _1_listdir_next = 18U;
      }
    }
    break;
    case 31: ;
    if (Jflag) {
      {
      _1_listdir_next = 48U;
      }
    } else {
      {
      _1_listdir_next = 32U;
      }
    }
    break;
    case 12: 
    *(dirs + lev) = 2;
    {
    _1_listdir_next = 41U;
    }
    break;
    case 69: ;
    if (fflag) {
      {
      _1_listdir_next = 51U;
      }
    } else {
      {
      _1_listdir_next = 47U;
      }
    }
    break;
    case 8: ;
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
      {
      _1_listdir_next = 53U;
      }
    } else {
      {
      _1_listdir_next = 93U;
      }
    }
    break;
    case 45: 
    (*(lc.newline))(*dir, lev, 0, (unsigned long )*(dir + 1) != (unsigned long )((void *)0));
    {
    _1_listdir_next = 79U;
    }
    break;
    case 78: ;
    if (*(dir + n)) {
      {
      _1_listdir_next = 11U;
      }
    } else {
      {
      _1_listdir_next = 22U;
      }
    }
    break;
    case 1: 
    *(dirs + lev) = 1;
    {
    _1_listdir_next = 37U;
    }
    break;
    case 81: 
    saveino((*dir)->inode, (*dir)->dev);
    {
    _1_listdir_next = 90U;
    }
    break;
    case 23: ;
    if (! found) {
      {
      _1_listdir_next = 81U;
      }
    } else {
      {
      _1_listdir_next = 90U;
      }
    }
    break;
    case 77: 
    tmp___7 = lev;
    {
    _1_listdir_next = 2U;
    }
    break;
    case 70: 
    err = (char *)"error opening dir";
    errors ++;
    {
    _1_listdir_next = 39U;
    }
    break;
    case 3: ;
    if ((unsigned long )*dir != (unsigned long )((void *)0)) {
      {
      _1_listdir_next = 34U;
      }
    } else {
      {
      _1_listdir_next = 15U;
      }
    }
    break;
    case 16: ;
    if (*(dir + 1)) {
      {
      _1_listdir_next = 1U;
      }
    } else {
      {
      _1_listdir_next = 42U;
      }
    }
    break;
    case 24: 
    push_files(newpath, & ig, & inf);
    subdir = read_dir(newpath, & n, (unsigned long )inf != (unsigned long )((void *)0));
    {
    _1_listdir_next = 85U;
    }
    break;
    case 21: 
    tmp___7 = -1;
    {
    _1_listdir_next = 2U;
    }
    break;
    case 36: 
    qsort((void *)dir, (size_t___1 )n, sizeof(struct _info *), (int (*)(void const   * ,
                                                                        void const   * ))topsort);
    {
    _1_listdir_next = 16U;
    }
    break;
    case 76: ;
    if (found) {
      {
      _1_listdir_next = 55U;
      }
    } else {
      {
      _1_listdir_next = 87U;
      }
    }
    break;
    case 57: 
    needsclosed = (*(lc.printfile))(dirname, filename, *dir, (descend + htmldescend) + tmp___6);
    {
    _1_listdir_next = 63U;
    }
    break;
    case 68: 
    outsave = outfile;
    paths[0] = newpath;
    paths[1] = (char *)((void *)0);
    tmp___3 = strlen((char const   *)newpath);
    tmp___4 = xmalloc(tmp___3 + 13UL);
    output = (char *)tmp___4;
    tmp___5 = xmalloc(sizeof(int ) * (unsigned long )(lev + 2));
    dirsave = (int *)tmp___5;
    memcpy((void */* __restrict  */)dirsave, (void const   */* __restrict  */)dirs,
           sizeof(int ) * (unsigned long )(lev + 1));
    sprintf((char *)((char */* __restrict  */)output), (char const   *)((char const   */* __restrict  */)"%s/00Tree.html"),
            newpath);
    setoutput(output);
    emit_tree(paths, hasfulltree);
    free((void *)output);
    fclose(outfile);
    outfile = outsave;
    memcpy((void */* __restrict  */)dirs, (void const   */* __restrict  */)dirsave,
           sizeof(int ) * (unsigned long )(lev + 1));
    free((void *)dirsave);
    htmldescend = 10;
    {
    _1_listdir_next = 26U;
    }
    break;
    case 85: ;
    if (! subdir) {
      {
      _1_listdir_next = 4U;
      }
    } else {
      {
      _1_listdir_next = 39U;
      }
    }
    break;
    case 26: 
    descend = 0;
    {
    _1_listdir_next = 83U;
    }
    break;
    case 11: 
    n ++;
    {
    _1_listdir_next = 78U;
    }
    break;
    case 13: 
    ig = pop_filterstack();
    {
    _1_listdir_next = 8U;
    }
    break;
    case 63: ;
    if (err) {
      {
      _1_listdir_next = 25U;
      }
    } else {
      {
      _1_listdir_next = 44U;
      }
    }
    break;
    case 51: 
    filename = path___0;
    {
    _1_listdir_next = 66U;
    }
    break;
    case 19: 
    free_dir(subdir);
    subdir = (struct _info **)((void *)0);
    {
    _1_listdir_next = 18U;
    }
    break;
    case 32: 
    tmp___6 = 0;
    {
    _1_listdir_next = 57U;
    }
    break;
    case 17: ;
    if ((unsigned long )ig != (unsigned long )((void *)0)) {
      {
      _1_listdir_next = 13U;
      }
    } else {
      {
      _1_listdir_next = 8U;
      }
    }
    break;
    case 90: ;
    if (xdev) {
      {
      _1_listdir_next = 40U;
      }
    } else {
      {
      _1_listdir_next = 58U;
      }
    }
    break;
    case 40: ;
    if (! (dev != (*dir)->dev)) {
      {
      _1_listdir_next = 58U;
      }
    } else {
      {
      _1_listdir_next = 31U;
      }
    }
    break;
    case 67: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
            dirname, (*dir)->lnk);
    {
    _1_listdir_next = 76U;
    }
    break;
    case 55: 
    err = (char *)"recursive, not followed";
    descend = 0;
    {
    _1_listdir_next = 87U;
    }
    break;
    case 60: 
    (*(lc.newline))(*dir, lev, 0, 0);
    subtotal = listdir(newpath, subdir, lev + 1, dev, hasfulltree);
    tot.dirs += subtotal.dirs;
    tot.files += subtotal.files;
    tot.size += subtotal.size;
    {
    _1_listdir_next = 79U;
    }
    break;
    case 59: ;
    if ((*dir)->isdir) {
      {
      _1_listdir_next = 84U;
      }
    } else {
      {
      _1_listdir_next = 0U;
      }
    }
    break;
    case 6: ;
    if ((unsigned long )subdir == (unsigned long )((void *)0)) {
      {
      _1_listdir_next = 29U;
      }
    } else {
      {
      _1_listdir_next = 31U;
      }
    }
    break;
    case 61: ;
    if (lflag) {
      {
      _1_listdir_next = 35U;
      }
    } else {
      {
      _1_listdir_next = 31U;
      }
    }
    break;
    case 87: ;
    if (Level >= 0) {
      {
      _1_listdir_next = 7U;
      }
    } else {
      {
      _1_listdir_next = 83U;
      }
    }
    break;
    case 58: 
    _L___0: ;
    if (! (*dir)->lnk) {
      {
      _1_listdir_next = 35U;
      }
    } else {
      {
      _1_listdir_next = 88U;
      }
    }
    break;
    case 84: 
    (tot.dirs) ++;
    found = findino((*dir)->inode, (*dir)->dev);
    {
    _1_listdir_next = 23U;
    }
    break;
    case 34: 
    (*(lc.printinfo))(dirname, *dir, lev);
    {
    _1_listdir_next = 28U;
    }
    break;
    case 74: ;
    if ((*dir)->lnk) {
      {
      _1_listdir_next = 82U;
      }
    } else {
      {
      _1_listdir_next = 87U;
      }
    }
    break;
    case 75: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            dirname, (*dir)->lnk);
    {
    _1_listdir_next = 76U;
    }
    break;
    case 48: ;
    if (errors) {
      {
      _1_listdir_next = 52U;
      }
    } else {
      {
      _1_listdir_next = 92U;
      }
    }
    break;
    case 71: ;
    return (tot);
    break;
    case 22: ;
    if (topsort) {
      {
      _1_listdir_next = 36U;
      }
    } else {
      {
      _1_listdir_next = 16U;
      }
    }
    break;
    case 28: ;
    if (es) {
      {
      _1_listdir_next = 49U;
      }
    } else {
      {
      _1_listdir_next = 56U;
      }
    }
    break;
    case 53: 
    inf = pop_infostack();
    {
    _1_listdir_next = 93U;
    }
    break;
    case 65: ;
    if (! needsclosed) {
      {
      _1_listdir_next = 45U;
      }
    } else {
      {
      _1_listdir_next = 79U;
      }
    }
    break;
    case 47: 
    filename = (*dir)->name;
    {
    _1_listdir_next = 66U;
    }
    break;
    case 44: ;
    if (descend) {
      {
      _1_listdir_next = 60U;
      }
    } else {
      {
      _1_listdir_next = 65U;
      }
    }
    break;
    case 5: ;
    if (tmp___2) {
      {
      _1_listdir_next = 62U;
      }
    } else {
      {
      _1_listdir_next = 67U;
      }
    }
    break;
    case 91: ;
    if (fflag) {
      {
      _1_listdir_next = 46U;
      }
    } else {
      {
      _1_listdir_next = 75U;
      }
    }
    break;
    case 72: ;
    if (Rflag) {
      {
      _1_listdir_next = 68U;
      }
    } else {
      {
      _1_listdir_next = 20U;
      }
    }
    break;
    case 33: ;
    if (hasfulltree) {
      {
      _1_listdir_next = 89U;
      }
    } else {
      {
      _1_listdir_next = 24U;
      }
    }
    break;
    case 37: 
    tmp___1 = xmalloc(sizeof(char ) * (unsigned long )pathlen);
    path___0 = (char *)tmp___1;
    {
    _1_listdir_next = 3U;
    }
    break;
    case 64: 
    tot.files = (u_long )0;
    tot.dirs = 0UL;
    tot.size = 0LL;
    ig = (struct ignorefile *)((void *)0);
    inf = (struct infofile *)((void *)0);
    subdir = (struct _info **)((void *)0);
    htmldescend = 0;
    tmp = strlen((char const   *)dirname);
    dirlen = (int )tmp;
    pathlen = dirlen + 257;
    err = (char *)((void *)0);
    tmp___0 = strlen((char const   *)dirname);
    es = (int )*(dirname + (tmp___0 - 1UL)) == 47;
    n = 0;
    {
    _1_listdir_next = 78U;
    }
    break;
    case 93: 
    dir ++;
    {
    _1_listdir_next = 3U;
    }
    break;
    case 41: 
    tot.size += (*dir)->size;
    {
    _1_listdir_next = 17U;
    }
    break;
    case 92: 
    tmp___6 = 0;
    {
    _1_listdir_next = 57U;
    }
    break;
    case 42: 
    *(dirs + lev) = 2;
    {
    _1_listdir_next = 37U;
    }
    break;
    case 0: 
    (tot.files) ++;
    {
    _1_listdir_next = 31U;
    }
    break;
    case 46: 
    tmp___2 = strcmp((char const   *)dirname, "/");
    {
    _1_listdir_next = 5U;
    }
    break;
    case 39: ;
    if (flimit > 0) {
      {
      _1_listdir_next = 43U;
      }
    } else {
      {
      _1_listdir_next = 6U;
      }
    }
    break;
    case 66: 
    descend = 0;
    err = (char *)((void *)0);
    {
    _1_listdir_next = 59U;
    }
    break;
    case 83: ;
    if (descend) {
      {
      _1_listdir_next = 33U;
      }
    } else {
      {
      _1_listdir_next = 31U;
      }
    }
    break;
    case 7: ;
    if (lev > Level) {
      {
      _1_listdir_next = 72U;
      }
    } else {
      {
      _1_listdir_next = 83U;
      }
    }
    break;
    case 88: ;
    if ((*dir)->lnk) {
      {
      _1_listdir_next = 61U;
      }
    } else {
      {
      _1_listdir_next = 31U;
      }
    }
    break;
    case 35: 
    _L: 
    descend = 1;
    newpath = path___0;
    {
    _1_listdir_next = 74U;
    }
    break;
    case 29: 
    descend = 0;
    {
    _1_listdir_next = 31U;
    }
    break;
    case 43: ;
    if (n > flimit) {
      {
      _1_listdir_next = 80U;
      }
    } else {
      {
      _1_listdir_next = 6U;
      }
    }
    break;
    case 86: ;
    if (descend) {
      {
      _1_listdir_next = 77U;
      }
    } else {
      {
      _1_listdir_next = 21U;
      }
    }
    break;
    case 2: 
    (*(lc.close))(*dir, tmp___7, (unsigned long )*(dir + 1) != (unsigned long )((void *)0));
    {
    _1_listdir_next = 14U;
    }
    break;
    case 20: 
    htmldescend = 0;
    {
    _1_listdir_next = 26U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF listdir LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF do_date LOC=UNKNOWN */
char *do_date(time_t t ) 
{ 
  struct tm *tm ;
  time_t c ;
  time_t tmp ;
  unsigned int _1_do_date_next ;

  {
  {
  _1_do_date_next = 7U;
  }
  while (1) {
    switch (_1_do_date_next) {
    case 4: ;
    if (t + 16070400LL < c) {
      {
      _1_do_date_next = 1U;
      }
    } else {
      {
      _1_do_date_next = 2U;
      }
    }
    break;
    case 8: ;
    if (timefmt) {
      {
      _1_do_date_next = 0U;
      }
    } else {
      {
      _1_do_date_next = 3U;
      }
    }
    break;
    case 1: 
    strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)"%b %e  %Y",
             (struct tm  const  */* __restrict  */)tm);
    {
    _1_do_date_next = 5U;
    }
    break;
    case 3: 
    tmp = time((time_t *)0);
    c = tmp;
    {
    _1_do_date_next = 6U;
    }
    break;
    case 9: 
    strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)"%b %e  %Y",
             (struct tm  const  */* __restrict  */)tm);
    {
    _1_do_date_next = 5U;
    }
    break;
    case 6: ;
    if (t > c) {
      {
      _1_do_date_next = 9U;
      }
    } else {
      {
      _1_do_date_next = 4U;
      }
    }
    break;
    case 5: ;
    return (buf___0);
    break;
    case 0: 
    strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)timefmt,
             (struct tm  const  */* __restrict  */)tm);
    buf___0[255] = (char)0;
    {
    _1_do_date_next = 5U;
    }
    break;
    case 7: 
    tm = localtime((time_t const   *)(& t));
    {
    _1_do_date_next = 8U;
    }
    break;
    case 2: 
    strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)"%b %e %R",
             (struct tm  const  */* __restrict  */)tm);
    {
    _1_do_date_next = 5U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF do_date LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_infofile LOC=UNKNOWN */
struct infofile *new_infofile(char *path___0 ) 
{ 
  char buf___1[4096] ;
  struct infofile *inf ;
  struct comment *chead ;
  struct comment *cend ;
  struct comment *com ;
  struct pattern *phead ;
  struct pattern *pend ;
  struct pattern *p ;
  char *line[4096] ;
  FILE *fp ;
  int lines ;
  int tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  struct comment *tmp___4 ;
  int i ;
  struct pattern *tmp___5 ;
  char *tmp___6 ;
  struct comment *tmp___7 ;
  int i___0 ;
  void *tmp___8 ;
  size_t___0 tmp___9 ;
  void *tmp___10 ;
  unsigned int _1_new_infofile_next ;

  {
  {
  _1_new_infofile_next = 24U;
  }
  while (1) {
    switch (_1_new_infofile_next) {
    case 25: 
    pend = p;
    phead = pend;
    {
    _1_new_infofile_next = 30U;
    }
    break;
    case 4: 
    fclose(fp);
    tmp___8 = xmalloc(sizeof(struct infofile ));
    inf = (struct infofile *)tmp___8;
    inf->comments = chead;
    tmp___9 = strlen((char const   *)path___0);
    tmp___10 = xmalloc(tmp___9 + 1UL);
    inf->path = strcpy((char *)((char */* __restrict  */)tmp___10), (char const   *)((char const   */* __restrict  */)path___0));
    inf->next = (struct infofile *)((void *)0);
    {
    _1_new_infofile_next = 2U;
    }
    break;
    case 30: 
    tmp___6 = fgets((char *)((char */* __restrict  */)(buf___1)), 4096, (FILE *)((FILE */* __restrict  */)fp));
    {
    _1_new_infofile_next = 33U;
    }
    break;
    case 14: ;
    if (i___0 < lines) {
      {
      _1_new_infofile_next = 39U;
      }
    } else {
      {
      _1_new_infofile_next = 4U;
      }
    }
    break;
    case 15: ;
    if (! chead) {
      {
      _1_new_infofile_next = 1U;
      }
    } else {
      {
      _1_new_infofile_next = 6U;
      }
    }
    break;
    case 12: ;
    if (lines) {
      {
      _1_new_infofile_next = 19U;
      }
    } else {
      {
      _1_new_infofile_next = 16U;
      }
    }
    break;
    case 8: 
    fp = fopen((char const   *)((char const   */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"r"));
    {
    _1_new_infofile_next = 9U;
    }
    break;
    case 1: 
    cend = com;
    chead = cend;
    {
    _1_new_infofile_next = 4U;
    }
    break;
    case 3: ;
    if (tmp == 0) {
      {
      _1_new_infofile_next = 8U;
      }
    } else {
      {
      _1_new_infofile_next = 29U;
      }
    }
    break;
    case 16: 
    p = new_pattern(buf___1);
    {
    _1_new_infofile_next = 21U;
    }
    break;
    case 24: 
    chead = (struct comment *)((void *)0);
    cend = (struct comment *)((void *)0);
    phead = (struct pattern *)((void *)0);
    pend = (struct pattern *)((void *)0);
    lines = 0;
    tmp = strcmp((char const   *)path___0, "/usr/share/finfo/global_info");
    {
    _1_new_infofile_next = 3U;
    }
    break;
    case 21: ;
    if ((unsigned long )phead == (unsigned long )((void *)0)) {
      {
      _1_new_infofile_next = 25U;
      }
    } else {
      {
      _1_new_infofile_next = 27U;
      }
    }
    break;
    case 36: ;
    if (tmp___0 < 1UL) {
      {
      _1_new_infofile_next = 30U;
      }
    } else {
      {
      _1_new_infofile_next = 0U;
      }
    }
    break;
    case 11: 
    gittrim(buf___1);
    tmp___0 = strlen((char const   *)(buf___1));
    {
    _1_new_infofile_next = 36U;
    }
    break;
    case 9: ;
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
      _1_new_infofile_next = 32U;
      }
    } else {
      {
      _1_new_infofile_next = 30U;
      }
    }
    break;
    case 19: ;
    if (phead) {
      {
      _1_new_infofile_next = 7U;
      }
    } else {
      {
      _1_new_infofile_next = 20U;
      }
    }
    break;
    case 32: ;
    return ((struct infofile *)((void *)0));
    break;
    case 17: ;
    if ((int )buf___1[0] == 35) {
      {
      _1_new_infofile_next = 30U;
      }
    } else {
      {
      _1_new_infofile_next = 11U;
      }
    }
    break;
    case 40: 
    tmp___1 = lines;
    lines ++;
    tmp___2 = strlen((char const   *)(buf___1 + 1));
    tmp___3 = xmalloc(tmp___2 + 1UL);
    line[tmp___1] = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(buf___1 + 1)));
    {
    _1_new_infofile_next = 30U;
    }
    break;
    case 6: 
    tmp___7 = com;
    cend->next = tmp___7;
    cend = tmp___7;
    {
    _1_new_infofile_next = 4U;
    }
    break;
    case 27: 
    tmp___5 = p;
    pend->next = tmp___5;
    pend = tmp___5;
    {
    _1_new_infofile_next = 30U;
    }
    break;
    case 38: 
    free((void *)line[i]);
    i ++;
    {
    _1_new_infofile_next = 43U;
    }
    break;
    case 34: 
    pend = (struct pattern *)((void *)0);
    phead = pend;
    lines = 0;
    {
    _1_new_infofile_next = 16U;
    }
    break;
    case 22: 
    cend = com;
    chead = cend;
    {
    _1_new_infofile_next = 34U;
    }
    break;
    case 28: 
    com = new_comment(phead, line, lines);
    {
    _1_new_infofile_next = 15U;
    }
    break;
    case 44: 
    i___0 = 0;
    {
    _1_new_infofile_next = 14U;
    }
    break;
    case 5: ;
    if (phead) {
      {
      _1_new_infofile_next = 28U;
      }
    } else {
      {
      _1_new_infofile_next = 44U;
      }
    }
    break;
    case 33: ;
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
      {
      _1_new_infofile_next = 5U;
      }
    } else {
      {
      _1_new_infofile_next = 17U;
      }
    }
    break;
    case 41: 
    tmp___4 = com;
    cend->next = tmp___4;
    cend = tmp___4;
    {
    _1_new_infofile_next = 34U;
    }
    break;
    case 0: ;
    if ((int )buf___1[0] == 9) {
      {
      _1_new_infofile_next = 40U;
      }
    } else {
      {
      _1_new_infofile_next = 12U;
      }
    }
    break;
    case 39: 
    free((void *)line[i___0]);
    i___0 ++;
    {
    _1_new_infofile_next = 14U;
    }
    break;
    case 7: 
    com = new_comment(phead, line, lines);
    {
    _1_new_infofile_next = 35U;
    }
    break;
    case 35: ;
    if (! chead) {
      {
      _1_new_infofile_next = 22U;
      }
    } else {
      {
      _1_new_infofile_next = 41U;
      }
    }
    break;
    case 29: 
    snprintf((char *)((char */* __restrict  */)(buf___1)), (size_t___0 )4096, (char const   *)((char const   */* __restrict  */)"%s/.info"),
             path___0);
    fp = fopen((char const   *)((char const   */* __restrict  */)(buf___1)), (char const   *)((char const   */* __restrict  */)"r"));
    {
    _1_new_infofile_next = 9U;
    }
    break;
    case 43: ;
    if (i < lines) {
      {
      _1_new_infofile_next = 38U;
      }
    } else {
      {
      _1_new_infofile_next = 34U;
      }
    }
    break;
    case 2: ;
    return (inf);
    break;
    case 20: 
    i = 0;
    {
    _1_new_infofile_next = 43U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF new_infofile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_printfile LOC=UNKNOWN */
int html_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  char *tmp ;
  int i ;
  int len ;
  size_t___0 tmp___0 ;
  int off ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned int _1_html_printfile_next ;

  {
  {
  _1_html_printfile_next = 12U;
  }
  while (1) {
    switch (_1_html_printfile_next) {
    case 18: 
    tmp = class(file);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" class=\"%s\""),
            tmp);
    {
    _1_html_printfile_next = 23U;
    }
    break;
    case 25: 
    tmp___1 = 0;
    {
    _1_html_printfile_next = 32U;
    }
    break;
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
    {
    _1_html_printfile_next = 15U;
    }
    break;
    case 30: ;
    if (descend > 1) {
      {
      _1_html_printfile_next = 9U;
      }
    } else {
      {
      _1_html_printfile_next = 0U;
      }
    }
    break;
    case 14: ;
    if (dirname) {
      {
      _1_html_printfile_next = 33U;
      }
    } else {
      {
      _1_html_printfile_next = 20U;
      }
    }
    break;
    case 15: 
    i ++;
    {
    _1_html_printfile_next = 17U;
    }
    break;
    case 31: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s\""),
            tmp___4);
    {
    _1_html_printfile_next = 27U;
    }
    break;
    case 12: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<a"));
    {
    _1_html_printfile_next = 26U;
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\""));
    {
    _1_html_printfile_next = 34U;
    }
    break;
    case 23: ;
    if (file->comment) {
      {
      _1_html_printfile_next = 5U;
      }
    } else {
      {
      _1_html_printfile_next = 34U;
      }
    }
    break;
    case 3: 
    tmp___0 = strlen((char const   *)dirname);
    len = (int )tmp___0;
    {
    _1_html_printfile_next = 37U;
    }
    break;
    case 16: 
    tmp___3 = (char *)"";
    {
    _1_html_printfile_next = 22U;
    }
    break;
    case 24: ;
    if (force_color) {
      {
      _1_html_printfile_next = 18U;
      }
    } else {
      {
      _1_html_printfile_next = 23U;
      }
    }
    break;
    case 21: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" href=\"%s"),
            host);
    {
    _1_html_printfile_next = 29U;
    }
    break;
    case 36: 
    tmp___1 = htmldirlen;
    {
    _1_html_printfile_next = 32U;
    }
    break;
    case 26: ;
    if (file) {
      {
      _1_html_printfile_next = 24U;
      }
    } else {
      {
      _1_html_printfile_next = 27U;
      }
    }
    break;
    case 11: ;
    if (descend > 1) {
      {
      _1_html_printfile_next = 19U;
      }
    } else {
      {
      _1_html_printfile_next = 16U;
      }
    }
    break;
    case 9: 
    tmp___4 = (char *)"/00Tree.html";
    {
    _1_html_printfile_next = 31U;
    }
    break;
    case 13: 
    html_encode(outfile, *(file->comment + i));
    {
    _1_html_printfile_next = 38U;
    }
    break;
    case 19: 
    tmp___3 = (char *)"/00Tree.html";
    {
    _1_html_printfile_next = 22U;
    }
    break;
    case 32: 
    off = tmp___1;
    url_encode(outfile, dirname + off);
    putc('/', outfile);
    url_encode(outfile, filename);
    {
    _1_html_printfile_next = 2U;
    }
    break;
    case 17: ;
    if (*(file->comment + i)) {
      {
      _1_html_printfile_next = 13U;
      }
    } else {
      {
      _1_html_printfile_next = 1U;
      }
    }
    break;
    case 6: 
    tmp___2 = (char *)"";
    {
    _1_html_printfile_next = 11U;
    }
    break;
    case 27: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)">"));
    {
    _1_html_printfile_next = 14U;
    }
    break;
    case 38: ;
    if (*(file->comment + (i + 1))) {
      {
      _1_html_printfile_next = 4U;
      }
    } else {
      {
      _1_html_printfile_next = 15U;
      }
    }
    break;
    case 34: ;
    if (! nolinks) {
      {
      _1_html_printfile_next = 21U;
      }
    } else {
      {
      _1_html_printfile_next = 27U;
      }
    }
    break;
    case 22: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s\""),
            tmp___3, tmp___2);
    {
    _1_html_printfile_next = 27U;
    }
    break;
    case 28: ;
    return (0);
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" title=\""));
    i = 0;
    {
    _1_html_printfile_next = 17U;
    }
    break;
    case 33: 
    html_encode(outfile, filename);
    {
    _1_html_printfile_next = 10U;
    }
    break;
    case 37: ;
    if (len >= htmldirlen) {
      {
      _1_html_printfile_next = 36U;
      }
    } else {
      {
      _1_html_printfile_next = 25U;
      }
    }
    break;
    case 10: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</a>"));
    {
    _1_html_printfile_next = 28U;
    }
    break;
    case 0: 
    tmp___4 = (char *)"";
    {
    _1_html_printfile_next = 31U;
    }
    break;
    case 35: 
    tmp___2 = (char *)"/";
    {
    _1_html_printfile_next = 11U;
    }
    break;
    case 29: ;
    if ((unsigned long )dirname != (unsigned long )((void *)0)) {
      {
      _1_html_printfile_next = 3U;
      }
    } else {
      {
      _1_html_printfile_next = 30U;
      }
    }
    break;
    case 2: ;
    if (file->isdir) {
      {
      _1_html_printfile_next = 35U;
      }
    } else {
      {
      _1_html_printfile_next = 6U;
      }
    }
    break;
    case 20: 
    html_encode(outfile, host);
    {
    _1_html_printfile_next = 10U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF push_infostack LOC=UNKNOWN */
void push_infostack(struct infofile *inf ) 
{ 
  unsigned int _1_push_infostack_next ;

  {
  {
  _1_push_infostack_next = 2U;
  }
  while (1) {
    switch (_1_push_infostack_next) {
    case 1: ;
    return;
    break;
    case 3: 
    inf->next = infostack;
    infostack = inf;
    {
    _1_push_infostack_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    case 2: ;
    if ((unsigned long )inf == (unsigned long )((void *)0)) {
      {
      _1_push_infostack_next = 1U;
      }
    } else {
      {
      _1_push_infostack_next = 3U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF push_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gidtoname LOC=UNKNOWN */
char *gidtoname(gid_t gid ) 
{ 
  struct xtable *o ;
  struct xtable *p ;
  struct xtable *t ;
  struct group *ent ;
  char gbuf[32] ;
  int gent ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  unsigned int _1_gidtoname_next ;

  {
  {
  _1_gidtoname_next = 9U;
  }
  while (1) {
    switch (_1_gidtoname_next) {
    case 4: 
    tmp___0 = strlen((char const   *)ent->gr_name);
    tmp___1 = xmalloc(tmp___0 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___1), (char const   *)((char const   */* __restrict  */)ent->gr_name));
    {
    _1_gidtoname_next = 2U;
    }
    break;
    case 15: ;
    if (gid == p->xid) {
      {
      _1_gidtoname_next = 17U;
      }
    } else {
      {
      _1_gidtoname_next = 1U;
      }
    }
    break;
    case 12: ;
    if (p) {
      {
      _1_gidtoname_next = 15U;
      }
    } else {
      {
      _1_gidtoname_next = 0U;
      }
    }
    break;
    case 8: 
    o = p;
    p = p->nxt;
    {
    _1_gidtoname_next = 12U;
    }
    break;
    case 1: ;
    if (gid < p->xid) {
      {
      _1_gidtoname_next = 0U;
      }
    } else {
      {
      _1_gidtoname_next = 8U;
      }
    }
    break;
    case 3: 
    gtable[gent] = t;
    {
    _1_gidtoname_next = 6U;
    }
    break;
    case 16: 
    snprintf((char *)((char */* __restrict  */)(gbuf)), (size_t___0 )30, (char const   *)((char const   */* __restrict  */)"%d"),
             gid);
    gbuf[31] = (char)0;
    tmp___2 = strlen((char const   *)(gbuf));
    tmp___3 = xmalloc(tmp___2 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(gbuf)));
    {
    _1_gidtoname_next = 2U;
    }
    break;
    case 9: 
    gent = (int )(gid & 255U);
    p = gtable[gent];
    o = p;
    {
    _1_gidtoname_next = 12U;
    }
    break;
    case 13: 
    o->nxt = t;
    {
    _1_gidtoname_next = 6U;
    }
    break;
    case 17: ;
    return (p->name);
    break;
    case 6: ;
    return (t->name);
    break;
    case 5: ;
    if ((unsigned long )p == (unsigned long )gtable[gent]) {
      {
      _1_gidtoname_next = 3U;
      }
    } else {
      {
      _1_gidtoname_next = 13U;
      }
    }
    break;
    case 10: ;
    if ((unsigned long )ent != (unsigned long )((void *)0)) {
      {
      _1_gidtoname_next = 4U;
      }
    } else {
      {
      _1_gidtoname_next = 16U;
      }
    }
    break;
    case 0: 
    tmp = xmalloc(sizeof(struct xtable ));
    t = (struct xtable *)tmp;
    ent = getgrgid(gid);
    {
    _1_gidtoname_next = 10U;
    }
    break;
    case 2: 
    t->xid = gid;
    t->nxt = p;
    {
    _1_gidtoname_next = 5U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gidtoname LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_close LOC=UNKNOWN */
void json_close(struct _info *file , int level , int needcomma ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int _1_json_close_next ;

  {
  {
  _1_json_close_next = 1U;
  }
  while (1) {
    switch (_1_json_close_next) {
    case 4: 
    tmp = (char *)"";
    {
    _1_json_close_next = 3U;
    }
    break;
    case 8: 
    tmp = (char *)"\n";
    {
    _1_json_close_next = 3U;
    }
    break;
    case 1: ;
    if (! noindent) {
      {
      _1_json_close_next = 0U;
      }
    } else {
      {
      _1_json_close_next = 7U;
      }
    }
    break;
    case 3: ;
    if (needcomma) {
      {
      _1_json_close_next = 2U;
      }
    } else {
      {
      _1_json_close_next = 5U;
      }
    }
    break;
    case 9: ;
    return;
    break;
    case 6: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"]}%s%s"),
            tmp___0, tmp);
    {
    _1_json_close_next = 9U;
    }
    break;
    case 5: 
    tmp___0 = (char *)"";
    {
    _1_json_close_next = 6U;
    }
    break;
    case 0: 
    json_indent(level - 1);
    {
    _1_json_close_next = 7U;
    }
    break;
    case 7: ;
    if (noindent) {
      {
      _1_json_close_next = 4U;
      }
    } else {
      {
      _1_json_close_next = 8U;
      }
    }
    break;
    case 2: 
    tmp___0 = (char *)",";
    {
    _1_json_close_next = 6U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_getfulltree LOC=UNKNOWN */
struct _info **unix_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) 
{ 
  char *path___0 ;
  long pathsize___0 ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **dir ;
  struct _info **sav ;
  struct _info **p ;
  struct _info *sp___0 ;
  struct stat sb ;
  int n ;
  u_long lev_tmp ;
  int tmp_pattern ;
  char *start_rel_path ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t___0 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  size_t___0 tmp___10 ;
  size_t___0 tmp___11 ;
  void *tmp___12 ;
  size_t___0 tmp___13 ;
  size_t___0 tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t___0 tmp___17 ;
  size_t___0 tmp___18 ;
  void *tmp___19 ;
  size_t___0 tmp___20 ;
  size_t___0 tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int _1_unix_getfulltree_next ;

  {
  {
  _1_unix_getfulltree_next = 21U;
  }
  while (1) {
    switch (_1_unix_getfulltree_next) {
    case 18: 
    start_rel_path --;
    {
    _1_unix_getfulltree_next = 59U;
    }
    break;
    case 50: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%d entries exceeds filelimit, not opening dir"),
            n);
    tmp___5 = strlen((char const   *)path___0);
    tmp___6 = xmalloc(tmp___5 + 1UL);
    *err = strcpy((char *)((char */* __restrict  */)tmp___6), (char const   *)((char const   */* __restrict  */)path___0));
    free_dir(sav);
    free((void *)path___0);
    {
    _1_unix_getfulltree_next = 43U;
    }
    break;
    case 80: 
    *p = *(p + 1);
    p ++;
    {
    _1_unix_getfulltree_next = 105U;
    }
    break;
    case 108: 
    free_dir(sav);
    {
    _1_unix_getfulltree_next = 66U;
    }
    break;
    case 104: ;
    if ((int )*((*dir)->lnk) == 47) {
      {
      _1_unix_getfulltree_next = 82U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 88U;
      }
    }
    break;
    case 25: ;
    if (lev == 0UL) {
      {
      _1_unix_getfulltree_next = 56U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 15U;
      }
    }
    break;
    case 49: 
    lev_tmp --;
    {
    _1_unix_getfulltree_next = 100U;
    }
    break;
    case 52: 
    saveino((*dir)->inode, (*dir)->dev);
    (*dir)->child = unix_getfulltree(path___0, lev + 1UL, dev, & (*dir)->size, & (*dir)->err);
    {
    _1_unix_getfulltree_next = 17U;
    }
    break;
    case 4: ;
    if (fflag) {
      {
      _1_unix_getfulltree_next = 74U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 54U;
      }
    }
    break;
    case 30: ;
    if (lflag) {
      {
      _1_unix_getfulltree_next = 3U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 17U;
      }
    }
    break;
    case 62: ;
    if ((*dir)->isdir) {
      {
      _1_unix_getfulltree_next = 70U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 7U;
      }
    }
    break;
    case 103: 
    tmp___8 = strlen("recursive, not followed");
    tmp___9 = xmalloc(tmp___8 + 1UL);
    (*dir)->err = strcpy((char *)((char */* __restrict  */)tmp___9), (char const   *)((char const   */* __restrict  */)"recursive, not followed"));
    {
    _1_unix_getfulltree_next = 17U;
    }
    break;
    case 102: 
    maxdirs += 1024;
    tmp___7 = xrealloc((void *)dirs, sizeof(int ) * (unsigned long )maxdirs);
    dirs = (int *)tmp___7;
    {
    _1_unix_getfulltree_next = 106U;
    }
    break;
    case 106: ;
    if (*dir) {
      {
      _1_unix_getfulltree_next = 62U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 87U;
      }
    }
    break;
    case 14: ;
    if (! tmp___23) {
      {
      _1_unix_getfulltree_next = 65U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 7U;
      }
    }
    break;
    case 15: ;
    if (matchdirs) {
      {
      _1_unix_getfulltree_next = 58U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 99U;
      }
    }
    break;
    case 82: 
    (*dir)->child = unix_getfulltree((*dir)->lnk, lev + 1UL, dev, & (*dir)->size,
                                     & (*dir)->err);
    {
    _1_unix_getfulltree_next = 17U;
    }
    break;
    case 89: ;
    if (xdev) {
      {
      _1_unix_getfulltree_next = 25U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 15U;
      }
    }
    break;
    case 56: 
    stat((char const   */* __restrict  */)d, (struct stat */* __restrict  */)(& sb));
    dev = sb.st_dev;
    {
    _1_unix_getfulltree_next = 15U;
    }
    break;
    case 79: 
    tmp___10 = strlen((char const   *)d);
    tmp___11 = strlen((char const   *)(*dir)->name);
    pathsize___0 = (long )((tmp___10 + tmp___11) + 1024UL);
    tmp___12 = xrealloc((void *)path___0, (size_t___0 )pathsize___0);
    path___0 = (char *)tmp___12;
    {
    _1_unix_getfulltree_next = 85U;
    }
    break;
    case 31: 
    lev_tmp = lev;
    tmp = strlen((char const   *)d);
    start_rel_path = d + tmp;
    tmp___0 = strlen((char const   *)d);
    start_rel_path = d + tmp___0;
    {
    _1_unix_getfulltree_next = 59U;
    }
    break;
    case 12: ;
    if (n == 0) {
      {
      _1_unix_getfulltree_next = 92U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 94U;
      }
    }
    break;
    case 101: 
    pattern = tmp_pattern;
    tmp_pattern = 0;
    {
    _1_unix_getfulltree_next = 5U;
    }
    break;
    case 69: ;
    if (lev >= (u_long )(maxdirs - 1)) {
      {
      _1_unix_getfulltree_next = 102U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 106U;
      }
    }
    break;
    case 8: ;
    if ((int )*start_rel_path == 47) {
      {
      _1_unix_getfulltree_next = 49U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 100U;
      }
    }
    break;
    case 96: 
    pop_filterstack();
    {
    _1_unix_getfulltree_next = 61U;
    }
    break;
    case 45: 
    tmp___2 = strlen("error opening dir");
    tmp___3 = xmalloc(tmp___2 + 1UL);
    *err = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)"error opening dir"));
    errors ++;
    {
    _1_unix_getfulltree_next = 32U;
    }
    break;
    case 54: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            d, (*dir)->name);
    {
    _1_unix_getfulltree_next = 52U;
    }
    break;
    case 78: ;
    if (*start_rel_path) {
      {
      _1_unix_getfulltree_next = 81U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 72U;
      }
    }
    break;
    case 1: ;
    return ((struct _info **)((void *)0));
    break;
    case 81: 
    start_rel_path ++;
    {
    _1_unix_getfulltree_next = 72U;
    }
    break;
    case 23: ;
    if (lev > (u_long )Level) {
      {
      _1_unix_getfulltree_next = 1U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 89U;
      }
    }
    break;
    case 77: ;
    if (sp___0->lnk) {
      {
      _1_unix_getfulltree_next = 98U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 51U;
      }
    }
    break;
    case 70: ;
    if (xdev) {
      {
      _1_unix_getfulltree_next = 28U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 9U;
      }
    }
    break;
    case 3: 
    tmp___16 = findino((*dir)->inode, (*dir)->dev);
    {
    _1_unix_getfulltree_next = 37U;
    }
    break;
    case 16: 
    dir ++;
    {
    _1_unix_getfulltree_next = 106U;
    }
    break;
    case 24: 
    tmp___15 = strcmp((char const   *)d, "/");
    {
    _1_unix_getfulltree_next = 10U;
    }
    break;
    case 21: 
    pathsize___0 = 0L;
    ig = (struct ignorefile *)((void *)0);
    inf = (struct infofile *)((void *)0);
    tmp_pattern = 0;
    *err = (char *)((void *)0);
    {
    _1_unix_getfulltree_next = 53U;
    }
    break;
    case 94: 
    pathsize___0 = 4096L;
    tmp___4 = xmalloc((size_t___0 )pathsize___0);
    path___0 = (char *)tmp___4;
    {
    _1_unix_getfulltree_next = 84U;
    }
    break;
    case 36: ;
    return ((struct _info **)((void *)0));
    break;
    case 76: 
    tmp___1 = patinclude(start_rel_path, 1);
    {
    _1_unix_getfulltree_next = 35U;
    }
    break;
    case 85: ;
    if (fflag) {
      {
      _1_unix_getfulltree_next = 24U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 38U;
      }
    }
    break;
    case 100: ;
    if (lev_tmp <= 0UL) {
      {
      _1_unix_getfulltree_next = 78U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 18U;
      }
    }
    break;
    case 98: 
    free((void *)sp___0->lnk);
    {
    _1_unix_getfulltree_next = 51U;
    }
    break;
    case 105: ;
    if (*p) {
      {
      _1_unix_getfulltree_next = 80U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 60U;
      }
    }
    break;
    case 11: ;
    if (n == 0) {
      {
      _1_unix_getfulltree_next = 108U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 91U;
      }
    }
    break;
    case 9: 
    _L___1: ;
    if ((*dir)->lnk) {
      {
      _1_unix_getfulltree_next = 30U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 47U;
      }
    }
    break;
    case 13: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
            d, (*dir)->lnk);
    {
    _1_unix_getfulltree_next = 95U;
    }
    break;
    case 63: ;
    if ((tmp___13 + tmp___14) + 2UL > (size_t___0 )pathsize___0) {
      {
      _1_unix_getfulltree_next = 79U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 85U;
      }
    }
    break;
    case 51: 
    free((void *)sp___0);
    {
    _1_unix_getfulltree_next = 106U;
    }
    break;
    case 107: 
    free_dir(sav);
    {
    _1_unix_getfulltree_next = 36U;
    }
    break;
    case 19: ;
    if ((tmp___20 + tmp___21) + 2UL > (size_t___0 )pathsize___0) {
      {
      _1_unix_getfulltree_next = 33U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 4U;
      }
    }
    break;
    case 32: ;
    return ((struct _info **)((void *)0));
    break;
    case 17: ;
    if (pruneflag) {
      {
      _1_unix_getfulltree_next = 55U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 7U;
      }
    }
    break;
    case 90: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            d, (*dir)->lnk);
    {
    _1_unix_getfulltree_next = 95U;
    }
    break;
    case 67: ;
    return (sav);
    break;
    case 55: ;
    if ((unsigned long )(*dir)->child == (unsigned long )((void *)0)) {
      {
      _1_unix_getfulltree_next = 73U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 7U;
      }
    }
    break;
    case 60: 
    n --;
    free((void *)sp___0->name);
    {
    _1_unix_getfulltree_next = 77U;
    }
    break;
    case 59: ;
    if ((unsigned long )start_rel_path != (unsigned long )d) {
      {
      _1_unix_getfulltree_next = 8U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 72U;
      }
    }
    break;
    case 38: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            d, (*dir)->lnk);
    {
    _1_unix_getfulltree_next = 95U;
    }
    break;
    case 61: ;
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
      {
      _1_unix_getfulltree_next = 71U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 67U;
      }
    }
    break;
    case 87: ;
    if (topsort) {
      {
      _1_unix_getfulltree_next = 44U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 20U;
      }
    }
    break;
    case 58: ;
    if (pattern) {
      {
      _1_unix_getfulltree_next = 31U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 99U;
      }
    }
    break;
    case 84: ;
    if (flimit > 0) {
      {
      _1_unix_getfulltree_next = 22U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 69U;
      }
    }
    break;
    case 74: 
    tmp___22 = strcmp((char const   *)d, "/");
    {
    _1_unix_getfulltree_next = 93U;
    }
    break;
    case 48: 
    saveino((*dir)->inode, (*dir)->dev);
    {
    _1_unix_getfulltree_next = 104U;
    }
    break;
    case 71: 
    pop_infostack();
    {
    _1_unix_getfulltree_next = 67U;
    }
    break;
    case 22: ;
    if (n > flimit) {
      {
      _1_unix_getfulltree_next = 50U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 69U;
      }
    }
    break;
    case 28: ;
    if (! (dev != (*dir)->dev)) {
      {
      _1_unix_getfulltree_next = 9U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 7U;
      }
    }
    break;
    case 53: ;
    if (Level >= 0) {
      {
      _1_unix_getfulltree_next = 23U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 89U;
      }
    }
    break;
    case 65: 
    _L___0: 
    sp___0 = *dir;
    p = dir;
    {
    _1_unix_getfulltree_next = 105U;
    }
    break;
    case 47: 
    tmp___20 = strlen((char const   *)d);
    tmp___21 = strlen((char const   *)(*dir)->name);
    {
    _1_unix_getfulltree_next = 19U;
    }
    break;
    case 73: ;
    if (matchdirs) {
      {
      _1_unix_getfulltree_next = 46U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 65U;
      }
    }
    break;
    case 44: 
    qsort((void *)sav, (size_t___1 )n, sizeof(struct _info *), (int (*)(void const   * ,
                                                                        void const   * ))topsort);
    {
    _1_unix_getfulltree_next = 20U;
    }
    break;
    case 5: ;
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
      {
      _1_unix_getfulltree_next = 29U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 12U;
      }
    }
    break;
    case 91: ;
    if ((unsigned long )ig != (unsigned long )((void *)0)) {
      {
      _1_unix_getfulltree_next = 96U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 61U;
      }
    }
    break;
    case 72: ;
    if (*start_rel_path) {
      {
      _1_unix_getfulltree_next = 76U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 99U;
      }
    }
    break;
    case 99: 
    push_files(d, & ig, & inf);
    dir = read_dir(d, & n, (unsigned long )inf != (unsigned long )((void *)0));
    sav = dir;
    {
    _1_unix_getfulltree_next = 64U;
    }
    break;
    case 33: 
    tmp___17 = strlen((char const   *)d);
    tmp___18 = strlen((char const   *)(*dir)->name);
    pathsize___0 = (long )((tmp___17 + tmp___18) + 1024UL);
    tmp___19 = xrealloc((void *)path___0, (size_t___0 )pathsize___0);
    path___0 = (char *)tmp___19;
    {
    _1_unix_getfulltree_next = 4U;
    }
    break;
    case 37: ;
    if (tmp___16) {
      {
      _1_unix_getfulltree_next = 103U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 48U;
      }
    }
    break;
    case 64: ;
    if (tmp_pattern) {
      {
      _1_unix_getfulltree_next = 101U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 5U;
      }
    }
    break;
    case 93: ;
    if (tmp___22) {
      {
      _1_unix_getfulltree_next = 42U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 86U;
      }
    }
    break;
    case 41: 
    tmp_pattern = pattern;
    pattern = 0;
    {
    _1_unix_getfulltree_next = 99U;
    }
    break;
    case 95: 
    (*dir)->child = unix_getfulltree(path___0, lev + 1UL, dev, & (*dir)->size, & (*dir)->err);
    {
    _1_unix_getfulltree_next = 17U;
    }
    break;
    case 92: ;
    if ((unsigned long )sav != (unsigned long )((void *)0)) {
      {
      _1_unix_getfulltree_next = 107U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 36U;
      }
    }
    break;
    case 10: ;
    if (tmp___15) {
      {
      _1_unix_getfulltree_next = 90U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 13U;
      }
    }
    break;
    case 42: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            d, (*dir)->name);
    {
    _1_unix_getfulltree_next = 52U;
    }
    break;
    case 46: ;
    if (pattern) {
      {
      _1_unix_getfulltree_next = 2U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 65U;
      }
    }
    break;
    case 39: 
    *size += (*dir)->size;
    {
    _1_unix_getfulltree_next = 16U;
    }
    break;
    case 66: ;
    return ((struct _info **)((void *)0));
    break;
    case 7: ;
    if (duflag) {
      {
      _1_unix_getfulltree_next = 39U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 16U;
      }
    }
    break;
    case 88: 
    tmp___13 = strlen((char const   *)d);
    tmp___14 = strlen((char const   *)(*dir)->lnk);
    {
    _1_unix_getfulltree_next = 63U;
    }
    break;
    case 35: ;
    if (tmp___1) {
      {
      _1_unix_getfulltree_next = 41U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 99U;
      }
    }
    break;
    case 29: ;
    if (n) {
      {
      _1_unix_getfulltree_next = 45U;
      }
    } else {
      {
      _1_unix_getfulltree_next = 12U;
      }
    }
    break;
    case 43: ;
    return ((struct _info **)((void *)0));
    break;
    case 86: 
    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
            d, (*dir)->name);
    {
    _1_unix_getfulltree_next = 52U;
    }
    break;
    case 2: 
    tmp___23 = patinclude((*dir)->name, (int )(*dir)->isdir);
    {
    _1_unix_getfulltree_next = 14U;
    }
    break;
    case 20: 
    free((void *)path___0);
    {
    _1_unix_getfulltree_next = 11U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF unix_getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_printinfo LOC=UNKNOWN */
int xml_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  mode_t mt ;
  int t ;
  char const   *tmp ;
  unsigned int _1_xml_printinfo_next ;

  {
  {
  _1_xml_printinfo_next = 1U;
  }
  while (1) {
    switch (_1_xml_printinfo_next) {
    case 4: ;
    if (ifmt[t]) {
      {
      _1_xml_printinfo_next = 12U;
      }
    } else {
      {
      _1_xml_printinfo_next = 0U;
      }
    }
    break;
    case 12: ;
    if ((mode_t )ifmt[t] == mt) {
      {
      _1_xml_printinfo_next = 0U;
      }
    } else {
      {
      _1_xml_printinfo_next = 8U;
      }
    }
    break;
    case 8: 
    t ++;
    {
    _1_xml_printinfo_next = 4U;
    }
    break;
    case 1: ;
    if (! noindent) {
      {
      _1_xml_printinfo_next = 9U;
      }
    } else {
      {
      _1_xml_printinfo_next = 3U;
      }
    }
    break;
    case 3: ;
    if (file->lnk) {
      {
      _1_xml_printinfo_next = 5U;
      }
    } else {
      {
      _1_xml_printinfo_next = 11U;
      }
    }
    break;
    case 11: 
    mt = file->mode & 61440U;
    {
    _1_xml_printinfo_next = 2U;
    }
    break;
    case 9: 
    xml_indent(level);
    {
    _1_xml_printinfo_next = 3U;
    }
    break;
    case 13: ;
    return (0);
    break;
    case 5: 
    mt = file->mode & 61440U;
    {
    _1_xml_printinfo_next = 2U;
    }
    break;
    case 0: 
    tmp = ftype[t];
    file->tag = tmp;
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<%s"),
            tmp);
    {
    _1_xml_printinfo_next = 13U;
    }
    break;
    case 2: 
    t = 0;
    {
    _1_xml_printinfo_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_encode LOC=UNKNOWN */
void json_encode(FILE *fd , char *s ) 
{ 
  char *ctrl ;
  unsigned int _1_json_encode_next ;

  {
  {
  _1_json_encode_next = 2U;
  }
  while (1) {
    switch (_1_json_encode_next) {
    case 4: ;
    if ((int )*s == 34) {
      {
      _1_json_encode_next = 1U;
      }
    } else {
      {
      _1_json_encode_next = 9U;
      }
    }
    break;
    case 14: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\u%04x"),
            (int )((unsigned char )*s));
    {
    _1_json_encode_next = 6U;
    }
    break;
    case 12: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"%c"),
            (int )*s);
    {
    _1_json_encode_next = 6U;
    }
    break;
    case 8: ;
    return;
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\%c"),
            (int )*s);
    {
    _1_json_encode_next = 6U;
    }
    break;
    case 3: ;
    if ((int )((unsigned char )*s) < 32) {
      {
      _1_json_encode_next = 11U;
      }
    } else {
      {
      _1_json_encode_next = 4U;
      }
    }
    break;
    case 11: ;
    if ((int )*(ctrl + (int )((unsigned char )*s)) != 45) {
      {
      _1_json_encode_next = 5U;
      }
    } else {
      {
      _1_json_encode_next = 14U;
      }
    }
    break;
    case 9: ;
    if ((int )*s == 92) {
      {
      _1_json_encode_next = 13U;
      }
    } else {
      {
      _1_json_encode_next = 12U;
      }
    }
    break;
    case 13: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\%c"),
            (int )*s);
    {
    _1_json_encode_next = 6U;
    }
    break;
    case 6: 
    s ++;
    {
    _1_json_encode_next = 0U;
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\%c"),
            (int )*(ctrl + (int )((unsigned char )*s)));
    {
    _1_json_encode_next = 6U;
    }
    break;
    case 0: ;
    if (*s) {
      {
      _1_json_encode_next = 3U;
      }
    } else {
      {
      _1_json_encode_next = 8U;
      }
    }
    break;
    case 2: 
    ctrl = (char *)"0-------btn-fr------------------";
    {
    _1_json_encode_next = 0U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF filesfirst LOC=UNKNOWN */
int filesfirst(struct _info **a , struct _info **b ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int _1_filesfirst_next ;

  {
  {
  _1_filesfirst_next = 3U;
  }
  while (1) {
    switch (_1_filesfirst_next) {
    case 4: 
    tmp___0 = (*basesort)(a, b);
    {
    _1_filesfirst_next = 6U;
    }
    break;
    case 1: 
    tmp = 1;
    {
    _1_filesfirst_next = 5U;
    }
    break;
    case 3: ;
    if ((unsigned int )(*a)->isdir != (unsigned int )(*b)->isdir) {
      {
      _1_filesfirst_next = 0U;
      }
    } else {
      {
      _1_filesfirst_next = 4U;
      }
    }
    break;
    case 6: ;
    return (tmp___0);
    break;
    case 5: ;
    return (tmp);
    break;
    case 0: ;
    if ((*a)->isdir) {
      {
      _1_filesfirst_next = 1U;
      }
    } else {
      {
      _1_filesfirst_next = 2U;
      }
    }
    break;
    case 2: 
    tmp = -1;
    {
    _1_filesfirst_next = 5U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF filesfirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_report LOC=UNKNOWN */
void html_report(struct totals tot ) 
{ 
  char buf___1[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int _1_html_report_next ;

  {
  {
  _1_html_report_next = 20U;
  }
  while (1) {
    switch (_1_html_report_next) {
    case 18: 
    tmp___0 = (char *)"ies";
    {
    _1_html_report_next = 9U;
    }
    break;
    case 4: 
    tmp___0 = (char *)"y";
    {
    _1_html_report_next = 9U;
    }
    break;
    case 14: 
    tmp = (char *)" bytes";
    {
    _1_html_report_next = 8U;
    }
    break;
    case 15: 
    psize(buf___1, tot.size);
    {
    _1_html_report_next = 7U;
    }
    break;
    case 12: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s, %ld file%s\n"),
            tot.dirs, tmp___2, tot.files, tmp___1);
    {
    _1_html_report_next = 19U;
    }
    break;
    case 8: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s used in "),
            buf___1, tmp);
    {
    _1_html_report_next = 13U;
    }
    break;
    case 1: 
    tmp___1 = (char *)"s";
    {
    _1_html_report_next = 3U;
    }
    break;
    case 3: ;
    if (tot.dirs == 1UL) {
      {
      _1_html_report_next = 22U;
      }
    } else {
      {
      _1_html_report_next = 10U;
      }
    }
    break;
    case 16: ;
    if (tot.files == 1UL) {
      {
      _1_html_report_next = 11U;
      }
    } else {
      {
      _1_html_report_next = 1U;
      }
    }
    break;
    case 21: ;
    return;
    break;
    case 11: 
    tmp___1 = (char *)"";
    {
    _1_html_report_next = 3U;
    }
    break;
    case 9: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s\n"),
            tot.dirs, tmp___0);
    {
    _1_html_report_next = 19U;
    }
    break;
    case 13: ;
    if (dflag) {
      {
      _1_html_report_next = 17U;
      }
    } else {
      {
      _1_html_report_next = 16U;
      }
    }
    break;
    case 19: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n</p>\n"));
    {
    _1_html_report_next = 21U;
    }
    break;
    case 17: ;
    if (tot.dirs == 1UL) {
      {
      _1_html_report_next = 4U;
      }
    } else {
      {
      _1_html_report_next = 18U;
      }
    }
    break;
    case 6: ;
    if (duflag) {
      {
      _1_html_report_next = 15U;
      }
    } else {
      {
      _1_html_report_next = 13U;
      }
    }
    break;
    case 22: 
    tmp___2 = (char *)"y";
    {
    _1_html_report_next = 12U;
    }
    break;
    case 5: 
    tmp = (char *)"";
    {
    _1_html_report_next = 8U;
    }
    break;
    case 10: 
    tmp___2 = (char *)"ies";
    {
    _1_html_report_next = 12U;
    }
    break;
    case 0: ;
    if (siflag) {
      {
      _1_html_report_next = 5U;
      }
    } else {
      {
      _1_html_report_next = 14U;
      }
    }
    break;
    case 7: ;
    if (hflag) {
      {
      _1_html_report_next = 2U;
      }
    } else {
      {
      _1_html_report_next = 0U;
      }
    }
    break;
    case 2: 
    tmp = (char *)"";
    {
    _1_html_report_next = 8U;
    }
    break;
    case 20: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<br><br><p>\n\n"));
    {
    _1_html_report_next = 6U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF emit_tree LOC=UNKNOWN */
void emit_tree(char **dirname , bool needfulltree ) 
{ 
  struct totals tot ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **dir ;
  struct _info *info___1 ;
  char *err ;
  int i ;
  int j ;
  int n ;
  int needsclosed ;
  struct stat st ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  struct totals __constr_expr_0 ;
  unsigned int _1_emit_tree_next ;

  {
  {
  _1_emit_tree_next = 2U;
  }
  while (1) {
    switch (_1_emit_tree_next) {
    case 18: ;
    if (dir) {
      {
      _1_emit_tree_next = 31U;
      }
    } else {
      {
      _1_emit_tree_next = 46U;
      }
    }
    break;
    case 50: 
    i ++;
    {
    _1_emit_tree_next = 9U;
    }
    break;
    case 25: ;
    if (! dir) {
      {
      _1_emit_tree_next = 38U;
      }
    } else {
      {
      _1_emit_tree_next = 17U;
      }
    }
    break;
    case 49: ;
    if ((unsigned long )ig != (unsigned long )((void *)0)) {
      {
      _1_emit_tree_next = 24U;
      }
    } else {
      {
      _1_emit_tree_next = 61U;
      }
    }
    break;
    case 52: 
    tot.size += st.st_size;
    {
    _1_emit_tree_next = 49U;
    }
    break;
    case 4: ;
    if (err) {
      {
      _1_emit_tree_next = 28U;
      }
    } else {
      {
      _1_emit_tree_next = 26U;
      }
    }
    break;
    case 62: 
    (*(lc.outtro))();
    {
    _1_emit_tree_next = 13U;
    }
    break;
    case 14: 
    __constr_expr_0.files = (u_long )0;
    __constr_expr_0.dirs = (u_long )0;
    __constr_expr_0.size = 0LL;
    tot = __constr_expr_0;
    {
    _1_emit_tree_next = 18U;
    }
    break;
    case 15: ;
    if (j > 1) {
      {
      _1_emit_tree_next = 23U;
      }
    } else {
      {
      _1_emit_tree_next = 56U;
      }
    }
    break;
    case 56: ;
    if (Hflag) {
      {
      _1_emit_tree_next = 37U;
      }
    } else {
      {
      _1_emit_tree_next = 51U;
      }
    }
    break;
    case 31: 
    free_dir(dir);
    dir = (struct _info **)((void *)0);
    {
    _1_emit_tree_next = 46U;
    }
    break;
    case 12: 
    saveino(st.st_ino, st.st_dev);
    info___1 = stat2info(& st);
    info___1->name = *(dirname + i);
    {
    _1_emit_tree_next = 39U;
    }
    break;
    case 8: 
    _L: 
    (*(lc.newline))(info___1, 0, 0, 0);
    {
    _1_emit_tree_next = 22U;
    }
    break;
    case 45: 
    needsclosed = (*(lc.printfile))((char *)((void *)0), *(dirname + i), info___1,
                                    tmp___1);
    {
    _1_emit_tree_next = 25U;
    }
    break;
    case 54: ;
    if (n > flimit) {
      {
      _1_emit_tree_next = 34U;
      }
    } else {
      {
      _1_emit_tree_next = 8U;
      }
    }
    break;
    case 23: ;
    if (! ((int )*(*(dirname + i) + (j - 1)) == 47)) {
      {
      _1_emit_tree_next = 56U;
      }
    } else {
      {
      _1_emit_tree_next = 57U;
      }
    }
    break;
    case 3: 
    j --;
    *(*(dirname + i) + j) = (char)0;
    {
    _1_emit_tree_next = 15U;
    }
    break;
    case 16: ;
    if (n) {
      {
      _1_emit_tree_next = 40U;
      }
    } else {
      {
      _1_emit_tree_next = 29U;
      }
    }
    break;
    case 24: 
    ig = pop_filterstack();
    {
    _1_emit_tree_next = 61U;
    }
    break;
    case 36: 
    tmp___1 = 1;
    {
    _1_emit_tree_next = 45U;
    }
    break;
    case 57: ;
    if (j > 1) {
      {
      _1_emit_tree_next = 41U;
      }
    } else {
      {
      _1_emit_tree_next = 15U;
      }
    }
    break;
    case 26: 
    n = 0;
    {
    _1_emit_tree_next = 58U;
    }
    break;
    case 11: ;
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
      {
      _1_emit_tree_next = 36U;
      }
    } else {
      {
      _1_emit_tree_next = 7U;
      }
    }
    break;
    case 9: ;
    if (*(dirname + i)) {
      {
      _1_emit_tree_next = 10U;
      }
    } else {
      {
      _1_emit_tree_next = 55U;
      }
    }
    break;
    case 13: ;
    return;
    break;
    case 51: 
    n = lstat((char const   *)((char const   */* __restrict  */)*(dirname + i)), (struct stat *)((struct stat */* __restrict  */)(& st)));
    {
    _1_emit_tree_next = 32U;
    }
    break;
    case 19: 
    dir = (*getfulltree)(*(dirname + i), (u_long )0, st.st_dev, & info___1->size,
                         & err);
    {
    _1_emit_tree_next = 4U;
    }
    break;
    case 32: ;
    if (n >= 0) {
      {
      _1_emit_tree_next = 12U;
      }
    } else {
      {
      _1_emit_tree_next = 42U;
      }
    }
    break;
    case 17: 
    _L___0: ;
    if (flimit > 0) {
      {
      _1_emit_tree_next = 54U;
      }
    } else {
      {
      _1_emit_tree_next = 8U;
      }
    }
    break;
    case 40: 
    tmp___1 = 1;
    {
    _1_emit_tree_next = 45U;
    }
    break;
    case 55: ;
    if (! noreport) {
      {
      _1_emit_tree_next = 44U;
      }
    } else {
      {
      _1_emit_tree_next = 62U;
      }
    }
    break;
    case 60: 
    push_files(*(dirname + i), & ig, & inf);
    dir = read_dir(*(dirname + i), & n, (unsigned long )inf != (unsigned long )((void *)0));
    {
    _1_emit_tree_next = 58U;
    }
    break;
    case 59: 
    inf = pop_infostack();
    {
    _1_emit_tree_next = 50U;
    }
    break;
    case 6: ;
    if (duflag) {
      {
      _1_emit_tree_next = 47U;
      }
    } else {
      {
      _1_emit_tree_next = 52U;
      }
    }
    break;
    case 27: 
    tmp___1 = 0;
    {
    _1_emit_tree_next = 45U;
    }
    break;
    case 38: ;
    if (n) {
      {
      _1_emit_tree_next = 48U;
      }
    } else {
      {
      _1_emit_tree_next = 17U;
      }
    }
    break;
    case 61: ;
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
      {
      _1_emit_tree_next = 59U;
      }
    } else {
      {
      _1_emit_tree_next = 50U;
      }
    }
    break;
    case 58: 
    (*(lc.printinfo))(*(dirname + i), info___1, 0);
    {
    _1_emit_tree_next = 11U;
    }
    break;
    case 34: 
    sprintf((char *)((char */* __restrict  */)(errbuf)), (char const   *)((char const   */* __restrict  */)"%d entries exceeds filelimit, not opening dir"),
            n);
    (*(lc.error))(errbuf);
    (*(lc.newline))(info___1, 0, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
    errors ++;
    {
    _1_emit_tree_next = 18U;
    }
    break;
    case 48: 
    (*(lc.error))((char *)"error opening dir");
    (*(lc.newline))(info___1, 0, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
    errors ++;
    {
    _1_emit_tree_next = 18U;
    }
    break;
    case 22: ;
    if (dir) {
      {
      _1_emit_tree_next = 0U;
      }
    } else {
      {
      _1_emit_tree_next = 14U;
      }
    }
    break;
    case 28: 
    n = -1;
    {
    _1_emit_tree_next = 58U;
    }
    break;
    case 53: 
    (*(lc.close))(info___1, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
    {
    _1_emit_tree_next = 6U;
    }
    break;
    case 47: 
    tot.size = info___1->size;
    {
    _1_emit_tree_next = 49U;
    }
    break;
    case 44: 
    (*(lc.report))(tot);
    {
    _1_emit_tree_next = 62U;
    }
    break;
    case 37: 
    tmp___0 = strlen((char const   *)*(dirname + i));
    htmldirlen = (int )tmp___0;
    {
    _1_emit_tree_next = 51U;
    }
    break;
    case 41: ;
    if ((int )*(*(dirname + i) + (j - 1)) == 47) {
      {
      _1_emit_tree_next = 3U;
      }
    } else {
      {
      _1_emit_tree_next = 15U;
      }
    }
    break;
    case 10: ;
    if (fflag) {
      {
      _1_emit_tree_next = 43U;
      }
    } else {
      {
      _1_emit_tree_next = 56U;
      }
    }
    break;
    case 42: 
    info___1 = (struct _info *)((void *)0);
    {
    _1_emit_tree_next = 11U;
    }
    break;
    case 0: 
    tot = listdir(*(dirname + i), dir, 1, st.st_dev, needfulltree);
    {
    _1_emit_tree_next = 18U;
    }
    break;
    case 46: ;
    if (needsclosed) {
      {
      _1_emit_tree_next = 53U;
      }
    } else {
      {
      _1_emit_tree_next = 6U;
      }
    }
    break;
    case 39: ;
    if (needfulltree) {
      {
      _1_emit_tree_next = 19U;
      }
    } else {
      {
      _1_emit_tree_next = 60U;
      }
    }
    break;
    case 7: ;
    if (! dir) {
      {
      _1_emit_tree_next = 16U;
      }
    } else {
      {
      _1_emit_tree_next = 27U;
      }
    }
    break;
    case 29: 
    tmp___1 = 0;
    {
    _1_emit_tree_next = 45U;
    }
    break;
    case 43: 
    tmp = strlen((char const   *)*(dirname + i));
    j = (int )tmp;
    {
    _1_emit_tree_next = 57U;
    }
    break;
    case 2: 
    tot.files = (u_long )0;
    tot.dirs = 0UL;
    tot.size = 0LL;
    ig = (struct ignorefile *)((void *)0);
    inf = (struct infofile *)((void *)0);
    dir = (struct _info **)((void *)0);
    info___1 = (struct _info *)((void *)0);
    (*(lc.intro))();
    i = 0;
    {
    _1_emit_tree_next = 9U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF emit_tree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmd LOC=UNKNOWN */
int cmd(char *s ) 
{ 
  int i ;
  int tmp ;
  unsigned int _1_cmd_next ;

  {
  {
  _1_cmd_next = 11U;
  }
  while (1) {
    switch (_1_cmd_next) {
    case 4: ;
    return (-1);
    break;
    case 8: ;
    if (! tmp) {
      {
      _1_cmd_next = 7U;
      }
    } else {
      {
      _1_cmd_next = 0U;
      }
    }
    break;
    case 1: ;
    return (25);
    break;
    case 3: ;
    return (-1);
    break;
    case 11: ;
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
      _1_cmd_next = 4U;
      }
    } else {
      {
      _1_cmd_next = 2U;
      }
    }
    break;
    case 6: ;
    if (cmds[i].cmdnum) {
      {
      _1_cmd_next = 10U;
      }
    } else {
      {
      _1_cmd_next = 3U;
      }
    }
    break;
    case 5: 
    i = 0;
    {
    _1_cmd_next = 6U;
    }
    break;
    case 10: 
    tmp = strcmp((char const   *)cmds[i].cmd, (char const   *)s);
    {
    _1_cmd_next = 8U;
    }
    break;
    case 0: 
    i ++;
    {
    _1_cmd_next = 6U;
    }
    break;
    case 7: ;
    return ((int )cmds[i].cmdnum);
    break;
    case 2: ;
    if ((int )*(s + 0) == 42) {
      {
      _1_cmd_next = 1U;
      }
    } else {
      {
      _1_cmd_next = 5U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cmd LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_error LOC=UNKNOWN */
int xml_error(char *error ) 
{ 
  unsigned int _1_xml_error_next ;

  {
  {
  _1_xml_error_next = 1U;
  }
  while (1) {
    switch (_1_xml_error_next) {
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<error>%s</error>"),
            error);
    {
    _1_xml_error_next = 0U;
    }
    break;
    case 0: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF patinclude LOC=UNKNOWN */
int patinclude(char *name , int isdir ) 
{ 
  int i ;
  int tmp ;
  unsigned int _1_patinclude_next ;

  {
  {
  _1_patinclude_next = 4U;
  }
  while (1) {
    switch (_1_patinclude_next) {
    case 4: 
    i = 0;
    {
    _1_patinclude_next = 6U;
    }
    break;
    case 3: ;
    return (1);
    break;
    case 6: ;
    if (i < pattern) {
      {
      _1_patinclude_next = 2U;
      }
    } else {
      {
      _1_patinclude_next = 0U;
      }
    }
    break;
    case 5: 
    i ++;
    {
    _1_patinclude_next = 6U;
    }
    break;
    case 0: ;
    return (0);
    break;
    case 7: ;
    if (tmp) {
      {
      _1_patinclude_next = 3U;
      }
    } else {
      {
      _1_patinclude_next = 5U;
      }
    }
    break;
    case 2: 
    tmp = patmatch(name, *(patterns + i), isdir);
    {
    _1_patinclude_next = 7U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF patinclude LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF getinfo LOC=UNKNOWN */
struct _info *getinfo(char *name , char *path___0 ) 
{ 
  struct _info *ent ;
  struct stat st ;
  struct stat lst ;
  int len ;
  int rs ;
  void *tmp ;
  int tmp___0 ;
  int isdir ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t___0 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  size_t___0 tmp___10 ;
  void *tmp___11 ;
  ssize_t tmp___12 ;
  unsigned int _1_getinfo_next ;

  {
  {
  _1_getinfo_next = 0U;
  }
  while (1) {
    switch (_1_getinfo_next) {
    case 18: 
    tmp___1 = filtercheck(path___0, name, isdir);
    {
    _1_getinfo_next = 5U;
    }
    break;
    case 4: 
    isdir = (st.st_mode & 61440U) == 16384U;
    {
    _1_getinfo_next = 34U;
    }
    break;
    case 30: ;
    if (! ((st.st_mode & 61440U) == 16384U)) {
      {
      _1_getinfo_next = 7U;
      }
    } else {
      {
      _1_getinfo_next = 17U;
      }
    }
    break;
    case 14: 
    ent->lnkmode = st.st_mode;
    {
    _1_getinfo_next = 31U;
    }
    break;
    case 15: ;
    if (rs < 0) {
      {
      _1_getinfo_next = 40U;
      }
    } else {
      {
      _1_getinfo_next = 4U;
      }
    }
    break;
    case 31: 
    ent->comment = (char **)((void *)0);
    {
    _1_getinfo_next = 3U;
    }
    break;
    case 12: 
    ent->orphan = (bool )1;
    {
    _1_getinfo_next = 14U;
    }
    break;
    case 8: ;
    if (lflag) {
      {
      _1_getinfo_next = 30U;
      }
    } else {
      {
      _1_getinfo_next = 7U;
      }
    }
    break;
    case 45: ;
    if ((lst.st_mode & 61440U) == 40960U) {
      {
      _1_getinfo_next = 22U;
      }
    } else {
      {
      _1_getinfo_next = 31U;
      }
    }
    break;
    case 1: 
    rs = stat((char const   */* __restrict  */)path___0, (struct stat */* __restrict  */)(& st));
    {
    _1_getinfo_next = 15U;
    }
    break;
    case 23: 
    lbufsize = (int )(lst.st_size + 8192LL);
    tmp___7 = xrealloc((void *)lbuf, (size_t___0 )lbufsize);
    lbuf = (char *)tmp___7;
    {
    _1_getinfo_next = 16U;
    }
    break;
    case 3: ;
    return (ent);
    break;
    case 16: 
    tmp___12 = readlink((char const   */* __restrict  */)path___0, (char */* __restrict  */)lbuf,
                        (size_t___0 )(lbufsize - 1));
    len = (int )tmp___12;
    {
    _1_getinfo_next = 33U;
    }
    break;
    case 24: 
    ent->isexe = (bool )0;
    {
    _1_getinfo_next = 45U;
    }
    break;
    case 21: 
    tmp___2 = patinclude(name, isdir);
    {
    _1_getinfo_next = 38U;
    }
    break;
    case 36: ;
    return ((struct _info *)((void *)0));
    break;
    case 26: 
    tmp___3 = patignore(name, isdir);
    {
    _1_getinfo_next = 29U;
    }
    break;
    case 11: ;
    if ((lst.st_mode & 61440U) != 16384U) {
      {
      _1_getinfo_next = 8U;
      }
    } else {
      {
      _1_getinfo_next = 17U;
      }
    }
    break;
    case 9: ;
    return ((struct _info *)((void *)0));
    break;
    case 13: ;
    if (tmp___0 < 0) {
      {
      _1_getinfo_next = 10U;
      }
    } else {
      {
      _1_getinfo_next = 42U;
      }
    }
    break;
    case 19: ;
    if (dflag) {
      {
      _1_getinfo_next = 6U;
      }
    } else {
      {
      _1_getinfo_next = 43U;
      }
    }
    break;
    case 32: ;
    return ((struct _info *)((void *)0));
    break;
    case 17: ;
    if (ipattern) {
      {
      _1_getinfo_next = 26U;
      }
    } else {
      {
      _1_getinfo_next = 19U;
      }
    }
    break;
    case 40: 
    memset((void *)(& st), 0, sizeof(st));
    {
    _1_getinfo_next = 4U;
    }
    break;
    case 6: ;
    if ((st.st_mode & 61440U) != 16384U) {
      {
      _1_getinfo_next = 32U;
      }
    } else {
      {
      _1_getinfo_next = 43U;
      }
    }
    break;
    case 27: ;
    if (rs < 0) {
      {
      _1_getinfo_next = 12U;
      }
    } else {
      {
      _1_getinfo_next = 14U;
      }
    }
    break;
    case 38: ;
    if (! tmp___2) {
      {
      _1_getinfo_next = 41U;
      }
    } else {
      {
      _1_getinfo_next = 17U;
      }
    }
    break;
    case 34: ;
    if (gitignore) {
      {
      _1_getinfo_next = 18U;
      }
    } else {
      {
      _1_getinfo_next = 11U;
      }
    }
    break;
    case 22: ;
    if (lst.st_size + 1LL > (off_t )lbufsize) {
      {
      _1_getinfo_next = 23U;
      }
    } else {
      {
      _1_getinfo_next = 16U;
      }
    }
    break;
    case 28: 
    *(lbuf + len) = (char)0;
    tmp___10 = strlen((char const   *)lbuf);
    tmp___11 = xmalloc(tmp___10 + 1UL);
    ent->lnk = strcpy((char *)((char */* __restrict  */)tmp___11), (char const   *)((char const   */* __restrict  */)lbuf));
    {
    _1_getinfo_next = 27U;
    }
    break;
    case 44: 
    ent->isexe = (bool )1;
    {
    _1_getinfo_next = 45U;
    }
    break;
    case 5: ;
    if (tmp___1) {
      {
      _1_getinfo_next = 36U;
      }
    } else {
      {
      _1_getinfo_next = 11U;
      }
    }
    break;
    case 33: ;
    if (len < 0) {
      {
      _1_getinfo_next = 2U;
      }
    } else {
      {
      _1_getinfo_next = 28U;
      }
    }
    break;
    case 37: 
    lbufsize = 4096;
    tmp = xmalloc((size_t___0 )lbufsize);
    lbuf = (char *)tmp;
    {
    _1_getinfo_next = 35U;
    }
    break;
    case 41: ;
    return ((struct _info *)((void *)0));
    break;
    case 10: ;
    return ((struct _info *)((void *)0));
    break;
    case 42: ;
    if ((lst.st_mode & 61440U) == 40960U) {
      {
      _1_getinfo_next = 1U;
      }
    } else {
      {
      _1_getinfo_next = 39U;
      }
    }
    break;
    case 0: ;
    if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
      {
      _1_getinfo_next = 37U;
      }
    } else {
      {
      _1_getinfo_next = 35U;
      }
    }
    break;
    case 39: 
    rs = 0;
    st.st_mode = lst.st_mode;
    st.st_dev = lst.st_dev;
    st.st_ino = lst.st_ino;
    {
    _1_getinfo_next = 4U;
    }
    break;
    case 7: 
    _L: ;
    if (pattern) {
      {
      _1_getinfo_next = 21U;
      }
    } else {
      {
      _1_getinfo_next = 17U;
      }
    }
    break;
    case 35: 
    tmp___0 = lstat((char const   *)((char const   */* __restrict  */)path___0), (struct stat *)((struct stat */* __restrict  */)(& lst)));
    {
    _1_getinfo_next = 13U;
    }
    break;
    case 29: ;
    if (tmp___3) {
      {
      _1_getinfo_next = 9U;
      }
    } else {
      {
      _1_getinfo_next = 19U;
      }
    }
    break;
    case 43: 
    tmp___4 = xmalloc(sizeof(struct _info ));
    ent = (struct _info *)tmp___4;
    memset((void *)ent, 0, sizeof(struct _info ));
    tmp___5 = strlen((char const   *)name);
    tmp___6 = xmalloc(tmp___5 + 1UL);
    ent->name = strcpy((char *)((char */* __restrict  */)tmp___6), (char const   *)((char const   */* __restrict  */)name));
    ent->mode = lst.st_mode;
    ent->uid = lst.st_uid;
    ent->gid = lst.st_gid;
    ent->size = lst.st_size;
    ent->dev = st.st_dev;
    ent->inode = st.st_ino;
    ent->ldev = lst.st_dev;
    ent->linode = lst.st_ino;
    ent->lnk = (char *)((void *)0);
    ent->orphan = (bool )0;
    ent->err = (char *)((void *)0);
    ent->child = (struct _info **)((void *)0);
    ent->atime = lst.st_atim.tv_sec;
    ent->ctime = lst.st_ctim.tv_sec;
    ent->mtime = lst.st_mtim.tv_sec;
    ent->isdir = (bool )isdir;
    ent->issok = (bool )((st.st_mode & 61440U) == 49152U);
    ent->isfifo = (bool )((st.st_mode & 61440U) == 4096U);
    {
    _1_getinfo_next = 20U;
    }
    break;
    case 2: 
    tmp___8 = strlen("[Error reading symbolic link information]");
    tmp___9 = xmalloc(tmp___8 + 1UL);
    ent->lnk = strcpy((char *)((char */* __restrict  */)tmp___9), (char const   *)((char const   */* __restrict  */)"[Error reading symbolic link information]"));
    ent->isdir = (bool )0;
    ent->lnkmode = st.st_mode;
    {
    _1_getinfo_next = 31U;
    }
    break;
    case 20: ;
    if (st.st_mode & 73U) {
      {
      _1_getinfo_next = 44U;
      }
    } else {
      {
      _1_getinfo_next = 24U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF getinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_newline LOC=UNKNOWN */
void json_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  char *tmp ;
  unsigned int _1_json_newline_next ;

  {
  {
  _1_json_newline_next = 3U;
  }
  while (1) {
    switch (_1_json_newline_next) {
    case 4: 
    tmp = (char *)"";
    {
    _1_json_newline_next = 2U;
    }
    break;
    case 1: 
    tmp = (char *)",";
    {
    _1_json_newline_next = 2U;
    }
    break;
    case 3: ;
    if (needcomma) {
      {
      _1_json_newline_next = 1U;
      }
    } else {
      {
      _1_json_newline_next = 4U;
      }
    }
    break;
    case 0: ;
    return;
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
            tmp, _nl);
    {
    _1_json_newline_next = 0U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF newent LOC=UNKNOWN */
struct _info *newent(char *name ) 
{ 
  struct _info *n ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  struct _info *tmp___2 ;
  unsigned int _1_newent_next ;

  {
  {
  _1_newent_next = 0U;
  }
  while (1) {
    switch (_1_newent_next) {
    case 1: ;
    return (n);
    break;
    case 0: 
    tmp = xmalloc(sizeof(struct _info ));
    n = (struct _info *)tmp;
    memset((void *)n, 0, sizeof(struct _info ));
    tmp___0 = strlen((char const   *)name);
    tmp___1 = xmalloc(tmp___0 + 1UL);
    n->name = strcpy((char *)((char */* __restrict  */)tmp___1), (char const   *)((char const   */* __restrict  */)name));
    n->child = (struct _info **)((void *)0);
    tmp___2 = (struct _info *)((void *)0);
    n->next = tmp___2;
    n->tchild = tmp___2;
    {
    _1_newent_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF newent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_newline LOC=UNKNOWN */
void unix_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  int infosize ;
  int line ;
  int lines ;
  size_t___0 tmp ;
  unsigned int _1_unix_newline_next ;

  {
  {
  _1_unix_newline_next = 18U;
  }
  while (1) {
    switch (_1_unix_newline_next) {
    case 18: ;
    if (postdir <= 0) {
      {
      _1_unix_newline_next = 14U;
      }
    } else {
      {
      _1_unix_newline_next = 2U;
      }
    }
    break;
    case 4: 
    lines = 0;
    {
    _1_unix_newline_next = 21U;
    }
    break;
    case 14: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
    {
    _1_unix_newline_next = 2U;
    }
    break;
    case 15: ;
    return;
    break;
    case 12: 
    lines ++;
    {
    _1_unix_newline_next = 21U;
    }
    break;
    case 1: ;
    if ((int )info___0[0] == 91) {
      {
      _1_unix_newline_next = 9U;
      }
    } else {
      {
      _1_unix_newline_next = 3U;
      }
    }
    break;
    case 3: 
    infosize = 0;
    {
    _1_unix_newline_next = 4U;
    }
    break;
    case 16: 
    indent(level);
    printcomment(line, lines, *(file->comment + line));
    line ++;
    {
    _1_unix_newline_next = 20U;
    }
    break;
    case 21: ;
    if (*(file->comment + lines)) {
      {
      _1_unix_newline_next = 12U;
      }
    } else {
      {
      _1_unix_newline_next = 17U;
      }
    }
    break;
    case 11: ;
    if (metafirst) {
      {
      _1_unix_newline_next = 1U;
      }
    } else {
      {
      _1_unix_newline_next = 4U;
      }
    }
    break;
    case 9: 
    tmp = strlen((char const   *)(info___0));
    infosize = (int )(tmp + 2UL);
    {
    _1_unix_newline_next = 4U;
    }
    break;
    case 19: ;
    if (file->comment) {
      {
      _1_unix_newline_next = 6U;
      }
    } else {
      {
      _1_unix_newline_next = 15U;
      }
    }
    break;
    case 17: 
    *(dirs + (level + 1)) = 1;
    line = 0;
    {
    _1_unix_newline_next = 20U;
    }
    break;
    case 6: 
    infosize = 0;
    {
    _1_unix_newline_next = 11U;
    }
    break;
    case 5: ;
    if (metafirst) {
      {
      _1_unix_newline_next = 10U;
      }
    } else {
      {
      _1_unix_newline_next = 16U;
      }
    }
    break;
    case 10: 
    printf((char const   *)((char const   */* __restrict  */)"%*s"), infosize, "");
    {
    _1_unix_newline_next = 16U;
    }
    break;
    case 7: 
    *(dirs + (level + 1)) = 0;
    {
    _1_unix_newline_next = 15U;
    }
    break;
    case 2: ;
    if (file) {
      {
      _1_unix_newline_next = 19U;
      }
    } else {
      {
      _1_unix_newline_next = 15U;
      }
    }
    break;
    case 20: ;
    if (line < lines) {
      {
      _1_unix_newline_next = 5U;
      }
    } else {
      {
      _1_unix_newline_next = 7U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF unix_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) 
{ 
  int init_elems1_inline_0_inline_1 ;
  char **dirname ;
  int i ;
  int j ;
  int k ;
  int n ;
  int optf ;
  int p ;
  int q ;
  char *stmp ;
  char *outfilename ;
  bool needfulltree ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct listingcalls __constr_expr_0 ;
  size_t___1 tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct listingcalls __constr_expr_1 ;
  struct listingcalls __constr_expr_2 ;
  struct listingcalls __constr_expr_3 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *v ;
  size_t___0 tmp___18 ;
  int tmp___19 ;
  size_t___0 tmp___20 ;
  int tmp___21 ;
  size_t___0 tmp___22 ;
  int tmp___23 ;
  size_t___0 tmp___24 ;
  int tmp___25 ;
  size_t___0 tmp___26 ;
  int tmp___27 ;
  size_t___0 tmp___28 ;
  int tmp___29 ;
  size_t___0 tmp___30 ;
  int tmp___31 ;
  size_t___0 tmp___32 ;
  int tmp___33 ;
  size_t___0 tmp___34 ;
  int tmp___35 ;
  size_t___0 tmp___36 ;
  int tmp___37 ;
  size_t___0 tmp___38 ;
  int tmp___39 ;
  size_t___0 tmp___40 ;
  int tmp___41 ;
  size_t___0 tmp___42 ;
  int tmp___43 ;
  size_t___0 tmp___44 ;
  int tmp___45 ;
  size_t___0 tmp___46 ;
  void *tmp___47 ;
  size_t___0 tmp___48 ;
  size_t___0 tmp___49 ;
  void *tmp___50 ;
  size_t___0 tmp___51 ;
  int tmp___52 ;
  size_t___0 tmp___53 ;
  int tmp___54 ;
  size_t___0 tmp___55 ;
  int tmp___56 ;
  size_t___0 tmp___57 ;
  int tmp___58 ;
  size_t___0 tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t___0 tmp___63 ;
  int tmp___64 ;
  size_t___0 tmp___65 ;
  int tmp___66 ;
  size_t___0 tmp___67 ;
  int tmp___68 ;
  size_t___0 tmp___69 ;
  int tmp___70 ;
  void *tmp___71 ;
  void *tmp___72 ;
  int tmp___73 ;
  size_t___0 tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  size_t___0 tmp___77 ;
  void *tmp___78 ;
  char *path___0 ;
  void *tmp___79 ;
  struct ignorefile *tmp___80 ;
  struct infofile *tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int _BARRIER_0 ;
  unsigned int _1_main_next ;

  {
  {
  {
  {
  {
  init_elems1_inline_0_inline_1 = 0;
  while (init_elems1_inline_0_inline_1 < 512) {
    info___0[init_elems1_inline_0_inline_1] = (char)0;
    init_elems1_inline_0_inline_1 ++;
  }
  goto info___0_i$nit_INLINE_info___0_i$nit;
  }
  info___0_i$nit_INLINE_info___0_i$nit: /* CIL Label */ ;
  }
  {
  {
  si_unit = (char *)"dkMGTPEZY";
  goto si_unit_i$nit_INLINE_si_unit_i$nit;
  }
  si_unit_i$nit_INLINE_si_unit_i$nit: /* CIL Label */ ;
  }
  {
  {
  iec_unit = (char *)"BKMGTPEZY";
  goto iec_unit_i$nit_INLINE_iec_unit_i$nit;
  }
  iec_unit_i$nit_INLINE_iec_unit_i$nit: /* CIL Label */ ;
  }
  {
  {
  perms[0] = (char )'r';
  perms[1] = (char )'w';
  perms[2] = (char )'x';
  perms[3] = (char )'r';
  perms[4] = (char )'w';
  perms[5] = (char )'x';
  perms[6] = (char )'r';
  perms[7] = (char )'w';
  perms[8] = (char )'x';
  perms[9] = (char )'\000';
  goto perms_i$nit_INLINE_perms_i$nit;
  }
  perms_i$nit_INLINE_perms_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto path_i$nit_INLINE_path_i$nit;
  }
  path_i$nit_INLINE_path_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto lbufsize_i$nit_INLINE_lbufsize_i$nit;
  }
  lbufsize_i$nit_INLINE_lbufsize_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto lbuf_i$nit_INLINE_lbuf_i$nit;
  }
  lbuf_i$nit_INLINE_lbuf_i$nit: /* CIL Label */ ;
  }
  {
  {
  sorts[0].name = (char *)"name";
  sorts[0].cmpfunc = (int (*)())(& alnumsort);
  sorts[1].name = (char *)"version";
  sorts[1].cmpfunc = (int (*)())(& versort);
  sorts[2].name = (char *)"size";
  sorts[2].cmpfunc = (int (*)())(& fsizesort);
  sorts[3].name = (char *)"mtime";
  sorts[3].cmpfunc = (int (*)())(& mtimesort);
  sorts[4].name = (char *)"ctime";
  sorts[4].cmpfunc = (int (*)())(& ctimesort);
  sorts[5].name = (char *)((void *)0);
  sorts[5].cmpfunc = (int (*)())((void *)0);
  goto sorts_i$nit_INLINE_sorts_i$nit;
  }
  sorts_i$nit_INLINE_sorts_i$nit: /* CIL Label */ ;
  }
  {
  {
  ftype[0] = "file";
  ftype[1] = "directory";
  ftype[2] = "link";
  ftype[3] = "char";
  ftype[4] = "block";
  ftype[5] = "socket";
  ftype[6] = "fifo";
  ftype[7] = "unknown";
  ftype[8] = (char const   *)((void *)0);
  goto ftype_i$nit_INLINE_ftype_i$nit;
  }
  ftype_i$nit_INLINE_ftype_i$nit: /* CIL Label */ ;
  }
  {
  {
  fmt[0] = (char const   )'-';
  fmt[1] = (char const   )'d';
  fmt[2] = (char const   )'l';
  fmt[3] = (char const   )'c';
  fmt[4] = (char const   )'b';
  fmt[5] = (char const   )'s';
  fmt[6] = (char const   )'p';
  fmt[7] = (char const   )'?';
  fmt[8] = (char const   )'\000';
  goto fmt_i$nit_INLINE_fmt_i$nit;
  }
  fmt_i$nit_INLINE_fmt_i$nit: /* CIL Label */ ;
  }
  {
  {
  ifmt[0] = (int const   )32768;
  ifmt[1] = (int const   )16384;
  ifmt[2] = (int const   )40960;
  ifmt[3] = (int const   )8192;
  ifmt[4] = (int const   )24576;
  ifmt[5] = (int const   )49152;
  ifmt[6] = (int const   )4096;
  ifmt[7] = (int const   )0;
  goto ifmt_i$nit_INLINE_ifmt_i$nit;
  }
  ifmt_i$nit_INLINE_ifmt_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto outfile_i$nit_INLINE_outfile_i$nit;
  }
  outfile_i$nit_INLINE_outfile_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto topsort_i$nit_INLINE_topsort_i$nit;
  }
  topsort_i$nit_INLINE_topsort_i$nit: /* CIL Label */ ;
  }
  {
  {
  basesort = (int (*)())(& alnumsort);
  goto basesort_i$nit_INLINE_basesort_i$nit;
  }
  basesort_i$nit_INLINE_basesort_i$nit: /* CIL Label */ ;
  }
  {
  {
  getfulltree = & unix_getfulltree;
  goto getfulltree_i$nit_INLINE_getfulltree_i$nit;
  }
  getfulltree_i$nit_INLINE_getfulltree_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto charset_i$nit_INLINE_charset_i$nit;
  }
  charset_i$nit_INLINE_charset_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto timefmt_i$nit_INLINE_timefmt_i$nit;
  }
  timefmt_i$nit_INLINE_timefmt_i$nit: /* CIL Label */ ;
  }
  {
  {
  file_pathsep = (char *)"/";
  goto file_pathsep_i$nit_INLINE_file_pathsep_i$nit;
  }
  file_pathsep_i$nit_INLINE_file_pathsep_i$nit: /* CIL Label */ ;
  }
  {
  {
  file_comment = (char *)"#";
  goto file_comment_i$nit_INLINE_file_comment_i$nit;
  }
  file_comment_i$nit_INLINE_file_comment_i$nit: /* CIL Label */ ;
  }
  {
  {
  _nl = (char *)"\n";
  goto _nl_i$nit_INLINE__nl_i$nit;
  }
  _nl_i$nit_INLINE__nl_i$nit: /* CIL Label */ ;
  }
  {
  {
  sp = (char *)" ";
  goto sp_i$nit_INLINE_sp_i$nit;
  }
  sp_i$nit_INLINE_sp_i$nit: /* CIL Label */ ;
  }
  {
  {
  title = (char *)"Directory Tree";
  goto title_i$nit_INLINE_title_i$nit;
  }
  title_i$nit_INLINE_title_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto host_i$nit_INLINE_host_i$nit;
  }
  host_i$nit_INLINE_host_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ipatterns_i$nit_INLINE_ipatterns_i$nit;
  }
  ipatterns_i$nit_INLINE_ipatterns_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto patterns_i$nit_INLINE_patterns_i$nit;
  }
  patterns_i$nit_INLINE_patterns_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto maxipattern_i$nit_INLINE_maxipattern_i$nit;
  }
  maxipattern_i$nit_INLINE_maxipattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ipattern_i$nit_INLINE_ipattern_i$nit;
  }
  ipattern_i$nit_INLINE_ipattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto maxpattern_i$nit_INLINE_maxpattern_i$nit;
  }
  maxpattern_i$nit_INLINE_maxpattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto pattern_i$nit_INLINE_pattern_i$nit;
  }
  pattern_i$nit_INLINE_pattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  hversion = (char *)"\t\t tree v2.0.4 %s 1996 - 2022 by Steve Baker and Thomas Moore <br>\n\t\t HTML output hacked and copyleft %s 1998 by Francesc Rocher <br>\n\t\t JSON output hacked and copyleft %s 2014 by Florian Sesser <br>\n\t\t Charsets / OS/2 support %s 2001 by Kyosuke Tokoro\n";
  goto hversion_i$nit_INLINE_hversion_i$nit;
  }
  hversion_i$nit_INLINE_hversion_i$nit: /* CIL Label */ ;
  }
  {
  {
  version = (char *)"$Version: $ tree v2.0.4 (c) 1996 - 2022 by Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro $";
  goto version_i$nit_INLINE_version_i$nit;
  }
  version_i$nit_INLINE_version_i$nit: /* CIL Label */ ;
  }
  {
  {
  result_type[0] = (int const   )2;
  result_type[1] = (int const   )2;
  result_type[2] = (int const   )2;
  result_type[3] = (int const   )2;
  result_type[4] = (int const   )2;
  result_type[5] = (int const   )3;
  result_type[6] = (int const   )2;
  result_type[7] = (int const   )2;
  result_type[8] = (int const   )2;
  result_type[9] = (int const   )2;
  result_type[10] = (int const   )2;
  result_type[11] = (int const   )2;
  result_type[12] = (int const   )2;
  result_type[13] = (int const   )2;
  result_type[14] = (int const   )2;
  result_type[15] = (int const   )2;
  result_type[16] = (int const   )2;
  result_type[17] = (int const   )-1;
  result_type[18] = (int const   )-1;
  result_type[19] = (int const   )2;
  result_type[20] = (int const   )1;
  result_type[21] = (int const   )3;
  result_type[22] = (int const   )3;
  result_type[23] = (int const   )2;
  result_type[24] = (int const   )1;
  result_type[25] = (int const   )3;
  result_type[26] = (int const   )3;
  result_type[27] = (int const   )2;
  result_type[28] = (int const   )2;
  result_type[29] = (int const   )2;
  result_type[30] = (int const   )2;
  result_type[31] = (int const   )2;
  result_type[32] = (int const   )2;
  result_type[33] = (int const   )2;
  result_type[34] = (int const   )2;
  result_type[35] = (int const   )2;
  result_type[36] = (int const   )2;
  result_type[37] = (int const   )3;
  result_type[38] = (int const   )2;
  result_type[39] = (int const   )2;
  result_type[40] = (int const   )2;
  result_type[41] = (int const   )2;
  result_type[42] = (int const   )2;
  result_type[43] = (int const   )2;
  result_type[44] = (int const   )2;
  result_type[45] = (int const   )2;
  result_type[46] = (int const   )2;
  result_type[47] = (int const   )2;
  result_type[48] = (int const   )2;
  result_type[49] = (int const   )1;
  result_type[50] = (int const   )1;
  result_type[51] = (int const   )2;
  result_type[52] = (int const   )-1;
  result_type[53] = (int const   )2;
  result_type[54] = (int const   )2;
  result_type[55] = (int const   )2;
  result_type[56] = (int const   )-1;
  result_type[57] = (int const   )2;
  result_type[58] = (int const   )2;
  result_type[59] = (int const   )2;
  goto result_type_i$nit_INLINE_result_type_i$nit;
  }
  result_type_i$nit_INLINE_result_type_i$nit: /* CIL Label */ ;
  }
  {
  {
  next_state[0] = (unsigned int const   )0;
  next_state[1] = (unsigned int const   )4;
  next_state[2] = (unsigned int const   )12;
  next_state[3] = (unsigned int const   )0;
  next_state[4] = (unsigned int const   )0;
  next_state[5] = (unsigned int const   )4;
  next_state[6] = (unsigned int const   )4;
  next_state[7] = (unsigned int const   )4;
  next_state[8] = (unsigned int const   )0;
  next_state[9] = (unsigned int const   )8;
  next_state[10] = (unsigned int const   )8;
  next_state[11] = (unsigned int const   )8;
  next_state[12] = (unsigned int const   )0;
  next_state[13] = (unsigned int const   )8;
  next_state[14] = (unsigned int const   )12;
  next_state[15] = (unsigned int const   )12;
  goto next_state_i$nit_INLINE_next_state_i$nit;
  }
  next_state_i$nit_INLINE_next_state_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto infostack_i$nit_INLINE_infostack_i$nit;
  }
  infostack_i$nit_INLINE_infostack_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto htmldirlen_i$nit_INLINE_htmldirlen_i$nit;
  }
  htmldirlen_i$nit_INLINE_htmldirlen_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto filterstack_i$nit_INLINE_filterstack_i$nit;
  }
  filterstack_i$nit_INLINE_filterstack_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto prev_i$nit_INLINE_prev_i$nit;
  }
  prev_i$nit_INLINE_prev_i$nit: /* CIL Label */ ;
  }
  {
  {
  cstable[0].name = latin1_3;
  cstable[0].vert = "|  ";
  cstable[0].vert_left = "|--";
  cstable[0].corner = "&middot;--";
  cstable[0].copy = "&copy;";
  cstable[0].ctop = " [";
  cstable[0].cbot = " [";
  cstable[0].cmid = " [";
  cstable[0].cext = " [";
  cstable[0].csingle = " [";
  cstable[1].name = iso8859_789;
  cstable[1].vert = "|  ";
  cstable[1].vert_left = "|--";
  cstable[1].corner = "&middot;--";
  cstable[1].copy = "(c)";
  cstable[1].ctop = " [";
  cstable[1].cbot = " [";
  cstable[1].cmid = " [";
  cstable[1].cext = " [";
  cstable[1].csingle = " [";
  cstable[2].name = shift_jis;
  cstable[2].vert = "\204\240 ";
  cstable[2].vert_left = "\204\245";
  cstable[2].corner = "\204\244";
  cstable[2].copy = "(c)";
  cstable[2].ctop = " [";
  cstable[2].cbot = " [";
  cstable[2].cmid = " [";
  cstable[2].cext = " [";
  cstable[2].csingle = " [";
  cstable[3].name = euc_jp;
  cstable[3].vert = "\250\242 ";
  cstable[3].vert_left = "\250\247";
  cstable[3].corner = "\250\246";
  cstable[3].copy = "(c)";
  cstable[3].ctop = " [";
  cstable[3].cbot = " [";
  cstable[3].cmid = " [";
  cstable[3].cext = " [";
  cstable[3].csingle = " [";
  cstable[4].name = euc_kr;
  cstable[4].vert = "\246\242 ";
  cstable[4].vert_left = "\246\247";
  cstable[4].corner = "\246\246";
  cstable[4].copy = "(c)";
  cstable[4].ctop = " [";
  cstable[4].cbot = " [";
  cstable[4].cmid = " [";
  cstable[4].cext = " [";
  cstable[4].csingle = " [";
  cstable[5].name = iso2022jp;
  cstable[5].vert = "\033$B(\"\033(B ";
  cstable[5].vert_left = "\033$B(\'\033(B";
  cstable[5].corner = "\033$B(&\033(B";
  cstable[5].copy = "(c)";
  cstable[5].ctop = " [";
  cstable[5].cbot = " [";
  cstable[5].cmid = " [";
  cstable[5].cext = " [";
  cstable[5].csingle = " [";
  cstable[6].name = ibm_pc;
  cstable[6].vert = "\263  ";
  cstable[6].vert_left = "\303\304\304";
  cstable[6].corner = "\300\304\304";
  cstable[6].copy = "(c)";
  cstable[6].ctop = " [";
  cstable[6].cbot = " [";
  cstable[6].cmid = " [";
  cstable[6].cext = " [";
  cstable[6].csingle = " [";
  cstable[7].name = ibm_ps2;
  cstable[7].vert = "\263  ";
  cstable[7].vert_left = "\303\304\304";
  cstable[7].corner = "\300\304\304";
  cstable[7].copy = "\227";
  cstable[7].ctop = " [";
  cstable[7].cbot = " [";
  cstable[7].cmid = " [";
  cstable[7].cext = " [";
  cstable[7].csingle = " [";
  cstable[8].name = ibm_gr;
  cstable[8].vert = "\263  ";
  cstable[8].vert_left = "\303\304\304";
  cstable[8].corner = "\300\304\304";
  cstable[8].copy = "\270";
  cstable[8].ctop = " [";
  cstable[8].cbot = " [";
  cstable[8].cmid = " [";
  cstable[8].cext = " [";
  cstable[8].csingle = " [";
  cstable[9].name = gb;
  cstable[9].vert = "\251\246 ";
  cstable[9].vert_left = "\251\300";
  cstable[9].corner = "\251\270";
  cstable[9].copy = "(c)";
  cstable[9].ctop = " [";
  cstable[9].cbot = " [";
  cstable[9].cmid = " [";
  cstable[9].cext = " [";
  cstable[9].csingle = " [";
  cstable[10].name = utf8;
  cstable[10].vert = "\342\224\202\302\240\302\240";
  cstable[10].vert_left = "\342\224\234\342\224\200\342\224\200";
  cstable[10].corner = "\342\224\224\342\224\200\342\224\200";
  cstable[10].copy = "\302\251";
  cstable[10].ctop = " \342\216\247";
  cstable[10].cbot = " \342\216\251";
  cstable[10].cmid = " \342\216\250";
  cstable[10].cext = " \342\216\252";
  cstable[10].csingle = " {";
  cstable[11].name = big5;
  cstable[11].vert = "\242x ";
  cstable[11].vert_left = "\242u";
  cstable[11].corner = "\242|";
  cstable[11].copy = "(c)";
  cstable[11].ctop = " [";
  cstable[11].cbot = " [";
  cstable[11].cmid = " [";
  cstable[11].cext = " [";
  cstable[11].csingle = " [";
  cstable[12].name = viscii;
  cstable[12].vert = "|  ";
  cstable[12].vert_left = "|--";
  cstable[12].corner = "`--";
  cstable[12].copy = "\371";
  cstable[12].ctop = " [";
  cstable[12].cbot = " [";
  cstable[12].cmid = " [";
  cstable[12].cext = " [";
  cstable[12].csingle = " [";
  cstable[13].name = koi8ru;
  cstable[13].vert = "\201  ";
  cstable[13].vert_left = "\206\200\200";
  cstable[13].corner = "\204\200\200";
  cstable[13].copy = "\277";
  cstable[13].ctop = " [";
  cstable[13].cbot = " [";
  cstable[13].cmid = " [";
  cstable[13].cext = " [";
  cstable[13].csingle = " [";
  cstable[14].name = windows;
  cstable[14].vert = "|  ";
  cstable[14].vert_left = "|--";
  cstable[14].corner = "`--";
  cstable[14].copy = "\251";
  cstable[14].ctop = " [";
  cstable[14].cbot = " [";
  cstable[14].cmid = " [";
  cstable[14].cext = " [";
  cstable[14].csingle = " [";
  cstable[15].name = (char const   **)((void *)0);
  cstable[15].vert = "|  ";
  cstable[15].vert_left = "|--";
  cstable[15].corner = "`--";
  cstable[15].copy = "(c)";
  cstable[15].ctop = " [";
  cstable[15].cbot = " [";
  cstable[15].cmid = " [";
  cstable[15].cext = " [";
  cstable[15].csingle = " [";
  goto cstable_i$nit_INLINE_cstable_i$nit;
  }
  cstable_i$nit_INLINE_cstable_i$nit: /* CIL Label */ ;
  }
  {
  {
  windows[0] = "ISO-8859-1-Windows-3.1-Latin-1";
  windows[1] = "csWindows31Latin1";
  windows[2] = "ISO-8859-2-Windows-Latin-2";
  windows[3] = "csWindows31Latin2";
  windows[4] = "windows-1250";
  windows[5] = "windows-1251";
  windows[6] = "windows-1253";
  windows[7] = "windows-1254";
  windows[8] = "windows-1255";
  windows[9] = "windows-1256";
  windows[10] = "windows-1256";
  windows[11] = "windows-1257";
  windows[12] = (char const   *)((void *)0);
  goto windows_i$nit_INLINE_windows_i$nit;
  }
  windows_i$nit_INLINE_windows_i$nit: /* CIL Label */ ;
  }
  {
  {
  koi8ru[0] = "KOI8-R";
  koi8ru[1] = "csKOI8R";
  koi8ru[2] = "KOI8-U";
  koi8ru[3] = (char const   *)((void *)0);
  goto koi8ru_i$nit_INLINE_koi8ru_i$nit;
  }
  koi8ru_i$nit_INLINE_koi8ru_i$nit: /* CIL Label */ ;
  }
  {
  {
  viscii[0] = "VISCII";
  viscii[1] = "csVISCII";
  viscii[2] = (char const   *)((void *)0);
  goto viscii_i$nit_INLINE_viscii_i$nit;
  }
  viscii_i$nit_INLINE_viscii_i$nit: /* CIL Label */ ;
  }
  {
  {
  big5[0] = "Big5";
  big5[1] = "csBig5";
  big5[2] = (char const   *)((void *)0);
  goto big5_i$nit_INLINE_big5_i$nit;
  }
  big5_i$nit_INLINE_big5_i$nit: /* CIL Label */ ;
  }
  {
  {
  utf8[0] = "UTF-8";
  utf8[1] = "utf8";
  utf8[2] = (char const   *)((void *)0);
  goto utf8_i$nit_INLINE_utf8_i$nit;
  }
  utf8_i$nit_INLINE_utf8_i$nit: /* CIL Label */ ;
  }
  {
  {
  gb[0] = "GB2312";
  gb[1] = "csGB2312";
  gb[2] = (char const   *)((void *)0);
  goto gb_i$nit_INLINE_gb_i$nit;
  }
  gb_i$nit_INLINE_gb_i$nit: /* CIL Label */ ;
  }
  {
  {
  ibm_gr[0] = "IBM869";
  ibm_gr[1] = "cp869";
  ibm_gr[2] = "869";
  ibm_gr[3] = "cp-gr";
  ibm_gr[4] = "csIBM869";
  ibm_gr[5] = (char const   *)((void *)0);
  goto ibm_gr_i$nit_INLINE_ibm_gr_i$nit;
  }
  ibm_gr_i$nit_INLINE_ibm_gr_i$nit: /* CIL Label */ ;
  }
  {
  {
  ibm_ps2[0] = "IBM850";
  ibm_ps2[1] = "cp850";
  ibm_ps2[2] = "850";
  ibm_ps2[3] = "csPC850Multilingual";
  ibm_ps2[4] = "IBM00858";
  ibm_ps2[5] = "CCSID00858";
  ibm_ps2[6] = "CP00858";
  ibm_ps2[7] = "PC-Multilingual-850+euro";
  ibm_ps2[8] = (char const   *)((void *)0);
  goto ibm_ps2_i$nit_INLINE_ibm_ps2_i$nit;
  }
  ibm_ps2_i$nit_INLINE_ibm_ps2_i$nit: /* CIL Label */ ;
  }
  {
  {
  ibm_pc[0] = "IBM437";
  ibm_pc[1] = "cp437";
  ibm_pc[2] = "437";
  ibm_pc[3] = "csPC8CodePage437";
  ibm_pc[4] = "IBM852";
  ibm_pc[5] = "cp852";
  ibm_pc[6] = "852";
  ibm_pc[7] = "csPCp852";
  ibm_pc[8] = "IBM863";
  ibm_pc[9] = "cp863";
  ibm_pc[10] = "863";
  ibm_pc[11] = "csIBM863";
  ibm_pc[12] = "IBM855";
  ibm_pc[13] = "cp855";
  ibm_pc[14] = "855";
  ibm_pc[15] = "csIBM855";
  ibm_pc[16] = "IBM865";
  ibm_pc[17] = "cp865";
  ibm_pc[18] = "865";
  ibm_pc[19] = "csIBM865";
  ibm_pc[20] = "IBM866";
  ibm_pc[21] = "cp866";
  ibm_pc[22] = "866";
  ibm_pc[23] = "csIBM866";
  ibm_pc[24] = (char const   *)((void *)0);
  goto ibm_pc_i$nit_INLINE_ibm_pc_i$nit;
  }
  ibm_pc_i$nit_INLINE_ibm_pc_i$nit: /* CIL Label */ ;
  }
  {
  {
  iso2022jp[0] = "ISO-2022-JP";
  iso2022jp[1] = "csISO2022JP";
  iso2022jp[2] = "ISO-2022-JP-2";
  iso2022jp[3] = "csISO2022JP2";
  iso2022jp[4] = (char const   *)((void *)0);
  goto iso2022jp_i$nit_INLINE_iso2022jp_i$nit;
  }
  iso2022jp_i$nit_INLINE_iso2022jp_i$nit: /* CIL Label */ ;
  }
  {
  {
  euc_kr[0] = "EUC-KR";
  euc_kr[1] = "csEUCKR";
  euc_kr[2] = (char const   *)((void *)0);
  goto euc_kr_i$nit_INLINE_euc_kr_i$nit;
  }
  euc_kr_i$nit_INLINE_euc_kr_i$nit: /* CIL Label */ ;
  }
  {
  {
  euc_jp[0] = "EUC-JP";
  euc_jp[1] = "Extended_UNIX_Code_Packed_Format_for_Japanese";
  euc_jp[2] = "csEUCPkdFmtJapanese";
  euc_jp[3] = (char const   *)((void *)0);
  goto euc_jp_i$nit_INLINE_euc_jp_i$nit;
  }
  euc_jp_i$nit_INLINE_euc_jp_i$nit: /* CIL Label */ ;
  }
  {
  {
  shift_jis[0] = "Shift_JIS";
  shift_jis[1] = "MS_Kanji";
  shift_jis[2] = "csShiftJIS";
  shift_jis[3] = (char const   *)((void *)0);
  goto shift_jis_i$nit_INLINE_shift_jis_i$nit;
  }
  shift_jis_i$nit_INLINE_shift_jis_i$nit: /* CIL Label */ ;
  }
  {
  {
  iso8859_789[0] = "ISO-8859-7";
  iso8859_789[1] = "ISO_8859-7:1987";
  iso8859_789[2] = "ISO_8859-7";
  iso8859_789[3] = "ELOT_928";
  iso8859_789[4] = "ECMA-118";
  iso8859_789[5] = "greek";
  iso8859_789[6] = "greek8";
  iso8859_789[7] = "csISOLatinGreek";
  iso8859_789[8] = "ISO-8859-8";
  iso8859_789[9] = "ISO_8859-8:1988";
  iso8859_789[10] = "iso-ir-138";
  iso8859_789[11] = "ISO_8859-8";
  iso8859_789[12] = "hebrew";
  iso8859_789[13] = "csISOLatinHebrew";
  iso8859_789[14] = "ISO-8859-9";
  iso8859_789[15] = "ISO_8859-9:1989";
  iso8859_789[16] = "iso-ir-148";
  iso8859_789[17] = "ISO_8859-9";
  iso8859_789[18] = "latin5";
  iso8859_789[19] = "l5";
  iso8859_789[20] = "csISOLatin5";
  iso8859_789[21] = (char const   *)((void *)0);
  goto iso8859_789_i$nit_INLINE_iso8859_789_i$nit;
  }
  iso8859_789_i$nit_INLINE_iso8859_789_i$nit: /* CIL Label */ ;
  }
  {
  {
  latin1_3[0] = "ISO-8859-1";
  latin1_3[1] = "ISO-8859-1:1987";
  latin1_3[2] = "ISO_8859-1";
  latin1_3[3] = "latin1";
  latin1_3[4] = "l1";
  latin1_3[5] = "IBM819";
  latin1_3[6] = "CP819";
  latin1_3[7] = "csISOLatin1";
  latin1_3[8] = "ISO-8859-3";
  latin1_3[9] = "ISO_8859-3:1988";
  latin1_3[10] = "ISO_8859-3";
  latin1_3[11] = "latin3";
  latin1_3[12] = "ls";
  latin1_3[13] = "csISOLatin3";
  latin1_3[14] = (char const   *)((void *)0);
  goto latin1_3_i$nit_INLINE_latin1_3_i$nit;
  }
  latin1_3_i$nit_INLINE_latin1_3_i$nit: /* CIL Label */ ;
  }
  {
  {
  cmds[0].cmd = (char *)"rs";
  cmds[0].cmdnum = (char)4;
  cmds[1].cmd = (char *)"no";
  cmds[1].cmdnum = (char)5;
  cmds[2].cmd = (char *)"fi";
  cmds[2].cmdnum = (char)6;
  cmds[3].cmd = (char *)"di";
  cmds[3].cmdnum = (char)7;
  cmds[4].cmd = (char *)"ln";
  cmds[4].cmdnum = (char)8;
  cmds[5].cmd = (char *)"pi";
  cmds[5].cmdnum = (char)9;
  cmds[6].cmd = (char *)"do";
  cmds[6].cmdnum = (char)10;
  cmds[7].cmd = (char *)"bd";
  cmds[7].cmdnum = (char)11;
  cmds[8].cmd = (char *)"cd";
  cmds[8].cmdnum = (char)12;
  cmds[9].cmd = (char *)"or";
  cmds[9].cmdnum = (char)13;
  cmds[10].cmd = (char *)"so";
  cmds[10].cmdnum = (char)14;
  cmds[11].cmd = (char *)"su";
  cmds[11].cmdnum = (char)15;
  cmds[12].cmd = (char *)"sg";
  cmds[12].cmdnum = (char)16;
  cmds[13].cmd = (char *)"tw";
  cmds[13].cmdnum = (char)17;
  cmds[14].cmd = (char *)"ow";
  cmds[14].cmdnum = (char)18;
  cmds[15].cmd = (char *)"st";
  cmds[15].cmdnum = (char)19;
  cmds[16].cmd = (char *)"ex";
  cmds[16].cmdnum = (char)20;
  cmds[17].cmd = (char *)"mi";
  cmds[17].cmdnum = (char)21;
  cmds[18].cmd = (char *)"lc";
  cmds[18].cmdnum = (char)22;
  cmds[19].cmd = (char *)"rc";
  cmds[19].cmdnum = (char)23;
  cmds[20].cmd = (char *)"ec";
  cmds[20].cmdnum = (char)24;
  cmds[21].cmd = (char *)((void *)0);
  cmds[21].cmdnum = (char)0;
  goto cmds_i$nit_INLINE_cmds_i$nit;
  }
  cmds_i$nit_INLINE_cmds_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ext_i$nit_INLINE_ext_i$nit;
  }
  ext_i$nit_INLINE_ext_i$nit: /* CIL Label */ ;
  }
  {
  {
  vgacolor[0] = (char *)"black";
  vgacolor[1] = (char *)"red";
  vgacolor[2] = (char *)"green";
  vgacolor[3] = (char *)"yellow";
  vgacolor[4] = (char *)"blue";
  vgacolor[5] = (char *)"fuchsia";
  vgacolor[6] = (char *)"aqua";
  vgacolor[7] = (char *)"white";
  vgacolor[8] = (char *)((void *)0);
  vgacolor[9] = (char *)((void *)0);
  vgacolor[10] = (char *)"transparent";
  vgacolor[11] = (char *)"red";
  vgacolor[12] = (char *)"green";
  vgacolor[13] = (char *)"yellow";
  vgacolor[14] = (char *)"blue";
  vgacolor[15] = (char *)"fuchsia";
  vgacolor[16] = (char *)"aqua";
  vgacolor[17] = (char *)"black";
  goto vgacolor_i$nit_INLINE_vgacolor_i$nit;
  }
  vgacolor_i$nit_INLINE_vgacolor_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto color_code_i$nit_INLINE_color_code_i$nit;
  }
  color_code_i$nit_INLINE_color_code_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto termmatch_i$nit_INLINE_termmatch_i$nit;
  }
  termmatch_i$nit_INLINE_termmatch_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto linktargetcolor_i$nit_INLINE_linktargetcolor_i$nit;
  }
  linktargetcolor_i$nit_INLINE_linktargetcolor_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ansilines_i$nit_INLINE_ansilines_i$nit;
  }
  ansilines_i$nit_INLINE_ansilines_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto colorize_i$nit_INLINE_colorize_i$nit;
  }
  colorize_i$nit_INLINE_colorize_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_envp_i$nit_INLINE__global_envp_i$nit;
  }
  _global_envp_i$nit_INLINE__global_envp_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argv_i$nit_INLINE__global_argv_i$nit;
  }
  _global_argv_i$nit_INLINE__global_argv_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argc_i$nit_INLINE__global_argc_i$nit;
  }
  _global_argc_i$nit_INLINE__global_argc_i$nit: /* CIL Label */ ;
  }
  goto megaInit_INLINE_megaInit;
  }
  megaInit_INLINE_megaInit: /* CIL Label */ ;
  }
  _global_argc = argc;
  _global_argv = argv;
  _global_envp = _formal_envp;
  _BARRIER_0 = 1;
  {
  _1_main_next = 22U;
  }
  while (1) {
    switch (_1_main_next) {
    case 239: 
    tmp___28 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___28 - 1UL);
    topsort = (int (*)())(& dirsfirst);
    {
    _1_main_next = 14U;
    }
    break;
    case 182: ;
    if (! tmp___35) {
      {
      _1_main_next = 171U;
      }
    } else {
      {
      _1_main_next = 158U;
      }
    }
    break;
    case 18: 
    tmp___11 = n;
    n ++;
    host = *(argv + tmp___11);
    sp = (char *)"&nbsp;";
    {
    _1_main_next = 14U;
    }
    break;
    case 50: 
    tmp___35 = strncmp("--filelimit", (char const   *)*(argv + i), (size_t___0 )11);
    {
    _1_main_next = 182U;
    }
    break;
    case 80: ;
    if (stmp) {
      {
      _1_main_next = 168U;
      }
    } else {
      {
      _1_main_next = 126U;
      }
    }
    break;
    case 104: 
    tmp___22 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___22 - 1UL);
    devflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 188: ;
    if (matchdirs) {
      {
      _1_main_next = 193U;
      }
    } else {
      {
      _1_main_next = 42U;
      }
    }
    break;
    case 4: 
    Fflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 258: ;
    if (dflag) {
      {
      _1_main_next = 49U;
      }
    } else {
      {
      _1_main_next = 179U;
      }
    }
    break;
    case 103: ;
    if (ipattern >= maxipattern - 1) {
      {
      _1_main_next = 183U;
      }
    } else {
      {
      _1_main_next = 75U;
      }
    }
    break;
    case 102: ;
    if (p == q - 2) {
      {
      _1_main_next = 81U;
      }
    } else {
      {
      _1_main_next = 119U;
      }
    }
    break;
    case 145: 
    tmp___31 = strcmp("--filesfirst", (char const   *)*(argv + i));
    {
    _1_main_next = 23U;
    }
    break;
    case 180: 
    tmp___37 = n;
    n ++;
    charset = (char const   *)*(argv + tmp___37);
    tmp___38 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___38 - 1UL);
    {
    _1_main_next = 14U;
    }
    break;
    case 275: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: sort type \'%s\' not valid, should be one of: "),
            stmp);
    k = 0;
    {
    _1_main_next = 60U;
    }
    break;
    case 121: 
    Xflag = (bool )1;
    Jflag = (bool )0;
    Hflag = Jflag;
    __constr_expr_1.intro = & xml_intro;
    __constr_expr_1.outtro = & xml_outtro;
    __constr_expr_1.printinfo = & xml_printinfo;
    __constr_expr_1.printfile = & xml_printfile;
    __constr_expr_1.error = & xml_error;
    __constr_expr_1.newline = & xml_newline;
    __constr_expr_1.close = & xml_close;
    __constr_expr_1.report = & xml_report;
    lc = __constr_expr_1;
    {
    _1_main_next = 14U;
    }
    break;
    case 216: 
    j ++;
    {
    _1_main_next = 226U;
    }
    break;
    case 168: 
    tmp___79 = xmalloc((size_t___0 )4096);
    path___0 = (char *)tmp___79;
    snprintf((char *)((char */* __restrict  */)path___0), (size_t___0 )4096, (char const   *)((char const   */* __restrict  */)"%s/info/exclude"),
             stmp);
    tmp___80 = new_ignorefile(path___0);
    push_filterstack(tmp___80);
    free((void *)path___0);
    {
    _1_main_next = 126U;
    }
    break;
    case 152: 
    j = 6;
    {
    _1_main_next = 134U;
    }
    break;
    case 205: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Invalid level, must be greater than 0.\n"));
    exit(1);
    {
    _1_main_next = 14U;
    }
    break;
    case 8: 
    tmp___36 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___36 - 1UL);
    {
    _1_main_next = 14U;
    }
    break;
    case 160: 
    fflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 235: ;
    if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
      {
      _1_main_next = 174U;
      }
    } else {
      {
      _1_main_next = 194U;
      }
    }
    break;
    case 246: 
    tmp___30 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___30 - 1UL);
    topsort = (int (*)())(& filesfirst);
    {
    _1_main_next = 14U;
    }
    break;
    case 195: 
    stmp = *(argv + i) + j;
    tmp___57 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___57 - 1UL);
    {
    _1_main_next = 256U;
    }
    break;
    case 124: 
    basesort = sorts[k].cmpfunc;
    {
    _1_main_next = 78U;
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --sort=\n"));
    exit(1);
    {
    _1_main_next = 256U;
    }
    break;
    case 242: ;
    if (! tmp___62) {
      {
      _1_main_next = 152U;
      }
    } else {
      {
      _1_main_next = 254U;
      }
    }
    break;
    case 159: 
    tmp___0 = nl_langinfo(14);
    tmp___1 = strcmp((char const   *)tmp___0, "UTF-8");
    {
    _1_main_next = 83U;
    }
    break;
    case 3: 
    maxpattern += 10;
    tmp___5 = xrealloc((void *)patterns, sizeof(char *) * (unsigned long )maxpattern);
    patterns = (char **)tmp___5;
    {
    _1_main_next = 173U;
    }
    break;
    case 16: 
    initlinedraw(1);
    exit(1);
    {
    _1_main_next = 14U;
    }
    break;
    case 231: 
    tmp___61 = ',';
    {
    _1_main_next = 167U;
    }
    break;
    case 122: 
    tmp___65 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___65 - 1UL);
    metafirst = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 181: ;
    if (! tmp___21) {
      {
      _1_main_next = 212U;
      }
    } else {
      {
      _1_main_next = 223U;
      }
    }
    break;
    case 85: 
    tmp___81 = new_infofile((char *)"/usr/share/finfo/global_info");
    push_infostack(tmp___81);
    {
    _1_main_next = 41U;
    }
    break;
    case 100: ;
    if (sorts[k + 1].name) {
      {
      _1_main_next = 231U;
      }
    } else {
      {
      _1_main_next = 110U;
      }
    }
    break;
    case 26: 
    tmp___83 = 0;
    {
    _1_main_next = 0U;
    }
    break;
    case 105: 
    tmp___24 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___24 - 1UL);
    noreport = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 247: ;
    if (*(*(argv + i) + j)) {
      {
      _1_main_next = 195U;
      }
    } else {
      {
      _1_main_next = 1U;
      }
    }
    break;
    case 279: 
    charset = (char const   *)(*(argv + i) + 10);
    {
    _1_main_next = 267U;
    }
    break;
    case 176: ;
    if (! tmp___23) {
      {
      _1_main_next = 104U;
      }
    } else {
      {
      _1_main_next = 271U;
      }
    }
    break;
    case 186: ;
    if (p) {
      {
      _1_main_next = 283U;
      }
    } else {
      {
      _1_main_next = 120U;
      }
    }
    break;
    case 297: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -o option.\n"));
    exit(1);
    {
    _1_main_next = 113U;
    }
    break;
    case 192: 
    tmp___19 = strcmp("--version", (char const   *)*(argv + i));
    {
    _1_main_next = 39U;
    }
    break;
    case 211: 
    sflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 259: 
    charset = "UTF-8";
    {
    _1_main_next = 88U;
    }
    break;
    case 271: 
    tmp___25 = strcmp("--noreport", (char const   *)*(argv + i));
    {
    _1_main_next = 191U;
    }
    break;
    case 125: 
    basesort = (int (*)())(& ctimesort);
    cflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 143: 
    tmp___43 = strncmp("--du", (char const   *)*(argv + i), (size_t___0 )4);
    {
    _1_main_next = 151U;
    }
    break;
    case 19: 
    printf((char const   *)((char const   */* __restrict  */)"here i = %d, n = %d\n"),
           i, n);
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Invalid argument -`%c\'.\n"),
            (int )*(*(argv + i) + j));
    usage(1);
    exit(1);
    {
    _1_main_next = 14U;
    }
    break;
    case 32: 
    Rflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 227: 
    tmp___44 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___44 - 1UL);
    pruneflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 228: 
    tmp___12 = n;
    n ++;
    title = *(argv + tmp___12);
    {
    _1_main_next = 14U;
    }
    break;
    case 226: ;
    if (*(*(argv + i) + j)) {
      {
      _1_main_next = 285U;
      }
    } else {
      {
      _1_main_next = 250U;
      }
    }
    break;
    case 199: 
    setlocale(2, "");
    {
    _1_main_next = 258U;
    }
    break;
    case 264: 
    tmp___41 = strncmp("--si", (char const   *)*(argv + i), (size_t___0 )4);
    {
    _1_main_next = 155U;
    }
    break;
    case 269: 
    tmp___40 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___40 - 1UL);
    sflag = (bool )1;
    hflag = (bool )1;
    siflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 295: ;
    if (errors) {
      {
      _1_main_next = 266U;
      }
    } else {
      {
      _1_main_next = 26U;
      }
    }
    break;
    case 117: 
    aflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 208: ;
    if (! tmp___64) {
      {
      _1_main_next = 139U;
      }
    } else {
      {
      _1_main_next = 114U;
      }
    }
    break;
    case 60: ;
    if (sorts[k].name) {
      {
      _1_main_next = 100U;
      }
    } else {
      {
      _1_main_next = 289U;
      }
    }
    break;
    case 150: 
    j = 9;
    {
    _1_main_next = 288U;
    }
    break;
    case 244: 
    tmp___60 = strcasecmp((char const   *)sorts[k].name, (char const   *)stmp);
    {
    _1_main_next = 132U;
    }
    break;
    case 142: ;
    if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
      {
      _1_main_next = 69U;
      }
    } else {
      {
      _1_main_next = 228U;
      }
    }
    break;
    case 144: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --timefmt\n"));
    exit(1);
    {
    _1_main_next = 46U;
    }
    break;
    case 243: ;
    if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
      {
      _1_main_next = 197U;
      }
    } else {
      {
      _1_main_next = 97U;
      }
    }
    break;
    case 157: 
    tmp___76 = xmalloc(sizeof(char *) * 2UL);
    dirname = (char **)tmp___76;
    tmp___77 = strlen(".");
    tmp___78 = xmalloc(tmp___77 + 1UL);
    *(dirname + 0) = strcpy((char *)((char */* __restrict  */)tmp___78), (char const   *)((char const   */* __restrict  */)"."));
    *(dirname + 1) = (char *)((void *)0);
    {
    _1_main_next = 133U;
    }
    break;
    case 194: ;
    if (pattern >= maxpattern - 1) {
      {
      _1_main_next = 3U;
      }
    } else {
      {
      _1_main_next = 173U;
      }
    }
    break;
    case 289: 
    exit(1);
    {
    _1_main_next = 14U;
    }
    break;
    case 212: 
    tmp___20 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___20 - 1UL);
    inodeflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 84: 
    xdev = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 183: 
    maxipattern += 10;
    tmp___8 = xrealloc((void *)ipatterns, sizeof(char *) * (unsigned long )maxipattern);
    ipatterns = (char **)tmp___8;
    {
    _1_main_next = 75U;
    }
    break;
    case 171: 
    j = 11;
    {
    _1_main_next = 48U;
    }
    break;
    case 34: ;
    if (optf) {
      {
      _1_main_next = 210U;
      }
    } else {
      {
      _1_main_next = 175U;
      }
    }
    break;
    case 274: 
    Nflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 251: 
    tmp___56 = strncmp("--matchdirs", (char const   *)*(argv + i), (size_t___0 )11);
    {
    _1_main_next = 220U;
    }
    break;
    case 169: ;
    if (! tmp___16) {
      {
      _1_main_next = 196U;
      }
    } else {
      {
      _1_main_next = 280U;
      }
    }
    break;
    case 127: ;
    if (! tmp___39) {
      {
      _1_main_next = 150U;
      }
    } else {
      {
      _1_main_next = 264U;
      }
    }
    break;
    case 22: 
    dirname = (char **)((void *)0);
    j = 0;
    p = 0;
    q = 0;
    outfilename = (char *)((void *)0);
    gflag = (bool )0;
    uflag = gflag;
    Fflag = uflag;
    sflag = Fflag;
    pflag = sflag;
    lflag = pflag;
    fflag = lflag;
    dflag = fflag;
    aflag = dflag;
    cflag = (bool )0;
    siflag = cflag;
    Hflag = siflag;
    hflag = Hflag;
    Rflag = hflag;
    Qflag = Rflag;
    Nflag = Qflag;
    qflag = Nflag;
    Dflag = qflag;
    reverse = (bool )0;
    nolinks = reverse;
    noreport = nolinks;
    xdev = noreport;
    nocolor = xdev;
    force_color = nocolor;
    noindent = force_color;
    Jflag = (bool )0;
    Xflag = Jflag;
    devflag = Xflag;
    inodeflag = devflag;
    matchdirs = inodeflag;
    ignorecase = matchdirs;
    gitignore = (bool )0;
    metafirst = gitignore;
    pruneflag = metafirst;
    duflag = pruneflag;
    flimit = 0;
    maxdirs = 4096;
    tmp = xmalloc(sizeof(int ) * (unsigned long )maxdirs);
    dirs = (int *)tmp;
    memset((void *)dirs, 0, sizeof(int ) * (unsigned long )maxdirs);
    *(dirs + 0) = 0;
    Level = -1;
    setlocale(0, "");
    setlocale(3, "");
    charset = (char *)getcharset();
    {
    _1_main_next = 29U;
    }
    break;
    case 215: 
    force_color = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 222: ;
    if (gitignore) {
      {
      _1_main_next = 236U;
      }
    } else {
      {
      _1_main_next = 126U;
      }
    }
    break;
    case 65: ;
    switch ((int )*(*(argv + i) + j)) {
    case 78: 
    {
    _1_main_next = 274U;
    }
    break;
    case 113: 
    {
    _1_main_next = 218U;
    }
    break;
    case 81: 
    {
    _1_main_next = 107U;
    }
    break;
    case 100: 
    {
    _1_main_next = 58U;
    }
    break;
    case 108: 
    {
    _1_main_next = 200U;
    }
    break;
    case 115: 
    {
    _1_main_next = 211U;
    }
    break;
    case 104: 
    {
    _1_main_next = 270U;
    }
    break;
    case 117: 
    {
    _1_main_next = 149U;
    }
    break;
    case 103: 
    {
    _1_main_next = 11U;
    }
    break;
    case 102: 
    {
    _1_main_next = 160U;
    }
    break;
    case 70: 
    {
    _1_main_next = 4U;
    }
    break;
    case 97: 
    {
    _1_main_next = 117U;
    }
    break;
    case 112: 
    {
    _1_main_next = 233U;
    }
    break;
    case 105: 
    {
    _1_main_next = 245U;
    }
    break;
    case 67: 
    {
    _1_main_next = 215U;
    }
    break;
    case 110: 
    {
    _1_main_next = 290U;
    }
    break;
    case 120: 
    {
    _1_main_next = 84U;
    }
    break;
    case 80: 
    {
    _1_main_next = 235U;
    }
    break;
    case 73: 
    {
    _1_main_next = 248U;
    }
    break;
    case 65: 
    {
    _1_main_next = 5U;
    }
    break;
    case 83: 
    {
    _1_main_next = 184U;
    }
    break;
    case 68: 
    {
    _1_main_next = 294U;
    }
    break;
    case 116: 
    {
    _1_main_next = 31U;
    }
    break;
    case 99: 
    {
    _1_main_next = 125U;
    }
    break;
    case 114: 
    {
    _1_main_next = 287U;
    }
    break;
    case 118: 
    {
    _1_main_next = 12U;
    }
    break;
    case 85: 
    {
    _1_main_next = 99U;
    }
    break;
    case 88: 
    {
    _1_main_next = 121U;
    }
    break;
    case 74: 
    {
    _1_main_next = 238U;
    }
    break;
    case 72: 
    {
    _1_main_next = 109U;
    }
    break;
    case 84: 
    {
    _1_main_next = 142U;
    }
    break;
    case 82: 
    {
    _1_main_next = 32U;
    }
    break;
    case 76: 
    {
    _1_main_next = 25U;
    }
    break;
    case 111: 
    {
    _1_main_next = 76U;
    }
    break;
    case 45: 
    {
    _1_main_next = 9U;
    }
    break;
    default: 
    {
    _1_main_next = 19U;
    }
    break;
    }
    break;
    case 280: 
    tmp___17 = strcmp("--help", (char const   *)*(argv + i));
    {
    _1_main_next = 128U;
    }
    break;
    case 44: 
    v = version + 12;
    tmp___18 = strlen((char const   *)v);
    printf((char const   *)((char const   */* __restrict  */)"%.*s\n"), (int )tmp___18 - 1,
           v);
    exit(0);
    {
    _1_main_next = 61U;
    }
    break;
    case 5: 
    ansilines = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 120: 
    setoutput(outfilename);
    parse_dir_colors();
    initlinedraw(0);
    {
    _1_main_next = 178U;
    }
    break;
    case 184: 
    charset = "IBM437";
    {
    _1_main_next = 14U;
    }
    break;
    case 162: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Missing argument to -L option.\n"));
    exit(1);
    {
    _1_main_next = 263U;
    }
    break;
    case 33: ;
    if ((unsigned long )outfilename != (unsigned long )((void *)0)) {
      {
      _1_main_next = 20U;
      }
    } else {
      {
      _1_main_next = 295U;
      }
    }
    break;
    case 64: 
    j = 1;
    {
    _1_main_next = 111U;
    }
    break;
    case 292: ;
    if (! tmp___52) {
      {
      _1_main_next = 71U;
      }
    } else {
      {
      _1_main_next = 203U;
      }
    }
    break;
    case 119: 
    tmp___73 = p;
    p ++;
    tmp___74 = strlen((char const   *)*(argv + i));
    tmp___75 = xmalloc(tmp___74 + 1UL);
    *(dirname + tmp___73) = strcpy((char *)((char */* __restrict  */)tmp___75), (char const   *)((char const   */* __restrict  */)*(argv + i)));
    {
    _1_main_next = 234U;
    }
    break;
    case 175: 
    _L___0: ;
    if (! dirname) {
      {
      _1_main_next = 198U;
      }
    } else {
      {
      _1_main_next = 102U;
      }
    }
    break;
    case 276: 
    tmp___82 = 1;
    {
    _1_main_next = 273U;
    }
    break;
    case 233: 
    pflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 92: ;
    if (! tmp___70) {
      {
      _1_main_next = 138U;
      }
    } else {
      {
      _1_main_next = 106U;
      }
    }
    break;
    case 10: ;
    if (! tmp___45) {
      {
      _1_main_next = 227U;
      }
    } else {
      {
      _1_main_next = 170U;
      }
    }
    break;
    case 0: ;
    return (tmp___83);
    break;
    case 136: ;
    if (tmp___3 == 0) {
      {
      _1_main_next = 259U;
      }
    } else {
      {
      _1_main_next = 88U;
      }
    }
    break;
    case 254: 
    tmp___64 = strncmp("--fromfile", (char const   *)*(argv + i), (size_t___0 )10);
    {
    _1_main_next = 208U;
    }
    break;
    case 153: 
    tmp___33 = n;
    n ++;
    flimit = atoi((char const   *)*(argv + tmp___33));
    tmp___34 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___34 - 1UL);
    {
    _1_main_next = 14U;
    }
    break;
    case 39: ;
    if (! tmp___19) {
      {
      _1_main_next = 44U;
      }
    } else {
      {
      _1_main_next = 61U;
      }
    }
    break;
    case 207: ;
    if (sorts[k].name) {
      {
      _1_main_next = 244U;
      }
    } else {
      {
      _1_main_next = 78U;
      }
    }
    break;
    case 7: 
    tmp___70 = strncmp("--info", (char const   *)*(argv + i), (size_t___0 )6);
    {
    _1_main_next = 92U;
    }
    break;
    case 88: 
    __constr_expr_0.intro = & null_intro;
    __constr_expr_0.outtro = & null_outtro;
    __constr_expr_0.printinfo = & unix_printinfo;
    __constr_expr_0.printfile = & unix_printfile;
    __constr_expr_0.error = & unix_error;
    __constr_expr_0.newline = & unix_newline;
    __constr_expr_0.close = & null_close;
    __constr_expr_0.report = & unix_report;
    lc = __constr_expr_0;
    tmp___4 = __ctype_get_mb_cur_max();
    mb_cur_max = (int )tmp___4;
    memset((void *)(utable), 0, sizeof(utable));
    memset((void *)(gtable), 0, sizeof(gtable));
    memset((void *)(itable), 0, sizeof(itable));
    optf = 1;
    i = 1;
    n = i;
    {
    _1_main_next = 89U;
    }
    break;
    case 174: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -P option.\n"));
    exit(1);
    {
    _1_main_next = 194U;
    }
    break;
    case 126: ;
    if (showinfo) {
      {
      _1_main_next = 85U;
      }
    } else {
      {
      _1_main_next = 41U;
      }
    }
    break;
    case 179: ;
    if (Rflag) {
      {
      _1_main_next = 268U;
      }
    } else {
      {
      _1_main_next = 222U;
      }
    }
    break;
    case 20: 
    fclose(outfile);
    {
    _1_main_next = 295U;
    }
    break;
    case 294: 
    Dflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 129: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --charset=\n"));
    exit(1);
    {
    _1_main_next = 67U;
    }
    break;
    case 25: 
    tmp___13 = n;
    n ++;
    sLevel = *(argv + tmp___13);
    {
    _1_main_next = 94U;
    }
    break;
    case 49: 
    pruneflag = (bool )0;
    {
    _1_main_next = 179U;
    }
    break;
    case 52: 
    tmp___49 = strlen((char const   *)*(argv + n));
    tmp___50 = xmalloc(tmp___49 + 1UL);
    timefmt = strcpy((char *)((char */* __restrict  */)tmp___50), (char const   *)((char const   */* __restrict  */)*(argv + n)));
    n ++;
    tmp___51 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___51 - 1UL);
    {
    _1_main_next = 46U;
    }
    break;
    case 200: 
    lflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 250: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --timefmt=\n"));
    exit(1);
    {
    _1_main_next = 46U;
    }
    break;
    case 106: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Invalid argument `%s\'.\n"),
            *(argv + i));
    usage(1);
    exit(1);
    {
    _1_main_next = 19U;
    }
    break;
    case 14: 
    j ++;
    {
    _1_main_next = 111U;
    }
    break;
    case 111: ;
    if (*(*(argv + i) + j)) {
      {
      _1_main_next = 65U;
      }
    } else {
      {
      _1_main_next = 234U;
      }
    }
    break;
    case 266: 
    tmp___83 = 2;
    {
    _1_main_next = 0U;
    }
    break;
    case 82: ;
    if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
      {
      _1_main_next = 52U;
      }
    } else {
      {
      _1_main_next = 144U;
      }
    }
    break;
    case 133: ;
    if ((unsigned long )topsort == (unsigned long )((void *)0)) {
      {
      _1_main_next = 123U;
      }
    } else {
      {
      _1_main_next = 37U;
      }
    }
    break;
    case 89: ;
    if (i < argc) {
      {
      _1_main_next = 165U;
      }
    } else {
      {
      _1_main_next = 186U;
      }
    }
    break;
    case 291: 
    usage(2);
    exit(0);
    {
    _1_main_next = 192U;
    }
    break;
    case 56: 
    tmp___45 = strncmp("--prune", (char const   *)*(argv + i), (size_t___0 )7);
    {
    _1_main_next = 10U;
    }
    break;
    case 217: ;
    if (pruneflag) {
      {
      _1_main_next = 51U;
      }
    } else {
      {
      _1_main_next = 188U;
      }
    }
    break;
    case 270: 
    hflag = (bool )1;
    sflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 164: 
    charset = "UTF-8";
    {
    _1_main_next = 88U;
    }
    break;
    case 31: 
    basesort = (int (*)())(& mtimesort);
    {
    _1_main_next = 14U;
    }
    break;
    case 12: 
    basesort = (int (*)())(& versort);
    {
    _1_main_next = 14U;
    }
    break;
    case 101: ;
    if (Level < 0) {
      {
      _1_main_next = 205U;
      }
    } else {
      {
      _1_main_next = 14U;
      }
    }
    break;
    case 209: ;
    if (! tmp___68) {
      {
      _1_main_next = 240U;
      }
    } else {
      {
      _1_main_next = 7U;
      }
    }
    break;
    case 69: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -T option.\n"));
    exit(1);
    {
    _1_main_next = 228U;
    }
    break;
    case 203: 
    tmp___54 = strncmp("--ignore-case", (char const   *)*(argv + i), (size_t___0 )13);
    {
    _1_main_next = 91U;
    }
    break;
    case 96: 
    tmp___29 = strcmp("--dirsfirst", (char const   *)*(argv + i));
    {
    _1_main_next = 95U;
    }
    break;
    case 288: ;
    if ((int )*(*(argv + i) + j) == 61) {
      {
      _1_main_next = 279U;
      }
    } else {
      {
      _1_main_next = 67U;
      }
    }
    break;
    case 45: 
    tmp___42 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___42 - 1UL);
    sflag = (bool )1;
    duflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 78: ;
    if ((unsigned long )basesort == (unsigned long )((void *)0)) {
      {
      _1_main_next = 275U;
      }
    } else {
      {
      _1_main_next = 14U;
      }
    }
    break;
    case 81: 
    q += 20;
    tmp___72 = xrealloc((void *)dirname, sizeof(char *) * (unsigned long )q);
    dirname = (char **)tmp___72;
    {
    _1_main_next = 119U;
    }
    break;
    case 128: ;
    if (! tmp___17) {
      {
      _1_main_next = 291U;
      }
    } else {
      {
      _1_main_next = 192U;
      }
    }
    break;
    case 236: 
    stmp = getenv("GIT_DIR");
    {
    _1_main_next = 80U;
    }
    break;
    case 23: ;
    if (! tmp___31) {
      {
      _1_main_next = 246U;
      }
    } else {
      {
      _1_main_next = 50U;
      }
    }
    break;
    case 285: 
    tmp___46 = strlen((char const   *)(*(argv + i) + j));
    tmp___47 = xmalloc(tmp___46 + 1UL);
    timefmt = strcpy((char *)((char */* __restrict  */)tmp___47), (char const   *)((char const   */* __restrict  */)(*(argv + i) + j)));
    tmp___48 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___48 - 1UL);
    {
    _1_main_next = 14U;
    }
    break;
    case 273: 
    needfulltree = (bool )tmp___82;
    emit_tree(dirname, needfulltree);
    {
    _1_main_next = 33U;
    }
    break;
    case 134: ;
    if ((int )*(*(argv + i) + j) == 61) {
      {
      _1_main_next = 163U;
      }
    } else {
      {
      _1_main_next = 243U;
      }
    }
    break;
    case 94: ;
    if ((unsigned long )sLevel == (unsigned long )((void *)0)) {
      {
      _1_main_next = 162U;
      }
    } else {
      {
      _1_main_next = 263U;
      }
    }
    break;
    case 109: 
    Hflag = (bool )1;
    Jflag = (bool )0;
    Xflag = Jflag;
    __constr_expr_3.intro = & html_intro;
    __constr_expr_3.outtro = & html_outtro;
    __constr_expr_3.printinfo = & html_printinfo;
    __constr_expr_3.printfile = & html_printfile;
    __constr_expr_3.error = & html_error;
    __constr_expr_3.newline = & html_newline;
    __constr_expr_3.close = & html_close;
    __constr_expr_3.report = & html_report;
    lc = __constr_expr_3;
    {
    _1_main_next = 156U;
    }
    break;
    case 190: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --filelimit\n"));
    exit(1);
    {
    _1_main_next = 14U;
    }
    break;
    case 167: 
    printf((char const   *)((char const   */* __restrict  */)"%s%c"), sorts[k].name,
           tmp___61);
    k ++;
    {
    _1_main_next = 60U;
    }
    break;
    case 76: ;
    if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
      {
      _1_main_next = 297U;
      }
    } else {
      {
      _1_main_next = 113U;
      }
    }
    break;
    case 197: 
    tmp___58 = n;
    n ++;
    stmp = *(argv + tmp___58);
    tmp___59 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___59 - 1UL);
    {
    _1_main_next = 256U;
    }
    break;
    case 245: 
    noindent = (bool )1;
    _nl = (char *)"";
    {
    _1_main_next = 14U;
    }
    break;
    case 57: 
    tmp___82 = 1;
    {
    _1_main_next = 273U;
    }
    break;
    case 156: ;
    if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
      {
      _1_main_next = 202U;
      }
    } else {
      {
      _1_main_next = 18U;
      }
    }
    break;
    case 257: ;
    if (*(*(argv + i) + 12)) {
      {
      _1_main_next = 229U;
      }
    } else {
      {
      _1_main_next = 74U;
      }
    }
    break;
    case 98: 
    k ++;
    {
    _1_main_next = 207U;
    }
    break;
    case 214: 
    tmp___27 = strcmp("--nolinks", (char const   *)*(argv + i));
    {
    _1_main_next = 90U;
    }
    break;
    case 11: 
    gflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 202: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -H option.\n"));
    exit(1);
    {
    _1_main_next = 18U;
    }
    break;
    case 9: ;
    if (j == 1) {
      {
      _1_main_next = 116U;
      }
    } else {
      {
      _1_main_next = 19U;
      }
    }
    break;
    case 220: ;
    if (! tmp___56) {
      {
      _1_main_next = 59U;
      }
    } else {
      {
      _1_main_next = 252U;
      }
    }
    break;
    case 51: 
    tmp___82 = 1;
    {
    _1_main_next = 273U;
    }
    break;
    case 107: 
    Qflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 146: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -I option.\n"));
    exit(1);
    {
    _1_main_next = 103U;
    }
    break;
    case 90: ;
    if (! tmp___27) {
      {
      _1_main_next = 86U;
      }
    } else {
      {
      _1_main_next = 96U;
      }
    }
    break;
    case 268: ;
    if (Level == -1) {
      {
      _1_main_next = 293U;
      }
    } else {
      {
      _1_main_next = 222U;
      }
    }
    break;
    case 40: ;
    if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
      {
      _1_main_next = 153U;
      }
    } else {
      {
      _1_main_next = 190U;
      }
    }
    break;
    case 210: ;
    if ((int )*(*(argv + i) + 0) == 45) {
      {
      _1_main_next = 154U;
      }
    } else {
      {
      _1_main_next = 175U;
      }
    }
    break;
    case 67: ;
    if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
      {
      _1_main_next = 180U;
      }
    } else {
      {
      _1_main_next = 16U;
      }
    }
    break;
    case 132: ;
    if (tmp___60 == 0) {
      {
      _1_main_next = 124U;
      }
    } else {
      {
      _1_main_next = 98U;
      }
    }
    break;
    case 110: 
    tmp___61 = '\n';
    {
    _1_main_next = 167U;
    }
    break;
    case 193: 
    tmp___82 = 1;
    {
    _1_main_next = 273U;
    }
    break;
    case 59: 
    tmp___55 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___55 - 1UL);
    matchdirs = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 165: 
    n ++;
    {
    _1_main_next = 34U;
    }
    break;
    case 196: 
    optf = 0;
    {
    _1_main_next = 14U;
    }
    break;
    case 223: 
    tmp___23 = strcmp("--device", (char const   *)*(argv + i));
    {
    _1_main_next = 176U;
    }
    break;
    case 155: ;
    if (! tmp___41) {
      {
      _1_main_next = 269U;
      }
    } else {
      {
      _1_main_next = 143U;
      }
    }
    break;
    case 116: 
    tmp___16 = strcmp("--", (char const   *)*(argv + i));
    {
    _1_main_next = 169U;
    }
    break;
    case 154: ;
    if (*(*(argv + i) + 1)) {
      {
      _1_main_next = 64U;
      }
    } else {
      {
      _1_main_next = 175U;
      }
    }
    break;
    case 151: ;
    if (! tmp___43) {
      {
      _1_main_next = 45U;
      }
    } else {
      {
      _1_main_next = 56U;
      }
    }
    break;
    case 38: 
    tmp___82 = 0;
    {
    _1_main_next = 273U;
    }
    break;
    case 61: 
    tmp___21 = strcmp("--inodes", (char const   *)*(argv + i));
    {
    _1_main_next = 181U;
    }
    break;
    case 158: 
    tmp___39 = strncmp("--charset", (char const   *)*(argv + i), (size_t___0 )9);
    {
    _1_main_next = 127U;
    }
    break;
    case 113: 
    tmp___15 = n;
    n ++;
    outfilename = *(argv + tmp___15);
    {
    _1_main_next = 14U;
    }
    break;
    case 138: 
    tmp___69 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___69 - 1UL);
    showinfo = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 256: 
    basesort = (int (*)())((void *)0);
    k = 0;
    {
    _1_main_next = 207U;
    }
    break;
    case 58: 
    dflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 170: 
    tmp___52 = strncmp("--timefmt", (char const   *)*(argv + i), (size_t___0 )9);
    {
    _1_main_next = 292U;
    }
    break;
    case 74: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --filelimit=\n"));
    exit(1);
    {
    _1_main_next = 40U;
    }
    break;
    case 178: ;
    if ((unsigned long )dirname == (unsigned long )((void *)0)) {
      {
      _1_main_next = 157U;
      }
    } else {
      {
      _1_main_next = 133U;
      }
    }
    break;
    case 75: 
    tmp___9 = ipattern;
    ipattern ++;
    tmp___10 = n;
    n ++;
    *(ipatterns + tmp___9) = *(argv + tmp___10);
    *(ipatterns + ipattern) = (char *)((void *)0);
    {
    _1_main_next = 14U;
    }
    break;
    case 123: 
    topsort = basesort;
    {
    _1_main_next = 37U;
    }
    break;
    case 267: ;
    if (*charset) {
      {
      _1_main_next = 8U;
      }
    } else {
      {
      _1_main_next = 129U;
      }
    }
    break;
    case 48: ;
    if ((int )*(*(argv + i) + 11) == 61) {
      {
      _1_main_next = 257U;
      }
    } else {
      {
      _1_main_next = 40U;
      }
    }
    break;
    case 139: 
    tmp___63 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___63 - 1UL);
    fromfile = (bool )1;
    getfulltree = & file_getfulltree;
    {
    _1_main_next = 14U;
    }
    break;
    case 71: 
    j = 9;
    {
    _1_main_next = 282U;
    }
    break;
    case 234: 
    i = n;
    {
    _1_main_next = 89U;
    }
    break;
    case 173: 
    tmp___6 = pattern;
    pattern ++;
    tmp___7 = n;
    n ++;
    *(patterns + tmp___6) = *(argv + tmp___7);
    *(patterns + pattern) = (char *)((void *)0);
    {
    _1_main_next = 14U;
    }
    break;
    case 293: 
    Rflag = (bool )0;
    {
    _1_main_next = 222U;
    }
    break;
    case 240: 
    tmp___67 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___67 - 1UL);
    gitignore = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 191: ;
    if (! tmp___25) {
      {
      _1_main_next = 105U;
      }
    } else {
      {
      _1_main_next = 214U;
      }
    }
    break;
    case 218: 
    qflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 91: ;
    if (! tmp___54) {
      {
      _1_main_next = 177U;
      }
    } else {
      {
      _1_main_next = 251U;
      }
    }
    break;
    case 282: ;
    if ((int )*(*(argv + i) + j) == 61) {
      {
      _1_main_next = 216U;
      }
    } else {
      {
      _1_main_next = 82U;
      }
    }
    break;
    case 97: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --sort\n"));
    exit(1);
    {
    _1_main_next = 256U;
    }
    break;
    case 163: 
    j ++;
    {
    _1_main_next = 247U;
    }
    break;
    case 230: 
    tmp___2 = nl_langinfo(14);
    tmp___3 = strcmp((char const   *)tmp___2, "utf8");
    {
    _1_main_next = 136U;
    }
    break;
    case 99: 
    basesort = (int (*)())((void *)0);
    {
    _1_main_next = 14U;
    }
    break;
    case 114: 
    tmp___66 = strncmp("--metafirst", (char const   *)*(argv + i), (size_t___0 )11);
    {
    _1_main_next = 232U;
    }
    break;
    case 37: ;
    if (timefmt) {
      {
      _1_main_next = 199U;
      }
    } else {
      {
      _1_main_next = 258U;
      }
    }
    break;
    case 252: 
    tmp___62 = strncmp("--sort", (char const   *)*(argv + i), (size_t___0 )6);
    {
    _1_main_next = 242U;
    }
    break;
    case 248: ;
    if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
      {
      _1_main_next = 146U;
      }
    } else {
      {
      _1_main_next = 103U;
      }
    }
    break;
    case 41: ;
    if (duflag) {
      {
      _1_main_next = 276U;
      }
    } else {
      {
      _1_main_next = 217U;
      }
    }
    break;
    case 283: 
    *(dirname + p) = (char *)((void *)0);
    {
    _1_main_next = 120U;
    }
    break;
    case 95: ;
    if (! tmp___29) {
      {
      _1_main_next = 239U;
      }
    } else {
      {
      _1_main_next = 145U;
      }
    }
    break;
    case 149: 
    uflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 198: 
    q = 30;
    tmp___71 = xmalloc(sizeof(char *) * (unsigned long )q);
    dirname = (char **)tmp___71;
    {
    _1_main_next = 119U;
    }
    break;
    case 232: ;
    if (! tmp___66) {
      {
      _1_main_next = 122U;
      }
    } else {
      {
      _1_main_next = 35U;
      }
    }
    break;
    case 290: 
    nocolor = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 42: ;
    if (fromfile) {
      {
      _1_main_next = 57U;
      }
    } else {
      {
      _1_main_next = 38U;
      }
    }
    break;
    case 287: 
    reverse = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 229: 
    flimit = atoi((char const   *)(*(argv + i) + 12));
    tmp___32 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___32 - 1UL);
    {
    _1_main_next = 14U;
    }
    break;
    case 46: 
    Dflag = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 177: 
    tmp___53 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___53 - 1UL);
    ignorecase = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    case 83: ;
    if (tmp___1 == 0) {
      {
      _1_main_next = 164U;
      }
    } else {
      {
      _1_main_next = 230U;
      }
    }
    break;
    case 35: 
    tmp___68 = strncmp("--gitignore", (char const   *)*(argv + i), (size_t___0 )11);
    {
    _1_main_next = 209U;
    }
    break;
    case 263: 
    tmp___14 = strtoul((char const   */* __restrict  */)sLevel, (char **/* __restrict  */)((void *)0),
                       0);
    Level = (int )(tmp___14 - 1UL);
    {
    _1_main_next = 101U;
    }
    break;
    case 238: 
    Jflag = (bool )1;
    Hflag = (bool )0;
    Xflag = Hflag;
    __constr_expr_2.intro = & json_intro;
    __constr_expr_2.outtro = & json_outtro;
    __constr_expr_2.printinfo = & json_printinfo;
    __constr_expr_2.printfile = & json_printfile;
    __constr_expr_2.error = & json_error;
    __constr_expr_2.newline = & json_newline;
    __constr_expr_2.close = & json_close;
    __constr_expr_2.report = & json_report;
    lc = __constr_expr_2;
    {
    _1_main_next = 14U;
    }
    break;
    case 29: ;
    if ((unsigned long )charset == (unsigned long )((void *)0)) {
      {
      _1_main_next = 159U;
      }
    } else {
      {
      _1_main_next = 88U;
      }
    }
    break;
    case 86: 
    tmp___26 = strlen((char const   *)*(argv + i));
    j = (int )(tmp___26 - 1UL);
    nolinks = (bool )1;
    {
    _1_main_next = 14U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF main LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF parse_dir_colors LOC=UNKNOWN */
void parse_dir_colors(void) 
{ 
  char buf___1[1025] ;
  char **arg ;
  char **c ;
  char *colors ;
  char *s ;
  char *cc ;
  int i ;
  int n ;
  int col ;
  struct extensions *e ;
  char *tmp ;
  char *tmp___0 ;
  size_t___0 tmp___1 ;
  int tmp___2 ;
  int i___0 ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  size_t___0 tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  size_t___0 tmp___11 ;
  void *tmp___12 ;
  size_t___0 tmp___13 ;
  void *tmp___14 ;
  size_t___0 tmp___15 ;
  void *tmp___16 ;
  size_t___0 tmp___17 ;
  void *tmp___18 ;
  size_t___0 tmp___19 ;
  void *tmp___20 ;
  unsigned int _1_parse_dir_colors_next ;

  {
  {
  _1_parse_dir_colors_next = 7U;
  }
  while (1) {
    switch (_1_parse_dir_colors_next) {
    case 50: 
    tmp___3 = strlen((char const   *)s);
    tmp___4 = xmalloc(tmp___3 + 1UL);
    colors = strcpy((char *)((char */* __restrict  */)tmp___4), (char const   *)((char const   */* __restrict  */)s));
    arg = split(colors, (char *)":", & n);
    i = 0;
    {
    _1_parse_dir_colors_next = 36U;
    }
    break;
    case 25: 
    sprintf((char *)((char */* __restrict  */)(buf___1)), (char const   *)((char const   */* __restrict  */)"%s%s%s"),
            color_code[22], color_code[4], color_code[23]);
    tmp___19 = strlen((char const   *)(buf___1));
    tmp___20 = xmalloc(tmp___19 + 1UL);
    color_code[24] = strcpy((char *)((char */* __restrict  */)tmp___20), (char const   *)((char const   */* __restrict  */)(buf___1)));
    {
    _1_parse_dir_colors_next = 14U;
    }
    break;
    case 49: ;
    switch (col) {
    case -1: 
    {
    _1_parse_dir_colors_next = 16U;
    }
    break;
    case 25: 
    {
    _1_parse_dir_colors_next = 9U;
    }
    break;
    case 8: 
    {
    _1_parse_dir_colors_next = 66U;
    }
    break;
    default: 
    {
    _1_parse_dir_colors_next = 59U;
    }
    break;
    }
    break;
    case 52: 
    cc = getenv("CLICOLOR");
    tmp___0 = getenv("CLICOLOR_FORCE");
    {
    _1_parse_dir_colors_next = 21U;
    }
    break;
    case 4: ;
    return;
    break;
    case 30: ;
    return;
    break;
    case 14: 
    free((void *)colors);
    {
    _1_parse_dir_colors_next = 4U;
    }
    break;
    case 15: 
    s = getenv("TREE_COLORS");
    {
    _1_parse_dir_colors_next = 20U;
    }
    break;
    case 56: 
    color_code[i___0] = (char *)((void *)0);
    i___0 ++;
    {
    _1_parse_dir_colors_next = 54U;
    }
    break;
    case 31: ;
    if ((unsigned long )cc != (unsigned long )((void *)0)) {
      {
      _1_parse_dir_colors_next = 39U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 22U;
      }
    }
    break;
    case 12: ;
    return;
    break;
    case 8: 
    linktargetcolor = (bool )1;
    color_code[8] = (char *)"01;36";
    {
    _1_parse_dir_colors_next = 16U;
    }
    break;
    case 45: ;
    if (! color_code[4]) {
      {
      _1_parse_dir_colors_next = 42U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 33U;
      }
    }
    break;
    case 54: ;
    if (i___0 < 25) {
      {
      _1_parse_dir_colors_next = 56U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 50U;
      }
    }
    break;
    case 3: ;
    if (! tmp___2) {
      {
      _1_parse_dir_colors_next = 6U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 65U;
      }
    }
    break;
    case 16: 
    free((void *)c);
    i ++;
    {
    _1_parse_dir_colors_next = 36U;
    }
    break;
    case 21: ;
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
      _1_parse_dir_colors_next = 46U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 11U;
      }
    }
    break;
    case 36: ;
    if (*(arg + i)) {
      {
      _1_parse_dir_colors_next = 26U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 55U;
      }
    }
    break;
    case 26: 
    c = split(*(arg + i), (char *)"=", & n);
    col = cmd(*(c + 0));
    {
    _1_parse_dir_colors_next = 49U;
    }
    break;
    case 11: ;
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
      _1_parse_dir_colors_next = 0U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 43U;
      }
    }
    break;
    case 9: ;
    if (*(c + 1)) {
      {
      _1_parse_dir_colors_next = 41U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 16U;
      }
    }
    break;
    case 13: 
    tmp___15 = strlen("m");
    tmp___16 = xmalloc(tmp___15 + 1UL);
    color_code[23] = strcpy((char *)((char */* __restrict  */)tmp___16), (char const   *)((char const   */* __restrict  */)"m"));
    {
    _1_parse_dir_colors_next = 45U;
    }
    break;
    case 63: ;
    if (! color_code[22]) {
      {
      _1_parse_dir_colors_next = 51U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 29U;
      }
    }
    break;
    case 51: 
    tmp___13 = strlen("\033[");
    tmp___14 = xmalloc(tmp___13 + 1UL);
    color_code[22] = strcpy((char *)((char */* __restrict  */)tmp___14), (char const   *)((char const   */* __restrict  */)"\033["));
    {
    _1_parse_dir_colors_next = 29U;
    }
    break;
    case 17: 
    s = (char *)":no=00:rs=0:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:";
    {
    _1_parse_dir_colors_next = 22U;
    }
    break;
    case 40: ;
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
      _1_parse_dir_colors_next = 61U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 15U;
      }
    }
    break;
    case 55: 
    free((void *)arg);
    {
    _1_parse_dir_colors_next = 63U;
    }
    break;
    case 60: ;
    if (tmp___1 == 0UL) {
      {
      _1_parse_dir_colors_next = 0U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 22U;
      }
    }
    break;
    case 59: ;
    if (*(c + 1)) {
      {
      _1_parse_dir_colors_next = 38U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 16U;
      }
    }
    break;
    case 6: 
    colorize = (bool )0;
    {
    _1_parse_dir_colors_next = 12U;
    }
    break;
    case 27: ;
    if (tmp___10 == 0) {
      {
      _1_parse_dir_colors_next = 8U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 59U;
      }
    }
    break;
    case 38: 
    tmp___11 = strlen((char const   *)*(c + 1));
    tmp___12 = xmalloc(tmp___11 + 1UL);
    color_code[col] = strcpy((char *)((char */* __restrict  */)tmp___12), (char const   *)((char const   */* __restrict  */)*(c + 1)));
    {
    _1_parse_dir_colors_next = 16U;
    }
    break;
    case 61: 
    colorize = (bool )0;
    {
    _1_parse_dir_colors_next = 37U;
    }
    break;
    case 58: ;
    if (! force_color) {
      {
      _1_parse_dir_colors_next = 28U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 65U;
      }
    }
    break;
    case 34: 
    force_color = (bool )1;
    {
    _1_parse_dir_colors_next = 11U;
    }
    break;
    case 48: ;
    return;
    break;
    case 22: ;
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
      _1_parse_dir_colors_next = 5U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 58U;
      }
    }
    break;
    case 28: ;
    if (nocolor) {
      {
      _1_parse_dir_colors_next = 44U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 10U;
      }
    }
    break;
    case 53: 
    tmp___10 = strcasecmp("target", (char const   *)*(c + 1));
    {
    _1_parse_dir_colors_next = 27U;
    }
    break;
    case 65: 
    colorize = (bool )1;
    i___0 = 0;
    {
    _1_parse_dir_colors_next = 54U;
    }
    break;
    case 47: 
    tmp = getenv("TERM");
    {
    _1_parse_dir_colors_next = 40U;
    }
    break;
    case 44: 
    colorize = (bool )0;
    {
    _1_parse_dir_colors_next = 48U;
    }
    break;
    case 5: 
    colorize = (bool )0;
    {
    _1_parse_dir_colors_next = 64U;
    }
    break;
    case 33: ;
    if (! color_code[24]) {
      {
      _1_parse_dir_colors_next = 25U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 14U;
      }
    }
    break;
    case 37: ;
    return;
    break;
    case 64: ;
    return;
    break;
    case 41: 
    tmp___5 = xmalloc(sizeof(struct extensions ));
    e = (struct extensions *)tmp___5;
    tmp___6 = strlen((char const   *)(*(c + 0) + 1));
    tmp___7 = xmalloc(tmp___6 + 1UL);
    e->ext = strcpy((char *)((char */* __restrict  */)tmp___7), (char const   *)((char const   */* __restrict  */)(*(c + 0) + 1)));
    tmp___8 = strlen((char const   *)*(c + 1));
    tmp___9 = xmalloc(tmp___8 + 1UL);
    e->term_flg = strcpy((char *)((char */* __restrict  */)tmp___9), (char const   *)((char const   */* __restrict  */)*(c + 1)));
    e->nxt = ext;
    ext = e;
    {
    _1_parse_dir_colors_next = 16U;
    }
    break;
    case 10: 
    tmp___2 = isatty(1);
    {
    _1_parse_dir_colors_next = 3U;
    }
    break;
    case 42: 
    tmp___17 = strlen("0");
    tmp___18 = xmalloc(tmp___17 + 1UL);
    color_code[4] = strcpy((char *)((char */* __restrict  */)tmp___18), (char const   *)((char const   */* __restrict  */)"0"));
    {
    _1_parse_dir_colors_next = 33U;
    }
    break;
    case 0: 
    _L: ;
    if (force_color) {
      {
      _1_parse_dir_colors_next = 17U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 31U;
      }
    }
    break;
    case 46: ;
    if (! nocolor) {
      {
      _1_parse_dir_colors_next = 34U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 11U;
      }
    }
    break;
    case 39: 
    s = (char *)":no=00:rs=0:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:";
    {
    _1_parse_dir_colors_next = 22U;
    }
    break;
    case 66: ;
    if (*(c + 1)) {
      {
      _1_parse_dir_colors_next = 53U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 59U;
      }
    }
    break;
    case 7: ;
    if (Hflag) {
      {
      _1_parse_dir_colors_next = 30U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 47U;
      }
    }
    break;
    case 29: ;
    if (! color_code[23]) {
      {
      _1_parse_dir_colors_next = 13U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 45U;
      }
    }
    break;
    case 43: 
    tmp___1 = strlen((char const   *)s);
    {
    _1_parse_dir_colors_next = 60U;
    }
    break;
    case 2: 
    s = getenv("LS_COLORS");
    {
    _1_parse_dir_colors_next = 52U;
    }
    break;
    case 20: ;
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
      _1_parse_dir_colors_next = 2U;
      }
    } else {
      {
      _1_parse_dir_colors_next = 52U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF parse_dir_colors LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_printinfo LOC=UNKNOWN */
int unix_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  unsigned int _1_unix_printinfo_next ;

  {
  {
  _1_unix_printinfo_next = 9U;
  }
  while (1) {
    switch (_1_unix_printinfo_next) {
    case 4: 
    indent(level);
    {
    _1_unix_printinfo_next = 3U;
    }
    break;
    case 8: ;
    if ((int )info___0[0] == 91) {
      {
      _1_unix_printinfo_next = 7U;
      }
    } else {
      {
      _1_unix_printinfo_next = 3U;
      }
    }
    break;
    case 1: 
    indent(level);
    {
    _1_unix_printinfo_next = 8U;
    }
    break;
    case 3: ;
    return (0);
    break;
    case 9: 
    fillinfo(info___0, file);
    {
    _1_unix_printinfo_next = 10U;
    }
    break;
    case 6: ;
    if (! noindent) {
      {
      _1_unix_printinfo_next = 1U;
      }
    } else {
      {
      _1_unix_printinfo_next = 8U;
      }
    }
    break;
    case 5: ;
    if (! noindent) {
      {
      _1_unix_printinfo_next = 4U;
      }
    } else {
      {
      _1_unix_printinfo_next = 3U;
      }
    }
    break;
    case 10: ;
    if (metafirst) {
      {
      _1_unix_printinfo_next = 2U;
      }
    } else {
      {
      _1_unix_printinfo_next = 6U;
      }
    }
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s  "),
            info___0);
    {
    _1_unix_printinfo_next = 5U;
    }
    break;
    case 7: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s  "),
            info___0);
    {
    _1_unix_printinfo_next = 3U;
    }
    break;
    case 2: ;
    if ((int )info___0[0] == 91) {
      {
      _1_unix_printinfo_next = 0U;
      }
    } else {
      {
      _1_unix_printinfo_next = 5U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF unix_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_report LOC=UNKNOWN */
void xml_report(struct totals tot ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int _1_xml_report_next ;

  {
  {
  _1_xml_report_next = 18U;
  }
  while (1) {
    switch (_1_xml_report_next) {
    case 18: ;
    if (noindent) {
      {
      _1_xml_report_next = 13U;
      }
    } else {
      {
      _1_xml_report_next = 8U;
      }
    }
    break;
    case 4: 
    tmp___1 = (char *)"";
    {
    _1_xml_report_next = 20U;
    }
    break;
    case 14: ;
    if (duflag) {
      {
      _1_xml_report_next = 19U;
      }
    } else {
      {
      _1_xml_report_next = 12U;
      }
    }
    break;
    case 15: 
    tmp___0 = (char *)"";
    {
    _1_xml_report_next = 17U;
    }
    break;
    case 12: ;
    if (noindent) {
      {
      _1_xml_report_next = 4U;
      }
    } else {
      {
      _1_xml_report_next = 16U;
      }
    }
    break;
    case 8: 
    tmp = (char *)"  ";
    {
    _1_xml_report_next = 22U;
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s</report>%s"),
            tmp___3, _nl);
    {
    _1_xml_report_next = 5U;
    }
    break;
    case 3: 
    tmp___2 = (char *)"    ";
    {
    _1_xml_report_next = 0U;
    }
    break;
    case 16: 
    tmp___1 = (char *)"    ";
    {
    _1_xml_report_next = 20U;
    }
    break;
    case 21: 
    tmp___0 = (char *)"    ";
    {
    _1_xml_report_next = 17U;
    }
    break;
    case 11: ;
    if (noindent) {
      {
      _1_xml_report_next = 10U;
      }
    } else {
      {
      _1_xml_report_next = 2U;
      }
    }
    break;
    case 9: ;
    if (! dflag) {
      {
      _1_xml_report_next = 7U;
      }
    } else {
      {
      _1_xml_report_next = 11U;
      }
    }
    break;
    case 13: 
    tmp = (char *)"";
    {
    _1_xml_report_next = 22U;
    }
    break;
    case 19: ;
    if (noindent) {
      {
      _1_xml_report_next = 15U;
      }
    } else {
      {
      _1_xml_report_next = 21U;
      }
    }
    break;
    case 17: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<size>%lld</size>%s"),
            tmp___0, tot.size, _nl);
    {
    _1_xml_report_next = 12U;
    }
    break;
    case 6: 
    tmp___2 = (char *)"";
    {
    _1_xml_report_next = 0U;
    }
    break;
    case 22: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<report>%s"),
            tmp, _nl);
    {
    _1_xml_report_next = 14U;
    }
    break;
    case 5: ;
    return;
    break;
    case 10: 
    tmp___3 = (char *)"";
    {
    _1_xml_report_next = 1U;
    }
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<files>%ld</files>%s"),
            tmp___2, tot.files, _nl);
    {
    _1_xml_report_next = 11U;
    }
    break;
    case 7: ;
    if (noindent) {
      {
      _1_xml_report_next = 6U;
      }
    } else {
      {
      _1_xml_report_next = 3U;
      }
    }
    break;
    case 2: 
    tmp___3 = (char *)"  ";
    {
    _1_xml_report_next = 1U;
    }
    break;
    case 20: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<directories>%ld</directories>%s"),
            tmp___1, tot.dirs, _nl);
    {
    _1_xml_report_next = 9U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF printcomment LOC=UNKNOWN */
void printcomment(int line , int lines , char *s ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned int _1_printcomment_next ;

  {
  {
  _1_printcomment_next = 6U;
  }
  while (1) {
    switch (_1_printcomment_next) {
    case 4: ;
    if (line < 2) {
      {
      _1_printcomment_next = 0U;
      }
    } else {
      {
      _1_printcomment_next = 11U;
      }
    }
    break;
    case 14: 
    tmp___0 = (char const   *)linedraw->cext;
    {
    _1_printcomment_next = 8U;
    }
    break;
    case 12: 
    tmp___0 = (char const   *)linedraw->cbot;
    {
    _1_printcomment_next = 8U;
    }
    break;
    case 8: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            tmp___0);
    {
    _1_printcomment_next = 5U;
    }
    break;
    case 1: 
    tmp = (char const   *)linedraw->cmid;
    {
    _1_printcomment_next = 13U;
    }
    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            linedraw->ctop);
    {
    _1_printcomment_next = 5U;
    }
    break;
    case 11: ;
    if (line == lines - 1) {
      {
      _1_printcomment_next = 12U;
      }
    } else {
      {
      _1_printcomment_next = 14U;
      }
    }
    break;
    case 9: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            linedraw->csingle);
    {
    _1_printcomment_next = 5U;
    }
    break;
    case 13: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            tmp);
    {
    _1_printcomment_next = 5U;
    }
    break;
    case 6: ;
    if (lines == 1) {
      {
      _1_printcomment_next = 9U;
      }
    } else {
      {
      _1_printcomment_next = 2U;
      }
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s\n"),
            s);
    {
    _1_printcomment_next = 7U;
    }
    break;
    case 10: 
    tmp = (char const   *)linedraw->cbot;
    {
    _1_printcomment_next = 13U;
    }
    break;
    case 0: ;
    if (lines == 2) {
      {
      _1_printcomment_next = 10U;
      }
    } else {
      {
      _1_printcomment_next = 1U;
      }
    }
    break;
    case 7: ;
    return;
    break;
    case 2: ;
    if (line == 0) {
      {
      _1_printcomment_next = 3U;
      }
    } else {
      {
      _1_printcomment_next = 4U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF printcomment LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_report LOC=UNKNOWN */
void unix_report(struct totals tot ) 
{ 
  char buf___1[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int _1_unix_report_next ;

  {
  {
  _1_unix_report_next = 2U;
  }
  while (1) {
    switch (_1_unix_report_next) {
    case 18: 
    tmp___2 = (char *)"ies";
    {
    _1_unix_report_next = 7U;
    }
    break;
    case 4: 
    tmp = (char *)"";
    {
    _1_unix_report_next = 13U;
    }
    break;
    case 14: ;
    if (tot.files == 1UL) {
      {
      _1_unix_report_next = 0U;
      }
    } else {
      {
      _1_unix_report_next = 11U;
      }
    }
    break;
    case 15: ;
    return;
    break;
    case 12: 
    tmp___0 = (char *)"ies";
    {
    _1_unix_report_next = 19U;
    }
    break;
    case 8: 
    tmp___2 = (char *)"y";
    {
    _1_unix_report_next = 7U;
    }
    break;
    case 1: ;
    if (dflag) {
      {
      _1_unix_report_next = 6U;
      }
    } else {
      {
      _1_unix_report_next = 14U;
      }
    }
    break;
    case 3: 
    tmp = (char *)"";
    {
    _1_unix_report_next = 13U;
    }
    break;
    case 16: ;
    if (hflag) {
      {
      _1_unix_report_next = 3U;
      }
    } else {
      {
      _1_unix_report_next = 20U;
      }
    }
    break;
    case 21: 
    tmp___0 = (char *)"y";
    {
    _1_unix_report_next = 19U;
    }
    break;
    case 11: 
    tmp___1 = (char *)"s";
    {
    _1_unix_report_next = 5U;
    }
    break;
    case 9: 
    psize(buf___1, tot.size);
    {
    _1_unix_report_next = 16U;
    }
    break;
    case 13: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s used in "),
            buf___1, tmp);
    {
    _1_unix_report_next = 1U;
    }
    break;
    case 19: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s\n"),
            tot.dirs, tmp___0);
    {
    _1_unix_report_next = 15U;
    }
    break;
    case 17: ;
    if (duflag) {
      {
      _1_unix_report_next = 9U;
      }
    } else {
      {
      _1_unix_report_next = 1U;
      }
    }
    break;
    case 6: ;
    if (tot.dirs == 1UL) {
      {
      _1_unix_report_next = 21U;
      }
    } else {
      {
      _1_unix_report_next = 12U;
      }
    }
    break;
    case 5: ;
    if (tot.dirs == 1UL) {
      {
      _1_unix_report_next = 8U;
      }
    } else {
      {
      _1_unix_report_next = 18U;
      }
    }
    break;
    case 10: 
    tmp = (char *)" bytes";
    {
    _1_unix_report_next = 13U;
    }
    break;
    case 0: 
    tmp___1 = (char *)"";
    {
    _1_unix_report_next = 5U;
    }
    break;
    case 7: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s, %ld file%s\n"),
            tot.dirs, tmp___2, tot.files, tmp___1);
    {
    _1_unix_report_next = 15U;
    }
    break;
    case 2: 
    fputc('\n', outfile);
    {
    _1_unix_report_next = 17U;
    }
    break;
    case 20: ;
    if (siflag) {
      {
      _1_unix_report_next = 4U;
      }
    } else {
      {
      _1_unix_report_next = 10U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF unix_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF push_files LOC=UNKNOWN */
void push_files(char *dir , struct ignorefile **ig , struct infofile **inf ) 
{ 
  unsigned int _1_push_files_next ;

  {
  {
  _1_push_files_next = 5U;
  }
  while (1) {
    switch (_1_push_files_next) {
    case 4: 
    *ig = new_ignorefile(dir);
    {
    _1_push_files_next = 0U;
    }
    break;
    case 8: ;
    return;
    break;
    case 1: 
    *inf = new_infofile(dir);
    {
    _1_push_files_next = 7U;
    }
    break;
    case 3: ;
    if (showinfo) {
      {
      _1_push_files_next = 1U;
      }
    } else {
      {
      _1_push_files_next = 8U;
      }
    }
    break;
    case 6: 
    push_infostack(*inf);
    {
    _1_push_files_next = 8U;
    }
    break;
    case 5: ;
    if (gitignore) {
      {
      _1_push_files_next = 4U;
      }
    } else {
      {
      _1_push_files_next = 3U;
      }
    }
    break;
    case 0: ;
    if ((unsigned long )*ig != (unsigned long )((void *)0)) {
      {
      _1_push_files_next = 2U;
      }
    } else {
      {
      _1_push_files_next = 3U;
      }
    }
    break;
    case 7: ;
    if ((unsigned long )*inf != (unsigned long )((void *)0)) {
      {
      _1_push_files_next = 6U;
      }
    } else {
      {
      _1_push_files_next = 8U;
      }
    }
    break;
    case 2: 
    push_filterstack(*ig);
    {
    _1_push_files_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF push_files LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF free_dir LOC=UNKNOWN */
void free_dir(struct _info **d ) 
{ 
  int i ;
  unsigned int _1_free_dir_next ;

  {
  {
  _1_free_dir_next = 6U;
  }
  while (1) {
    switch (_1_free_dir_next) {
    case 4: 
    free((void *)*(d + i));
    i ++;
    {
    _1_free_dir_next = 8U;
    }
    break;
    case 8: ;
    if (*(d + i)) {
      {
      _1_free_dir_next = 7U;
      }
    } else {
      {
      _1_free_dir_next = 9U;
      }
    }
    break;
    case 1: 
    free((void *)(*(d + i))->lnk);
    {
    _1_free_dir_next = 4U;
    }
    break;
    case 3: ;
    if ((*(d + i))->lnk) {
      {
      _1_free_dir_next = 1U;
      }
    } else {
      {
      _1_free_dir_next = 4U;
      }
    }
    break;
    case 9: 
    free((void *)d);
    {
    _1_free_dir_next = 5U;
    }
    break;
    case 6: 
    i = 0;
    {
    _1_free_dir_next = 8U;
    }
    break;
    case 5: ;
    return;
    break;
    case 7: 
    free((void *)(*(d + i))->name);
    {
    _1_free_dir_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF free_dir LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_outtro LOC=UNKNOWN */
void xml_outtro(void) 
{ 
  unsigned int _1_xml_outtro_next ;

  {
  {
  _1_xml_outtro_next = 1U;
  }
  while (1) {
    switch (_1_xml_outtro_next) {
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</tree>\n"));
    {
    _1_xml_outtro_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF null_outtro LOC=UNKNOWN */
void null_outtro(void) 
{ 
  unsigned int _1_null_outtro_next ;

  {
  {
  _1_null_outtro_next = 0U;
  }
  while (1) {
    switch (_1_null_outtro_next) {
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF null_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_printinfo LOC=UNKNOWN */
int json_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  mode_t mt ;
  int t ;
  unsigned int _1_json_printinfo_next ;

  {
  {
  _1_json_printinfo_next = 2U;
  }
  while (1) {
    switch (_1_json_printinfo_next) {
    case 4: 
    t ++;
    {
    _1_json_printinfo_next = 1U;
    }
    break;
    case 12: ;
    if (file->lnk) {
      {
      _1_json_printinfo_next = 11U;
      }
    } else {
      {
      _1_json_printinfo_next = 8U;
      }
    }
    break;
    case 8: 
    mt = file->mode & 61440U;
    {
    _1_json_printinfo_next = 5U;
    }
    break;
    case 1: ;
    if (ifmt[t]) {
      {
      _1_json_printinfo_next = 7U;
      }
    } else {
      {
      _1_json_printinfo_next = 9U;
      }
    }
    break;
    case 3: 
    json_indent(level);
    {
    _1_json_printinfo_next = 12U;
    }
    break;
    case 11: 
    mt = file->mode & 61440U;
    {
    _1_json_printinfo_next = 5U;
    }
    break;
    case 9: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"{\"type\":\"%s\""),
            ftype[t]);
    {
    _1_json_printinfo_next = 10U;
    }
    break;
    case 5: 
    t = 0;
    {
    _1_json_printinfo_next = 1U;
    }
    break;
    case 10: ;
    return (0);
    break;
    case 7: ;
    if ((mode_t )ifmt[t] == mt) {
      {
      _1_json_printinfo_next = 9U;
      }
    } else {
      {
      _1_json_printinfo_next = 4U;
      }
    }
    break;
    case 2: ;
    if (! noindent) {
      {
      _1_json_printinfo_next = 3U;
      }
    } else {
      {
      _1_json_printinfo_next = 12U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_print LOC=UNKNOWN */
void html_print(char *s ) 
{ 
  int i ;
  unsigned int _1_html_print_next ;

  {
  {
  _1_html_print_next = 3U;
  }
  while (1) {
    switch (_1_html_print_next) {
    case 4: 
    i ++;
    {
    _1_html_print_next = 8U;
    }
    break;
    case 8: ;
    if (*(s + i)) {
      {
      _1_html_print_next = 6U;
      }
    } else {
      {
      _1_html_print_next = 7U;
      }
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%c"),
            (int )*(s + i));
    {
    _1_html_print_next = 4U;
    }
    break;
    case 3: 
    i = 0;
    {
    _1_html_print_next = 8U;
    }
    break;
    case 9: ;
    return;
    break;
    case 6: ;
    if ((int )*(s + i) == 32) {
      {
      _1_html_print_next = 5U;
      }
    } else {
      {
      _1_html_print_next = 1U;
      }
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s"),
            sp);
    {
    _1_html_print_next = 4U;
    }
    break;
    case 7: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
            sp, sp);
    {
    _1_html_print_next = 9U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_print LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alnumsort LOC=UNKNOWN */
int alnumsort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1_alnumsort_next ;

  {
  {
  _1_alnumsort_next = 0U;
  }
  while (1) {
    switch (_1_alnumsort_next) {
    case 4: 
    tmp___0 = - v;
    {
    _1_alnumsort_next = 1U;
    }
    break;
    case 1: ;
    return (tmp___0);
    break;
    case 3: ;
    if (reverse) {
      {
      _1_alnumsort_next = 4U;
      }
    } else {
      {
      _1_alnumsort_next = 2U;
      }
    }
    break;
    case 0: 
    tmp = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
    v = tmp;
    {
    _1_alnumsort_next = 3U;
    }
    break;
    case 2: 
    tmp___0 = v;
    {
    _1_alnumsort_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF alnumsort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF printit LOC=UNKNOWN */
void printit(char *s ) 
{ 
  int c ;
  wchar_t___1 *ws ;
  wchar_t___1 *tp ;
  size_t___0 tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t___1 tmp___2 ;
  int tmp___3 ;
  unsigned int _1_printit_next ;

  {
  {
  _1_printit_next = 13U;
  }
  while (1) {
    switch (_1_printit_next) {
    case 18: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%lc"),
            (wint_t )*tp);
    {
    _1_printit_next = 8U;
    }
    break;
    case 50: 
    tmp___1 = iswprint((wint_t )*tp);
    {
    _1_printit_next = 2U;
    }
    break;
    case 25: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s"),
            s);
    {
    _1_printit_next = 60U;
    }
    break;
    case 49: 
    putc('\"', outfile);
    {
    _1_printit_next = 30U;
    }
    break;
    case 52: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\"%s\""),
            s);
    {
    _1_printit_next = 60U;
    }
    break;
    case 30: 
    free((void *)ws);
    {
    _1_printit_next = 44U;
    }
    break;
    case 14: 
    putc((int )*("abtnvfr" + (c - 7)), outfile);
    {
    _1_printit_next = 63U;
    }
    break;
    case 15: ;
    if (Qflag) {
      {
      _1_printit_next = 9U;
      }
    } else {
      {
      _1_printit_next = 7U;
      }
    }
    break;
    case 56: 
    putc('?', outfile);
    {
    _1_printit_next = 8U;
    }
    break;
    case 31: 
    tp = ws;
    {
    _1_printit_next = 36U;
    }
    break;
    case 12: 
    putc(c, outfile);
    {
    _1_printit_next = 63U;
    }
    break;
    case 8: 
    tp ++;
    c --;
    {
    _1_printit_next = 36U;
    }
    break;
    case 45: 
    free((void *)ws);
    {
    _1_printit_next = 1U;
    }
    break;
    case 54: ;
    if (*s) {
      {
      _1_printit_next = 51U;
      }
    } else {
      {
      _1_printit_next = 21U;
      }
    }
    break;
    case 1: ;
    if (Qflag) {
      {
      _1_printit_next = 57U;
      }
    } else {
      {
      _1_printit_next = 54U;
      }
    }
    break;
    case 23: ;
    if (tmp___3) {
      {
      _1_printit_next = 42U;
      }
    } else {
      {
      _1_printit_next = 27U;
      }
    }
    break;
    case 3: ;
    if (Qflag) {
      {
      _1_printit_next = 49U;
      }
    } else {
      {
      _1_printit_next = 30U;
      }
    }
    break;
    case 16: 
    putc('?', outfile);
    {
    _1_printit_next = 63U;
    }
    break;
    case 24: ;
    if (c > 13) {
      {
      _1_printit_next = 53U;
      }
    } else {
      {
      _1_printit_next = 14U;
      }
    }
    break;
    case 21: ;
    if (Qflag) {
      {
      _1_printit_next = 48U;
      }
    } else {
      {
      _1_printit_next = 47U;
      }
    }
    break;
    case 36: ;
    if (*tp) {
      {
      _1_printit_next = 26U;
      }
    } else {
      {
      _1_printit_next = 3U;
      }
    }
    break;
    case 57: 
    putc('\"', outfile);
    {
    _1_printit_next = 54U;
    }
    break;
    case 26: ;
    if (! (c > 1)) {
      {
      _1_printit_next = 3U;
      }
    } else {
      {
      _1_printit_next = 50U;
      }
    }
    break;
    case 11: 
    _L___2: ;
    if (c == 92) {
      {
      _1_printit_next = 9U;
      }
    } else {
      {
      _1_printit_next = 38U;
      }
    }
    break;
    case 9: 
    _L: 
    putc('\\', outfile);
    {
    _1_printit_next = 24U;
    }
    break;
    case 13: ;
    if (Nflag) {
      {
      _1_printit_next = 32U;
      }
    } else {
      {
      _1_printit_next = 17U;
      }
    }
    break;
    case 63: 
    s ++;
    {
    _1_printit_next = 54U;
    }
    break;
    case 51: 
    c = (int )((unsigned char )*s);
    {
    _1_printit_next = 28U;
    }
    break;
    case 32: ;
    if (Qflag) {
      {
      _1_printit_next = 52U;
      }
    } else {
      {
      _1_printit_next = 25U;
      }
    }
    break;
    case 17: ;
    if (mb_cur_max > 1) {
      {
      _1_printit_next = 20U;
      }
    } else {
      {
      _1_printit_next = 1U;
      }
    }
    break;
    case 55: ;
    if (c <= 13) {
      {
      _1_printit_next = 9U;
      }
    } else {
      {
      _1_printit_next = 11U;
      }
    }
    break;
    case 60: ;
    return;
    break;
    case 59: 
    putc('?', outfile);
    {
    _1_printit_next = 63U;
    }
    break;
    case 27: ;
    if (qflag) {
      {
      _1_printit_next = 0U;
      }
    } else {
      {
      _1_printit_next = 35U;
      }
    }
    break;
    case 38: ;
    if (c == 34) {
      {
      _1_printit_next = 15U;
      }
    } else {
      {
      _1_printit_next = 7U;
      }
    }
    break;
    case 61: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\\%03o"),
            (unsigned int )*tp);
    {
    _1_printit_next = 8U;
    }
    break;
    case 58: ;
    if (qflag) {
      {
      _1_printit_next = 56U;
      }
    } else {
      {
      _1_printit_next = 61U;
      }
    }
    break;
    case 34: ;
    if (c > 127) {
      {
      _1_printit_next = 12U;
      }
    } else {
      {
      _1_printit_next = 59U;
      }
    }
    break;
    case 48: 
    putc('\"', outfile);
    {
    _1_printit_next = 47U;
    }
    break;
    case 28: ;
    if (c >= 7) {
      {
      _1_printit_next = 55U;
      }
    } else {
      {
      _1_printit_next = 11U;
      }
    }
    break;
    case 53: 
    putc(c, outfile);
    {
    _1_printit_next = 63U;
    }
    break;
    case 47: ;
    return;
    break;
    case 44: ;
    return;
    break;
    case 5: ;
    if ((unsigned long long )tmp___2 != 0xffffffffffffffffULL) {
      {
      _1_printit_next = 33U;
      }
    } else {
      {
      _1_printit_next = 45U;
      }
    }
    break;
    case 33: ;
    if (Qflag) {
      {
      _1_printit_next = 29U;
      }
    } else {
      {
      _1_printit_next = 31U;
      }
    }
    break;
    case 41: ;
    if (! Qflag) {
      {
      _1_printit_next = 9U;
      }
    } else {
      {
      _1_printit_next = 39U;
      }
    }
    break;
    case 42: 
    putc(c, outfile);
    {
    _1_printit_next = 63U;
    }
    break;
    case 0: ;
    if (mb_cur_max > 1) {
      {
      _1_printit_next = 34U;
      }
    } else {
      {
      _1_printit_next = 16U;
      }
    }
    break;
    case 39: 
    _L___0: 
    tmp___3 = isprint(c);
    {
    _1_printit_next = 23U;
    }
    break;
    case 7: 
    _L___1: ;
    if (c == 32) {
      {
      _1_printit_next = 41U;
      }
    } else {
      {
      _1_printit_next = 39U;
      }
    }
    break;
    case 35: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\\%03o"),
            c);
    {
    _1_printit_next = 63U;
    }
    break;
    case 29: 
    putc('\"', outfile);
    {
    _1_printit_next = 31U;
    }
    break;
    case 2: ;
    if (tmp___1) {
      {
      _1_printit_next = 18U;
      }
    } else {
      {
      _1_printit_next = 58U;
      }
    }
    break;
    case 20: 
    tmp = strlen((char const   *)s);
    c = (int )(tmp + 1UL);
    tmp___0 = xmalloc(sizeof(wchar_t___1 ) * (unsigned long )c);
    ws = (wchar_t___1 *)tmp___0;
    tmp___2 = mbstowcs((wchar_t___0 */* __restrict  */)ws, (char const   */* __restrict  */)s,
                       (size_t___1 )c);
    {
    _1_printit_next = 5U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF printit LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_pattern LOC=UNKNOWN */
struct pattern *new_pattern(char *pattern___0 ) 
{ 
  struct pattern *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  unsigned int _1_new_pattern_next ;

  {
  {
  _1_new_pattern_next = 7U;
  }
  while (1) {
    switch (_1_new_pattern_next) {
    case 4: 
    tmp___0 = 0;
    {
    _1_new_pattern_next = 8U;
    }
    break;
    case 8: ;
    if ((int )*(pattern___0 + 0) == 47) {
      {
      _1_new_pattern_next = 6U;
      }
    } else {
      {
      _1_new_pattern_next = 2U;
      }
    }
    break;
    case 1: 
    tmp___0 = 1;
    {
    _1_new_pattern_next = 8U;
    }
    break;
    case 3: 
    tmp___2 = strlen((char const   *)(pattern___0 + tmp___1));
    tmp___3 = xmalloc(tmp___2 + 1UL);
    p->pattern = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(pattern___0 + tmp___0)));
    tmp___4 = strchr((char const   *)pattern___0, '/');
    p->relative = (unsigned long )tmp___4 == (unsigned long )((void *)0);
    p->next = (struct pattern *)((void *)0);
    {
    _1_new_pattern_next = 5U;
    }
    break;
    case 6: 
    tmp___1 = 1;
    {
    _1_new_pattern_next = 3U;
    }
    break;
    case 5: ;
    return (p);
    break;
    case 0: ;
    if ((int )*(pattern___0 + 0) == 47) {
      {
      _1_new_pattern_next = 1U;
      }
    } else {
      {
      _1_new_pattern_next = 4U;
      }
    }
    break;
    case 7: 
    tmp = xmalloc(sizeof(struct pattern ));
    p = (struct pattern *)tmp;
    {
    _1_new_pattern_next = 0U;
    }
    break;
    case 2: 
    tmp___1 = 0;
    {
    _1_new_pattern_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF new_pattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_close LOC=UNKNOWN */
void html_close(struct _info *file , int level , int needcomma ) 
{ 
  unsigned int _1_html_close_next ;

  {
  {
  _1_html_close_next = 1U;
  }
  while (1) {
    switch (_1_html_close_next) {
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</%s><br>\n"),
            file->tag);
    {
    _1_html_close_next = 0U;
    }
    break;
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF endcolor LOC=UNKNOWN */
void endcolor(void) 
{ 
  unsigned int _1_endcolor_next ;

  {
  {
  _1_endcolor_next = 1U;
  }
  while (1) {
    switch (_1_endcolor_next) {
    case 1: ;
    if (color_code[24]) {
      {
      _1_endcolor_next = 0U;
      }
    } else {
      {
      _1_endcolor_next = 2U;
      }
    }
    break;
    case 0: 
    fputs((char const   *)((char const   */* __restrict  */)color_code[24]), (FILE *)((FILE */* __restrict  */)outfile));
    {
    _1_endcolor_next = 2U;
    }
    break;
    case 2: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF endcolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF setoutput LOC=UNKNOWN */
void setoutput(char *filename ) 
{ 
  unsigned int _1_setoutput_next ;

  {
  {
  _1_setoutput_next = 6U;
  }
  while (1) {
    switch (_1_setoutput_next) {
    case 4: 
    outfile = stdout;
    {
    _1_setoutput_next = 2U;
    }
    break;
    case 1: 
    outfile = fopen((char const   *)((char const   */* __restrict  */)filename), (char const   *)((char const   */* __restrict  */)"w"));
    {
    _1_setoutput_next = 3U;
    }
    break;
    case 3: ;
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      {
      _1_setoutput_next = 0U;
      }
    } else {
      {
      _1_setoutput_next = 2U;
      }
    }
    break;
    case 6: ;
    if ((unsigned long )filename == (unsigned long )((void *)0)) {
      {
      _1_setoutput_next = 5U;
      }
    } else {
      {
      _1_setoutput_next = 1U;
      }
    }
    break;
    case 5: ;
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      {
      _1_setoutput_next = 4U;
      }
    } else {
      {
      _1_setoutput_next = 2U;
      }
    }
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: invalid filename \'%s\'\n"),
            filename);
    exit(1);
    {
    _1_setoutput_next = 2U;
    }
    break;
    case 2: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF setoutput LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF infocheck LOC=UNKNOWN */
struct comment *infocheck(char *path___0 , char *name , int top , int isdir ) 
{ 
  struct infofile *inf ;
  struct comment *com ;
  struct pattern *p ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1_infocheck_next ;

  {
  {
  _1_infocheck_next = 14U;
  }
  while (1) {
    switch (_1_infocheck_next) {
    case 18: ;
    return ((struct comment *)((void *)0));
    break;
    case 25: ;
    return (com);
    break;
    case 4: 
    p = com->pattern;
    {
    _1_infocheck_next = 21U;
    }
    break;
    case 14: 
    inf = infostack;
    {
    _1_infocheck_next = 20U;
    }
    break;
    case 15: ;
    if (top) {
      {
      _1_infocheck_next = 12U;
      }
    } else {
      {
      _1_infocheck_next = 1U;
      }
    }
    break;
    case 12: 
    tmp___0 = patmatch(name, p->pattern, isdir);
    {
    _1_infocheck_next = 24U;
    }
    break;
    case 1: 
    p = p->next;
    {
    _1_infocheck_next = 21U;
    }
    break;
    case 3: ;
    return ((struct comment *)((void *)0));
    break;
    case 24: ;
    if (tmp___0 == 1) {
      {
      _1_infocheck_next = 17U;
      }
    } else {
      {
      _1_infocheck_next = 1U;
      }
    }
    break;
    case 21: ;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      _1_infocheck_next = 0U;
      }
    } else {
      {
      _1_infocheck_next = 10U;
      }
    }
    break;
    case 11: ;
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
      {
      _1_infocheck_next = 2U;
      }
    } else {
      {
      _1_infocheck_next = 18U;
      }
    }
    break;
    case 9: ;
    if ((unsigned long )com != (unsigned long )((void *)0)) {
      {
      _1_infocheck_next = 4U;
      }
    } else {
      {
      _1_infocheck_next = 19U;
      }
    }
    break;
    case 19: 
    top = 0;
    inf = inf->next;
    {
    _1_infocheck_next = 11U;
    }
    break;
    case 17: ;
    return (com);
    break;
    case 6: 
    inf = infostack;
    {
    _1_infocheck_next = 11U;
    }
    break;
    case 10: 
    com = com->next;
    {
    _1_infocheck_next = 9U;
    }
    break;
    case 0: 
    tmp = patmatch(path___0, p->pattern, isdir);
    {
    _1_infocheck_next = 7U;
    }
    break;
    case 7: ;
    if (tmp == 1) {
      {
      _1_infocheck_next = 25U;
      }
    } else {
      {
      _1_infocheck_next = 15U;
      }
    }
    break;
    case 2: 
    com = inf->comments;
    {
    _1_infocheck_next = 9U;
    }
    break;
    case 20: ;
    if ((unsigned long )inf == (unsigned long )((void *)0)) {
      {
      _1_infocheck_next = 3U;
      }
    } else {
      {
      _1_infocheck_next = 6U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF infocheck LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_error LOC=UNKNOWN */
int html_error(char *error ) 
{ 
  unsigned int _1_html_error_next ;

  {
  {
  _1_html_error_next = 0U;
  }
  while (1) {
    switch (_1_html_error_next) {
    case 1: ;
    return (0);
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  [%s]"),
            error);
    {
    _1_html_error_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_indent LOC=UNKNOWN */
void json_indent(int maxlevel ) 
{ 
  int i ;
  unsigned int _1_json_indent_next ;

  {
  {
  _1_json_indent_next = 1U;
  }
  while (1) {
    switch (_1_json_indent_next) {
    case 4: ;
    return;
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
    i = 0;
    {
    _1_json_indent_next = 0U;
    }
    break;
    case 0: ;
    if (i < maxlevel) {
      {
      _1_json_indent_next = 2U;
      }
    } else {
      {
      _1_json_indent_next = 4U;
      }
    }
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
    i ++;
    {
    _1_json_indent_next = 0U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_indent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF prot LOC=UNKNOWN */
char *prot(mode_t m ) 
{ 
  int i ;
  int b ;
  unsigned int _1_prot_next ;

  {
  {
  _1_prot_next = 9U;
  }
  while (1) {
    switch (_1_prot_next) {
    case 25: ;
    if ((int )buf[9] == 45) {
      {
      _1_prot_next = 5U;
      }
    } else {
      {
      _1_prot_next = 27U;
      }
    }
    break;
    case 4: ;
    if (ifmt[i]) {
      {
      _1_prot_next = 2U;
      }
    } else {
      {
      _1_prot_next = 12U;
      }
    }
    break;
    case 15: 
    buf[i + 1] = perms[i];
    {
    _1_prot_next = 7U;
    }
    break;
    case 12: 
    buf[0] = (char )fmt[i];
    b = 256;
    i = 0;
    {
    _1_prot_next = 23U;
    }
    break;
    case 8: ;
    return (buf);
    break;
    case 1: 
    buf[6] = (char )'s';
    {
    _1_prot_next = 11U;
    }
    break;
    case 23: ;
    if (i < 9) {
      {
      _1_prot_next = 10U;
      }
    } else {
      {
      _1_prot_next = 13U;
      }
    }
    break;
    case 3: 
    buf[3] = (char )'S';
    {
    _1_prot_next = 28U;
    }
    break;
    case 16: 
    i ++;
    {
    _1_prot_next = 4U;
    }
    break;
    case 24: ;
    if ((int )buf[3] == 45) {
      {
      _1_prot_next = 3U;
      }
    } else {
      {
      _1_prot_next = 17U;
      }
    }
    break;
    case 21: ;
    if ((int )buf[6] == 45) {
      {
      _1_prot_next = 6U;
      }
    } else {
      {
      _1_prot_next = 1U;
      }
    }
    break;
    case 26: 
    buf[10] = (char)0;
    {
    _1_prot_next = 8U;
    }
    break;
    case 11: ;
    if (m & 512U) {
      {
      _1_prot_next = 25U;
      }
    } else {
      {
      _1_prot_next = 26U;
      }
    }
    break;
    case 9: 
    i = 0;
    {
    _1_prot_next = 4U;
    }
    break;
    case 13: ;
    if (m & 2048U) {
      {
      _1_prot_next = 24U;
      }
    } else {
      {
      _1_prot_next = 28U;
      }
    }
    break;
    case 17: 
    buf[3] = (char )'s';
    {
    _1_prot_next = 28U;
    }
    break;
    case 6: 
    buf[6] = (char )'S';
    {
    _1_prot_next = 11U;
    }
    break;
    case 27: 
    buf[9] = (char )'t';
    {
    _1_prot_next = 26U;
    }
    break;
    case 28: ;
    if (m & 1024U) {
      {
      _1_prot_next = 21U;
      }
    } else {
      {
      _1_prot_next = 11U;
      }
    }
    break;
    case 5: 
    buf[9] = (char )'T';
    {
    _1_prot_next = 26U;
    }
    break;
    case 10: ;
    if (m & (unsigned int )b) {
      {
      _1_prot_next = 15U;
      }
    } else {
      {
      _1_prot_next = 20U;
      }
    }
    break;
    case 7: 
    b >>= 1;
    i ++;
    {
    _1_prot_next = 23U;
    }
    break;
    case 2: ;
    if (! ((m & 61440U) != (unsigned int )ifmt[i])) {
      {
      _1_prot_next = 12U;
      }
    } else {
      {
      _1_prot_next = 16U;
      }
    }
    break;
    case 20: 
    buf[i + 1] = (char )'-';
    {
    _1_prot_next = 7U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF prot LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF uidtoname LOC=UNKNOWN */
char *uidtoname(uid_t uid ) 
{ 
  struct xtable *o ;
  struct xtable *p ;
  struct xtable *t ;
  struct passwd *ent ;
  char ubuf[32] ;
  int uent ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  unsigned int _1_uidtoname_next ;

  {
  {
  _1_uidtoname_next = 13U;
  }
  while (1) {
    switch (_1_uidtoname_next) {
    case 14: ;
    if (p) {
      {
      _1_uidtoname_next = 15U;
      }
    } else {
      {
      _1_uidtoname_next = 10U;
      }
    }
    break;
    case 15: ;
    if (uid == p->xid) {
      {
      _1_uidtoname_next = 8U;
      }
    } else {
      {
      _1_uidtoname_next = 2U;
      }
    }
    break;
    case 12: 
    t->xid = uid;
    t->nxt = p;
    {
    _1_uidtoname_next = 3U;
    }
    break;
    case 8: ;
    return (p->name);
    break;
    case 1: 
    snprintf((char *)((char */* __restrict  */)(ubuf)), (size_t___0 )30, (char const   *)((char const   */* __restrict  */)"%d"),
             uid);
    ubuf[31] = (char)0;
    tmp___2 = strlen((char const   *)(ubuf));
    tmp___3 = xmalloc(tmp___2 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(ubuf)));
    {
    _1_uidtoname_next = 12U;
    }
    break;
    case 3: ;
    if ((unsigned long )p == (unsigned long )utable[uent]) {
      {
      _1_uidtoname_next = 6U;
      }
    } else {
      {
      _1_uidtoname_next = 7U;
      }
    }
    break;
    case 16: ;
    if ((unsigned long )ent != (unsigned long )((void *)0)) {
      {
      _1_uidtoname_next = 5U;
      }
    } else {
      {
      _1_uidtoname_next = 1U;
      }
    }
    break;
    case 11: ;
    return (t->name);
    break;
    case 13: 
    uent = (int )(uid & 255U);
    p = utable[uent];
    o = p;
    {
    _1_uidtoname_next = 14U;
    }
    break;
    case 6: 
    utable[uent] = t;
    {
    _1_uidtoname_next = 11U;
    }
    break;
    case 5: 
    tmp___0 = strlen((char const   *)ent->pw_name);
    tmp___1 = xmalloc(tmp___0 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___1), (char const   *)((char const   */* __restrict  */)ent->pw_name));
    {
    _1_uidtoname_next = 12U;
    }
    break;
    case 10: 
    tmp = xmalloc(sizeof(struct xtable ));
    t = (struct xtable *)tmp;
    ent = getpwuid(uid);
    {
    _1_uidtoname_next = 16U;
    }
    break;
    case 0: 
    o = p;
    p = p->nxt;
    {
    _1_uidtoname_next = 14U;
    }
    break;
    case 7: 
    o->nxt = t;
    {
    _1_uidtoname_next = 11U;
    }
    break;
    case 2: ;
    if (uid < p->xid) {
      {
      _1_uidtoname_next = 10U;
      }
    } else {
      {
      _1_uidtoname_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF uidtoname LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_fillinfo LOC=UNKNOWN */
void xml_fillinfo(struct _info *ent ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  time_t tmp___2 ;
  char *tmp___3 ;
  unsigned int _1_xml_fillinfo_next ;

  {
  {
  _1_xml_fillinfo_next = 3U;
  }
  while (1) {
    switch (_1_xml_fillinfo_next) {
    case 4: 
    tmp___1 = gidtoname(ent->gid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" group=\"%s\""),
            tmp___1);
    {
    _1_xml_fillinfo_next = 5U;
    }
    break;
    case 14: 
    tmp___3 = do_date(tmp___2);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" time=\"%s\""),
            tmp___3);
    {
    _1_xml_fillinfo_next = 8U;
    }
    break;
    case 15: ;
    if (pflag) {
      {
      _1_xml_fillinfo_next = 2U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 12U;
      }
    }
    break;
    case 12: ;
    if (uflag) {
      {
      _1_xml_fillinfo_next = 6U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 16U;
      }
    }
    break;
    case 8: ;
    return;
    break;
    case 1: 
    tmp___2 = ent->ctime;
    {
    _1_xml_fillinfo_next = 14U;
    }
    break;
    case 3: ;
    if (inodeflag) {
      {
      _1_xml_fillinfo_next = 13U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 7U;
      }
    }
    break;
    case 16: ;
    if (gflag) {
      {
      _1_xml_fillinfo_next = 4U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 5U;
      }
    }
    break;
    case 11: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" dev=\"%d\""),
            (int )ent->dev);
    {
    _1_xml_fillinfo_next = 15U;
    }
    break;
    case 9: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" size=\"%lld\""),
            ent->size);
    {
    _1_xml_fillinfo_next = 0U;
    }
    break;
    case 13: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" inode=\"%ld\""),
            (long )ent->inode);
    {
    _1_xml_fillinfo_next = 7U;
    }
    break;
    case 17: ;
    if (cflag) {
      {
      _1_xml_fillinfo_next = 1U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 10U;
      }
    }
    break;
    case 6: 
    tmp___0 = uidtoname(ent->uid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" user=\"%s\""),
            tmp___0);
    {
    _1_xml_fillinfo_next = 16U;
    }
    break;
    case 5: ;
    if (sflag) {
      {
      _1_xml_fillinfo_next = 9U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 0U;
      }
    }
    break;
    case 10: 
    tmp___2 = ent->mtime;
    {
    _1_xml_fillinfo_next = 14U;
    }
    break;
    case 0: ;
    if (Dflag) {
      {
      _1_xml_fillinfo_next = 17U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 8U;
      }
    }
    break;
    case 7: ;
    if (devflag) {
      {
      _1_xml_fillinfo_next = 11U;
      }
    } else {
      {
      _1_xml_fillinfo_next = 15U;
      }
    }
    break;
    case 2: 
    tmp = prot(ent->mode);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" mode=\"%04o\" prot=\"%s\""),
            ent->mode & 4095U, tmp);
    {
    _1_xml_fillinfo_next = 12U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF patignore LOC=UNKNOWN */
int patignore(char *name , int isdir ) 
{ 
  int i ;
  int tmp ;
  unsigned int _1_patignore_next ;

  {
  {
  _1_patignore_next = 6U;
  }
  while (1) {
    switch (_1_patignore_next) {
    case 4: ;
    return (1);
    break;
    case 1: ;
    if (i < ipattern) {
      {
      _1_patignore_next = 0U;
      }
    } else {
      {
      _1_patignore_next = 2U;
      }
    }
    break;
    case 3: ;
    if (tmp) {
      {
      _1_patignore_next = 4U;
      }
    } else {
      {
      _1_patignore_next = 7U;
      }
    }
    break;
    case 6: 
    i = 0;
    {
    _1_patignore_next = 1U;
    }
    break;
    case 0: 
    tmp = patmatch(name, *(ipatterns + i), isdir);
    {
    _1_patignore_next = 3U;
    }
    break;
    case 7: 
    i ++;
    {
    _1_patignore_next = 1U;
    }
    break;
    case 2: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF patignore LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fsizesort LOC=UNKNOWN */
int fsizesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1_fsizesort_next ;

  {
  {
  _1_fsizesort_next = 1U;
  }
  while (1) {
    switch (_1_fsizesort_next) {
    case 4: ;
    if (reverse) {
      {
      _1_fsizesort_next = 3U;
      }
    } else {
      {
      _1_fsizesort_next = 2U;
      }
    }
    break;
    case 1: 
    tmp = sizecmp((*a)->size, (*b)->size);
    v = tmp;
    {
    _1_fsizesort_next = 5U;
    }
    break;
    case 3: 
    tmp___0 = - v;
    {
    _1_fsizesort_next = 6U;
    }
    break;
    case 6: ;
    return (tmp___0);
    break;
    case 5: ;
    if (v == 0) {
      {
      _1_fsizesort_next = 0U;
      }
    } else {
      {
      _1_fsizesort_next = 4U;
      }
    }
    break;
    case 0: 
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
    {
    _1_fsizesort_next = 4U;
    }
    break;
    case 2: 
    tmp___0 = v;
    {
    _1_fsizesort_next = 6U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF fsizesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF url_encode LOC=UNKNOWN */
void url_encode(FILE *fd , char *s ) 
{ 
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int _1_url_encode_next ;

  {
  {
  _1_url_encode_next = 0U;
  }
  while (1) {
    switch (_1_url_encode_next) {
    case 14: ;
    return;
    break;
    case 15: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)tmp___0),
            (int )((u_char )*s));
    {
    _1_url_encode_next = 5U;
    }
    break;
    case 12: ;
    if (tmp___1) {
      {
      _1_url_encode_next = 1U;
      }
    } else {
      {
      _1_url_encode_next = 13U;
      }
    }
    break;
    case 8: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"%%%02X"),
            (int )*s);
    {
    _1_url_encode_next = 5U;
    }
    break;
    case 1: 
    tmp___0 = (char *)"%c";
    {
    _1_url_encode_next = 15U;
    }
    break;
    case 3: ;
    if (*s) {
      {
      _1_url_encode_next = 2U;
      }
    } else {
      {
      _1_url_encode_next = 14U;
      }
    }
    break;
    case 9: 
    tmp___1 = isprint((int )((u_int )*s));
    {
    _1_url_encode_next = 12U;
    }
    break;
    case 13: 
    tmp___0 = (char *)"%%%02X";
    {
    _1_url_encode_next = 15U;
    }
    break;
    case 6: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"&amp;"));
    {
    _1_url_encode_next = 5U;
    }
    break;
    case 5: 
    s ++;
    {
    _1_url_encode_next = 3U;
    }
    break;
    case 0: ;
    {
    _1_url_encode_next = 3U;
    }
    break;
    case 2: ;
    switch ((int )*s) {
    case 32: 
    case 34: 
    case 35: 
    case 37: 
    case 60: 
    case 62: 
    case 91: 
    case 93: 
    case 94: 
    case 92: 
    case 63: 
    case 43: 
    {
    _1_url_encode_next = 8U;
    }
    break;
    case 38: 
    {
    _1_url_encode_next = 6U;
    }
    break;
    default: 
    {
    _1_url_encode_next = 9U;
    }
    break;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF url_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF null_intro LOC=UNKNOWN */
void null_intro(void) 
{ 
  unsigned int _1_null_intro_next ;

  {
  {
  _1_null_intro_next = 0U;
  }
  while (1) {
    switch (_1_null_intro_next) {
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF null_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF findino LOC=UNKNOWN */
int findino(ino_t inode , dev_t device ) 
{ 
  struct inotable *it ;
  unsigned int _1_findino_next ;

  {
  {
  _1_findino_next = 3U;
  }
  while (1) {
    switch (_1_findino_next) {
    case 4: ;
    if (it->device >= device) {
      {
      _1_findino_next = 13U;
      }
    } else {
      {
      _1_findino_next = 1U;
      }
    }
    break;
    case 14: ;
    if (it->inode == inode) {
      {
      _1_findino_next = 11U;
      }
    } else {
      {
      _1_findino_next = 2U;
      }
    }
    break;
    case 12: ;
    if (it->inode == inode) {
      {
      _1_findino_next = 4U;
      }
    } else {
      {
      _1_findino_next = 1U;
      }
    }
    break;
    case 1: 
    it = it->nxt;
    {
    _1_findino_next = 7U;
    }
    break;
    case 3: 
    it = itable[inode & 255ULL];
    {
    _1_findino_next = 7U;
    }
    break;
    case 11: ;
    if (it->device == device) {
      {
      _1_findino_next = 5U;
      }
    } else {
      {
      _1_findino_next = 2U;
      }
    }
    break;
    case 13: ;
    if (it) {
      {
      _1_findino_next = 14U;
      }
    } else {
      {
      _1_findino_next = 2U;
      }
    }
    break;
    case 5: ;
    return (1);
    break;
    case 10: ;
    if (it->inode > inode) {
      {
      _1_findino_next = 13U;
      }
    } else {
      {
      _1_findino_next = 12U;
      }
    }
    break;
    case 7: ;
    if (it) {
      {
      _1_findino_next = 10U;
      }
    } else {
      {
      _1_findino_next = 13U;
      }
    }
    break;
    case 2: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF findino LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_printfile LOC=UNKNOWN */
int unix_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int colored ;
  int c ;
  char tmp ;
  char tmp___0 ;
  unsigned int _1_unix_printfile_next ;

  {
  {
  _1_unix_printfile_next = 24U;
  }
  while (1) {
    switch (_1_unix_printfile_next) {
    case 18: 
    tmp___0 = Ftype(file->lnkmode);
    c = (int )tmp___0;
    {
    _1_unix_printfile_next = 19U;
    }
    break;
    case 25: 
    tmp = Ftype(file->mode);
    c = (int )tmp;
    {
    _1_unix_printfile_next = 8U;
    }
    break;
    case 4: ;
    if (linktargetcolor) {
      {
      _1_unix_printfile_next = 23U;
      }
    } else {
      {
      _1_unix_printfile_next = 13U;
      }
    }
    break;
    case 14: ;
    if (! file->lnk) {
      {
      _1_unix_printfile_next = 25U;
      }
    } else {
      {
      _1_unix_printfile_next = 11U;
      }
    }
    break;
    case 15: 
    printit(filename);
    {
    _1_unix_printfile_next = 20U;
    }
    break;
    case 12: ;
    if (file) {
      {
      _1_unix_printfile_next = 22U;
      }
    } else {
      {
      _1_unix_printfile_next = 10U;
      }
    }
    break;
    case 8: ;
    if (c) {
      {
      _1_unix_printfile_next = 16U;
      }
    } else {
      {
      _1_unix_printfile_next = 11U;
      }
    }
    break;
    case 1: ;
    if (colored) {
      {
      _1_unix_printfile_next = 3U;
      }
    } else {
      {
      _1_unix_printfile_next = 9U;
      }
    }
    break;
    case 23: 
    colored = color((u_short )file->lnkmode, file->name, file->orphan, (bool )0);
    {
    _1_unix_printfile_next = 15U;
    }
    break;
    case 3: 
    endcolor();
    {
    _1_unix_printfile_next = 9U;
    }
    break;
    case 16: 
    fputc(c, outfile);
    {
    _1_unix_printfile_next = 11U;
    }
    break;
    case 24: 
    colored = 0;
    {
    _1_unix_printfile_next = 21U;
    }
    break;
    case 21: ;
    if (file) {
      {
      _1_unix_printfile_next = 0U;
      }
    } else {
      {
      _1_unix_printfile_next = 15U;
      }
    }
    break;
    case 26: 
    colored = color((u_short )file->mode, file->name, file->orphan, (bool )0);
    {
    _1_unix_printfile_next = 15U;
    }
    break;
    case 11: ;
    if (file->lnk) {
      {
      _1_unix_printfile_next = 6U;
      }
    } else {
      {
      _1_unix_printfile_next = 10U;
      }
    }
    break;
    case 9: ;
    if (Fflag) {
      {
      _1_unix_printfile_next = 18U;
      }
    } else {
      {
      _1_unix_printfile_next = 10U;
      }
    }
    break;
    case 13: 
    colored = color((u_short )file->mode, file->name, file->orphan, (bool )0);
    {
    _1_unix_printfile_next = 15U;
    }
    break;
    case 19: ;
    if (c) {
      {
      _1_unix_printfile_next = 7U;
      }
    } else {
      {
      _1_unix_printfile_next = 10U;
      }
    }
    break;
    case 17: 
    printit(file->lnk);
    {
    _1_unix_printfile_next = 1U;
    }
    break;
    case 6: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" -> "));
    {
    _1_unix_printfile_next = 28U;
    }
    break;
    case 27: ;
    if (file->lnk) {
      {
      _1_unix_printfile_next = 4U;
      }
    } else {
      {
      _1_unix_printfile_next = 26U;
      }
    }
    break;
    case 22: ;
    if (Fflag) {
      {
      _1_unix_printfile_next = 14U;
      }
    } else {
      {
      _1_unix_printfile_next = 11U;
      }
    }
    break;
    case 28: ;
    if (colorize) {
      {
      _1_unix_printfile_next = 5U;
      }
    } else {
      {
      _1_unix_printfile_next = 17U;
      }
    }
    break;
    case 5: 
    colored = color((u_short )file->lnkmode, file->lnk, file->orphan, (bool )1);
    {
    _1_unix_printfile_next = 17U;
    }
    break;
    case 10: ;
    return (0);
    break;
    case 0: ;
    if (colorize) {
      {
      _1_unix_printfile_next = 27U;
      }
    } else {
      {
      _1_unix_printfile_next = 15U;
      }
    }
    break;
    case 7: 
    fputc(c, outfile);
    {
    _1_unix_printfile_next = 10U;
    }
    break;
    case 2: 
    endcolor();
    {
    _1_unix_printfile_next = 12U;
    }
    break;
    case 20: ;
    if (colored) {
      {
      _1_unix_printfile_next = 2U;
      }
    } else {
      {
      _1_unix_printfile_next = 12U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF unix_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xmalloc LOC=UNKNOWN */
void *xmalloc(size_t___0 size ) 
{ 
  register void *value ;
  void *tmp ;
  unsigned int _1_xmalloc_next ;

  {
  {
  _1_xmalloc_next = 0U;
  }
  while (1) {
    switch (_1_xmalloc_next) {
    case 1: ;
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
      _1_xmalloc_next = 2U;
      }
    } else {
      {
      _1_xmalloc_next = 3U;
      }
    }
    break;
    case 3: ;
    return (value);
    break;
    case 0: 
    tmp = malloc(size);
    value = tmp;
    {
    _1_xmalloc_next = 1U;
    }
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: virtual memory exhausted.\n"));
    exit(1);
    {
    _1_xmalloc_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xmalloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF freefiletree LOC=UNKNOWN */
void freefiletree(struct _info *ent ) 
{ 
  struct _info *ptr ;
  struct _info *t ;
  unsigned int _1_freefiletree_next ;

  {
  {
  _1_freefiletree_next = 4U;
  }
  while (1) {
    switch (_1_freefiletree_next) {
    case 4: 
    ptr = ent;
    {
    _1_freefiletree_next = 2U;
    }
    break;
    case 6: 
    t = ptr;
    ptr = ptr->next;
    free((void *)t);
    {
    _1_freefiletree_next = 2U;
    }
    break;
    case 5: ;
    if (ptr->tchild) {
      {
      _1_freefiletree_next = 7U;
      }
    } else {
      {
      _1_freefiletree_next = 6U;
      }
    }
    break;
    case 0: ;
    return;
    break;
    case 7: 
    freefiletree(ptr->tchild);
    {
    _1_freefiletree_next = 6U;
    }
    break;
    case 2: ;
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
      {
      _1_freefiletree_next = 5U;
      }
    } else {
      {
      _1_freefiletree_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF freefiletree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_close LOC=UNKNOWN */
void xml_close(struct _info *file , int level , int needcomma ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  unsigned int _1_xml_close_next ;

  {
  {
  _1_xml_close_next = 3U;
  }
  while (1) {
    switch (_1_xml_close_next) {
    case 4: 
    tmp = (char *)"";
    {
    _1_xml_close_next = 8U;
    }
    break;
    case 8: ;
    if (file) {
      {
      _1_xml_close_next = 6U;
      }
    } else {
      {
      _1_xml_close_next = 5U;
      }
    }
    break;
    case 1: ;
    if (level >= 0) {
      {
      _1_xml_close_next = 2U;
      }
    } else {
      {
      _1_xml_close_next = 7U;
      }
    }
    break;
    case 3: ;
    if (! noindent) {
      {
      _1_xml_close_next = 1U;
      }
    } else {
      {
      _1_xml_close_next = 7U;
      }
    }
    break;
    case 9: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</%s>%s"),
            tmp___0, tmp);
    {
    _1_xml_close_next = 10U;
    }
    break;
    case 6: 
    tmp___0 = file->tag;
    {
    _1_xml_close_next = 9U;
    }
    break;
    case 5: 
    tmp___0 = "unknown";
    {
    _1_xml_close_next = 9U;
    }
    break;
    case 10: ;
    return;
    break;
    case 0: 
    tmp = (char *)"\n";
    {
    _1_xml_close_next = 8U;
    }
    break;
    case 7: ;
    if (noindent) {
      {
      _1_xml_close_next = 4U;
      }
    } else {
      {
      _1_xml_close_next = 0U;
      }
    }
    break;
    case 2: 
    xml_indent(level - 1);
    {
    _1_xml_close_next = 7U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_newline LOC=UNKNOWN */
void xml_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  unsigned int _1_xml_newline_next ;

  {
  {
  _1_xml_newline_next = 2U;
  }
  while (1) {
    switch (_1_xml_newline_next) {
    case 1: ;
    return;
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
    {
    _1_xml_newline_next = 1U;
    }
    break;
    case 2: ;
    if (postdir >= 0) {
      {
      _1_xml_newline_next = 0U;
      }
    } else {
      {
      _1_xml_newline_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF strverscmp LOC=UNKNOWN */
int strverscmp(char const   *s1 , char const   *s2 ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int state ;
  int diff ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char const   *tmp___6 ;
  int tmp___7 ;
  unsigned char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned int _1_strverscmp_next ;

  {
  {
  _1_strverscmp_next = 19U;
  }
  while (1) {
    switch (_1_strverscmp_next) {
    case 18: ;
    if (diff == 0) {
      {
      _1_strverscmp_next = 6U;
      }
    } else {
      {
      _1_strverscmp_next = 24U;
      }
    }
    break;
    case 25: ;
    if (! tmp___7) {
      {
      _1_strverscmp_next = 22U;
      }
    } else {
      {
      _1_strverscmp_next = 20U;
      }
    }
    break;
    case 4: ;
    switch (state) {
    case 2: 
    {
    _1_strverscmp_next = 9U;
    }
    break;
    case 3: 
    {
    _1_strverscmp_next = 20U;
    }
    break;
    default: 
    {
    _1_strverscmp_next = 10U;
    }
    break;
    }
    break;
    case 14: 
    tmp___12 = isdigit((int )*p2);
    {
    _1_strverscmp_next = 12U;
    }
    break;
    case 15: ;
    if ((unsigned long )p1 == (unsigned long )p2) {
      {
      _1_strverscmp_next = 27U;
      }
    } else {
      {
      _1_strverscmp_next = 11U;
      }
    }
    break;
    case 12: ;
    if (tmp___12) {
      {
      _1_strverscmp_next = 8U;
      }
    } else {
      {
      _1_strverscmp_next = 23U;
      }
    }
    break;
    case 8: 
    tmp___11 = -1;
    {
    _1_strverscmp_next = 0U;
    }
    break;
    case 1: 
    state = (int )next_state[state];
    tmp___2 = p1;
    p1 ++;
    c1 = (unsigned char )*tmp___2;
    tmp___3 = p2;
    p2 ++;
    c2 = (unsigned char )*tmp___3;
    tmp___4 = isdigit((int )c1);
    state |= ((int )c1 == 48) + (tmp___4 != 0);
    {
    _1_strverscmp_next = 16U;
    }
    break;
    case 23: 
    tmp___11 = diff;
    {
    _1_strverscmp_next = 0U;
    }
    break;
    case 16: 
    diff = (int )c1 - (int )c2;
    {
    _1_strverscmp_next = 18U;
    }
    break;
    case 24: 
    tmp___5 = isdigit((int )c2);
    state = (int )result_type[(state << 2) | (((int )c2 == 48) + (tmp___5 != 0))];
    {
    _1_strverscmp_next = 4U;
    }
    break;
    case 21: 
    tmp___6 = p2;
    p2 ++;
    tmp___7 = isdigit((int )*tmp___6);
    {
    _1_strverscmp_next = 25U;
    }
    break;
    case 11: 
    tmp = p1;
    p1 ++;
    c1 = (unsigned char )*tmp;
    tmp___0 = p2;
    p2 ++;
    c2 = (unsigned char )*tmp___0;
    tmp___1 = isdigit((int )c1);
    state = ((int )c1 == 48) + (tmp___1 != 0);
    {
    _1_strverscmp_next = 16U;
    }
    break;
    case 9: ;
    return (diff);
    break;
    case 19: 
    p1 = (unsigned char const   *)s1;
    p2 = (unsigned char const   *)s2;
    {
    _1_strverscmp_next = 15U;
    }
    break;
    case 6: ;
    if (! ((int )c1 != 0)) {
      {
      _1_strverscmp_next = 24U;
      }
    } else {
      {
      _1_strverscmp_next = 1U;
      }
    }
    break;
    case 27: ;
    return (0);
    break;
    case 22: ;
    return (1);
    break;
    case 10: ;
    return (state);
    break;
    case 0: ;
    return (tmp___11);
    break;
    case 2: ;
    if (! tmp___9) {
      {
      _1_strverscmp_next = 14U;
      }
    } else {
      {
      _1_strverscmp_next = 21U;
      }
    }
    break;
    case 20: 
    tmp___8 = p1;
    p1 ++;
    tmp___9 = isdigit((int )*tmp___8);
    {
    _1_strverscmp_next = 2U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF strverscmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF versort LOC=UNKNOWN */
int versort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  unsigned int _1_versort_next ;

  {
  {
  _1_versort_next = 1U;
  }
  while (1) {
    switch (_1_versort_next) {
    case 4: ;
    return (tmp___0);
    break;
    case 1: 
    tmp = strverscmp((char const   *)(*a)->name, (char const   *)(*b)->name);
    v = tmp;
    {
    _1_versort_next = 2U;
    }
    break;
    case 3: 
    tmp___0 = - v;
    {
    _1_versort_next = 4U;
    }
    break;
    case 0: 
    tmp___0 = v;
    {
    _1_versort_next = 4U;
    }
    break;
    case 2: ;
    if (reverse) {
      {
      _1_versort_next = 3U;
      }
    } else {
      {
      _1_versort_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF versort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF pop_filterstack LOC=UNKNOWN */
struct ignorefile *pop_filterstack(void) 
{ 
  struct ignorefile *ig ;
  struct pattern *p ;
  struct pattern *c ;
  unsigned int _1_pop_filterstack_next ;

  {
  {
  _1_pop_filterstack_next = 1U;
  }
  while (1) {
    switch (_1_pop_filterstack_next) {
    case 4: 
    c = ig->reverse;
    p = c;
    {
    _1_pop_filterstack_next = 7U;
    }
    break;
    case 1: 
    ig = filterstack;
    filterstack = filterstack->next;
    c = ig->remove;
    p = c;
    {
    _1_pop_filterstack_next = 3U;
    }
    break;
    case 3: ;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      _1_pop_filterstack_next = 5U;
      }
    } else {
      {
      _1_pop_filterstack_next = 4U;
      }
    }
    break;
    case 9: ;
    return ((struct ignorefile *)((void *)0));
    break;
    case 6: 
    p = p->next;
    free((void *)c->pattern);
    c = p;
    {
    _1_pop_filterstack_next = 7U;
    }
    break;
    case 5: 
    p = p->next;
    free((void *)c->pattern);
    c = p;
    {
    _1_pop_filterstack_next = 3U;
    }
    break;
    case 0: 
    free((void *)ig->path);
    free((void *)ig);
    {
    _1_pop_filterstack_next = 9U;
    }
    break;
    case 7: ;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      _1_pop_filterstack_next = 6U;
      }
    } else {
      {
      _1_pop_filterstack_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF pop_filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF class LOC=UNKNOWN */
char *class(struct _info *info___1 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int _1_class_next ;

  {
  {
  _1_class_next = 7U;
  }
  while (1) {
    switch (_1_class_next) {
    case 4: 
    tmp___1 = (char *)"EXEC";
    {
    _1_class_next = 6U;
    }
    break;
    case 12: 
    tmp = (char *)"SOCK";
    {
    _1_class_next = 11U;
    }
    break;
    case 8: ;
    if (info___1->isexe) {
      {
      _1_class_next = 4U;
      }
    } else {
      {
      _1_class_next = 1U;
      }
    }
    break;
    case 1: ;
    if (info___1->isfifo) {
      {
      _1_class_next = 0U;
      }
    } else {
      {
      _1_class_next = 3U;
      }
    }
    break;
    case 3: ;
    if (info___1->issok) {
      {
      _1_class_next = 12U;
      }
    } else {
      {
      _1_class_next = 5U;
      }
    }
    break;
    case 11: 
    tmp___0 = tmp;
    {
    _1_class_next = 10U;
    }
    break;
    case 9: ;
    return (tmp___2);
    break;
    case 6: 
    tmp___2 = tmp___1;
    {
    _1_class_next = 9U;
    }
    break;
    case 5: 
    tmp = (char *)"NORM";
    {
    _1_class_next = 11U;
    }
    break;
    case 10: 
    tmp___1 = tmp___0;
    {
    _1_class_next = 6U;
    }
    break;
    case 0: 
    tmp___0 = (char *)"FIFO";
    {
    _1_class_next = 10U;
    }
    break;
    case 7: ;
    if (info___1->isdir) {
      {
      _1_class_next = 2U;
      }
    } else {
      {
      _1_class_next = 8U;
      }
    }
    break;
    case 2: 
    tmp___2 = (char *)"DIR";
    {
    _1_class_next = 9U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF class LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_printfile LOC=UNKNOWN */
int xml_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int t ;
  int mt ;
  int i ;
  unsigned int _1_xml_printfile_next ;

  {
  {
  _1_xml_printfile_next = 12U;
  }
  while (1) {
    switch (_1_xml_printfile_next) {
    case 18: ;
    if (file) {
      {
      _1_xml_printfile_next = 14U;
      }
    } else {
      {
      _1_xml_printfile_next = 15U;
      }
    }
    break;
    case 25: ;
    if (file->comment) {
      {
      _1_xml_printfile_next = 5U;
      }
    } else {
      {
      _1_xml_printfile_next = 27U;
      }
    }
    break;
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<%s"),
            ftype[t]);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" name=\""));
    html_encode(outfile, filename);
    fputc('\"', outfile);
    {
    _1_xml_printfile_next = 11U;
    }
    break;
    case 30: 
    t = 0;
    {
    _1_xml_printfile_next = 3U;
    }
    break;
    case 14: 
    xml_fillinfo(file);
    {
    _1_xml_printfile_next = 15U;
    }
    break;
    case 15: 
    fputc('>', outfile);
    {
    _1_xml_printfile_next = 19U;
    }
    break;
    case 12: ;
    if (file) {
      {
      _1_xml_printfile_next = 0U;
      }
    } else {
      {
      _1_xml_printfile_next = 29U;
      }
    }
    break;
    case 8: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" target=\""));
    html_encode(outfile, file->lnk);
    fputc('\"', outfile);
    {
    _1_xml_printfile_next = 18U;
    }
    break;
    case 23: ;
    if (*(file->comment + (i + 1))) {
      {
      _1_xml_printfile_next = 13U;
      }
    } else {
      {
      _1_xml_printfile_next = 9U;
      }
    }
    break;
    case 3: ;
    if (ifmt[t]) {
      {
      _1_xml_printfile_next = 21U;
      }
    } else {
      {
      _1_xml_printfile_next = 4U;
      }
    }
    break;
    case 24: 
    mt = (int )(file->mode & 61440U);
    {
    _1_xml_printfile_next = 30U;
    }
    break;
    case 21: ;
    if (ifmt[t] == (int const   )mt) {
      {
      _1_xml_printfile_next = 4U;
      }
    } else {
      {
      _1_xml_printfile_next = 26U;
      }
    }
    break;
    case 26: 
    t ++;
    {
    _1_xml_printfile_next = 3U;
    }
    break;
    case 11: ;
    if (file) {
      {
      _1_xml_printfile_next = 25U;
      }
    } else {
      {
      _1_xml_printfile_next = 27U;
      }
    }
    break;
    case 9: 
    i ++;
    {
    _1_xml_printfile_next = 6U;
    }
    break;
    case 13: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
    {
    _1_xml_printfile_next = 9U;
    }
    break;
    case 19: ;
    return (1);
    break;
    case 6: ;
    if (*(file->comment + i)) {
      {
      _1_xml_printfile_next = 10U;
      }
    } else {
      {
      _1_xml_printfile_next = 7U;
      }
    }
    break;
    case 27: ;
    if (file) {
      {
      _1_xml_printfile_next = 2U;
      }
    } else {
      {
      _1_xml_printfile_next = 18U;
      }
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" info=\""));
    i = 0;
    {
    _1_xml_printfile_next = 6U;
    }
    break;
    case 10: 
    html_encode(outfile, *(file->comment + i));
    {
    _1_xml_printfile_next = 23U;
    }
    break;
    case 0: ;
    if (file->lnk) {
      {
      _1_xml_printfile_next = 20U;
      }
    } else {
      {
      _1_xml_printfile_next = 24U;
      }
    }
    break;
    case 7: 
    fputc('\"', outfile);
    {
    _1_xml_printfile_next = 27U;
    }
    break;
    case 29: 
    mt = 0;
    {
    _1_xml_printfile_next = 30U;
    }
    break;
    case 2: ;
    if (file->lnk) {
      {
      _1_xml_printfile_next = 8U;
      }
    } else {
      {
      _1_xml_printfile_next = 18U;
      }
    }
    break;
    case 20: 
    mt = (int )(file->mode & 61440U);
    {
    _1_xml_printfile_next = 30U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_intro LOC=UNKNOWN */
void json_intro(void) 
{ 
  char *tmp ;
  unsigned int _1_json_intro_next ;

  {
  {
  _1_json_intro_next = 0U;
  }
  while (1) {
    switch (_1_json_intro_next) {
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"[%s"),
            tmp);
    {
    _1_json_intro_next = 3U;
    }
    break;
    case 1: 
    tmp = _nl;
    {
    _1_json_intro_next = 4U;
    }
    break;
    case 3: ;
    return;
    break;
    case 0: ;
    if (noindent) {
      {
      _1_json_intro_next = 2U;
      }
    } else {
      {
      _1_json_intro_next = 1U;
      }
    }
    break;
    case 2: 
    tmp = (char *)"";
    {
    _1_json_intro_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_error LOC=UNKNOWN */
int json_error(char *error ) 
{ 
  char *tmp ;
  unsigned int _1_json_error_next ;

  {
  {
  _1_json_error_next = 2U;
  }
  while (1) {
    switch (_1_json_error_next) {
    case 4: 
    tmp = (char *)"\n";
    {
    _1_json_error_next = 0U;
    }
    break;
    case 1: 
    tmp = (char *)"";
    {
    _1_json_error_next = 0U;
    }
    break;
    case 3: ;
    return (0);
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"{\"error\": \"%s\"}%s"),
            error, tmp);
    {
    _1_json_error_next = 3U;
    }
    break;
    case 2: ;
    if (noindent) {
      {
      _1_json_error_next = 1U;
      }
    } else {
      {
      _1_json_error_next = 4U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fillinfo LOC=UNKNOWN */
char *fillinfo(char *buf___1 , struct _info *ent ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  unsigned int _1_fillinfo_next ;

  {
  {
  _1_fillinfo_next = 19U;
  }
  while (1) {
    switch (_1_fillinfo_next) {
    case 18: ;
    if (cflag) {
      {
      _1_fillinfo_next = 8U;
      }
    } else {
      {
      _1_fillinfo_next = 0U;
      }
    }
    break;
    case 4: ;
    if (pflag) {
      {
      _1_fillinfo_next = 15U;
      }
    } else {
      {
      _1_fillinfo_next = 5U;
      }
    }
    break;
    case 14: 
    tmp___9 = do_date(tmp___8);
    tmp___10 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %s"),
                       tmp___9);
    n += tmp___10;
    {
    _1_fillinfo_next = 2U;
    }
    break;
    case 15: 
    tmp___1 = prot(ent->mode);
    tmp___2 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %s"),
                      tmp___1);
    n += tmp___2;
    {
    _1_fillinfo_next = 5U;
    }
    break;
    case 12: 
    tmp = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)" %7ld"),
                  (long )ent->linode);
    n += tmp;
    {
    _1_fillinfo_next = 6U;
    }
    break;
    case 8: 
    tmp___8 = ent->ctime;
    {
    _1_fillinfo_next = 14U;
    }
    break;
    case 1: 
    tmp___0 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %3d"),
                      (int )ent->ldev);
    n += tmp___0;
    {
    _1_fillinfo_next = 4U;
    }
    break;
    case 3: ;
    if (inodeflag) {
      {
      _1_fillinfo_next = 12U;
      }
    } else {
      {
      _1_fillinfo_next = 6U;
      }
    }
    break;
    case 16: 
    tmp___7 = psize(buf___1 + n, ent->size);
    n += tmp___7;
    {
    _1_fillinfo_next = 11U;
    }
    break;
    case 11: ;
    if (Dflag) {
      {
      _1_fillinfo_next = 18U;
      }
    } else {
      {
      _1_fillinfo_next = 2U;
      }
    }
    break;
    case 9: ;
    if (sflag) {
      {
      _1_fillinfo_next = 16U;
      }
    } else {
      {
      _1_fillinfo_next = 11U;
      }
    }
    break;
    case 13: 
    tmp___5 = gidtoname(ent->gid);
    tmp___6 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %-8.32s"),
                      tmp___5);
    n += tmp___6;
    {
    _1_fillinfo_next = 9U;
    }
    break;
    case 19: 
    n = 0;
    *(buf___1 + n) = (char)0;
    {
    _1_fillinfo_next = 3U;
    }
    break;
    case 17: ;
    return (buf___1);
    break;
    case 6: ;
    if (devflag) {
      {
      _1_fillinfo_next = 1U;
      }
    } else {
      {
      _1_fillinfo_next = 4U;
      }
    }
    break;
    case 5: ;
    if (uflag) {
      {
      _1_fillinfo_next = 7U;
      }
    } else {
      {
      _1_fillinfo_next = 10U;
      }
    }
    break;
    case 10: ;
    if (gflag) {
      {
      _1_fillinfo_next = 13U;
      }
    } else {
      {
      _1_fillinfo_next = 9U;
      }
    }
    break;
    case 0: 
    tmp___8 = ent->mtime;
    {
    _1_fillinfo_next = 14U;
    }
    break;
    case 7: 
    tmp___3 = uidtoname(ent->uid);
    tmp___4 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %-8.32s"),
                      tmp___3);
    n += tmp___4;
    {
    _1_fillinfo_next = 10U;
    }
    break;
    case 2: ;
    if ((int )*(buf___1 + 0) == 32) {
      {
      _1_fillinfo_next = 20U;
      }
    } else {
      {
      _1_fillinfo_next = 17U;
      }
    }
    break;
    case 20: 
    *(buf___1 + 0) = (char )'[';
    sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)"]"));
    {
    _1_fillinfo_next = 17U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stat2info LOC=UNKNOWN */
struct _info *stat2info(struct stat *st ) 
{ 
  unsigned int _1_stat2info_next ;

  {
  {
  _1_stat2info_next = 3U;
  }
  while (1) {
    switch (_1_stat2info_next) {
    case 4: ;
    return (& info);
    break;
    case 1: ;
    if (st->st_mode & 73U) {
      {
      _1_stat2info_next = 2U;
      }
    } else {
      {
      _1_stat2info_next = 0U;
      }
    }
    break;
    case 3: 
    info.linode = st->st_ino;
    info.ldev = st->st_dev;
    info.mode = st->st_mode;
    info.uid = st->st_uid;
    info.gid = st->st_gid;
    info.size = st->st_size;
    info.atime = st->st_atim.tv_sec;
    info.ctime = st->st_ctim.tv_sec;
    info.mtime = st->st_mtim.tv_sec;
    info.isdir = (bool )((st->st_mode & 61440U) == 16384U);
    info.issok = (bool )((st->st_mode & 61440U) == 49152U);
    info.isfifo = (bool )((st->st_mode & 61440U) == 4096U);
    {
    _1_stat2info_next = 1U;
    }
    break;
    case 0: 
    info.isexe = (bool )0;
    {
    _1_stat2info_next = 4U;
    }
    break;
    case 2: 
    info.isexe = (bool )1;
    {
    _1_stat2info_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF stat2info LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF read_dir LOC=UNKNOWN */
struct _info **read_dir(char *dir , int *n , int infotop ) 
{ 
  struct comment *com ;
  struct _info **dl ;
  struct _info *info___1 ;
  struct dirent *ent ;
  DIR *d ;
  int ne ;
  int p ;
  int i ;
  int es ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t___0 tmp___6 ;
  size_t___0 tmp___7 ;
  void *tmp___8 ;
  size_t___0 tmp___9 ;
  size_t___0 tmp___10 ;
  void *tmp___11 ;
  size_t___0 tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  struct dirent *tmp___16 ;
  int tmp___17 ;
  unsigned int _1_read_dir_next ;

  {
  {
  _1_read_dir_next = 10U;
  }
  while (1) {
    switch (_1_read_dir_next) {
    case 18: 
    com = infocheck(path, ent->d_name, infotop, (int )info___1->isdir);
    {
    _1_read_dir_next = 35U;
    }
    break;
    case 25: ;
    if ((unsigned long )path == (unsigned long )((void *)0)) {
      {
      _1_read_dir_next = 5U;
      }
    } else {
      {
      _1_read_dir_next = 49U;
      }
    }
    break;
    case 49: 
    *n = -1;
    d = opendir((char const   *)dir);
    {
    _1_read_dir_next = 12U;
    }
    break;
    case 52: ;
    if (! aflag) {
      {
      _1_read_dir_next = 33U;
      }
    } else {
      {
      _1_read_dir_next = 41U;
      }
    }
    break;
    case 4: 
    *(dl + p) = (struct _info *)((void *)0);
    {
    _1_read_dir_next = 31U;
    }
    break;
    case 14: ;
    if ((unsigned long )*(com->desc + i) != (unsigned long )((void *)0)) {
      {
      _1_read_dir_next = 9U;
      }
    } else {
      {
      _1_read_dir_next = 42U;
      }
    }
    break;
    case 31: ;
    return (dl);
    break;
    case 12: ;
    if ((unsigned long )d == (unsigned long )((void *)0)) {
      {
      _1_read_dir_next = 19U;
      }
    } else {
      {
      _1_read_dir_next = 40U;
      }
    }
    break;
    case 8: ;
    if ((unsigned long )*(com->desc + i) != (unsigned long )((void *)0)) {
      {
      _1_read_dir_next = 46U;
      }
    } else {
      {
      _1_read_dir_next = 2U;
      }
    }
    break;
    case 45: ;
    if (es) {
      {
      _1_read_dir_next = 26U;
      }
    } else {
      {
      _1_read_dir_next = 27U;
      }
    }
    break;
    case 54: ;
    if (! tmp___5) {
      {
      _1_read_dir_next = 32U;
      }
    } else {
      {
      _1_read_dir_next = 52U;
      }
    }
    break;
    case 1: ;
    if (tmp___17 == 0) {
      {
      _1_read_dir_next = 51U;
      }
    } else {
      {
      _1_read_dir_next = 4U;
      }
    }
    break;
    case 3: 
    tmp___3 = strcmp("..", (char const   *)(ent->d_name));
    {
    _1_read_dir_next = 44U;
    }
    break;
    case 16: ;
    if (info___1) {
      {
      _1_read_dir_next = 28U;
      }
    } else {
      {
      _1_read_dir_next = 32U;
      }
    }
    break;
    case 24: 
    info___1 = getinfo(ent->d_name, path);
    {
    _1_read_dir_next = 16U;
    }
    break;
    case 21: ;
    if (p == ne - 1) {
      {
      _1_read_dir_next = 43U;
      }
    } else {
      {
      _1_read_dir_next = 17U;
      }
    }
    break;
    case 36: ;
    return ((struct _info **)((void *)0));
    break;
    case 26: 
    sprintf((char *)((char */* __restrict  */)path), (char const   *)((char const   */* __restrict  */)"%s%s"),
            dir, ent->d_name);
    {
    _1_read_dir_next = 24U;
    }
    break;
    case 9: 
    i ++;
    {
    _1_read_dir_next = 14U;
    }
    break;
    case 13: ;
    if (! ent) {
      {
      _1_read_dir_next = 37U;
      }
    } else {
      {
      _1_read_dir_next = 3U;
      }
    }
    break;
    case 51: 
    free((void *)dl);
    {
    _1_read_dir_next = 36U;
    }
    break;
    case 19: ;
    return ((struct _info **)((void *)0));
    break;
    case 32: 
    tmp___16 = readdir(d);
    ent = tmp___16;
    {
    _1_read_dir_next = 13U;
    }
    break;
    case 17: 
    tmp___15 = p;
    p ++;
    *(dl + tmp___15) = info___1;
    {
    _1_read_dir_next = 32U;
    }
    break;
    case 40: 
    ne = 30;
    tmp___2 = xmalloc(sizeof(struct _info *) * (unsigned long )ne);
    dl = (struct _info **)tmp___2;
    {
    _1_read_dir_next = 32U;
    }
    break;
    case 27: 
    sprintf((char *)((char */* __restrict  */)path), (char const   *)((char const   */* __restrict  */)"%s/%s"),
            dir, ent->d_name);
    {
    _1_read_dir_next = 24U;
    }
    break;
    case 38: ;
    if ((tmp___9 + tmp___10) + 2UL > (size_t___0 )pathsize) {
      {
      _1_read_dir_next = 34U;
      }
    } else {
      {
      _1_read_dir_next = 45U;
      }
    }
    break;
    case 34: 
    tmp___6 = strlen((char const   *)dir);
    tmp___7 = strlen((char const   *)(ent->d_name));
    pathsize = (long )((tmp___6 + tmp___7) + 4096UL);
    tmp___8 = xrealloc((void *)path, (size_t___0 )pathsize);
    path = (char *)tmp___8;
    {
    _1_read_dir_next = 45U;
    }
    break;
    case 48: 
    tmp___5 = strcmp((char const   *)(ent->d_name), "00Tree.html");
    {
    _1_read_dir_next = 54U;
    }
    break;
    case 22: ;
    if (! tmp___4) {
      {
      _1_read_dir_next = 32U;
      }
    } else {
      {
      _1_read_dir_next = 0U;
      }
    }
    break;
    case 28: ;
    if (showinfo) {
      {
      _1_read_dir_next = 18U;
      }
    } else {
      {
      _1_read_dir_next = 21U;
      }
    }
    break;
    case 47: 
    tmp___4 = strcmp(".", (char const   *)(ent->d_name));
    {
    _1_read_dir_next = 22U;
    }
    break;
    case 44: ;
    if (tmp___3) {
      {
      _1_read_dir_next = 47U;
      }
    } else {
      {
      _1_read_dir_next = 32U;
      }
    }
    break;
    case 5: 
    tmp___0 = strlen((char const   *)dir);
    pathsize = (long )(tmp___0 + 4096UL);
    tmp___1 = xmalloc((size_t___0 )pathsize);
    path = (char *)tmp___1;
    {
    _1_read_dir_next = 49U;
    }
    break;
    case 33: ;
    if ((int )ent->d_name[0] == 46) {
      {
      _1_read_dir_next = 32U;
      }
    } else {
      {
      _1_read_dir_next = 41U;
      }
    }
    break;
    case 37: 
    closedir(d);
    tmp___17 = p;
    *n = tmp___17;
    {
    _1_read_dir_next = 1U;
    }
    break;
    case 41: 
    tmp___9 = strlen((char const   *)dir);
    tmp___10 = strlen((char const   *)(ent->d_name));
    {
    _1_read_dir_next = 38U;
    }
    break;
    case 10: 
    p = 0;
    tmp = strlen((char const   *)dir);
    es = (int )*(dir + (tmp - 1UL)) == 47;
    {
    _1_read_dir_next = 25U;
    }
    break;
    case 42: 
    tmp___11 = xmalloc(sizeof(char *) * (unsigned long )(i + 1));
    info___1->comment = (char **)tmp___11;
    i = 0;
    {
    _1_read_dir_next = 8U;
    }
    break;
    case 0: ;
    if (Hflag) {
      {
      _1_read_dir_next = 48U;
      }
    } else {
      {
      _1_read_dir_next = 52U;
      }
    }
    break;
    case 46: 
    tmp___12 = strlen((char const   *)*(com->desc + i));
    tmp___13 = xmalloc(tmp___12 + 1UL);
    *(info___1->comment + i) = strcpy((char *)((char */* __restrict  */)tmp___13),
                                      (char const   *)((char const   */* __restrict  */)*(com->desc + i)));
    i ++;
    {
    _1_read_dir_next = 8U;
    }
    break;
    case 35: ;
    if (com) {
      {
      _1_read_dir_next = 20U;
      }
    } else {
      {
      _1_read_dir_next = 21U;
      }
    }
    break;
    case 43: 
    ne += 20;
    tmp___14 = xrealloc((void *)dl, sizeof(struct _info *) * (unsigned long )ne);
    dl = (struct _info **)tmp___14;
    {
    _1_read_dir_next = 17U;
    }
    break;
    case 2: 
    *(info___1->comment + i) = (char *)((void *)0);
    {
    _1_read_dir_next = 21U;
    }
    break;
    case 20: 
    i = 0;
    {
    _1_read_dir_next = 14U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF read_dir LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF print_color LOC=UNKNOWN */
int print_color(int color___0 ) 
{ 
  unsigned int _1_print_color_next ;

  {
  {
  _1_print_color_next = 2U;
  }
  while (1) {
    switch (_1_print_color_next) {
    case 1: ;
    return (1);
    break;
    case 3: ;
    return (0);
    break;
    case 0: 
    fputs((char const   *)((char const   */* __restrict  */)color_code[22]), (FILE *)((FILE */* __restrict  */)outfile));
    fputs((char const   *)((char const   */* __restrict  */)color_code[color___0]),
          (FILE *)((FILE */* __restrict  */)outfile));
    fputs((char const   *)((char const   */* __restrict  */)color_code[23]), (FILE *)((FILE */* __restrict  */)outfile));
    {
    _1_print_color_next = 1U;
    }
    break;
    case 2: ;
    if (! color_code[color___0]) {
      {
      _1_print_color_next = 3U;
      }
    } else {
      {
      _1_print_color_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF print_color LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_indent LOC=UNKNOWN */
void xml_indent(int maxlevel ) 
{ 
  int i ;
  unsigned int _1_xml_indent_next ;

  {
  {
  _1_xml_indent_next = 3U;
  }
  while (1) {
    switch (_1_xml_indent_next) {
    case 1: ;
    return;
    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
    i = 0;
    {
    _1_xml_indent_next = 2U;
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
    i ++;
    {
    _1_xml_indent_next = 2U;
    }
    break;
    case 2: ;
    if (i < maxlevel) {
      {
      _1_xml_indent_next = 5U;
      }
    } else {
      {
      _1_xml_indent_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_indent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF initlinedraw LOC=UNKNOWN */
void initlinedraw(int flag ) 
{ 
  char const   **s ;
  int tmp ;
  unsigned int _1_initlinedraw_next ;

  {
  {
  _1_initlinedraw_next = 6U;
  }
  while (1) {
    switch (_1_initlinedraw_next) {
    case 18: ;
    if (*s) {
      {
      _1_initlinedraw_next = 8U;
      }
    } else {
      {
      _1_initlinedraw_next = 12U;
      }
    }
    break;
    case 25: ;
    return;
    break;
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --charset, valid charsets include:\n"));
    linedraw = cstable;
    {
    _1_initlinedraw_next = 3U;
    }
    break;
    case 14: 
    linedraw = (cstable + sizeof(cstable) / sizeof(cstable[0])) - 1;
    {
    _1_initlinedraw_next = 25U;
    }
    break;
    case 12: 
    linedraw ++;
    {
    _1_initlinedraw_next = 2U;
    }
    break;
    case 8: 
    tmp = strcasecmp(charset, *s);
    {
    _1_initlinedraw_next = 27U;
    }
    break;
    case 1: 
    linedraw = cstable;
    {
    _1_initlinedraw_next = 2U;
    }
    break;
    case 3: ;
    if (linedraw->name) {
      {
      _1_initlinedraw_next = 24U;
      }
    } else {
      {
      _1_initlinedraw_next = 7U;
      }
    }
    break;
    case 24: 
    s = (char const   **)linedraw->name;
    {
    _1_initlinedraw_next = 26U;
    }
    break;
    case 26: ;
    if (*s) {
      {
      _1_initlinedraw_next = 19U;
      }
    } else {
      {
      _1_initlinedraw_next = 20U;
      }
    }
    break;
    case 11: 
    s ++;
    {
    _1_initlinedraw_next = 18U;
    }
    break;
    case 9: 
    s = (char const   **)linedraw->name;
    {
    _1_initlinedraw_next = 18U;
    }
    break;
    case 13: ;
    return;
    break;
    case 19: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"  %s\n"),
            *s);
    s ++;
    {
    _1_initlinedraw_next = 26U;
    }
    break;
    case 6: ;
    if (flag) {
      {
      _1_initlinedraw_next = 4U;
      }
    } else {
      {
      _1_initlinedraw_next = 5U;
      }
    }
    break;
    case 27: ;
    if (! tmp) {
      {
      _1_initlinedraw_next = 13U;
      }
    } else {
      {
      _1_initlinedraw_next = 11U;
      }
    }
    break;
    case 5: ;
    if (charset) {
      {
      _1_initlinedraw_next = 1U;
      }
    } else {
      {
      _1_initlinedraw_next = 14U;
      }
    }
    break;
    case 7: ;
    return;
    break;
    case 2: ;
    if (linedraw->name) {
      {
      _1_initlinedraw_next = 9U;
      }
    } else {
      {
      _1_initlinedraw_next = 14U;
      }
    }
    break;
    case 20: 
    linedraw ++;
    {
    _1_initlinedraw_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF initlinedraw LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF color LOC=UNKNOWN */
int color(u_short mode , char *name , bool orphan , bool islink ) 
{ 
  struct extensions *e ;
  int l ;
  int xl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t___0 tmp___13 ;
  size_t___0 tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int _1_color_next ;

  {
  {
  _1_color_next = 40U;
  }
  while (1) {
    switch (_1_color_next) {
    case 18: ;
    return (1);
    break;
    case 50: ;
    if (tmp___5) {
      {
      _1_color_next = 18U;
      }
    } else {
      {
      _1_color_next = 31U;
      }
    }
    break;
    case 25: ;
    if ((int )mode & 1024) {
      {
      _1_color_next = 53U;
      }
    } else {
      {
      _1_color_next = 49U;
      }
    }
    break;
    case 49: ;
    if ((int )mode & 73) {
      {
      _1_color_next = 62U;
      }
    } else {
      {
      _1_color_next = 9U;
      }
    }
    break;
    case 52: ;
    return (tmp___18);
    break;
    case 4: ;
    if (tmp___4) {
      {
      _1_color_next = 28U;
      }
    } else {
      {
      _1_color_next = 27U;
      }
    }
    break;
    case 30: ;
    return (1);
    break;
    case 62: 
    tmp___12 = print_color(20);
    {
    _1_color_next = 13U;
    }
    break;
    case 14: ;
    if (tmp___11) {
      {
      _1_color_next = 43U;
      }
    } else {
      {
      _1_color_next = 49U;
      }
    }
    break;
    case 15: 
    tmp___1 = print_color(9);
    {
    _1_color_next = 20U;
    }
    break;
    case 56: ;
    if (islink) {
      {
      _1_color_next = 17U;
      }
    } else {
      {
      _1_color_next = 7U;
      }
    }
    break;
    case 31: 
    tmp___6 = print_color(7);
    {
    _1_color_next = 36U;
    }
    break;
    case 12: ;
    return (tmp___9);
    break;
    case 8: ;
    return (1);
    break;
    case 45: 
    tmp___16 = strcmp((char const   *)tmp___15, (char const   *)e->ext);
    {
    _1_color_next = 59U;
    }
    break;
    case 54: 
    tmp___15 = name;
    {
    _1_color_next = 45U;
    }
    break;
    case 1: ;
    if (! ((int )mode & 2)) {
      {
      _1_color_next = 38U;
      }
    } else {
      {
      _1_color_next = 27U;
      }
    }
    break;
    case 23: ;
    return (1);
    break;
    case 3: ;
    if (l > xl) {
      {
      _1_color_next = 26U;
      }
    } else {
      {
      _1_color_next = 54U;
      }
    }
    break;
    case 16: 
    tmp___3 = print_color(17);
    {
    _1_color_next = 33U;
    }
    break;
    case 24: ;
    if (tmp___10) {
      {
      _1_color_next = 23U;
      }
    } else {
      {
      _1_color_next = 25U;
      }
    }
    break;
    case 21: ;
    if ((int )mode & 2048) {
      {
      _1_color_next = 10U;
      }
    } else {
      {
      _1_color_next = 25U;
      }
    }
    break;
    case 36: ;
    return (tmp___6);
    break;
    case 57: ;
    return (tmp___7);
    break;
    case 26: 
    tmp___15 = name + (l - xl);
    {
    _1_color_next = 45U;
    }
    break;
    case 11: ;
    return (1);
    break;
    case 9: 
    tmp___13 = strlen((char const   *)name);
    l = (int )tmp___13;
    e = ext;
    {
    _1_color_next = 5U;
    }
    break;
    case 13: ;
    if (tmp___12) {
      {
      _1_color_next = 11U;
      }
    } else {
      {
      _1_color_next = 9U;
      }
    }
    break;
    case 51: ;
    return (tmp___17);
    break;
    case 19: 
    e = e->nxt;
    {
    _1_color_next = 5U;
    }
    break;
    case 17: 
    tmp = print_color(21);
    {
    _1_color_next = 42U;
    }
    break;
    case 40: ;
    if (orphan) {
      {
      _1_color_next = 56U;
      }
    } else {
      {
      _1_color_next = 39U;
      }
    }
    break;
    case 55: ;
    if ((int )mode & 512) {
      {
      _1_color_next = 60U;
      }
    } else {
      {
      _1_color_next = 27U;
      }
    }
    break;
    case 60: ;
    if ((int )mode & 2) {
      {
      _1_color_next = 16U;
      }
    } else {
      {
      _1_color_next = 1U;
      }
    }
    break;
    case 59: ;
    if (! tmp___16) {
      {
      _1_color_next = 37U;
      }
    } else {
      {
      _1_color_next = 19U;
      }
    }
    break;
    case 6: 
    tmp___8 = print_color(8);
    {
    _1_color_next = 58U;
    }
    break;
    case 27: ;
    if ((int )mode & 2) {
      {
      _1_color_next = 48U;
      }
    } else {
      {
      _1_color_next = 31U;
      }
    }
    break;
    case 38: 
    tmp___4 = print_color(19);
    {
    _1_color_next = 4U;
    }
    break;
    case 61: 
    tmp___2 = print_color(12);
    {
    _1_color_next = 22U;
    }
    break;
    case 58: ;
    return (tmp___8);
    break;
    case 34: ;
    return (1);
    break;
    case 48: 
    tmp___5 = print_color(18);
    {
    _1_color_next = 50U;
    }
    break;
    case 22: ;
    return (tmp___2);
    break;
    case 28: ;
    return (1);
    break;
    case 53: 
    tmp___11 = print_color(16);
    {
    _1_color_next = 14U;
    }
    break;
    case 44: 
    tmp___9 = print_color(14);
    {
    _1_color_next = 12U;
    }
    break;
    case 5: ;
    if (e) {
      {
      _1_color_next = 41U;
      }
    } else {
      {
      _1_color_next = 29U;
      }
    }
    break;
    case 33: ;
    if (tmp___3) {
      {
      _1_color_next = 35U;
      }
    } else {
      {
      _1_color_next = 1U;
      }
    }
    break;
    case 37: 
    fputs((char const   *)((char const   */* __restrict  */)color_code[22]), (FILE *)((FILE */* __restrict  */)outfile));
    fputs((char const   *)((char const   */* __restrict  */)e->term_flg), (FILE *)((FILE */* __restrict  */)outfile));
    fputs((char const   *)((char const   */* __restrict  */)color_code[23]), (FILE *)((FILE */* __restrict  */)outfile));
    {
    _1_color_next = 8U;
    }
    break;
    case 41: 
    tmp___14 = strlen((char const   *)e->ext);
    xl = (int )tmp___14;
    {
    _1_color_next = 3U;
    }
    break;
    case 10: 
    tmp___10 = print_color(15);
    {
    _1_color_next = 24U;
    }
    break;
    case 42: ;
    if (tmp) {
      {
      _1_color_next = 30U;
      }
    } else {
      {
      _1_color_next = 39U;
      }
    }
    break;
    case 0: 
    tmp___18 = print_color(5);
    {
    _1_color_next = 52U;
    }
    break;
    case 46: 
    tmp___7 = print_color(11);
    {
    _1_color_next = 57U;
    }
    break;
    case 39: ;
    switch ((int )mode & 61440) {
    case 4096: 
    {
    _1_color_next = 15U;
    }
    break;
    case 8192: 
    {
    _1_color_next = 61U;
    }
    break;
    case 16384: 
    {
    _1_color_next = 55U;
    }
    break;
    case 24576: 
    {
    _1_color_next = 46U;
    }
    break;
    case 40960: 
    {
    _1_color_next = 6U;
    }
    break;
    case 49152: 
    {
    _1_color_next = 44U;
    }
    break;
    case 32768: 
    {
    _1_color_next = 21U;
    }
    break;
    default: 
    {
    _1_color_next = 0U;
    }
    break;
    }
    break;
    case 7: 
    tmp___0 = print_color(13);
    {
    _1_color_next = 2U;
    }
    break;
    case 35: ;
    return (1);
    break;
    case 29: 
    tmp___17 = print_color(6);
    {
    _1_color_next = 51U;
    }
    break;
    case 43: ;
    return (1);
    break;
    case 2: ;
    if (tmp___0) {
      {
      _1_color_next = 34U;
      }
    } else {
      {
      _1_color_next = 39U;
      }
    }
    break;
    case 20: ;
    return (tmp___1);
    break;
    }
  }
}
}
/* END FUNCTION-DEF color LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF dirsfirst LOC=UNKNOWN */
int dirsfirst(struct _info **a , struct _info **b ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int _1_dirsfirst_next ;

  {
  {
  _1_dirsfirst_next = 0U;
  }
  while (1) {
    switch (_1_dirsfirst_next) {
    case 4: 
    tmp = 1;
    {
    _1_dirsfirst_next = 2U;
    }
    break;
    case 1: ;
    if ((*a)->isdir) {
      {
      _1_dirsfirst_next = 3U;
      }
    } else {
      {
      _1_dirsfirst_next = 4U;
      }
    }
    break;
    case 3: 
    tmp = -1;
    {
    _1_dirsfirst_next = 2U;
    }
    break;
    case 6: 
    tmp___0 = (*basesort)(a, b);
    {
    _1_dirsfirst_next = 5U;
    }
    break;
    case 5: ;
    return (tmp___0);
    break;
    case 0: ;
    if ((unsigned int )(*a)->isdir != (unsigned int )(*b)->isdir) {
      {
      _1_dirsfirst_next = 1U;
      }
    } else {
      {
      _1_dirsfirst_next = 6U;
      }
    }
    break;
    case 2: ;
    return (tmp);
    break;
    }
  }
}
}
/* END FUNCTION-DEF dirsfirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_printinfo LOC=UNKNOWN */
int html_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  char info___1[512] ;
  unsigned int _1_html_printinfo_next ;

  {
  {
  _1_html_printinfo_next = 5U;
  }
  while (1) {
    switch (_1_html_printinfo_next) {
    case 4: ;
    if ((int )info___1[0] == 91) {
      {
      _1_html_printinfo_next = 9U;
      }
    } else {
      {
      _1_html_printinfo_next = 6U;
      }
    }
    break;
    case 8: ;
    if (metafirst) {
      {
      _1_html_printinfo_next = 3U;
      }
    } else {
      {
      _1_html_printinfo_next = 1U;
      }
    }
    break;
    case 1: ;
    if (! noindent) {
      {
      _1_html_printinfo_next = 2U;
      }
    } else {
      {
      _1_html_printinfo_next = 4U;
      }
    }
    break;
    case 3: ;
    if ((int )info___1[0] == 91) {
      {
      _1_html_printinfo_next = 10U;
      }
    } else {
      {
      _1_html_printinfo_next = 0U;
      }
    }
    break;
    case 9: 
    html_print(info___1);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
            sp, sp);
    {
    _1_html_printinfo_next = 6U;
    }
    break;
    case 6: ;
    return (0);
    break;
    case 5: 
    fillinfo(info___1, file);
    {
    _1_html_printinfo_next = 8U;
    }
    break;
    case 10: 
    html_print(info___1);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
            sp, sp);
    {
    _1_html_printinfo_next = 0U;
    }
    break;
    case 0: ;
    if (! noindent) {
      {
      _1_html_printinfo_next = 7U;
      }
    } else {
      {
      _1_html_printinfo_next = 6U;
      }
    }
    break;
    case 7: 
    indent(level);
    {
    _1_html_printinfo_next = 6U;
    }
    break;
    case 2: 
    indent(level);
    {
    _1_html_printinfo_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF file_getfulltree LOC=UNKNOWN */
struct _info **file_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  char *path___0 ;
  char *spath ;
  char *s ;
  long pathsize___0 ;
  struct _info *root ;
  struct _info **cwd ;
  struct _info *ent ;
  int l ;
  int tok ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t___0 tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  struct _info **tmp___8 ;
  unsigned int _1_file_getfulltree_next ;

  {
  {
  _1_file_getfulltree_next = 42U;
  }
  while (1) {
    switch (_1_file_getfulltree_next) {
    case 18: 
    tmp___0 = fopen((char const   *)((char const   */* __restrict  */)d), (char const   *)((char const   */* __restrict  */)"r"));
    tmp___1 = tmp___0;
    {
    _1_file_getfulltree_next = 22U;
    }
    break;
    case 25: ;
    if (tmp___4 == 0) {
      {
      _1_file_getfulltree_next = 16U;
      }
    } else {
      {
      _1_file_getfulltree_next = 15U;
      }
    }
    break;
    case 30: ;
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
      {
      _1_file_getfulltree_next = 1U;
      }
    } else {
      {
      _1_file_getfulltree_next = 40U;
      }
    }
    break;
    case 15: 
    tmp___5 = strlen((char const   *)path___0);
    l = (int )tmp___5;
    {
    _1_file_getfulltree_next = 39U;
    }
    break;
    case 31: 
    tmp___4 = strcmp((char const   *)path___0, (char const   *)file_comment);
    {
    _1_file_getfulltree_next = 25U;
    }
    break;
    case 8: ;
    if (tmp___2) {
      {
      _1_file_getfulltree_next = 18U;
      }
    } else {
      {
      _1_file_getfulltree_next = 9U;
      }
    }
    break;
    case 45: ;
    if (l == 0) {
      {
      _1_file_getfulltree_next = 16U;
      }
    } else {
      {
      _1_file_getfulltree_next = 27U;
      }
    }
    break;
    case 1: ;
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
      _1_file_getfulltree_next = 20U;
      }
    } else {
      {
      _1_file_getfulltree_next = 21U;
      }
    }
    break;
    case 23: 
    ent->isdir = (bool )1;
    ent->mode = (mode_t )16384;
    {
    _1_file_getfulltree_next = 28U;
    }
    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error opening %s for reading.\n"),
            d);
    {
    _1_file_getfulltree_next = 36U;
    }
    break;
    case 16: 
    tmp___7 = fgets((char *)((char */* __restrict  */)path___0), (int )pathsize___0,
                    (FILE *)((FILE */* __restrict  */)fp));
    {
    _1_file_getfulltree_next = 30U;
    }
    break;
    case 21: 
    tmp___8 = fprune(root, (bool )0, (bool )1);
    {
    _1_file_getfulltree_next = 34U;
    }
    break;
    case 36: ;
    return ((struct _info **)((void *)0));
    break;
    case 26: 
    ent->mode = (mode_t )32768;
    {
    _1_file_getfulltree_next = 28U;
    }
    break;
    case 9: 
    tmp___1 = stdin;
    {
    _1_file_getfulltree_next = 22U;
    }
    break;
    case 13: ;
    if (! tmp___6) {
      {
      _1_file_getfulltree_next = 45U;
      }
    } else {
      {
      _1_file_getfulltree_next = 33U;
      }
    }
    break;
    case 19: 
    ent = search(cwd, s);
    {
    _1_file_getfulltree_next = 0U;
    }
    break;
    case 40: ;
    if ((unsigned long )file_comment != (unsigned long )((void *)0)) {
      {
      _1_file_getfulltree_next = 31U;
      }
    } else {
      {
      _1_file_getfulltree_next = 15U;
      }
    }
    break;
    case 27: 
    spath = path___0;
    cwd = & root;
    {
    _1_file_getfulltree_next = 38U;
    }
    break;
    case 38: 
    s = nextpc(& spath, & tok);
    {
    _1_file_getfulltree_next = 35U;
    }
    break;
    case 34: ;
    return (tmp___8);
    break;
    case 22: 
    fp = tmp___1;
    root = (struct _info *)((void *)0);
    size = (off_t *)0;
    {
    _1_file_getfulltree_next = 46U;
    }
    break;
    case 28: 
    cwd = & ent->tchild;
    {
    _1_file_getfulltree_next = 29U;
    }
    break;
    case 5: 
    tmp___6 = isspace((int )*(path___0 + (l - 1)));
    {
    _1_file_getfulltree_next = 13U;
    }
    break;
    case 33: 
    l --;
    *(path___0 + l) = (char )'\000';
    {
    _1_file_getfulltree_next = 39U;
    }
    break;
    case 10: 
    pathsize___0 = 65536L;
    tmp___3 = xmalloc(sizeof(char *) * (unsigned long )pathsize___0);
    path___0 = (char *)tmp___3;
    {
    _1_file_getfulltree_next = 16U;
    }
    break;
    case 42: 
    tmp___2 = strcmp((char const   *)d, ".");
    {
    _1_file_getfulltree_next = 8U;
    }
    break;
    case 0: ;
    if (tok == 1) {
      {
      _1_file_getfulltree_next = 23U;
      }
    } else {
      {
      _1_file_getfulltree_next = 26U;
      }
    }
    break;
    case 46: ;
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
      _1_file_getfulltree_next = 3U;
      }
    } else {
      {
      _1_file_getfulltree_next = 10U;
      }
    }
    break;
    case 39: ;
    if (l) {
      {
      _1_file_getfulltree_next = 5U;
      }
    } else {
      {
      _1_file_getfulltree_next = 45U;
      }
    }
    break;
    case 7: ;
    if (! (tok != 3)) {
      {
      _1_file_getfulltree_next = 16U;
      }
    } else {
      {
      _1_file_getfulltree_next = 38U;
      }
    }
    break;
    case 35: ;
    if (tok == 0) {
      {
      _1_file_getfulltree_next = 29U;
      }
    } else {
      {
      _1_file_getfulltree_next = 43U;
      }
    }
    break;
    case 29: 
    __Cont: ;
    if (tok != 2) {
      {
      _1_file_getfulltree_next = 7U;
      }
    } else {
      {
      _1_file_getfulltree_next = 16U;
      }
    }
    break;
    case 43: ;
    switch (tok) {
    case 0: 
    {
    _1_file_getfulltree_next = 29U;
    }
    break;
    case 2: 
    case 1: 
    {
    _1_file_getfulltree_next = 19U;
    }
    break;
    default: 
    {
    _1_file_getfulltree_next = 29U;
    }
    break;
    }
    break;
    case 20: 
    fclose(fp);
    {
    _1_file_getfulltree_next = 21U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF file_getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF push_filterstack LOC=UNKNOWN */
void push_filterstack(struct ignorefile *ig ) 
{ 
  unsigned int _1_push_filterstack_next ;

  {
  {
  _1_push_filterstack_next = 0U;
  }
  while (1) {
    switch (_1_push_filterstack_next) {
    case 1: 
    ig->next = filterstack;
    filterstack = ig;
    {
    _1_push_filterstack_next = 2U;
    }
    break;
    case 3: ;
    return;
    break;
    case 0: ;
    if ((unsigned long )ig == (unsigned long )((void *)0)) {
      {
      _1_push_filterstack_next = 3U;
      }
    } else {
      {
      _1_push_filterstack_next = 1U;
      }
    }
    break;
    case 2: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF push_filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_encode LOC=UNKNOWN */
void html_encode(FILE *fd , char *s ) 
{ 
  unsigned int _1_html_encode_next ;

  {
  {
  _1_html_encode_next = 0U;
  }
  while (1) {
    switch (_1_html_encode_next) {
    case 14: ;
    switch ((int )*s) {
    case 60: 
    {
    _1_html_encode_next = 12U;
    }
    break;
    case 62: 
    {
    _1_html_encode_next = 11U;
    }
    break;
    case 38: 
    {
    _1_html_encode_next = 6U;
    }
    break;
    case 34: 
    {
    _1_html_encode_next = 13U;
    }
    break;
    default: 
    {
    _1_html_encode_next = 8U;
    }
    break;
    }
    break;
    case 12: 
    fputs((char const   *)((char const   */* __restrict  */)"&lt;"), (FILE *)((FILE */* __restrict  */)fd));
    {
    _1_html_encode_next = 9U;
    }
    break;
    case 8: 
    fputc((int )*s, fd);
    {
    _1_html_encode_next = 9U;
    }
    break;
    case 3: ;
    if (*s) {
      {
      _1_html_encode_next = 14U;
      }
    } else {
      {
      _1_html_encode_next = 7U;
      }
    }
    break;
    case 11: 
    fputs((char const   *)((char const   */* __restrict  */)"&gt;"), (FILE *)((FILE */* __restrict  */)fd));
    {
    _1_html_encode_next = 9U;
    }
    break;
    case 9: 
    s ++;
    {
    _1_html_encode_next = 3U;
    }
    break;
    case 13: 
    fputs((char const   *)((char const   */* __restrict  */)"&quot;"), (FILE *)((FILE */* __restrict  */)fd));
    {
    _1_html_encode_next = 9U;
    }
    break;
    case 6: 
    fputs((char const   *)((char const   */* __restrict  */)"&amp;"), (FILE *)((FILE */* __restrict  */)fd));
    {
    _1_html_encode_next = 9U;
    }
    break;
    case 0: ;
    {
    _1_html_encode_next = 3U;
    }
    break;
    case 7: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF psize LOC=UNKNOWN */
int psize(char *buf___1 , off_t size ) 
{ 
  char *unit ;
  char *tmp ;
  int idx ;
  int usize ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned int _1_psize_next ;

  {
  {
  _1_psize_next = 27U;
  }
  while (1) {
    switch (_1_psize_next) {
    case 18: 
    idx = 1;
    {
    _1_psize_next = 10U;
    }
    break;
    case 25: 
    tmp___4 = (char *)" %11lld";
    {
    _1_psize_next = 14U;
    }
    break;
    case 4: 
    usize = tmp___0;
    {
    _1_psize_next = 13U;
    }
    break;
    case 30: 
    tmp___4 = (char *)" %9lld";
    {
    _1_psize_next = 14U;
    }
    break;
    case 14: 
    tmp___5 = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)tmp___4),
                      size);
    {
    _1_psize_next = 6U;
    }
    break;
    case 31: 
    tmp___0 = 1000;
    {
    _1_psize_next = 4U;
    }
    break;
    case 12: 
    tmp = iec_unit;
    {
    _1_psize_next = 29U;
    }
    break;
    case 8: 
    tmp = si_unit;
    {
    _1_psize_next = 29U;
    }
    break;
    case 1: ;
    if (! idx) {
      {
      _1_psize_next = 16U;
      }
    } else {
      {
      _1_psize_next = 5U;
      }
    }
    break;
    case 3: 
    tmp___2 = (char *)" %3.1f%c";
    {
    _1_psize_next = 17U;
    }
    break;
    case 16: 
    tmp___1 = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)" %4d"),
                      (int )size);
    {
    _1_psize_next = 9U;
    }
    break;
    case 21: 
    idx = 0;
    {
    _1_psize_next = 10U;
    }
    break;
    case 26: ;
    return (tmp___3);
    break;
    case 11: 
    idx ++;
    size /= (off_t )usize;
    {
    _1_psize_next = 10U;
    }
    break;
    case 9: ;
    return (tmp___1);
    break;
    case 13: ;
    if (hflag) {
      {
      _1_psize_next = 2U;
      }
    } else {
      {
      _1_psize_next = 0U;
      }
    }
    break;
    case 17: 
    tmp___3 = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)tmp___2),
                      (double )((float )size / (float )usize), (int )*(unit + idx));
    {
    _1_psize_next = 26U;
    }
    break;
    case 6: ;
    return (tmp___5);
    break;
    case 27: ;
    if (siflag) {
      {
      _1_psize_next = 8U;
      }
    } else {
      {
      _1_psize_next = 12U;
      }
    }
    break;
    case 22: ;
    if (sizeof(off_t ) == sizeof(long long )) {
      {
      _1_psize_next = 25U;
      }
    } else {
      {
      _1_psize_next = 30U;
      }
    }
    break;
    case 28: ;
    if (siflag) {
      {
      _1_psize_next = 31U;
      }
    } else {
      {
      _1_psize_next = 7U;
      }
    }
    break;
    case 5: ;
    if (size / (off_t )usize >= 10LL) {
      {
      _1_psize_next = 20U;
      }
    } else {
      {
      _1_psize_next = 3U;
      }
    }
    break;
    case 10: ;
    if (size >= (off_t )(usize * usize)) {
      {
      _1_psize_next = 11U;
      }
    } else {
      {
      _1_psize_next = 1U;
      }
    }
    break;
    case 0: ;
    if (siflag) {
      {
      _1_psize_next = 2U;
      }
    } else {
      {
      _1_psize_next = 22U;
      }
    }
    break;
    case 7: 
    tmp___0 = 1024;
    {
    _1_psize_next = 4U;
    }
    break;
    case 29: 
    unit = tmp;
    {
    _1_psize_next = 28U;
    }
    break;
    case 2: 
    _L: ;
    if (size < (off_t )usize) {
      {
      _1_psize_next = 21U;
      }
    } else {
      {
      _1_psize_next = 18U;
      }
    }
    break;
    case 20: 
    tmp___2 = (char *)" %3.0f%c";
    {
    _1_psize_next = 17U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF psize LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_fillinfo LOC=UNKNOWN */
void json_fillinfo(struct _info *ent ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char nbuf[64] ;
  int i ;
  int tmp___2 ;
  time_t tmp___3 ;
  char *tmp___4 ;
  unsigned int _1_json_fillinfo_next ;

  {
  {
  _1_json_fillinfo_next = 17U;
  }
  while (1) {
    switch (_1_json_fillinfo_next) {
    case 18: 
    tmp___4 = do_date(tmp___3);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"time\":\"%s\""),
            tmp___4);
    {
    _1_json_fillinfo_next = 4U;
    }
    break;
    case 4: ;
    return;
    break;
    case 14: ;
    if (sflag) {
      {
      _1_json_fillinfo_next = 16U;
      }
    } else {
      {
      _1_json_fillinfo_next = 19U;
      }
    }
    break;
    case 12: 
    tmp___2 = isspace((int )nbuf[i]);
    {
    _1_json_fillinfo_next = 21U;
    }
    break;
    case 8: 
    i ++;
    {
    _1_json_fillinfo_next = 12U;
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"size\":\"%s\""),
            nbuf + i);
    {
    _1_json_fillinfo_next = 19U;
    }
    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"dev\":%d"),
            (int )ent->dev);
    {
    _1_json_fillinfo_next = 5U;
    }
    break;
    case 16: ;
    if (hflag) {
      {
      _1_json_fillinfo_next = 11U;
      }
    } else {
      {
      _1_json_fillinfo_next = 7U;
      }
    }
    break;
    case 24: ;
    if (uflag) {
      {
      _1_json_fillinfo_next = 10U;
      }
    } else {
      {
      _1_json_fillinfo_next = 0U;
      }
    }
    break;
    case 21: ;
    if (! tmp___2) {
      {
      _1_json_fillinfo_next = 1U;
      }
    } else {
      {
      _1_json_fillinfo_next = 8U;
      }
    }
    break;
    case 26: 
    tmp___3 = ent->ctime;
    {
    _1_json_fillinfo_next = 18U;
    }
    break;
    case 11: 
    _L: 
    psize(nbuf, ent->size);
    i = 0;
    {
    _1_json_fillinfo_next = 12U;
    }
    break;
    case 9: 
    tmp___1 = gidtoname(ent->gid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"group\":\"%s\""),
            tmp___1);
    {
    _1_json_fillinfo_next = 14U;
    }
    break;
    case 13: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"inode\":%ld"),
            (long )ent->inode);
    {
    _1_json_fillinfo_next = 6U;
    }
    break;
    case 19: ;
    if (Dflag) {
      {
      _1_json_fillinfo_next = 2U;
      }
    } else {
      {
      _1_json_fillinfo_next = 4U;
      }
    }
    break;
    case 17: ;
    if (inodeflag) {
      {
      _1_json_fillinfo_next = 13U;
      }
    } else {
      {
      _1_json_fillinfo_next = 6U;
      }
    }
    break;
    case 6: ;
    if (devflag) {
      {
      _1_json_fillinfo_next = 3U;
      }
    } else {
      {
      _1_json_fillinfo_next = 5U;
      }
    }
    break;
    case 27: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"size\":%lld"),
            ent->size);
    {
    _1_json_fillinfo_next = 19U;
    }
    break;
    case 22: 
    tmp = prot(ent->mode);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"mode\":\"%04o\",\"prot\":\"%s\""),
            ent->mode & 4095U, tmp);
    {
    _1_json_fillinfo_next = 24U;
    }
    break;
    case 5: ;
    if (pflag) {
      {
      _1_json_fillinfo_next = 22U;
      }
    } else {
      {
      _1_json_fillinfo_next = 24U;
      }
    }
    break;
    case 10: 
    tmp___0 = uidtoname(ent->uid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"user\":\"%s\""),
            tmp___0);
    {
    _1_json_fillinfo_next = 0U;
    }
    break;
    case 0: ;
    if (gflag) {
      {
      _1_json_fillinfo_next = 9U;
      }
    } else {
      {
      _1_json_fillinfo_next = 14U;
      }
    }
    break;
    case 7: ;
    if (siflag) {
      {
      _1_json_fillinfo_next = 11U;
      }
    } else {
      {
      _1_json_fillinfo_next = 27U;
      }
    }
    break;
    case 2: ;
    if (cflag) {
      {
      _1_json_fillinfo_next = 26U;
      }
    } else {
      {
      _1_json_fillinfo_next = 20U;
      }
    }
    break;
    case 20: 
    tmp___3 = ent->mtime;
    {
    _1_json_fillinfo_next = 18U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_error LOC=UNKNOWN */
int unix_error(char *error ) 
{ 
  unsigned int _1_unix_error_next ;

  {
  {
  _1_unix_error_next = 1U;
  }
  while (1) {
    switch (_1_unix_error_next) {
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  [%s]"),
            error);
    {
    _1_unix_error_next = 0U;
    }
    break;
    case 0: ;
    return (0);
    break;
    }
  }
}
}
/* END FUNCTION-DEF unix_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gittrim LOC=UNKNOWN */
void gittrim(char *s ) 
{ 
  int i ;
  int e ;
  size_t___0 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int _1_gittrim_next ;

  {
  {
  _1_gittrim_next = 21U;
  }
  while (1) {
    switch (_1_gittrim_next) {
    case 18: 
    i ++;
    {
    _1_gittrim_next = 2U;
    }
    break;
    case 4: 
    e --;
    {
    _1_gittrim_next = 9U;
    }
    break;
    case 14: ;
    if ((int )*(s + i) != 0) {
      {
      _1_gittrim_next = 20U;
      }
    } else {
      {
      _1_gittrim_next = 13U;
      }
    }
    break;
    case 15: ;
    if ((int )*(s + e) == 10) {
      {
      _1_gittrim_next = 4U;
      }
    } else {
      {
      _1_gittrim_next = 9U;
      }
    }
    break;
    case 8: 
    i --;
    {
    _1_gittrim_next = 16U;
    }
    break;
    case 1: ;
    return;
    break;
    case 16: ;
    if (i >= 0) {
      {
      _1_gittrim_next = 6U;
      }
    } else {
      {
      _1_gittrim_next = 5U;
      }
    }
    break;
    case 21: 
    tmp = strlen((char const   *)s);
    e = (int )(tmp - 1UL);
    {
    _1_gittrim_next = 15U;
    }
    break;
    case 11: 
    e --;
    {
    _1_gittrim_next = 8U;
    }
    break;
    case 9: 
    i = e;
    {
    _1_gittrim_next = 16U;
    }
    break;
    case 13: 
    *(s + e) = (char )'\000';
    {
    _1_gittrim_next = 1U;
    }
    break;
    case 19: ;
    if ((int )*(s + (i - 1)) != 92) {
      {
      _1_gittrim_next = 11U;
      }
    } else {
      {
      _1_gittrim_next = 8U;
      }
    }
    break;
    case 6: ;
    if ((int )*(s + i) != 32) {
      {
      _1_gittrim_next = 5U;
      }
    } else {
      {
      _1_gittrim_next = 10U;
      }
    }
    break;
    case 5: 
    *(s + (e + 1)) = (char )'\000';
    e = 0;
    i = e;
    {
    _1_gittrim_next = 14U;
    }
    break;
    case 10: ;
    if (i) {
      {
      _1_gittrim_next = 19U;
      }
    } else {
      {
      _1_gittrim_next = 8U;
      }
    }
    break;
    case 2: 
    tmp___0 = e;
    e ++;
    tmp___1 = i;
    i ++;
    *(s + tmp___0) = *(s + tmp___1);
    {
    _1_gittrim_next = 14U;
    }
    break;
    case 20: ;
    if ((int )*(s + i) == 92) {
      {
      _1_gittrim_next = 18U;
      }
    } else {
      {
      _1_gittrim_next = 2U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gittrim LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF Ftype LOC=UNKNOWN */
char Ftype(mode_t mode ) 
{ 
  int m ;
  unsigned int _1_Ftype_next ;

  {
  {
  _1_Ftype_next = 8U;
  }
  while (1) {
    switch (_1_Ftype_next) {
    case 4: ;
    if (m == 16384) {
      {
      _1_Ftype_next = 5U;
      }
    } else {
      {
      _1_Ftype_next = 3U;
      }
    }
    break;
    case 14: ;
    return ((char )'*');
    break;
    case 12: ;
    if (m == 32768) {
      {
      _1_Ftype_next = 9U;
      }
    } else {
      {
      _1_Ftype_next = 6U;
      }
    }
    break;
    case 8: 
    m = (int )(mode & 61440U);
    {
    _1_Ftype_next = 10U;
    }
    break;
    case 1: ;
    return ((char )'@');
    break;
    case 3: 
    _L: ;
    if (m == 49152) {
      {
      _1_Ftype_next = 2U;
      }
    } else {
      {
      _1_Ftype_next = 13U;
      }
    }
    break;
    case 9: ;
    if (mode & 73U) {
      {
      _1_Ftype_next = 14U;
      }
    } else {
      {
      _1_Ftype_next = 6U;
      }
    }
    break;
    case 13: ;
    if (m == 4096) {
      {
      _1_Ftype_next = 0U;
      }
    } else {
      {
      _1_Ftype_next = 7U;
      }
    }
    break;
    case 6: ;
    return ((char)0);
    break;
    case 5: ;
    return ((char )'/');
    break;
    case 10: ;
    if (! dflag) {
      {
      _1_Ftype_next = 4U;
      }
    } else {
      {
      _1_Ftype_next = 3U;
      }
    }
    break;
    case 0: ;
    return ((char )'|');
    break;
    case 7: ;
    if (m == 40960) {
      {
      _1_Ftype_next = 1U;
      }
    } else {
      {
      _1_Ftype_next = 12U;
      }
    }
    break;
    case 2: ;
    return ((char )'=');
    break;
    }
  }
}
}
/* END FUNCTION-DEF Ftype LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_outtro LOC=UNKNOWN */
void html_outtro(void) 
{ 
  unsigned int _1_html_outtro_next ;

  {
  {
  _1_html_outtro_next = 0U;
  }
  while (1) {
    switch (_1_html_outtro_next) {
    case 1: ;
    return;
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t<hr>\n"));
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t<p class=\"VERSION\">\n"));
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)hversion),
            linedraw->copy, linedraw->copy, linedraw->copy, linedraw->copy);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t</p>\n"));
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</body>\n"));
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</html>\n"));
    {
    _1_html_outtro_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_intro LOC=UNKNOWN */
void html_intro(void) 
{ 
  char const   *tmp ;
  unsigned int _1_html_intro_next ;

  {
  {
  _1_html_intro_next = 1U;
  }
  while (1) {
    switch (_1_html_intro_next) {
    case 4: ;
    return;
    break;
    case 1: ;
    if (charset) {
      {
      _1_html_intro_next = 0U;
      }
    } else {
      {
      _1_html_intro_next = 3U;
      }
    }
    break;
    case 3: 
    tmp = "iso-8859-1";
    {
    _1_html_intro_next = 2U;
    }
    break;
    case 0: 
    tmp = charset;
    {
    _1_html_intro_next = 2U;
    }
    break;
    case 2: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<!DOCTYPE html>\n<html>\n<head>\n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=%s\">\n <meta name=\"Author\" content=\"Made by \'tree\'\">\n <meta name=\"GENERATOR\" content=\"%s\">\n <title>%s</title>\n <style type=\"text/css\">\n  BODY { font-family : monospace, sans-serif;  color: black;}\n  P { font-family : monospace, sans-serif; color: black; margin:0px; padding: 0px;}\n  A:visited { text-decoration : none; margin : 0px; padding : 0px;}\n  A:link    { text-decoration : none; margin : 0px; padding : 0px;}\n  A:hover   { text-decoration: underline; background-color : yellow; margin : 0px; padding : 0px;}\n  A:active  { margin : 0px; padding : 0px;}\n  .VERSION { font-size: small; font-family : arial, sans-serif; }\n  .NORM  { color: black;  }\n  .FIFO  { color: purple; }\n  .CHAR  { color: yellow; }\n  .DIR   { color: blue;   }\n  .BLOCK { color: yellow; }\n  .LINK  { color: aqua;   }\n  .SOCK  { color: fuchsia;}\n  .EXEC  { color: green;  }\n </style>\n</head>\n<body>\n\t<h1>%s</h1><p>\n"),
            tmp, version, title, title);
    {
    _1_html_intro_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF html_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF getcharset LOC=UNKNOWN */
char const   *getcharset(void) 
{ 
  char *tmp ;
  unsigned int _1_getcharset_next ;

  {
  {
  _1_getcharset_next = 0U;
  }
  while (1) {
    switch (_1_getcharset_next) {
    case 1: ;
    return ((char const   *)tmp);
    break;
    case 0: 
    tmp = getenv("TREE_CHARSET");
    {
    _1_getcharset_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF getcharset LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_report LOC=UNKNOWN */
void json_report(struct totals tot ) 
{ 
  char *tmp ;
  unsigned int _1_json_report_next ;

  {
  {
  _1_json_report_next = 10U;
  }
  while (1) {
    switch (_1_json_report_next) {
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",%s{\"type\":\"report\""),
            tmp);
    {
    _1_json_report_next = 7U;
    }
    break;
    case 8: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"directories\":%ld"),
            tot.dirs);
    {
    _1_json_report_next = 2U;
    }
    break;
    case 1: 
    tmp = (char *)"";
    {
    _1_json_report_next = 4U;
    }
    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"}"));
    {
    _1_json_report_next = 9U;
    }
    break;
    case 9: ;
    return;
    break;
    case 6: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"files\":%ld"),
            tot.files);
    {
    _1_json_report_next = 3U;
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"size\":%lld"),
            tot.size);
    {
    _1_json_report_next = 8U;
    }
    break;
    case 10: ;
    if (noindent) {
      {
      _1_json_report_next = 1U;
      }
    } else {
      {
      _1_json_report_next = 0U;
      }
    }
    break;
    case 0: 
    tmp = (char *)"\n  ";
    {
    _1_json_report_next = 4U;
    }
    break;
    case 7: ;
    if (duflag) {
      {
      _1_json_report_next = 5U;
      }
    } else {
      {
      _1_json_report_next = 8U;
      }
    }
    break;
    case 2: ;
    if (! dflag) {
      {
      _1_json_report_next = 6U;
      }
    } else {
      {
      _1_json_report_next = 3U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fprune LOC=UNKNOWN */
struct _info **fprune(struct _info *head , bool matched , bool root ) 
{ 
  struct _info **dir ;
  struct _info *new ;
  struct _info *end ;
  struct _info *ent ;
  struct _info *t ;
  int show ;
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct _info *tmp___2 ;
  void *tmp___3 ;
  unsigned int _1_fprune_next ;

  {
  {
  _1_fprune_next = 2U;
  }
  while (1) {
    switch (_1_fprune_next) {
    case 18: 
    tmp___0 = patignore(ent->name, 0);
    {
    _1_fprune_next = 7U;
    }
    break;
    case 50: ;
    if (end) {
      {
      _1_fprune_next = 13U;
      }
    } else {
      {
      _1_fprune_next = 30U;
      }
    }
    break;
    case 25: 
    matched = (bool )1;
    {
    _1_fprune_next = 17U;
    }
    break;
    case 49: 
    show = 0;
    {
    _1_fprune_next = 5U;
    }
    break;
    case 52: ;
    if (show) {
      {
      _1_fprune_next = 43U;
      }
    } else {
      {
      _1_fprune_next = 45U;
      }
    }
    break;
    case 4: ;
    if (end) {
      {
      _1_fprune_next = 12U;
      }
    } else {
      {
      _1_fprune_next = 46U;
      }
    }
    break;
    case 30: 
    tmp___3 = xmalloc(sizeof(struct _info *) * (unsigned long )(count + 1));
    dir = (struct _info **)tmp___3;
    count = 0;
    ent = new;
    {
    _1_fprune_next = 14U;
    }
    break;
    case 14: ;
    if ((unsigned long )ent != (unsigned long )((void *)0)) {
      {
      _1_fprune_next = 42U;
      }
    } else {
      {
      _1_fprune_next = 11U;
      }
    }
    break;
    case 15: ;
    if (pattern) {
      {
      _1_fprune_next = 33U;
      }
    } else {
      {
      _1_fprune_next = 57U;
      }
    }
    break;
    case 56: 
    show = 0;
    {
    _1_fprune_next = 53U;
    }
    break;
    case 31: ;
    if (! matched) {
      {
      _1_fprune_next = 40U;
      }
    } else {
      {
      _1_fprune_next = 52U;
      }
    }
    break;
    case 12: 
    tmp___2 = t;
    end->next = tmp___2;
    end = tmp___2;
    {
    _1_fprune_next = 54U;
    }
    break;
    case 8: 
    ent->child = fprune(ent->tchild, matched, (bool )0);
    {
    _1_fprune_next = 45U;
    }
    break;
    case 45: 
    t = ent;
    ent = ent->next;
    {
    _1_fprune_next = 1U;
    }
    break;
    case 54: 
    count ++;
    {
    _1_fprune_next = 24U;
    }
    break;
    case 1: ;
    if (show) {
      {
      _1_fprune_next = 4U;
      }
    } else {
      {
      _1_fprune_next = 47U;
      }
    }
    break;
    case 23: 
    tmp___1 = patinclude(ent->name, 1);
    {
    _1_fprune_next = 39U;
    }
    break;
    case 3: ;
    if (! aflag) {
      {
      _1_fprune_next = 21U;
      }
    } else {
      {
      _1_fprune_next = 53U;
      }
    }
    break;
    case 24: ;
    if ((unsigned long )ent != (unsigned long )((void *)0)) {
      {
      _1_fprune_next = 20U;
      }
    } else {
      {
      _1_fprune_next = 50U;
      }
    }
    break;
    case 21: ;
    if (! root) {
      {
      _1_fprune_next = 22U;
      }
    } else {
      {
      _1_fprune_next = 53U;
      }
    }
    break;
    case 36: 
    show = 1;
    {
    _1_fprune_next = 34U;
    }
    break;
    case 57: ;
    if (ipattern) {
      {
      _1_fprune_next = 18U;
      }
    } else {
      {
      _1_fprune_next = 5U;
      }
    }
    break;
    case 26: 
    show = 0;
    {
    _1_fprune_next = 3U;
    }
    break;
    case 11: 
    *(dir + count) = (struct _info *)((void *)0);
    {
    _1_fprune_next = 19U;
    }
    break;
    case 9: 
    ent->isdir = (bool )1;
    {
    _1_fprune_next = 36U;
    }
    break;
    case 13: 
    end->next = (struct _info *)((void *)0);
    {
    _1_fprune_next = 30U;
    }
    break;
    case 51: ;
    if (! matched) {
      {
      _1_fprune_next = 32U;
      }
    } else {
      {
      _1_fprune_next = 17U;
      }
    }
    break;
    case 19: ;
    if (topsort) {
      {
      _1_fprune_next = 38U;
      }
    } else {
      {
      _1_fprune_next = 55U;
      }
    }
    break;
    case 32: ;
    if (! ent->isdir) {
      {
      _1_fprune_next = 15U;
      }
    } else {
      {
      _1_fprune_next = 5U;
      }
    }
    break;
    case 17: ;
    if (pruneflag) {
      {
      _1_fprune_next = 31U;
      }
    } else {
      {
      _1_fprune_next = 52U;
      }
    }
    break;
    case 40: ;
    if (ent->isdir) {
      {
      _1_fprune_next = 35U;
      }
    } else {
      {
      _1_fprune_next = 52U;
      }
    }
    break;
    case 55: ;
    return (dir);
    break;
    case 6: ;
    if (! ent->isdir) {
      {
      _1_fprune_next = 26U;
      }
    } else {
      {
      _1_fprune_next = 3U;
      }
    }
    break;
    case 27: ;
    if (matchdirs) {
      {
      _1_fprune_next = 29U;
      }
    } else {
      {
      _1_fprune_next = 17U;
      }
    }
    break;
    case 38: 
    qsort((void *)dir, (size_t___1 )count, sizeof(struct _info *), (int (*)(void const   * ,
                                                                            void const   * ))topsort);
    {
    _1_fprune_next = 55U;
    }
    break;
    case 34: ;
    if (dflag) {
      {
      _1_fprune_next = 6U;
      }
    } else {
      {
      _1_fprune_next = 3U;
      }
    }
    break;
    case 22: ;
    if ((int )*(ent->name + 0) == 46) {
      {
      _1_fprune_next = 56U;
      }
    } else {
      {
      _1_fprune_next = 53U;
      }
    }
    break;
    case 28: ;
    if (! tmp) {
      {
      _1_fprune_next = 37U;
      }
    } else {
      {
      _1_fprune_next = 57U;
      }
    }
    break;
    case 53: ;
    if (show) {
      {
      _1_fprune_next = 51U;
      }
    } else {
      {
      _1_fprune_next = 17U;
      }
    }
    break;
    case 47: 
    t->next = (struct _info *)((void *)0);
    freefiletree(t);
    {
    _1_fprune_next = 24U;
    }
    break;
    case 5: ;
    if (ent->isdir) {
      {
      _1_fprune_next = 10U;
      }
    } else {
      {
      _1_fprune_next = 17U;
      }
    }
    break;
    case 33: 
    tmp = patinclude(ent->name, 0);
    {
    _1_fprune_next = 28U;
    }
    break;
    case 37: 
    show = 0;
    {
    _1_fprune_next = 57U;
    }
    break;
    case 10: ;
    if (show) {
      {
      _1_fprune_next = 27U;
      }
    } else {
      {
      _1_fprune_next = 17U;
      }
    }
    break;
    case 42: 
    *(dir + count) = ent;
    ent = ent->next;
    count ++;
    {
    _1_fprune_next = 14U;
    }
    break;
    case 0: 
    show = 0;
    {
    _1_fprune_next = 52U;
    }
    break;
    case 46: 
    end = t;
    new = end;
    {
    _1_fprune_next = 54U;
    }
    break;
    case 39: ;
    if (tmp___1) {
      {
      _1_fprune_next = 25U;
      }
    } else {
      {
      _1_fprune_next = 17U;
      }
    }
    break;
    case 7: ;
    if (tmp___0) {
      {
      _1_fprune_next = 49U;
      }
    } else {
      {
      _1_fprune_next = 5U;
      }
    }
    break;
    case 35: ;
    if ((unsigned long )ent->tchild == (unsigned long )((void *)0)) {
      {
      _1_fprune_next = 0U;
      }
    } else {
      {
      _1_fprune_next = 52U;
      }
    }
    break;
    case 29: ;
    if (pattern) {
      {
      _1_fprune_next = 23U;
      }
    } else {
      {
      _1_fprune_next = 17U;
      }
    }
    break;
    case 43: ;
    if ((unsigned long )ent->tchild != (unsigned long )((void *)0)) {
      {
      _1_fprune_next = 8U;
      }
    } else {
      {
      _1_fprune_next = 45U;
      }
    }
    break;
    case 2: 
    new = (struct _info *)((void *)0);
    end = (struct _info *)((void *)0);
    count = 0;
    ent = head;
    {
    _1_fprune_next = 24U;
    }
    break;
    case 20: ;
    if (ent->tchild) {
      {
      _1_fprune_next = 9U;
      }
    } else {
      {
      _1_fprune_next = 36U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF fprune LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF sizecmp LOC=UNKNOWN */
int sizecmp(off_t a , off_t b ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int _1_sizecmp_next ;

  {
  {
  _1_sizecmp_next = 6U;
  }
  while (1) {
    switch (_1_sizecmp_next) {
    case 4: 
    tmp___0 = 0;
    {
    _1_sizecmp_next = 5U;
    }
    break;
    case 1: 
    tmp = 1;
    {
    _1_sizecmp_next = 0U;
    }
    break;
    case 3: ;
    if (a < b) {
      {
      _1_sizecmp_next = 1U;
      }
    } else {
      {
      _1_sizecmp_next = 2U;
      }
    }
    break;
    case 6: ;
    if (a == b) {
      {
      _1_sizecmp_next = 4U;
      }
    } else {
      {
      _1_sizecmp_next = 3U;
      }
    }
    break;
    case 5: ;
    return (tmp___0);
    break;
    case 0: 
    tmp___0 = tmp;
    {
    _1_sizecmp_next = 5U;
    }
    break;
    case 2: 
    tmp = -1;
    {
    _1_sizecmp_next = 0U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF sizecmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF pop_infostack LOC=UNKNOWN */
struct infofile *pop_infostack(void) 
{ 
  struct infofile *inf ;
  struct comment *cn ;
  struct comment *cc ;
  struct pattern *p ;
  struct pattern *c ;
  int i ;
  unsigned int _1_pop_infostack_next ;

  {
  {
  _1_pop_infostack_next = 18U;
  }
  while (1) {
    switch (_1_pop_infostack_next) {
    case 18: 
    inf = infostack;
    infostack = infostack->next;
    {
    _1_pop_infostack_next = 0U;
    }
    break;
    case 4: 
    free((void *)*(cc->desc + i));
    i ++;
    {
    _1_pop_infostack_next = 17U;
    }
    break;
    case 8: 
    p = p->next;
    free((void *)c->pattern);
    c = p;
    {
    _1_pop_infostack_next = 13U;
    }
    break;
    case 1: 
    cc = inf->comments;
    cn = cc;
    {
    _1_pop_infostack_next = 6U;
    }
    break;
    case 11: 
    free((void *)cc->desc);
    free((void *)cc);
    cc = cn;
    {
    _1_pop_infostack_next = 6U;
    }
    break;
    case 9: 
    i = 0;
    {
    _1_pop_infostack_next = 17U;
    }
    break;
    case 13: ;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      _1_pop_infostack_next = 8U;
      }
    } else {
      {
      _1_pop_infostack_next = 9U;
      }
    }
    break;
    case 17: ;
    if ((unsigned long )*(cc->desc + i) != (unsigned long )((void *)0)) {
      {
      _1_pop_infostack_next = 4U;
      }
    } else {
      {
      _1_pop_infostack_next = 11U;
      }
    }
    break;
    case 6: ;
    if ((unsigned long )cn != (unsigned long )((void *)0)) {
      {
      _1_pop_infostack_next = 5U;
      }
    } else {
      {
      _1_pop_infostack_next = 10U;
      }
    }
    break;
    case 5: 
    cn = cn->next;
    c = cc->pattern;
    p = c;
    {
    _1_pop_infostack_next = 13U;
    }
    break;
    case 10: 
    free((void *)inf->path);
    free((void *)inf);
    {
    _1_pop_infostack_next = 2U;
    }
    break;
    case 0: ;
    if ((unsigned long )inf == (unsigned long )((void *)0)) {
      {
      _1_pop_infostack_next = 7U;
      }
    } else {
      {
      _1_pop_infostack_next = 1U;
      }
    }
    break;
    case 7: ;
    return ((struct infofile *)((void *)0));
    break;
    case 2: ;
    return ((struct infofile *)((void *)0));
    break;
    }
  }
}
}
/* END FUNCTION-DEF pop_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF nextpc LOC=UNKNOWN */
char *nextpc(char **p , int *tok ) 
{ 
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int _1_nextpc_next ;

  {
  {
  _1_nextpc_next = 18U;
  }
  while (1) {
    switch (_1_nextpc_next) {
    case 18: 
    s = *p;
    {
    _1_nextpc_next = 4U;
    }
    break;
    case 4: ;
    if (! *(*p)) {
      {
      _1_nextpc_next = 16U;
      }
    } else {
      {
      _1_nextpc_next = 12U;
      }
    }
    break;
    case 15: ;
    return ((char *)((void *)0));
    break;
    case 12: ;
    if (prev) {
      {
      _1_nextpc_next = 20U;
      }
    } else {
      {
      _1_nextpc_next = 17U;
      }
    }
    break;
    case 1: 
    tmp___0 = strchr((char const   *)file_pathsep, (int )*(*p));
    {
    _1_nextpc_next = 7U;
    }
    break;
    case 3: ;
    if (*(*p)) {
      {
      _1_nextpc_next = 11U;
      }
    } else {
      {
      _1_nextpc_next = 0U;
      }
    }
    break;
    case 16: 
    *tok = 3;
    {
    _1_nextpc_next = 15U;
    }
    break;
    case 21: ;
    return ((char *)((void *)0));
    break;
    case 11: 
    *tok = 1;
    prev = *(*p);
    tmp___1 = *p;
    (*p) ++;
    *tmp___1 = (char )'\000';
    {
    _1_nextpc_next = 9U;
    }
    break;
    case 9: ;
    return (s);
    break;
    case 13: ;
    if (*(*p)) {
      {
      _1_nextpc_next = 1U;
      }
    } else {
      {
      _1_nextpc_next = 3U;
      }
    }
    break;
    case 19: 
    (*p) ++;
    *tok = 0;
    {
    _1_nextpc_next = 21U;
    }
    break;
    case 17: 
    tmp = strchr((char const   *)file_pathsep, (int )*(*p));
    {
    _1_nextpc_next = 2U;
    }
    break;
    case 6: 
    (*p) ++;
    {
    _1_nextpc_next = 13U;
    }
    break;
    case 5: ;
    return ((char *)((void *)0));
    break;
    case 0: 
    *tok = 2;
    {
    _1_nextpc_next = 9U;
    }
    break;
    case 7: ;
    if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
      {
      _1_nextpc_next = 3U;
      }
    } else {
      {
      _1_nextpc_next = 6U;
      }
    }
    break;
    case 2: ;
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
      _1_nextpc_next = 19U;
      }
    } else {
      {
      _1_nextpc_next = 13U;
      }
    }
    break;
    case 20: 
    prev = (char)0;
    *tok = 0;
    {
    _1_nextpc_next = 5U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF nextpc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF null_close LOC=UNKNOWN */
void null_close(struct _info *file , int level , int needcomma ) 
{ 
  unsigned int _1_null_close_next ;

  {
  {
  _1_null_close_next = 0U;
  }
  while (1) {
    switch (_1_null_close_next) {
    case 0: ;
    return;
    break;
    }
  }
}
}
/* END FUNCTION-DEF null_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_comment LOC=UNKNOWN */
struct comment *new_comment(struct pattern *phead , char **line , int lines ) 
{ 
  struct comment *com ;
  void *tmp ;
  void *tmp___0 ;
  int i ;
  unsigned int _1_new_comment_next ;

  {
  {
  _1_new_comment_next = 4U;
  }
  while (1) {
    switch (_1_new_comment_next) {
    case 4: 
    tmp = xmalloc(sizeof(struct comment ));
    com = (struct comment *)tmp;
    com->pattern = phead;
    tmp___0 = xmalloc(sizeof(char *) * (unsigned long )(lines + 1));
    com->desc = (char **)tmp___0;
    i = 0;
    {
    _1_new_comment_next = 2U;
    }
    break;
    case 1: ;
    return (com);
    break;
    case 3: 
    *(com->desc + i) = *(line + i);
    i ++;
    {
    _1_new_comment_next = 2U;
    }
    break;
    case 0: 
    *(com->desc + i) = (char *)((void *)0);
    com->next = (struct comment *)((void *)0);
    {
    _1_new_comment_next = 1U;
    }
    break;
    case 2: ;
    if (i < lines) {
      {
      _1_new_comment_next = 3U;
      }
    } else {
      {
      _1_new_comment_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF new_comment LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xrealloc LOC=UNKNOWN */
void *xrealloc(void *ptr , size_t___0 size ) 
{ 
  register void *value ;
  void *tmp ;
  unsigned int _1_xrealloc_next ;

  {
  {
  _1_xrealloc_next = 2U;
  }
  while (1) {
    switch (_1_xrealloc_next) {
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: virtual memory exhausted.\n"));
    exit(1);
    {
    _1_xrealloc_next = 0U;
    }
    break;
    case 3: ;
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
      _1_xrealloc_next = 1U;
      }
    } else {
      {
      _1_xrealloc_next = 0U;
      }
    }
    break;
    case 0: ;
    return (value);
    break;
    case 2: 
    tmp = realloc(ptr, size);
    value = tmp;
    {
    _1_xrealloc_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xrealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ctimesort LOC=UNKNOWN */
int ctimesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int _1_ctimesort_next ;

  {
  {
  _1_ctimesort_next = 0U;
  }
  while (1) {
    switch (_1_ctimesort_next) {
    case 4: 
    tmp___0 = 1;
    {
    _1_ctimesort_next = 9U;
    }
    break;
    case 14: ;
    if (reverse) {
      {
      _1_ctimesort_next = 6U;
      }
    } else {
      {
      _1_ctimesort_next = 15U;
      }
    }
    break;
    case 15: 
    tmp = v;
    {
    _1_ctimesort_next = 8U;
    }
    break;
    case 12: ;
    if ((*a)->ctime < (*b)->ctime) {
      {
      _1_ctimesort_next = 5U;
      }
    } else {
      {
      _1_ctimesort_next = 4U;
      }
    }
    break;
    case 8: ;
    return (tmp);
    break;
    case 1: 
    v = 0;
    {
    _1_ctimesort_next = 3U;
    }
    break;
    case 3: ;
    if (reverse) {
      {
      _1_ctimesort_next = 10U;
      }
    } else {
      {
      _1_ctimesort_next = 11U;
      }
    }
    break;
    case 11: 
    tmp___1 = v;
    {
    _1_ctimesort_next = 13U;
    }
    break;
    case 9: 
    v = tmp___0;
    {
    _1_ctimesort_next = 3U;
    }
    break;
    case 13: ;
    return (tmp___1);
    break;
    case 6: 
    tmp = - v;
    {
    _1_ctimesort_next = 8U;
    }
    break;
    case 5: 
    tmp___0 = -1;
    {
    _1_ctimesort_next = 9U;
    }
    break;
    case 10: 
    tmp___1 = - v;
    {
    _1_ctimesort_next = 13U;
    }
    break;
    case 0: ;
    if ((*a)->ctime == (*b)->ctime) {
      {
      _1_ctimesort_next = 7U;
      }
    } else {
      {
      _1_ctimesort_next = 2U;
      }
    }
    break;
    case 7: 
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
    {
    _1_ctimesort_next = 14U;
    }
    break;
    case 2: ;
    if ((*a)->ctime == (*b)->ctime) {
      {
      _1_ctimesort_next = 1U;
      }
    } else {
      {
      _1_ctimesort_next = 12U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF ctimesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF mtimesort LOC=UNKNOWN */
int mtimesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int _1_mtimesort_next ;

  {
  {
  _1_mtimesort_next = 6U;
  }
  while (1) {
    switch (_1_mtimesort_next) {
    case 4: ;
    if (reverse) {
      {
      _1_mtimesort_next = 2U;
      }
    } else {
      {
      _1_mtimesort_next = 0U;
      }
    }
    break;
    case 14: 
    tmp___0 = -1;
    {
    _1_mtimesort_next = 5U;
    }
    break;
    case 15: 
    tmp___0 = 1;
    {
    _1_mtimesort_next = 5U;
    }
    break;
    case 12: ;
    if ((*a)->mtime == (*b)->mtime) {
      {
      _1_mtimesort_next = 10U;
      }
    } else {
      {
      _1_mtimesort_next = 7U;
      }
    }
    break;
    case 8: 
    tmp = - v;
    {
    _1_mtimesort_next = 3U;
    }
    break;
    case 1: ;
    return (tmp___1);
    break;
    case 3: ;
    return (tmp);
    break;
    case 11: ;
    if (reverse) {
      {
      _1_mtimesort_next = 8U;
      }
    } else {
      {
      _1_mtimesort_next = 13U;
      }
    }
    break;
    case 9: 
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
    {
    _1_mtimesort_next = 11U;
    }
    break;
    case 13: 
    tmp = v;
    {
    _1_mtimesort_next = 3U;
    }
    break;
    case 6: ;
    if ((*a)->mtime == (*b)->mtime) {
      {
      _1_mtimesort_next = 9U;
      }
    } else {
      {
      _1_mtimesort_next = 12U;
      }
    }
    break;
    case 5: 
    v = tmp___0;
    {
    _1_mtimesort_next = 4U;
    }
    break;
    case 10: 
    v = 0;
    {
    _1_mtimesort_next = 4U;
    }
    break;
    case 0: 
    tmp___1 = v;
    {
    _1_mtimesort_next = 1U;
    }
    break;
    case 7: ;
    if ((*a)->mtime < (*b)->mtime) {
      {
      _1_mtimesort_next = 14U;
      }
    } else {
      {
      _1_mtimesort_next = 15U;
      }
    }
    break;
    case 2: 
    tmp___1 = - v;
    {
    _1_mtimesort_next = 1U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF mtimesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF indent LOC=UNKNOWN */
void indent(int maxlevel ) 
{ 
  int i ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned int _1_indent_next ;

  {
  {
  _1_indent_next = 2U;
  }
  while (1) {
    switch (_1_indent_next) {
    case 18: 
    tmp___0 = (char const   *)linedraw->vert;
    {
    _1_indent_next = 28U;
    }
    break;
    case 4: 
    tmp = (char *)"   ";
    {
    _1_indent_next = 7U;
    }
    break;
    case 30: ;
    if (*(dirs + i) == 1) {
      {
      _1_indent_next = 37U;
      }
    } else {
      {
      _1_indent_next = 9U;
      }
    }
    break;
    case 14: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\033(B"));
    {
    _1_indent_next = 32U;
    }
    break;
    case 15: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"x   "));
    {
    _1_indent_next = 19U;
    }
    break;
    case 31: 
    i = 1;
    {
    _1_indent_next = 22U;
    }
    break;
    case 12: 
    i = 1;
    {
    _1_indent_next = 17U;
    }
    break;
    case 1: 
    tmp___1 = (char const   *)linedraw->corner;
    {
    _1_indent_next = 10U;
    }
    break;
    case 23: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t"));
    {
    _1_indent_next = 12U;
    }
    break;
    case 3: ;
    if (*(dirs + (i + 1))) {
      {
      _1_indent_next = 0U;
      }
    } else {
      {
      _1_indent_next = 30U;
      }
    }
    break;
    case 16: 
    printf((char const   *)((char const   */* __restrict  */)"    "));
    {
    _1_indent_next = 19U;
    }
    break;
    case 24: ;
    if (*(dirs + 1)) {
      {
      _1_indent_next = 26U;
      }
    } else {
      {
      _1_indent_next = 31U;
      }
    }
    break;
    case 21: ;
    if (*(dirs + i) == 1) {
      {
      _1_indent_next = 18U;
      }
    } else {
      {
      _1_indent_next = 39U;
      }
    }
    break;
    case 36: ;
    if (*(dirs + i) == 1) {
      {
      _1_indent_next = 27U;
      }
    } else {
      {
      _1_indent_next = 1U;
      }
    }
    break;
    case 26: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\033(0"));
    {
    _1_indent_next = 31U;
    }
    break;
    case 9: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"mqq "));
    {
    _1_indent_next = 19U;
    }
    break;
    case 19: 
    i ++;
    {
    _1_indent_next = 22U;
    }
    break;
    case 32: ;
    return;
    break;
    case 17: ;
    if (i <= maxlevel) {
      {
      _1_indent_next = 38U;
      }
    } else {
      {
      _1_indent_next = 32U;
      }
    }
    break;
    case 40: ;
    if (Hflag) {
      {
      _1_indent_next = 23U;
      }
    } else {
      {
      _1_indent_next = 12U;
      }
    }
    break;
    case 6: ;
    if (*(dirs + (i + 1))) {
      {
      _1_indent_next = 21U;
      }
    } else {
      {
      _1_indent_next = 36U;
      }
    }
    break;
    case 27: 
    tmp___1 = (char const   *)linedraw->vert_left;
    {
    _1_indent_next = 10U;
    }
    break;
    case 38: ;
    if (! *(dirs + i)) {
      {
      _1_indent_next = 32U;
      }
    } else {
      {
      _1_indent_next = 6U;
      }
    }
    break;
    case 34: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            tmp___2);
    i ++;
    {
    _1_indent_next = 17U;
    }
    break;
    case 22: ;
    if (i <= maxlevel) {
      {
      _1_indent_next = 35U;
      }
    } else {
      {
      _1_indent_next = 5U;
      }
    }
    break;
    case 28: 
    tmp___2 = tmp___0;
    {
    _1_indent_next = 34U;
    }
    break;
    case 5: ;
    if (*(dirs + 1)) {
      {
      _1_indent_next = 14U;
      }
    } else {
      {
      _1_indent_next = 32U;
      }
    }
    break;
    case 37: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"tqq "));
    {
    _1_indent_next = 19U;
    }
    break;
    case 10: 
    tmp___2 = tmp___1;
    {
    _1_indent_next = 34U;
    }
    break;
    case 0: ;
    if (*(dirs + i) == 1) {
      {
      _1_indent_next = 15U;
      }
    } else {
      {
      _1_indent_next = 16U;
      }
    }
    break;
    case 39: ;
    if (Hflag) {
      {
      _1_indent_next = 20U;
      }
    } else {
      {
      _1_indent_next = 4U;
      }
    }
    break;
    case 7: 
    tmp___0 = (char const   *)tmp;
    {
    _1_indent_next = 28U;
    }
    break;
    case 35: ;
    if (! *(dirs + i)) {
      {
      _1_indent_next = 5U;
      }
    } else {
      {
      _1_indent_next = 3U;
      }
    }
    break;
    case 2: ;
    if (ansilines) {
      {
      _1_indent_next = 24U;
      }
    } else {
      {
      _1_indent_next = 40U;
      }
    }
    break;
    case 20: 
    tmp = (char *)"&nbsp;&nbsp;&nbsp;";
    {
    _1_indent_next = 7U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF indent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF search LOC=UNKNOWN */
struct _info *search(struct _info **dir , char *name ) 
{ 
  struct _info *ptr ;
  struct _info *prev___0 ;
  struct _info *n ;
  int cmp ;
  struct _info *tmp ;
  unsigned int _1_search_next ;

  {
  {
  _1_search_next = 1U;
  }
  while (1) {
    switch (_1_search_next) {
    case 4: ;
    if ((unsigned long )prev___0 == (unsigned long )ptr) {
      {
      _1_search_next = 16U;
      }
    } else {
      {
      _1_search_next = 12U;
      }
    }
    break;
    case 14: ;
    return (tmp);
    break;
    case 12: 
    prev___0->next = n;
    {
    _1_search_next = 9U;
    }
    break;
    case 8: ;
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
      {
      _1_search_next = 2U;
      }
    } else {
      {
      _1_search_next = 0U;
      }
    }
    break;
    case 1: ;
    if ((unsigned long )*dir == (unsigned long )((void *)0)) {
      {
      _1_search_next = 3U;
      }
    } else {
      {
      _1_search_next = 6U;
      }
    }
    break;
    case 3: 
    tmp = newent(name);
    *dir = tmp;
    {
    _1_search_next = 14U;
    }
    break;
    case 16: 
    *dir = n;
    {
    _1_search_next = 9U;
    }
    break;
    case 11: 
    prev___0 = ptr;
    ptr = ptr->next;
    {
    _1_search_next = 8U;
    }
    break;
    case 9: ;
    return (n);
    break;
    case 13: ;
    return (ptr);
    break;
    case 6: 
    ptr = *dir;
    prev___0 = ptr;
    {
    _1_search_next = 8U;
    }
    break;
    case 5: ;
    if (cmp > 0) {
      {
      _1_search_next = 0U;
      }
    } else {
      {
      _1_search_next = 11U;
      }
    }
    break;
    case 10: ;
    if (cmp == 0) {
      {
      _1_search_next = 13U;
      }
    } else {
      {
      _1_search_next = 5U;
      }
    }
    break;
    case 0: 
    n = newent(name);
    n->next = ptr;
    {
    _1_search_next = 4U;
    }
    break;
    case 2: 
    cmp = strcmp((char const   *)ptr->name, (char const   *)name);
    {
    _1_search_next = 10U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF search LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF filtercheck LOC=UNKNOWN */
int filtercheck(char *path___0 , char *name , int isdir ) 
{ 
  int filter ;
  struct ignorefile *ig ;
  struct pattern *p ;
  int fpos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int fpos___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int _1_filtercheck_next ;

  {
  {
  _1_filtercheck_next = 10U;
  }
  while (1) {
    switch (_1_filtercheck_next) {
    case 25: 
    ig = ig->next;
    {
    _1_filtercheck_next = 20U;
    }
    break;
    case 30: ;
    if (! ig) {
      {
      _1_filtercheck_next = 1U;
      }
    } else {
      {
      _1_filtercheck_next = 11U;
      }
    }
    break;
    case 14: 
    filter = 1;
    {
    _1_filtercheck_next = 17U;
    }
    break;
    case 31: 
    tmp___2 = sprintf((char *)((char */* __restrict  */)(fpattern)), (char const   *)((char const   */* __restrict  */)"%s/"),
                      ig->path);
    fpos___0 = tmp___2;
    p = ig->reverse;
    {
    _1_filtercheck_next = 33U;
    }
    break;
    case 1: ;
    if (! filter) {
      {
      _1_filtercheck_next = 2U;
      }
    } else {
      {
      _1_filtercheck_next = 28U;
      }
    }
    break;
    case 23: ;
    if (tmp___4 == 1) {
      {
      _1_filtercheck_next = 7U;
      }
    } else {
      {
      _1_filtercheck_next = 27U;
      }
    }
    break;
    case 3: ;
    if (p->relative) {
      {
      _1_filtercheck_next = 19U;
      }
    } else {
      {
      _1_filtercheck_next = 22U;
      }
    }
    break;
    case 16: 
    tmp___0 = patmatch(name, p->pattern, isdir);
    {
    _1_filtercheck_next = 29U;
    }
    break;
    case 24: ;
    return (1);
    break;
    case 21: ;
    return (0);
    break;
    case 26: 
    p = p->next;
    {
    _1_filtercheck_next = 37U;
    }
    break;
    case 11: 
    tmp = sprintf((char *)((char */* __restrict  */)(fpattern)), (char const   *)((char const   */* __restrict  */)"%s/"),
                  ig->path);
    fpos = tmp;
    p = ig->remove;
    {
    _1_filtercheck_next = 37U;
    }
    break;
    case 13: ;
    if (p->relative) {
      {
      _1_filtercheck_next = 16U;
      }
    } else {
      {
      _1_filtercheck_next = 35U;
      }
    }
    break;
    case 19: 
    tmp___3 = patmatch(name, p->pattern, isdir);
    {
    _1_filtercheck_next = 38U;
    }
    break;
    case 32: 
    filter = 1;
    {
    _1_filtercheck_next = 17U;
    }
    break;
    case 17: 
    ig = ig->next;
    {
    _1_filtercheck_next = 40U;
    }
    break;
    case 40: ;
    if (! filter) {
      {
      _1_filtercheck_next = 30U;
      }
    } else {
      {
      _1_filtercheck_next = 1U;
      }
    }
    break;
    case 6: ;
    if (tmp___1 == 1) {
      {
      _1_filtercheck_next = 32U;
      }
    } else {
      {
      _1_filtercheck_next = 26U;
      }
    }
    break;
    case 27: 
    p = p->next;
    {
    _1_filtercheck_next = 33U;
    }
    break;
    case 38: ;
    if (tmp___3 == 1) {
      {
      _1_filtercheck_next = 21U;
      }
    } else {
      {
      _1_filtercheck_next = 27U;
      }
    }
    break;
    case 22: 
    sprintf((char *)((char */* __restrict  */)(fpattern + fpos___0)), (char const   *)((char const   */* __restrict  */)"%s"),
            p->pattern);
    tmp___4 = patmatch(path___0, fpattern, isdir);
    {
    _1_filtercheck_next = 23U;
    }
    break;
    case 28: 
    ig = filterstack;
    {
    _1_filtercheck_next = 20U;
    }
    break;
    case 33: ;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      _1_filtercheck_next = 3U;
      }
    } else {
      {
      _1_filtercheck_next = 25U;
      }
    }
    break;
    case 37: ;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      _1_filtercheck_next = 13U;
      }
    } else {
      {
      _1_filtercheck_next = 17U;
      }
    }
    break;
    case 10: 
    filter = 0;
    ig = filterstack;
    {
    _1_filtercheck_next = 40U;
    }
    break;
    case 7: ;
    return (0);
    break;
    case 35: 
    sprintf((char *)((char */* __restrict  */)(fpattern + fpos)), (char const   *)((char const   */* __restrict  */)"%s"),
            p->pattern);
    tmp___1 = patmatch(path___0, fpattern, isdir);
    {
    _1_filtercheck_next = 6U;
    }
    break;
    case 29: ;
    if (tmp___0 == 1) {
      {
      _1_filtercheck_next = 14U;
      }
    } else {
      {
      _1_filtercheck_next = 26U;
      }
    }
    break;
    case 2: ;
    return (0);
    break;
    case 20: ;
    if (ig) {
      {
      _1_filtercheck_next = 31U;
      }
    } else {
      {
      _1_filtercheck_next = 24U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF filtercheck LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_ignorefile LOC=UNKNOWN */
struct ignorefile *new_ignorefile(char *path___0 ) 
{ 
  char buf___1[4096] ;
  struct ignorefile *ig ;
  struct pattern *remove___0 ;
  struct pattern *remend ;
  struct pattern *p ;
  struct pattern *reverse___0 ;
  struct pattern *revend ;
  int rev ;
  FILE *fp ;
  size_t___0 tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  unsigned int _1_new_ignorefile_next ;

  {
  {
  _1_new_ignorefile_next = 14U;
  }
  while (1) {
    switch (_1_new_ignorefile_next) {
    case 18: ;
    if ((int )buf___1[0] == 35) {
      {
      _1_new_ignorefile_next = 4U;
      }
    } else {
      {
      _1_new_ignorefile_next = 12U;
      }
    }
    break;
    case 4: 
    tmp___1 = fgets((char *)((char */* __restrict  */)(buf___1)), 4096, (FILE *)((FILE */* __restrict  */)fp));
    {
    _1_new_ignorefile_next = 1U;
    }
    break;
    case 14: 
    remove___0 = (struct pattern *)((void *)0);
    reverse___0 = (struct pattern *)((void *)0);
    snprintf((char *)((char */* __restrict  */)(buf___1)), (size_t___0 )4096, (char const   *)((char const   */* __restrict  */)"%s/.gitignore"),
             path___0);
    fp = fopen((char const   *)((char const   */* __restrict  */)(buf___1)), (char const   *)((char const   */* __restrict  */)"r"));
    {
    _1_new_ignorefile_next = 11U;
    }
    break;
    case 12: 
    rev = (int )buf___1[0] == 33;
    gittrim(buf___1);
    tmp = strlen((char const   *)(buf___1));
    {
    _1_new_ignorefile_next = 10U;
    }
    break;
    case 8: ;
    if (rev) {
      {
      _1_new_ignorefile_next = 6U;
      }
    } else {
      {
      _1_new_ignorefile_next = 9U;
      }
    }
    break;
    case 1: ;
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
      {
      _1_new_ignorefile_next = 7U;
      }
    } else {
      {
      _1_new_ignorefile_next = 18U;
      }
    }
    break;
    case 3: 
    remend->next = p;
    remend = p;
    {
    _1_new_ignorefile_next = 4U;
    }
    break;
    case 16: 
    tmp___0 = 1;
    {
    _1_new_ignorefile_next = 17U;
    }
    break;
    case 24: 
    revend->next = p;
    revend = p;
    {
    _1_new_ignorefile_next = 4U;
    }
    break;
    case 11: ;
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
      _1_new_ignorefile_next = 19U;
      }
    } else {
      {
      _1_new_ignorefile_next = 4U;
      }
    }
    break;
    case 9: ;
    if ((unsigned long )remove___0 == (unsigned long )((void *)0)) {
      {
      _1_new_ignorefile_next = 20U;
      }
    } else {
      {
      _1_new_ignorefile_next = 3U;
      }
    }
    break;
    case 13: ;
    if (rev) {
      {
      _1_new_ignorefile_next = 16U;
      }
    } else {
      {
      _1_new_ignorefile_next = 5U;
      }
    }
    break;
    case 19: ;
    return ((struct ignorefile *)((void *)0));
    break;
    case 17: 
    p = new_pattern(buf___1 + tmp___0);
    {
    _1_new_ignorefile_next = 8U;
    }
    break;
    case 6: ;
    if ((unsigned long )reverse___0 == (unsigned long )((void *)0)) {
      {
      _1_new_ignorefile_next = 22U;
      }
    } else {
      {
      _1_new_ignorefile_next = 24U;
      }
    }
    break;
    case 22: 
    revend = p;
    reverse___0 = revend;
    {
    _1_new_ignorefile_next = 4U;
    }
    break;
    case 5: 
    tmp___0 = 0;
    {
    _1_new_ignorefile_next = 17U;
    }
    break;
    case 10: ;
    if (tmp == 0UL) {
      {
      _1_new_ignorefile_next = 4U;
      }
    } else {
      {
      _1_new_ignorefile_next = 13U;
      }
    }
    break;
    case 0: ;
    return (ig);
    break;
    case 7: 
    fclose(fp);
    tmp___2 = xmalloc(sizeof(struct ignorefile ));
    ig = (struct ignorefile *)tmp___2;
    ig->remove = remove___0;
    ig->reverse = reverse___0;
    tmp___3 = strlen((char const   *)path___0);
    tmp___4 = xmalloc(tmp___3 + 1UL);
    ig->path = strcpy((char *)((char */* __restrict  */)tmp___4), (char const   *)((char const   */* __restrict  */)path___0));
    ig->next = (struct ignorefile *)((void *)0);
    {
    _1_new_ignorefile_next = 0U;
    }
    break;
    case 20: 
    remend = p;
    remove___0 = remend;
    {
    _1_new_ignorefile_next = 4U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF new_ignorefile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cond_lower LOC=UNKNOWN */
__inline static char cond_lower(char c ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int _1_cond_lower_next ;

  {
  {
  _1_cond_lower_next = 2U;
  }
  while (1) {
    switch (_1_cond_lower_next) {
    case 1: 
    tmp = tolower((int )c);
    tmp___0 = tmp;
    {
    _1_cond_lower_next = 3U;
    }
    break;
    case 3: ;
    return ((char )tmp___0);
    break;
    case 0: 
    tmp___0 = (int )c;
    {
    _1_cond_lower_next = 3U;
    }
    break;
    case 2: ;
    if (ignorecase) {
      {
      _1_cond_lower_next = 1U;
      }
    } else {
      {
      _1_cond_lower_next = 0U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF cond_lower LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_intro LOC=UNKNOWN */
void xml_intro(void) 
{ 
  unsigned int _1_xml_intro_next ;

  {
  {
  _1_xml_intro_next = 0U;
  }
  while (1) {
    switch (_1_xml_intro_next) {
    case 4: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" encoding=\"%s\""),
            charset);
    {
    _1_xml_intro_next = 1U;
    }
    break;
    case 1: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"?>%s<tree>%s"),
            _nl, _nl);
    {
    _1_xml_intro_next = 3U;
    }
    break;
    case 3: ;
    return;
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<?xml version=\"1.0\""));
    {
    _1_xml_intro_next = 2U;
    }
    break;
    case 2: ;
    if (charset) {
      {
      _1_xml_intro_next = 4U;
      }
    } else {
      {
      _1_xml_intro_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF xml_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gnu_getcwd LOC=UNKNOWN */
char *gnu_getcwd(void) 
{ 
  int size ;
  char *buffer ;
  void *tmp ;
  char *value ;
  char *tmp___0 ;
  void *tmp___1 ;
  unsigned int _1_gnu_getcwd_next ;

  {
  {
  _1_gnu_getcwd_next = 0U;
  }
  while (1) {
    switch (_1_gnu_getcwd_next) {
    case 1: ;
    return (buffer);
    break;
    case 3: ;
    if ((unsigned long )value != (unsigned long )((char *)0)) {
      {
      _1_gnu_getcwd_next = 1U;
      }
    } else {
      {
      _1_gnu_getcwd_next = 5U;
      }
    }
    break;
    case 5: 
    size *= 2;
    free((void *)buffer);
    tmp___1 = xmalloc((size_t___0 )size);
    buffer = (char *)tmp___1;
    {
    _1_gnu_getcwd_next = 2U;
    }
    break;
    case 0: 
    size = 100;
    tmp = xmalloc((size_t___0 )size);
    buffer = (char *)tmp;
    {
    _1_gnu_getcwd_next = 2U;
    }
    break;
    case 2: 
    tmp___0 = getcwd(buffer, (size_t___0 )size);
    value = tmp___0;
    {
    _1_gnu_getcwd_next = 3U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF gnu_getcwd LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF saveino LOC=UNKNOWN */
void saveino(ino_t inode , dev_t device ) 
{ 
  struct inotable *it ;
  struct inotable *ip ;
  struct inotable *pp ;
  int hp ;
  void *tmp ;
  unsigned int _1_saveino_next ;

  {
  {
  _1_saveino_next = 12U;
  }
  while (1) {
    switch (_1_saveino_next) {
    case 4: 
    tmp = xmalloc(sizeof(struct inotable ));
    it = (struct inotable *)tmp;
    it->inode = inode;
    it->device = device;
    it->nxt = ip;
    {
    _1_saveino_next = 15U;
    }
    break;
    case 15: ;
    if ((unsigned long )ip == (unsigned long )itable[hp]) {
      {
      _1_saveino_next = 8U;
      }
    } else {
      {
      _1_saveino_next = 11U;
      }
    }
    break;
    case 12: 
    hp = (int )(inode & 255ULL);
    ip = itable[hp];
    pp = ip;
    {
    _1_saveino_next = 17U;
    }
    break;
    case 8: 
    itable[hp] = it;
    {
    _1_saveino_next = 7U;
    }
    break;
    case 1: ;
    if (ip) {
      {
      _1_saveino_next = 9U;
      }
    } else {
      {
      _1_saveino_next = 4U;
      }
    }
    break;
    case 3: 
    pp = ip;
    ip = ip->nxt;
    {
    _1_saveino_next = 17U;
    }
    break;
    case 16: ;
    if (ip->device >= device) {
      {
      _1_saveino_next = 1U;
      }
    } else {
      {
      _1_saveino_next = 3U;
      }
    }
    break;
    case 11: 
    pp->nxt = it;
    {
    _1_saveino_next = 7U;
    }
    break;
    case 9: ;
    if (ip->inode == inode) {
      {
      _1_saveino_next = 2U;
      }
    } else {
      {
      _1_saveino_next = 4U;
      }
    }
    break;
    case 13: ;
    return;
    break;
    case 17: ;
    if (ip) {
      {
      _1_saveino_next = 0U;
      }
    } else {
      {
      _1_saveino_next = 1U;
      }
    }
    break;
    case 10: ;
    if (ip->inode == inode) {
      {
      _1_saveino_next = 16U;
      }
    } else {
      {
      _1_saveino_next = 3U;
      }
    }
    break;
    case 0: ;
    if (ip->inode > inode) {
      {
      _1_saveino_next = 1U;
      }
    } else {
      {
      _1_saveino_next = 10U;
      }
    }
    break;
    case 7: ;
    return;
    break;
    case 2: ;
    if (ip->device == device) {
      {
      _1_saveino_next = 13U;
      }
    } else {
      {
      _1_saveino_next = 4U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF saveino LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF usage LOC=UNKNOWN */
void usage(int n ) 
{ 
  FILE *tmp ;
  unsigned int _1_usage_next ;

  {
  {
  _1_usage_next = 2U;
  }
  while (1) {
    switch (_1_usage_next) {
    case 4: ;
    return;
    break;
    case 1: 
    tmp = stdout;
    {
    _1_usage_next = 6U;
    }
    break;
    case 3: 
    fprintf((FILE *)((FILE */* __restrict  */)stdout), (char const   *)((char const   */* __restrict  */)"  ------- Listing options -------\n  -a            All files are listed.\n  -d            List directories only.\n  -l            Follow symbolic links like directories.\n  -f            Print the full path prefix for each file.\n  -x            Stay on current filesystem only.\n  -L level      Descend only level directories deep.\n  -R            Rerun tree when max dir level reached.\n  -P pattern    List only those files that match the pattern given.\n  -I pattern    Do not list files that match the given pattern.\n  --gitignore   Filter by using .gitignore files.\n  --ignore-case Ignore case when pattern matching.\n  --matchdirs   Include directory names in -P pattern matching.\n  --metafirst   Print meta-data at the beginning of each line.\n  --prune       Prune empty directories from the output.\n  --info        Print information about files found in .info files.\n  --noreport    Turn off file/directory count at end of tree listing.\n  --charset X   Use charset X for terminal/HTML and indentation line output.\n  --filelimit # Do not descend dirs with more than # files in them.\n  -o filename   Output to file instead of stdout.\n  ------- File options -------\n  -q            Print non-printable characters as \'?\'.\n  -N            Print non-printable characters as is.\n  -Q            Quote filenames with double quotes.\n  -p            Print the protections for each file.\n  -u            Displays file owner or UID number.\n  -g            Displays file group owner or GID number.\n  -s            Print the size in bytes of each file.\n  -h            Print the size in a more human readable way.\n  --si          Like -h, but use in SI units (powers of 1000).\n  --du          Compute size of directories by their contents.\n  -D            Print the date of last modification or (-c) status change.\n  --timefmt <f> Print and format time according to the format <f>.\n  -F            Appends \'/\', \'=\', \'*\', \'@\', \'|\' or \'>\' as per ls -F.\n  --inodes      Print inode number of each file.\n  --device      Print device ID number to which each file belongs.\n  ------- Sorting options -------\n  -v            Sort files alphanumerically by version.\n  -t            Sort files by last modification time.\n  -c            Sort files by last status change time.\n  -U            Leave files unsorted.\n  -r            Reverse the order of the sort.\n  --dirsfirst   List directories before files (-U disables).\n  --filesfirst  List files before directories (-U disables).\n  --sort X      Select sort: name,version,size,mtime,ctime.\n  ------- Graphics options -------\n  -i            Don\'t print indentation lines.\n  -A            Print ANSI lines graphic indentation lines.\n  -S            Print with CP437 (console) graphics indentation lines.\n  -n            Turn colorization off always (-C overrides).\n  -C            Turn colorization on always.\n  ------- XML/HTML/JSON options -------\n  -X            Prints out an XML representation of the tree.\n  -J            Prints out an JSON representation of the tree.\n  -H baseHREF   Prints out HTML format with baseHREF as top directory.\n  -T string     Replace the default HTML title and H1 header with string.\n  --nolinks     Turn off hyperlinks in HTML output.\n  ------- Input options -------\n  --fromfile    Reads paths from files (.=stdin)\n  ------- Miscellaneous options -------\n  --version     Print version and exit.\n  --help        Print usage and this help message and exit.\n  --            Options processing terminator.\n"));
    exit(0);
    {
    _1_usage_next = 7U;
    }
    break;
    case 6: 
    fprintf((FILE *)((FILE */* __restrict  */)tmp), (char const   *)((char const   */* __restrict  */)"usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-L level [-R]] [-H  baseHREF]\n\t[-T title] [-o filename] [-P pattern] [-I pattern] [--gitignore]\n\t[--matchdirs] [--metafirst] [--ignore-case] [--nolinks] [--inodes]\n\t[--device] [--sort[=]<name>] [--dirsfirst] [--filesfirst]\n\t[--filelimit #] [--si] [--du] [--prune] [--charset X]\n\t[--timefmt[=]format] [--fromfile] [--noreport] [--version] [--help]\n\t[--] [directory ...]\n"));
    {
    _1_usage_next = 5U;
    }
    break;
    case 5: ;
    if (n < 2) {
      {
      _1_usage_next = 4U;
      }
    } else {
      {
      _1_usage_next = 3U;
      }
    }
    break;
    case 0: 
    tmp = stderr;
    {
    _1_usage_next = 6U;
    }
    break;
    case 7: ;
    return;
    break;
    case 2: ;
    if (n < 2) {
      {
      _1_usage_next = 0U;
      }
    } else {
      {
      _1_usage_next = 1U;
      }
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_printfile LOC=UNKNOWN */
int json_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int i ;
  unsigned int _1_json_printfile_next ;

  {
  {
  _1_json_printfile_next = 15U;
  }
  while (1) {
    switch (_1_json_printfile_next) {
    case 18: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"error\": \"%s\""),
            file->err);
    {
    _1_json_printfile_next = 1U;
    }
    break;
    case 4: ;
    if (file) {
      {
      _1_json_printfile_next = 20U;
      }
    } else {
      {
      _1_json_printfile_next = 22U;
      }
    }
    break;
    case 14: ;
    if (file) {
      {
      _1_json_printfile_next = 3U;
      }
    } else {
      {
      _1_json_printfile_next = 4U;
      }
    }
    break;
    case 15: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"name\":\""));
    json_encode(outfile, filename);
    fputc('\"', outfile);
    {
    _1_json_printfile_next = 11U;
    }
    break;
    case 8: ;
    if (file->err) {
      {
      _1_json_printfile_next = 18U;
      }
    } else {
      {
      _1_json_printfile_next = 1U;
      }
    }
    break;
    case 1: ;
    if (! descend) {
      {
      _1_json_printfile_next = 10U;
      }
    } else {
      {
      _1_json_printfile_next = 5U;
      }
    }
    break;
    case 23: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\\n"));
    {
    _1_json_printfile_next = 2U;
    }
    break;
    case 3: ;
    if (file->lnk) {
      {
      _1_json_printfile_next = 21U;
      }
    } else {
      {
      _1_json_printfile_next = 4U;
      }
    }
    break;
    case 16: ;
    if (*(file->comment + i)) {
      {
      _1_json_printfile_next = 6U;
      }
    } else {
      {
      _1_json_printfile_next = 13U;
      }
    }
    break;
    case 21: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"target\":\""));
    json_encode(outfile, file->lnk);
    fputc('\"', outfile);
    {
    _1_json_printfile_next = 4U;
    }
    break;
    case 11: ;
    if (file) {
      {
      _1_json_printfile_next = 17U;
      }
    } else {
      {
      _1_json_printfile_next = 14U;
      }
    }
    break;
    case 9: ;
    return (descend);
    break;
    case 13: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\""));
    {
    _1_json_printfile_next = 14U;
    }
    break;
    case 19: ;
    if (*(file->comment + (i + 1))) {
      {
      _1_json_printfile_next = 23U;
      }
    } else {
      {
      _1_json_printfile_next = 2U;
      }
    }
    break;
    case 17: ;
    if (file->comment) {
      {
      _1_json_printfile_next = 0U;
      }
    } else {
      {
      _1_json_printfile_next = 14U;
      }
    }
    break;
    case 6: 
    json_encode(outfile, *(file->comment + i));
    {
    _1_json_printfile_next = 19U;
    }
    break;
    case 22: ;
    if (file) {
      {
      _1_json_printfile_next = 8U;
      }
    } else {
      {
      _1_json_printfile_next = 1U;
      }
    }
    break;
    case 5: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"contents\":["));
    {
    _1_json_printfile_next = 9U;
    }
    break;
    case 10: 
    fputc('}', outfile);
    {
    _1_json_printfile_next = 9U;
    }
    break;
    case 0: 
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"info\":\""));
    i = 0;
    {
    _1_json_printfile_next = 16U;
    }
    break;
    case 2: 
    i ++;
    {
    _1_json_printfile_next = 16U;
    }
    break;
    case 20: 
    json_fillinfo(file);
    {
    _1_json_printfile_next = 22U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF json_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF split LOC=UNKNOWN */
char **split(char *str , char *delim , int *nwrds ) 
{ 
  int n ;
  char **w ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned int _1_split_next ;

  {
  {
  _1_split_next = 3U;
  }
  while (1) {
    switch (_1_split_next) {
    case 8: 
    (*nwrds) ++;
    *(w + *nwrds) = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)delim);
    {
    _1_split_next = 0U;
    }
    break;
    case 1: ;
    if (*nwrds == n - 2) {
      {
      _1_split_next = 7U;
      }
    } else {
      {
      _1_split_next = 8U;
      }
    }
    break;
    case 3: 
    n = 128;
    tmp = xmalloc(sizeof(char *) * (unsigned long )n);
    w = (char **)tmp;
    tmp___0 = 0;
    *nwrds = tmp___0;
    *(w + tmp___0) = strtok((char */* __restrict  */)str, (char const   */* __restrict  */)delim);
    {
    _1_split_next = 0U;
    }
    break;
    case 6: ;
    return (w);
    break;
    case 5: 
    *(w + *nwrds) = (char *)((void *)0);
    {
    _1_split_next = 6U;
    }
    break;
    case 0: ;
    if (*(w + *nwrds)) {
      {
      _1_split_next = 1U;
      }
    } else {
      {
      _1_split_next = 5U;
      }
    }
    break;
    case 7: 
    n += 256;
    tmp___1 = xrealloc((void *)w, sizeof(char *) * (unsigned long )n);
    w = (char **)tmp___1;
    {
    _1_split_next = 8U;
    }
    break;
    }
  }
}
}
/* END FUNCTION-DEF split LOC=UNKNOWN */
