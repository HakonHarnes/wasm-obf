
/* Generated by Tigress v3.2 (https://tigress.wtf), 08:27:35-2023/04/23 */


/*
BEGIN-UNIVERSE
{
  "Not added to universe": [
    "__sync_and_and_fetch", "__sync_fetch_and_or", "__atomic_or_fetch",
    "__atomic_nand_fetch_8", "__atomic_fetch_and", "__atomic_xor_fetch_16",
    "__atomic_fetch_nand_16", "__atomic_sub_fetch_1", "__atomic_fetch_or",
    "__sync_synchronize", "__sync_or_and_fetch", "__atomic_nand_fetch_4",
    "__atomic_sub_fetch_4", "__atomic_compare_exchange_n",
    "__sync_add_and_fetch", "__atomic_signal_fence", "__atomic_fetch_nand_1",
    "__atomic_and_fetch_16", "__sync_fetch_and_nand", "__atomic_xor_fetch_8",
    "__atomic_xor_fetch_2", "__atomic_thread_fence", "__atomic_store_16",
    "__atomic_fetch_and_8", "__atomic_and_fetch_2", "__atomic_test_and_set",
    "__atomic_fetch_add_8", "__atomic_fetch_nand", "__atomic_exchange_16",
    "__atomic_clear", "__atomic_store", "__atomic_add_fetch_2",
    "__atomic_fetch_xor_1", "__atomic_and_fetch",
    "__atomic_compare_exchange_4", "__sync_sub_and_fetch",
    "__sync_nand_and_fetch", "__atomic_load_16", "__atomic_always_lock_free",
    "__atomic_nand_fetch_16", "__sync_xor_and_fetch", "__atomic_fetch_xor_8",
    "__atomic_exchange_8", "__atomic_exchange_1", "__sync_fetch_and_and",
    "__atomic_feraiseexcept", "__atomic_and_fetch_4", "__atomic_or_fetch_8",
    "__atomic_or_fetch_4", "__atomic_or_fetch_1", "__atomic_fetch_and_2",
    "__sync_lock_release", "__atomic_fetch_nand_8", "__atomic_fetch_add",
    "__atomic_nand_fetch_1", "__atomic_fetch_nand_2", "__atomic_load_n",
    "__atomic_compare_exchange_16", "__atomic_exchange_n",
    "__atomic_fetch_or_1", "__atomic_fetch_or_8", "__atomic_fetch_add_1",
    "__atomic_fetch_sub_1", "__atomic_fetch_or_4", "__atomic_load_2",
    "__atomic_store_2", "__atomic_exchange_4", "__sync_fetch_and_xor",
    "__atomic_fetch_sub_4", "__atomic_fetch_and_4",
    "__atomic_compare_exchange", "__atomic_load_1",
    "__atomic_compare_exchange_1", "__atomic_fetch_xor_2", "__atomic_load",
    "__atomic_or_fetch_16", "__atomic_add_fetch_16",
    "__sync_val_compare_and_swap", "__atomic_store_4",
    "__atomic_fetch_and_1", "__atomic_fetch_nand_4", "__atomic_fetch_add_16",
    "__atomic_compare_exchange_2", "__atomic_exchange",
    "__atomic_sub_fetch_8", "__atomic_fetch_sub_16", "__atomic_exchange_2",
    "__atomic_sub_fetch_2", "__atomic_fetch_xor_16", "__atomic_fetch_or_16",
    "__atomic_load_4", "__atomic_store_n", "__atomic_fetch_add_4",
    "__atomic_nand_fetch_2", "__sync_lock_test_and_set",
    "__atomic_sub_fetch", "__atomic_fetch_and_16",
    "__atomic_compare_exchange_8", "__atomic_nand_fetch", "__atomic_load_8",
    "__atomic_xor_fetch_4", "__atomic_fetch_sub_2", "__atomic_add_fetch",
    "__atomic_store_8", "__atomic_xor_fetch", "__sync_fetch_and_add",
    "__atomic_or_fetch_2", "__atomic_add_fetch_1", "__atomic_fetch_xor",
    "__atomic_add_fetch_8", "__atomic_fetch_xor_4", "__atomic_fetch_sub_8",
    "__sync_bool_compare_and_swap", "__atomic_and_fetch_1",
    "__atomic_store_1", "__atomic_xor_fetch_1", "__atomic_fetch_or_2",
    "__atomic_sub_fetch_16", "__sync_fetch_and_sub", "__atomic_fetch_add_2",
    "__atomic_is_lock_free", "__atomic_and_fetch_8", "__atomic_fetch_sub",
    "__atomic_add_fetch_4", "xmalloc", "xrealloc", "parse_dir_colors",
    "color", "endcolor", "getcharset", "initlinedraw", "split", "cmd",
    "outfile", "charset", "patignore", "patinclude", "file_getfulltree",
    "pattern", "ipattern", "topsort", "file_comment", "file_pathsep",
    "nextpc", "patmatch", "gittrim", "new_pattern", "filtercheck",
    "new_ignorefile", "push_filterstack", "pop_filterstack", "uidtoname",
    "gidtoname", "findino", "saveino", "indent", "psize", "fillinfo",
    "html_intro", "html_outtro", "html_printinfo", "html_printfile",
    "html_error", "html_newline", "html_close", "html_report", "html_encode",
    "version", "hversion", "host", "sp", "title", "new_infofile",
    "push_infostack", "pop_infostack", "infocheck", "printcomment", "prot",
    "do_date", "json_indent", "json_fillinfo", "json_intro", "json_outtro",
    "json_printinfo", "json_printfile", "json_error", "json_newline",
    "json_close", "json_report", "ifmt", "ftype", "_nl", "setoutput",
    "push_files", "read_dir", "free_dir", "stat2info", "null_intro",
    "null_outtro", "null_close", "emit_tree", "listdir", "getfulltree",
    "strverscmp", "usage", "unix_getfulltree", "filesfirst", "dirsfirst",
    "alnumsort", "versort", "mtimesort", "ctimesort", "sizecmp", "fsizesort",
    "gnu_getcwd", "printit", "Ftype", "unix_printinfo", "unix_printfile",
    "unix_error", "unix_newline", "unix_report", "xml_intro", "xml_outtro",
    "xml_printinfo", "xml_printfile", "xml_error", "xml_newline",
    "xml_close", "xml_report", "getinfo"
  ],
  "Transformations": [
    { "TransformationNumber": 1, "TransformationKind": "AntiTaintAnalysis",
    "TransformationUpdates": {} }, { "TransformationNumber": 0,
    "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "Modified Function Implementations": [ "main" ],
      "New Global Variables": {
        "_global_envp": "FUN: '_global_envp_i$nit'",
        "_global_argv": "FUN: '_global_argv_i$nit'",
        "_global_argc": "FUN: '_global_argc_i$nit'"
      }
    } }, { "TransformationNumber": -1, "TransformationKind": "Initialize",
    "TransformationUpdates": {
      "New Functions": [
        "xml_report", "xml_close", "xml_newline", "xml_error",
        "xml_printfile", "xml_printinfo", "xml_outtro", "xml_intro",
        "xml_fillinfo", "xml_indent", "unix_report", "unix_newline",
        "unix_error", "unix_printfile", "unix_printinfo", "fillinfo",
        "stat2info", "Ftype", "psize", "printit", "do_date", "prot",
        "indent", "patmatch", "cond_lower", "gnu_getcwd", "free_dir",
        "xrealloc", "xmalloc", "fsizesort", "sizecmp", "ctimesort",
        "mtimesort", "versort", "alnumsort", "dirsfirst", "filesfirst",
        "unix_getfulltree", "push_files", "read_dir", "getinfo",
        "patinclude", "patignore", "usage", "setoutput", "main",
        "strverscmp", "listdir", "emit_tree", "null_close", "null_outtro",
        "null_intro", "json_report", "json_close", "json_newline",
        "json_error", "json_printfile", "json_printinfo", "json_outtro",
        "json_intro", "json_fillinfo", "json_indent", "json_encode",
        "printcomment", "infocheck", "pop_infostack", "push_infostack",
        "new_infofile", "new_comment", "html_report", "html_close",
        "html_newline", "html_error", "html_printfile", "html_printinfo",
        "html_print", "html_outtro", "html_intro", "url_encode",
        "html_encode", "class", "findino", "saveino", "gidtoname",
        "uidtoname", "filtercheck", "pop_filterstack", "push_filterstack",
        "new_ignorefile", "new_pattern", "gittrim", "file_getfulltree",
        "fprune", "freefiletree", "search", "newent", "nextpc",
        "initlinedraw", "getcharset", "color", "endcolor", "print_color",
        "cmd", "split", "parse_dir_colors"
      ],
      "New Global Variables": {
        "info___0": "FUN: 'info___0_i$nit'",
        "info": "None",
        "si_unit": "FUN: 'si_unit_i$nit'",
        "iec_unit": "FUN: 'iec_unit_i$nit'",
        "buf___0": "None",
        "perms": "FUN: 'perms_i$nit'",
        "buf": "None",
        "pathsize": "None",
        "path": "FUN: 'path_i$nit'",
        "lbufsize": "FUN: 'lbufsize_i$nit'",
        "lbuf": "FUN: 'lbuf_i$nit'",
        "sorts": "FUN: 'sorts_i$nit'",
        "ftype": "FUN: 'ftype_i$nit'",
        "fmt": "FUN: 'fmt_i$nit'",
        "ifmt": "FUN: 'ifmt_i$nit'",
        "mb_cur_max": "None",
        "maxdirs": "None",
        "outfile": "FUN: 'outfile_i$nit'",
        "curdir": "None",
        "sLevel": "None",
        "topsort": "FUN: 'topsort_i$nit'",
        "basesort": "FUN: 'basesort_i$nit'",
        "getfulltree": "FUN: 'getfulltree_i$nit'",
        "charset": "FUN: 'charset_i$nit'",
        "timefmt": "FUN: 'timefmt_i$nit'",
        "file_pathsep": "FUN: 'file_pathsep_i$nit'",
        "file_comment": "FUN: 'file_comment_i$nit'",
        "_nl": "FUN: '_nl_i$nit'",
        "sp": "FUN: 'sp_i$nit'",
        "title": "FUN: 'title_i$nit'",
        "host": "FUN: 'host_i$nit'",
        "ipatterns": "FUN: 'ipatterns_i$nit'",
        "patterns": "FUN: 'patterns_i$nit'",
        "maxipattern": "FUN: 'maxipattern_i$nit'",
        "ipattern": "FUN: 'ipattern_i$nit'",
        "maxpattern": "FUN: 'maxpattern_i$nit'",
        "pattern": "FUN: 'pattern_i$nit'",
        "reverse": "None",
        "showinfo": "None",
        "gitignore": "None",
        "fromfile": "None",
        "ignorecase": "None",
        "Xflag": "None",
        "Qflag": "None",
        "Nflag": "None",
        "qflag": "None",
        "Fflag": "None",
        "hversion": "FUN: 'hversion_i$nit'",
        "version": "FUN: 'version_i$nit'",
        "result_type": "FUN: 'result_type_i$nit'",
        "next_state": "FUN: 'next_state_i$nit'",
        "lc": "None",
        "errbuf": "None",
        "errors": "None",
        "dirs": "None",
        "Level": "None",
        "flimit": "None",
        "xdev": "None",
        "noreport": "None",
        "Jflag": "None",
        "Rflag": "None",
        "fflag": "None",
        "lflag": "None",
        "cflag": "None",
        "devflag": "None",
        "inodeflag": "None",
        "Dflag": "None",
        "gflag": "None",
        "uflag": "None",
        "sflag": "None",
        "pflag": "None",
        "infostack": "FUN: 'infostack_i$nit'",
        "htmldirlen": "FUN: 'htmldirlen_i$nit'",
        "metafirst": "None",
        "nolinks": "None",
        "noindent": "None",
        "siflag": "None",
        "hflag": "None",
        "duflag": "None",
        "itable": "None",
        "utable": "None",
        "gtable": "None",
        "fpattern": "None",
        "filterstack": "FUN: 'filterstack_i$nit'",
        "prev": "FUN: 'prev_i$nit'",
        "matchdirs": "None",
        "pruneflag": "None",
        "aflag": "None",
        "dflag": "None",
        "cstable": "FUN: 'cstable_i$nit'",
        "windows": "FUN: 'windows_i$nit'",
        "koi8ru": "FUN: 'koi8ru_i$nit'",
        "viscii": "FUN: 'viscii_i$nit'",
        "big5": "FUN: 'big5_i$nit'",
        "utf8": "FUN: 'utf8_i$nit'",
        "gb": "FUN: 'gb_i$nit'",
        "ibm_gr": "FUN: 'ibm_gr_i$nit'",
        "ibm_ps2": "FUN: 'ibm_ps2_i$nit'",
        "ibm_pc": "FUN: 'ibm_pc_i$nit'",
        "iso2022jp": "FUN: 'iso2022jp_i$nit'",
        "euc_kr": "FUN: 'euc_kr_i$nit'",
        "euc_jp": "FUN: 'euc_jp_i$nit'",
        "shift_jis": "FUN: 'shift_jis_i$nit'",
        "iso8859_789": "FUN: 'iso8859_789_i$nit'",
        "latin1_3": "FUN: 'latin1_3_i$nit'",
        "cmds": "FUN: 'cmds_i$nit'",
        "nocolor": "None",
        "force_color": "None",
        "Hflag": "None",
        "linedraw": "None",
        "ext": "FUN: 'ext_i$nit'",
        "colortable": "None",
        "vgacolor": "FUN: 'vgacolor_i$nit'",
        "color_code": "FUN: 'color_code_i$nit'",
        "istty": "None",
        "termmatch": "FUN: 'termmatch_i$nit'",
        "term": "None",
        "linktargetcolor": "FUN: 'linktargetcolor_i$nit'",
        "ansilines": "FUN: 'ansilines_i$nit'",
        "colorize": "FUN: 'colorize_i$nit'"
      },
      "New Externs": [
        "__builtin_va_copy", "__builtin_frob_return_address",
        "__builtin_popcountll", "__builtin_atanf", "__builtin_ia32_addps",
        "__builtin_strcspn", "__builtin_asinf", "__builtin_ia32_maxps",
        "__builtin_ia32_unpckhps", "__builtin_acos",
        "__builtin___sprintf_chk", "__builtin_cosh", "__builtin_tanhf",
        "__builtin_mempcpy", "__builtin_sqrtl", "__builtin_parity",
        "__builtin_coshl", "__builtin_cosl", "__builtin_cosf",
        "__builtin_acosl", "__builtin___mempcpy_chk", "__builtin_clz",
        "__builtin_log10", "__builtin___strcat_chk", "__builtin_modff",
        "__builtin_sin", "__builtin_frexp", "__builtin_acosf",
        "__builtin_sinhl", "__builtin___stpcpy_chk", "__builtin_fabs",
        "__builtin_va_start", "__builtin_bswap16", "__builtin_ctz",
        "__builtin_strpbrk", "__builtin_strcpy", "__builtin_sqrt",
        "__builtin_next_arg", "__builtin_log10f", "__builtin_fabsl",
        "__builtin_floorl", "__builtin_floorf", "__builtin_memcpy",
        "__builtin_ia32_subps", "__builtin_parityll", "__builtin_va_end",
        "__builtin_bzero", "__builtin_strncmp", "__builtin___vsprintf_chk",
        "__builtin_sqrtf", "__builtin_nans", "__builtin_exp",
        "__builtin_strcmp", "__builtin_ldexpf", "__builtin_powif",
        "__builtin_log10l", "__builtin___memmove_chk",
        "__builtin_return_address", "__builtin_fabsf",
        "__builtin_object_size", "__builtin_alloca",
        "__builtin_va_arg_pack_len", "__builtin_tanl", "__builtin_modfl",
        "__builtin_stpcpy", "__builtin_sinl", "__builtin_asin",
        "__builtin_sinhf", "__builtin_ctzl", "__builtin_tanhl",
        "__builtin_bswap64", "__builtin_ia32_mulps", "__builtin_tan",
        "__builtin_strncpy", "__builtin_inff", "__builtin___memset_chk",
        "__builtin_huge_val", "__builtin_clzl", "__builtin_frexpf",
        "__builtin_fmodl", "__builtin_atan", "__builtin___fprintf_chk",
        "__builtin_ceilf", "__builtin_return", "__builtin_asinl",
        "__builtin_ffsll", "__builtin_va_arg_pack",
        "__builtin___strncpy_chk", "__builtin_powi", "__builtin_strchr",
        "__builtin___strncat_chk", "__builtin_huge_vall", "__builtin_ffsl",
        "__builtin___vprintf_chk", "__builtin_ia32_unpcklps",
        "__builtin_strncat", "__builtin_ctzll", "__builtin_stdarg_start",
        "__builtin_frexpl", "__builtin_tanf", "__builtin_logl",
        "__builtin_va_arg", "__builtin_expect", "__builtin___printf_chk",
        "__builtin___vfprintf_chk", "__builtin_prefetch", "__builtin_nansl",
        "__builtin_fmod", "__builtin_tanh", "__builtin_unreachable",
        "__builtin_ldexpl", "__builtin_apply", "__builtin_sinf",
        "__builtin_ceil", "__builtin_powil", "__builtin_expl",
        "__builtin_constant_p", "__builtin_log", "__builtin_expf",
        "__builtin_types_compatible_p", "__builtin_atan2l",
        "__builtin_apply_args", "__builtin_logf", "__builtin_strlen",
        "__builtin_ffs", "__builtin_inf", "__builtin___memcpy_chk",
        "__builtin_trap", "__builtin_parityl", "__builtin_strspn",
        "__builtin_varargs_start", "__builtin_nan",
        "__builtin___snprintf_chk", "__builtin_atanl", "__builtin_clzll",
        "__builtin_huge_valf", "__builtin_coshf", "__builtin_nansf",
        "__builtin___vsnprintf_chk", "__builtin_nanf", "__builtin_atan2",
        "__builtin_popcountl", "__builtin_ceill", "__builtin___strcpy_chk",
        "__builtin_floor", "__builtin_cos", "__builtin_memset",
        "__builtin_nanl", "__builtin_atan2f", "__builtin_popcount",
        "__builtin_sinh", "__builtin_bcopy", "__builtin_extract_return_addr",
        "__builtin_bswap32", "__builtin_ldexp", "__builtin_infl",
        "__builtin_fmodf", "__builtin_frame_address", "getloadavg", "atoi",
        "atol", "atoll", "atof", "strtof", "strtod", "strtold", "strtol",
        "strtoul", "strtoll", "strtoull", "rand", "srand", "malloc",
        "calloc", "realloc", "free", "aligned_alloc", "abort", "atexit",
        "exit", "_Exit", "at_quick_exit", "quick_exit", "getenv", "system",
        "bsearch", "qsort", "abs", "labs", "llabs", "div", "ldiv", "lldiv",
        "mblen", "mbtowc", "wctomb", "mbstowcs", "wcstombs",
        "__ctype_get_mb_cur_max", "posix_memalign", "setenv", "unsetenv",
        "mkstemp", "mkostemp", "mkdtemp", "getsubopt", "rand_r", "realpath",
        "random", "srandom", "initstate", "setstate", "putenv",
        "posix_openpt", "grantpt", "unlockpt", "ptsname", "l64a", "a64l",
        "setkey", "drand48", "erand48", "lrand48", "nrand48", "mrand48",
        "jrand48", "srand48", "seed48", "lcong48", "alloca", "mktemp",
        "mkstemps", "mkostemps", "valloc", "memalign", "clearenv",
        "reallocarray", "qsort_r", "stderr", "fputs", "fprintf", "sprintf",
        "strcpy", "strcmp", "strtok", "strlen", "strcasecmp", "isatty",
        "stdin", "fopen", "fclose", "fgets", "memset", "strchr", "isspace",
        "snprintf", "getpwuid", "getgrgid", "fputc", "putc", "isprint",
        "memcpy", "lstat", "isdigit", "stdout", "printf", "time", "strftime",
        "localtime", "strncmp", "strcoll", "stat", "closedir", "opendir",
        "readdir", "tolower", "readlink", "getcwd", "setlocale",
        "nl_langinfo", "iswprint"
      ],
      "New Types": [
        "sorts", "wint_t", "nl_item", "DIR", "__dirstream", "dirent", "tm",
        "ssize_t", "wchar_t___1", "wchar_t___0", "listingcalls", "stat",
        "blkcnt_t", "blksize_t", "nlink_t", "timespec", "infofile",
        "comment", "totals", "u_int", "u_char", "inotable", "xtable",
        "group", "passwd", "ignorefile", "pattern", "_info", "u_long",
        "gid_t", "uid_t", "dev_t", "ino_t", "mode_t", "time_t", "off_t",
        "size_t___1", "__anonstruct_cmds_476363767", "linedraw",
        "extensions", "colortable", "bool", "__anonenum_bool_753424039",
        "u_short", "FILE", "_IO_FILE", "size_t___0", "lldiv_t",
        "__anonstruct_lldiv_t_989260392", "ldiv_t",
        "__anonstruct_ldiv_t_721778306", "div_t",
        "__anonstruct_div_t_109580352", "size_t", "wchar_t"
      ],
      "New Texts/Asms/Pragmas": [
        "Pragma", "Pragma", "Pragma", "Pragma", "Pragma", "Pragma", "Pragma",
        "Pragma", "Pragma", "Pragma", "Pragma", "Pragma"
      ]
    } }
  ]
}
END-UNIVERSE
*/

/* #pragma merger("0","/tmp/cil-w3mnZ5pV.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-P_5uu9MH.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-XGpO47Sf.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-mQfoqFRQ.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-0dBnSK4d.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Hu4juU2I.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-BMi3HdqY.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-0A5qHwSS.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-P_2dvFnt.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Voeg1cNE.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Rb_dOvMG.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */
/* #pragma merger("0","/tmp/cil-Z0JqcW8b.i","-sUSE_ZLIB=1,-sUSE_ZLIB=1,-sINVOKE_RUN=0,-sINVOKE_RUN=0,-sFORCE_FILESYSTEM=1,-sFORCE_FILESYSTEM=1,-sMODULARIZE=1,-sMODULARIZE=1,-sENVIRONMENT=web,worker,-sENVIRONMENT=web,worker,-sALLOW_MEMORY_GROWTH=1,-sALLOW_MEMORY_GROWTH=1") */

/* BEGIN STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
struct _IO_FILE ;
/* END STRUCT-DECL _IO_FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN STRUCT-DECL __dirstream LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */
struct __dirstream ;
/* END STRUCT-DECL __dirstream LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */

/* BEGIN STRUCT-DECL totals LOC=../tree.h:116 */
struct totals ;
/* END STRUCT-DECL totals LOC=../tree.h:116 */

/* BEGIN STRUCT-DECL sorts LOC=../tree.c:83 */
struct sorts ;
/* END STRUCT-DECL sorts LOC=../tree.c:83 */

/* BEGIN STRUCT-DECL ignorefile LOC=../tree.h:170 */
struct ignorefile ;
/* END STRUCT-DECL ignorefile LOC=../tree.h:170 */

/* BEGIN STRUCT-DECL __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
struct __anonstruct_ldiv_t_721778306 ;
/* END STRUCT-DECL __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN STRUCT-DECL stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */
struct stat ;
/* END STRUCT-DECL stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */

/* BEGIN STRUCT-DECL _info LOC=../tree.h:91 */
struct _info ;
/* END STRUCT-DECL _info LOC=../tree.h:91 */

/* BEGIN STRUCT-DECL __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
struct __anonstruct_lldiv_t_989260392 ;
/* END STRUCT-DECL __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN STRUCT-DECL extensions LOC=../tree.h:149 */
struct extensions ;
/* END STRUCT-DECL extensions LOC=../tree.h:149 */

/* BEGIN STRUCT-DECL xtable LOC=../tree.h:134 */
struct xtable ;
/* END STRUCT-DECL xtable LOC=../tree.h:134 */

/* BEGIN STRUCT-DECL infofile LOC=../tree.h:183 */
struct infofile ;
/* END STRUCT-DECL infofile LOC=../tree.h:183 */

/* BEGIN ENUM-DECL __anonenum_bool_753424039 LOC=../tree.h:86 */
enum __anonenum_bool_753424039 ;
/* END ENUM-DECL __anonenum_bool_753424039 LOC=../tree.h:86 */

/* BEGIN STRUCT-DECL colortable LOC=../tree.h:146 */
struct colortable ;
/* END STRUCT-DECL colortable LOC=../tree.h:146 */

/* BEGIN STRUCT-DECL linedraw LOC=../tree.h:154 */
struct linedraw ;
/* END STRUCT-DECL linedraw LOC=../tree.h:154 */

/* BEGIN STRUCT-DECL dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */
struct dirent ;
/* END STRUCT-DECL dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */

/* BEGIN STRUCT-DECL tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */
struct tm ;
/* END STRUCT-DECL tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */

/* BEGIN STRUCT-DECL comment LOC=../tree.h:177 */
struct comment ;
/* END STRUCT-DECL comment LOC=../tree.h:177 */

/* BEGIN STRUCT-DECL __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
struct __anonstruct_div_t_109580352 ;
/* END STRUCT-DECL __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN STRUCT-DECL inotable LOC=../tree.h:139 */
struct inotable ;
/* END STRUCT-DECL inotable LOC=../tree.h:139 */

/* BEGIN STRUCT-DECL passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */
struct passwd ;
/* END STRUCT-DECL passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */

/* BEGIN STRUCT-DECL group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */
struct group ;
/* END STRUCT-DECL group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */

/* BEGIN STRUCT-DECL listingcalls LOC=../tree.h:121 */
struct listingcalls ;
/* END STRUCT-DECL listingcalls LOC=../tree.h:121 */

/* BEGIN STRUCT-DECL pattern LOC=../tree.h:164 */
struct pattern ;
/* END STRUCT-DECL pattern LOC=../tree.h:164 */

/* BEGIN STRUCT-DECL __anonstruct_cmds_476363767 LOC=../color.c:176 */
struct __anonstruct_cmds_476363767 ;
/* END STRUCT-DECL __anonstruct_cmds_476363767 LOC=../color.c:176 */

/* BEGIN STRUCT-DECL timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */
struct timespec ;
/* END STRUCT-DECL timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */

/* BEGIN FUNCTION-DECL __builtin_strchr LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* END FUNCTION-DECL __builtin_strchr LOC=BUILTIN */

/* BEGIN TYPEDEF u_int LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:66 */
typedef unsigned int u_int;
/* END TYPEDEF u_int LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:66 */

/* BEGIN FUNCTION-DECL-EXTERN mrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:132 */
extern long mrand48(void) ;
/* END FUNCTION-DECL-EXTERN mrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:132 */

/* BEGIN FUNCTION-DECL __builtin_ctz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ctz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */
extern int isdigit(int  ) ;
/* END FUNCTION-DECL-EXTERN isdigit LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:14 */

/* BEGIN TYPEDEF ino_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:246 */
typedef unsigned long long ino_t;
/* END TYPEDEF ino_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:246 */

/* BEGIN FUNCTION-DECL __builtin_acosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_acosf LOC=BUILTIN */

/* BEGIN TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */
typedef struct _IO_FILE FILE;
/* END TYPEDEF FILE LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:398 */

/* BEGIN FUNCTION-DECL-EXTERN putc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:108 */
extern int putc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN putc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:108 */

/* BEGIN TYPEDEF gid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:333 */
typedef unsigned int gid_t;
/* END TYPEDEF gid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:333 */

/* BEGIN FUNCTION-DECL gidtoname LOC=UNKNOWN */
char *gidtoname(gid_t gid ) ;
/* END FUNCTION-DECL gidtoname LOC=UNKNOWN */

/* BEGIN TYPEDEF blksize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:256 */
typedef int blksize_t;
/* END TYPEDEF blksize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:256 */

/* BEGIN FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* END FUNCTION-DECL __builtin_sinh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_newline LOC=UNKNOWN */
void html_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL html_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fabsf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL mtimesort LOC=UNKNOWN */
int mtimesort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL mtimesort LOC=UNKNOWN */

/* BEGIN TYPEDEF DIR LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */
typedef struct __dirstream DIR;
/* END TYPEDEF DIR LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:20 */

/* BEGIN STRUCT linedraw LOC=../tree.h:154 */
struct linedraw {
   char **name ;
   char *vert ;
   char *vert_left ;
   char *corner ;
   char *copy ;
   char *ctop ;
   char *cbot ;
   char *cmid ;
   char *cext ;
   char *csingle ;
};
/* END STRUCT linedraw LOC=../tree.h:154 */

/* BEGIN FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* END FUNCTION-DECL __builtin_fmodf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* END FUNCTION-DECL __builtin_va_arg LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */
extern int fputs(char const   * , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fputs LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:116 */

/* BEGIN TYPEDEF nlink_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:236 */
typedef unsigned long nlink_t;
/* END TYPEDEF nlink_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:236 */

/* BEGIN FUNCTION-DECL-EXTERN __ctype_get_mb_cur_max LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:81 */
extern unsigned long __ctype_get_mb_cur_max(void) ;
/* END FUNCTION-DECL-EXTERN __ctype_get_mb_cur_max LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:81 */

/* BEGIN FUNCTION-DECL versort LOC=UNKNOWN */
int versort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL versort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_acos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* END FUNCTION-DECL __builtin_acos LOC=BUILTIN */

/* BEGIN ENUM __anonenum_bool_753424039 LOC=../tree.h:86 */
enum __anonenum_bool_753424039 {
    FALSE = 0,
    TRUE = 1
} ;
/* END ENUM __anonenum_bool_753424039 LOC=../tree.h:86 */

/* BEGIN TYPEDEF bool LOC=../tree.h:86 */
typedef enum __anonenum_bool_753424039 bool;
/* END TYPEDEF bool LOC=../tree.h:86 */

/* BEGIN VARIABLE-DEF matchdirs LOC=UNKNOWN */
bool matchdirs  ;
/* END VARIABLE-DEF matchdirs LOC=UNKNOWN */

/* BEGIN TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */
typedef long long off_t;
/* END TYPEDEF off_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:241 */

/* BEGIN TYPEDEF u_long LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:67 */
typedef unsigned long u_long;
/* END TYPEDEF u_long LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:67 */

/* BEGIN STRUCT totals LOC=../tree.h:116 */
struct totals {
   u_long files ;
   u_long dirs ;
   off_t size ;
};
/* END STRUCT totals LOC=../tree.h:116 */

/* BEGIN VARIABLE-DEF vgacolor LOC=UNKNOWN */
char *vgacolor[18]  ;
/* END VARIABLE-DEF vgacolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN abort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:46 */
extern void abort(void) ;
/* END FUNCTION-DECL-EXTERN abort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:46 */

/* BEGIN FUNCTION-DECL-EXTERN getloadavg LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h:8 */
extern int getloadavg(double *loadavg , int nelem ) ;
/* END FUNCTION-DECL-EXTERN getloadavg LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/compat/stdlib.h:8 */

/* BEGIN VARIABLE-DEF pathsize LOC=UNKNOWN */
static long pathsize  ;
/* END VARIABLE-DEF pathsize LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL pop_filterstack LOC=UNKNOWN */
struct ignorefile *pop_filterstack(void) ;
/* END FUNCTION-DECL pop_filterstack LOC=UNKNOWN */

/* BEGIN STRUCT sorts LOC=../tree.c:83 */
struct sorts {
   char *name ;
   int (*cmpfunc)() ;
};
/* END STRUCT sorts LOC=../tree.c:83 */

/* BEGIN VARIABLE-DEF result_type LOC=UNKNOWN */
static int result_type[60]  ;
/* END VARIABLE-DEF result_type LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN at_quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:50 */
extern int at_quick_exit(void (*)(void) ) ;
/* END FUNCTION-DECL-EXTERN at_quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:50 */

/* BEGIN VARIABLE-DEF term LOC=UNKNOWN */
char *term  ;
/* END VARIABLE-DEF term LOC=UNKNOWN */

/* BEGIN STRUCT tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
/* END STRUCT tm LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:40 */

/* BEGIN FUNCTION-DECL xml_outtro LOC=UNKNOWN */
void xml_outtro(void) ;
/* END FUNCTION-DECL xml_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_stpcpy LOC=BUILTIN */

/* BEGIN STRUCT group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */
struct group {
   char *gr_name ;
   char *gr_passwd ;
   gid_t gr_gid ;
   char **gr_mem ;
};
/* END STRUCT group LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:19 */

/* BEGIN FUNCTION-DECL newent LOC=UNKNOWN */
struct _info *newent(char *name ) ;
/* END FUNCTION-DECL newent LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF fromfile LOC=UNKNOWN */
bool fromfile  ;
/* END VARIABLE-DEF fromfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strcasecmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h:29 */
extern int strcasecmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcasecmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/strings.h:29 */

/* BEGIN FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_subps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF patterns LOC=UNKNOWN */
char **patterns  ;
/* END VARIABLE-DEF patterns LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN closedir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:24 */
extern int closedir(DIR * ) ;
/* END FUNCTION-DECL-EXTERN closedir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:24 */

/* BEGIN VARIABLE-DEF charset LOC=UNKNOWN */
char *charset  ;
/* END VARIABLE-DEF charset LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN ptsname LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:124 */
extern char *ptsname(int  ) ;
/* END FUNCTION-DECL-EXTERN ptsname LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:124 */

/* BEGIN TYPEDEF dev_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:251 */
typedef unsigned int dev_t;
/* END TYPEDEF dev_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:251 */

/* BEGIN FUNCTION-DECL listdir LOC=UNKNOWN */
struct totals listdir(char *dirname , struct _info **dir , int lev , dev_t dev , bool hasfulltree ) ;
/* END FUNCTION-DECL listdir LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_asin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* END FUNCTION-DECL __builtin_asin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_object_size LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* END FUNCTION-DECL __builtin_object_size LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN rand_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:108 */
extern int rand_r(unsigned int * ) ;
/* END FUNCTION-DECL-EXTERN rand_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:108 */

/* BEGIN TYPEDEF time_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:81 */
typedef long long time_t;
/* END TYPEDEF time_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:81 */

/* BEGIN FUNCTION-DECL-EXTERN time LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:55 */
extern time_t time(time_t * ) ;
/* END FUNCTION-DECL-EXTERN time LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:55 */

/* BEGIN FUNCTION-DECL __builtin_asinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_asinf LOC=BUILTIN */

/* BEGIN STRUCT pattern LOC=../tree.h:164 */
struct pattern {
   char *pattern ;
   int relative ;
   struct pattern *next ;
};
/* END STRUCT pattern LOC=../tree.h:164 */

/* BEGIN FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */
extern int tolower(int  ) ;
/* END FUNCTION-DECL-EXTERN tolower LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:22 */

/* BEGIN FUNCTION-DECL __builtin_coshl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_coshl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN malloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:40 */
extern void *malloc(unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN malloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:40 */

/* BEGIN FUNCTION-DECL __builtin_tan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* END FUNCTION-DECL __builtin_tan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN atoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:25 */
extern long long atoll(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:25 */

/* BEGIN FUNCTION-DECL fprune LOC=UNKNOWN */
struct _info **fprune(struct _info *head , bool matched , bool root ) ;
/* END FUNCTION-DECL fprune LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF viscii LOC=UNKNOWN */
static char *viscii[3]  ;
/* END VARIABLE-DEF viscii LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strpbrk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN realpath LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:115 */
extern char *realpath(char const   * __restrict   , char * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN realpath LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:115 */

/* BEGIN FUNCTION-DECL filtercheck LOC=UNKNOWN */
int filtercheck(char *path___0 , char *name , int isdir ) ;
/* END FUNCTION-DECL filtercheck LOC=UNKNOWN */

/* BEGIN TYPEDEF ldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
typedef struct __anonstruct_ldiv_t_721778306 ldiv_t;
/* END TYPEDEF ldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN FUNCTION-DECL printcomment LOC=UNKNOWN */
void printcomment(int line , int lines , char *s ) ;
/* END FUNCTION-DECL printcomment LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL new_pattern LOC=UNKNOWN */
struct pattern *new_pattern(char *pattern___0 ) ;
/* END FUNCTION-DECL new_pattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___stpcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* END FUNCTION-DECL __builtin_next_arg LOC=BUILTIN */

/* BEGIN TYPEDEF lldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
typedef struct __anonstruct_lldiv_t_989260392 lldiv_t;
/* END TYPEDEF lldiv_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* END FUNCTION-DECL __builtin_bswap32 LOC=BUILTIN */

/* BEGIN VARIABLE-DEF host LOC=UNKNOWN */
char *host  ;
/* END VARIABLE-DEF host LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountll LOC=BUILTIN */

/* BEGIN VARIABLE-DEF lbuf LOC=UNKNOWN */
static char *lbuf  ;
/* END VARIABLE-DEF lbuf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:53 */
extern char *getenv(char const   * ) ;
/* END FUNCTION-DECL-EXTERN getenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:53 */

/* BEGIN FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* END FUNCTION-DECL __builtin_unreachable LOC=BUILTIN */

/* BEGIN VARIABLE-DEF iec_unit LOC=UNKNOWN */
static char *iec_unit  ;
/* END VARIABLE-DEF iec_unit LOC=UNKNOWN */

/* BEGIN TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:46 */
typedef unsigned long size_t___0;
/* END TYPEDEF size_t___0 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:46 */

/* BEGIN FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */
extern size_t___0 strlen(char const   * ) ;
/* END FUNCTION-DECL-EXTERN strlen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:54 */

/* BEGIN FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */
extern int isspace(int  ) ;
/* END FUNCTION-DECL-EXTERN isspace LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:19 */

/* BEGIN FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_stdarg_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memset_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF utable LOC=UNKNOWN */
struct xtable *utable[256]  ;
/* END VARIABLE-DEF utable LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF iso8859_789 LOC=UNKNOWN */
static char *iso8859_789[22]  ;
/* END VARIABLE-DEF iso8859_789 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_coshf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* END FUNCTION-DECL __builtin_coshf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN clearenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:147 */
extern int clearenv(void) ;
/* END FUNCTION-DECL-EXTERN clearenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:147 */

/* BEGIN VARIABLE-DEF getfulltree LOC=UNKNOWN */
struct _info **(*getfulltree)(char *d , u_long lev , dev_t dev , off_t *size , char **err )  ;
/* END VARIABLE-DEF getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF maxpattern LOC=UNKNOWN */
int maxpattern  ;
/* END VARIABLE-DEF maxpattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floor LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* END FUNCTION-DECL __builtin_floor LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_infl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* END FUNCTION-DECL __builtin_infl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_modfl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* END FUNCTION-DECL __builtin_modfl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN erand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:129 */
extern double erand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN erand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:129 */

/* BEGIN FUNCTION-DECL-EXTERN sprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:121 */
extern int sprintf(char * , char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN sprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:121 */

/* BEGIN VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */
extern FILE *stdout ;
/* END VARIABLE-DECL-EXTERN stdout LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:73 */

/* BEGIN FUNCTION-DECL-EXTERN exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:48 */
extern void exit(int  ) ;
/* END FUNCTION-DECL-EXTERN exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:48 */

/* BEGIN FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncmp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_expf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* END FUNCTION-DECL __builtin_expf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_printfile LOC=UNKNOWN */
int html_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL html_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ffs LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_ffs LOC=BUILTIN */

/* BEGIN VARIABLE-DEF curdir LOC=UNKNOWN */
char *curdir  ;
/* END VARIABLE-DEF curdir LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getcwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:92 */
extern char *getcwd(char * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN getcwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:92 */

/* BEGIN FUNCTION-DECL-EXTERN abs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:60 */
extern int abs(int  ) ;
/* END FUNCTION-DECL-EXTERN abs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:60 */

/* BEGIN TYPEDEF size_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t;
/* END TYPEDEF size_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN TYPEDEF wchar_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:38 */
typedef int wchar_t;
/* END TYPEDEF wchar_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/bits/alltypes.h:38 */

/* BEGIN FUNCTION-DECL-EXTERN mbtowc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:73 */
extern int mbtowc(wchar_t * __restrict   , char const   * __restrict   , size_t  ) ;
/* END FUNCTION-DECL-EXTERN mbtowc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:73 */

/* BEGIN FUNCTION-DECL initlinedraw LOC=UNKNOWN */
void initlinedraw(int flag ) ;
/* END FUNCTION-DECL initlinedraw LOC=UNKNOWN */

/* BEGIN TYPEDEF ssize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:154 */
typedef long ssize_t;
/* END TYPEDEF ssize_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:154 */

/* BEGIN FUNCTION-DECL-EXTERN labs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:61 */
extern long labs(long  ) ;
/* END FUNCTION-DECL-EXTERN labs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:61 */

/* BEGIN FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexp LOC=BUILTIN */

/* BEGIN STRUCT timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
/* END STRUCT timespec LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:312 */

/* BEGIN TYPEDEF blkcnt_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:261 */
typedef int blkcnt_t;
/* END TYPEDEF blkcnt_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:261 */

/* BEGIN TYPEDEF mode_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:231 */
typedef unsigned int mode_t;
/* END TYPEDEF mode_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:231 */

/* BEGIN TYPEDEF uid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:328 */
typedef unsigned int uid_t;
/* END TYPEDEF uid_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:328 */

/* BEGIN STRUCT stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */
struct stat {
   dev_t st_dev ;
   int __st_dev_padding ;
   long __st_ino_truncated ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   int __st_rdev_padding ;
   off_t st_size ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   ino_t st_ino ;
};
/* END STRUCT stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/stat.h:4 */

/* BEGIN VARIABLE-DEF ftype LOC=UNKNOWN */
char *ftype[9]  ;
/* END VARIABLE-DEF ftype LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsnprintf_chk LOC=BUILTIN */

/* BEGIN STRUCT extensions LOC=../tree.h:149 */
struct extensions {
   char *ext ;
   char *term_flg ;
   char *CSS_name ;
   char *web_fg ;
   char *web_bg ;
   char *web_extattr ;
   struct extensions *nxt ;
};
/* END STRUCT extensions LOC=../tree.h:149 */

/* BEGIN STRUCT listingcalls LOC=../tree.h:121 */
struct listingcalls {
   void (*intro)(void) ;
   void (*outtro)(void) ;
   int (*printinfo)(char *dirname , struct _info *file , int level ) ;
   int (*printfile)(char *dirname , char *filename , struct _info *file , int descend ) ;
   int (*error)(char *error ) ;
   void (*newline)(struct _info *file , int level , int postdir , int needcomma ) ;
   void (*close)(struct _info *file , int level , int needcomma ) ;
   void (*report)(struct totals tot ) ;
};
/* END STRUCT listingcalls LOC=../tree.h:121 */

/* BEGIN VARIABLE-DEF lc LOC=UNKNOWN */
struct listingcalls lc  ;
/* END VARIABLE-DEF lc LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF xdev LOC=UNKNOWN */
bool xdev  ;
/* END VARIABLE-DEF xdev LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL new_comment LOC=UNKNOWN */
struct comment *new_comment(struct pattern *phead , char **line , int lines ) ;
/* END FUNCTION-DECL new_comment LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL class LOC=UNKNOWN */
char *class(struct _info *info___1 ) ;
/* END FUNCTION-DECL class LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL unix_report LOC=UNKNOWN */
void unix_report(struct totals tot ) ;
/* END FUNCTION-DECL unix_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN system LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:55 */
extern int system(char const   * ) ;
/* END FUNCTION-DECL-EXTERN system LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:55 */

/* BEGIN VARIABLE-DEF hflag LOC=UNKNOWN */
bool hflag  ;
/* END VARIABLE-DEF hflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sinhf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF maxipattern LOC=UNKNOWN */
int maxipattern  ;
/* END VARIABLE-DEF maxipattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mkostemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:105 */
extern int mkostemp(char * , int  ) ;
/* END FUNCTION-DECL-EXTERN mkostemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:105 */

/* BEGIN FUNCTION-DECL-EXTERN strtof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:28 */
extern float strtof(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:28 */

/* BEGIN FUNCTION-DECL cmd LOC=UNKNOWN */
int cmd(char *s ) ;
/* END FUNCTION-DECL cmd LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floorf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* END FUNCTION-DECL __builtin_floorf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF file_pathsep LOC=UNKNOWN */
char *file_pathsep  ;
/* END VARIABLE-DEF file_pathsep LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF flimit LOC=UNKNOWN */
int flimit  ;
/* END VARIABLE-DEF flimit LOC=UNKNOWN */

/* BEGIN STRUCT __anonstruct_cmds_476363767 LOC=../color.c:176 */
struct __anonstruct_cmds_476363767 {
   char *cmd ;
   char cmdnum ;
};
/* END STRUCT __anonstruct_cmds_476363767 LOC=../color.c:176 */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpckhps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL prot LOC=UNKNOWN */
char *prot(mode_t m ) ;
/* END FUNCTION-DECL prot LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL saveino LOC=UNKNOWN */
void saveino(ino_t inode , dev_t device ) ;
/* END FUNCTION-DECL saveino LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL sizecmp LOC=UNKNOWN */
int sizecmp(off_t a , off_t b ) ;
/* END FUNCTION-DECL sizecmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsll LOC=BUILTIN */

/* BEGIN TYPEDEF u_char LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:64 */
typedef unsigned char u_char;
/* END TYPEDEF u_char LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:64 */

/* BEGIN FUNCTION-DECL-EXTERN setkey LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:127 */
extern void setkey(char const   * ) ;
/* END FUNCTION-DECL-EXTERN setkey LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:127 */

/* BEGIN FUNCTION-DECL do_date LOC=UNKNOWN */
char *do_date(time_t t ) ;
/* END FUNCTION-DECL do_date LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN isprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:17 */
extern int isprint(int  ) ;
/* END FUNCTION-DECL-EXTERN isprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/ctype.h:17 */

/* BEGIN FUNCTION-DECL-EXTERN strtoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:34 */
extern long long strtoll(char const   * __restrict   , char ** __restrict   , int  ) ;
/* END FUNCTION-DECL-EXTERN strtoll LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:34 */

/* BEGIN FUNCTION-DECL json_intro LOC=UNKNOWN */
void json_intro(void) ;
/* END FUNCTION-DECL json_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL html_error LOC=UNKNOWN */
int html_error(char *error ) ;
/* END FUNCTION-DECL html_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL unix_error LOC=UNKNOWN */
int unix_error(char *error ) ;
/* END FUNCTION-DECL unix_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_memcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_powil LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* END FUNCTION-DECL __builtin_huge_valf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _global_argv LOC=UNKNOWN */
char **_global_argv  ;
/* END VARIABLE-DEF _global_argv LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF Qflag LOC=UNKNOWN */
bool Qflag  ;
/* END VARIABLE-DEF Qflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN posix_memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:101 */
extern int posix_memalign(void ** , size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN posix_memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:101 */

/* BEGIN VARIABLE-DEF uflag LOC=UNKNOWN */
bool uflag  ;
/* END VARIABLE-DEF uflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF noreport LOC=UNKNOWN */
bool noreport  ;
/* END VARIABLE-DEF noreport LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nansf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN random LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:116 */
extern long random(void) ;
/* END FUNCTION-DECL-EXTERN random LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:116 */

/* BEGIN VARIABLE-DEF linktargetcolor LOC=UNKNOWN */
bool linktargetcolor  ;
/* END VARIABLE-DEF linktargetcolor LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF sorts LOC=UNKNOWN */
struct sorts sorts[6]  ;
/* END VARIABLE-DEF sorts LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF _nl LOC=UNKNOWN */
char *_nl  ;
/* END VARIABLE-DEF _nl LOC=UNKNOWN */

/* BEGIN TYPEDEF nl_item LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/nl_types.h:11 */
typedef int nl_item;
/* END TYPEDEF nl_item LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/nl_types.h:11 */

/* BEGIN FUNCTION-DECL html_outtro LOC=UNKNOWN */
void html_outtro(void) ;
/* END FUNCTION-DECL html_outtro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF outfile LOC=UNKNOWN */
FILE *outfile  ;
/* END VARIABLE-DEF outfile LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF shift_jis LOC=UNKNOWN */
static char *shift_jis[4]  ;
/* END VARIABLE-DEF shift_jis LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___sprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN putenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:120 */
extern int putenv(char * ) ;
/* END FUNCTION-DECL-EXTERN putenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:120 */

/* BEGIN VARIABLE-DEF gtable LOC=UNKNOWN */
struct xtable *gtable[256]  ;
/* END VARIABLE-DEF gtable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_printfile LOC=UNKNOWN */
int json_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL json_printfile LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF timefmt LOC=UNKNOWN */
char *timefmt  ;
/* END VARIABLE-DEF timefmt LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF koi8ru LOC=UNKNOWN */
static char *koi8ru[4]  ;
/* END VARIABLE-DEF koi8ru LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF pflag LOC=UNKNOWN */
bool pflag  ;
/* END VARIABLE-DEF pflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* END FUNCTION-DECL __builtin_huge_val LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN getsubopt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:107 */
extern int getsubopt(char ** , char * const  * , char ** ) ;
/* END FUNCTION-DECL-EXTERN getsubopt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:107 */

/* BEGIN FUNCTION-DECL unix_newline LOC=UNKNOWN */
void unix_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL unix_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */
extern void *memcpy(void * __restrict   , void const   * __restrict   , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:27 */

/* BEGIN FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* END FUNCTION-DECL __builtin_extract_return_addr LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_asinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_asinl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Rflag LOC=UNKNOWN */
bool Rflag  ;
/* END VARIABLE-DEF Rflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ipattern LOC=UNKNOWN */
int ipattern  ;
/* END VARIABLE-DEF ipattern LOC=UNKNOWN */

/* BEGIN STRUCT infofile LOC=../tree.h:183 */
struct infofile {
   char *path ;
   struct comment *comments ;
   struct infofile *next ;
};
/* END STRUCT infofile LOC=../tree.h:183 */

/* BEGIN FUNCTION-DECL-EXTERN setstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:119 */
extern char *setstate(char * ) ;
/* END FUNCTION-DECL-EXTERN setstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:119 */

/* BEGIN FUNCTION-DECL json_encode LOC=UNKNOWN */
void json_encode(FILE *fd , char *s ) ;
/* END FUNCTION-DECL json_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_ctzll LOC=BUILTIN */

/* BEGIN STRUCT dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */
struct dirent {
   ino_t d_ino ;
   off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
/* END STRUCT dirent LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/dirent.h:5 */

/* BEGIN FUNCTION-DECL __builtin_parityll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_parityll LOC=BUILTIN */

/* BEGIN FUNCTION-DECL freefiletree LOC=UNKNOWN */
void freefiletree(struct _info *ent ) ;
/* END FUNCTION-DECL freefiletree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN localtime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:60 */
extern struct tm *localtime(time_t const   * ) ;
/* END FUNCTION-DECL-EXTERN localtime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:60 */

/* BEGIN VARIABLE-DEF lflag LOC=UNKNOWN */
bool lflag  ;
/* END VARIABLE-DEF lflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN llabs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:62 */
extern long long llabs(long long  ) ;
/* END FUNCTION-DECL-EXTERN llabs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:62 */

/* BEGIN FUNCTION-DECL gittrim LOC=UNKNOWN */
void gittrim(char *s ) ;
/* END FUNCTION-DECL gittrim LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN opendir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:26 */
extern DIR *opendir(char const   * ) ;
/* END FUNCTION-DECL-EXTERN opendir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:26 */

/* BEGIN FUNCTION-DECL xml_printinfo LOC=UNKNOWN */
int xml_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL xml_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strtoull LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:35 */
extern unsigned long long strtoull(char const   * __restrict   , char ** __restrict   ,
                                   int  ) ;
/* END FUNCTION-DECL-EXTERN strtoull LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:35 */

/* BEGIN FUNCTION-DECL ctimesort LOC=UNKNOWN */
int ctimesort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL ctimesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL push_filterstack LOC=UNKNOWN */
void push_filterstack(struct ignorefile *ig ) ;
/* END FUNCTION-DECL push_filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_floorl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_floorl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF version LOC=UNKNOWN */
char *version  ;
/* END VARIABLE-DEF version LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */
extern FILE *stderr ;
/* END VARIABLE-DECL-EXTERN stderr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:74 */

/* BEGIN VARIABLE-DEF noindent LOC=UNKNOWN */
bool noindent  ;
/* END VARIABLE-DEF noindent LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN lldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:70 */
extern lldiv_t lldiv(long long  , long long  ) ;
/* END FUNCTION-DECL-EXTERN lldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:70 */

/* BEGIN FUNCTION-DECL __builtin_popcount LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_popcount LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_varargs_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */
extern int strcmp(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:39 */

/* BEGIN FUNCTION-DECL infocheck LOC=UNKNOWN */
struct comment *infocheck(char *path___0 , char *name , int top , int isdir ) ;
/* END FUNCTION-DECL infocheck LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL nextpc LOC=UNKNOWN */
char *nextpc(char **p , int *tok ) ;
/* END FUNCTION-DECL nextpc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN readdir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:27 */
extern struct dirent *readdir(DIR * ) ;
/* END FUNCTION-DECL-EXTERN readdir LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/dirent.h:27 */

/* BEGIN FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL push_infostack LOC=UNKNOWN */
void push_infostack(struct infofile *inf ) ;
/* END FUNCTION-DECL push_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_memset LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* END FUNCTION-DECL __builtin_memset LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN setlocale LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/locale.h:55 */
extern char *setlocale(int  , char const   * ) ;
/* END FUNCTION-DECL-EXTERN setlocale LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/locale.h:55 */

/* BEGIN STRUCT colortable LOC=../tree.h:146 */
struct colortable {
   char *term_flg ;
   char *CSS_name ;
   char *font_fg ;
   char *font_bg ;
};
/* END STRUCT colortable LOC=../tree.h:146 */

/* BEGIN VARIABLE-DEF colortable LOC=UNKNOWN */
struct colortable colortable[11]  ;
/* END VARIABLE-DEF colortable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN posix_openpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:121 */
extern int posix_openpt(int  ) ;
/* END FUNCTION-DECL-EXTERN posix_openpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:121 */

/* BEGIN FUNCTION-DECL json_outtro LOC=UNKNOWN */
void json_outtro(void) ;
/* END FUNCTION-DECL json_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* END FUNCTION-DECL __builtin_atan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fabsl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL pop_infostack LOC=UNKNOWN */
struct infofile *pop_infostack(void) ;
/* END FUNCTION-DECL pop_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL dirsfirst LOC=UNKNOWN */
int dirsfirst(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL dirsfirst LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF duflag LOC=UNKNOWN */
bool duflag  ;
/* END VARIABLE-DEF duflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strftime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:58 */
extern size_t___0 strftime(char * __restrict   , size_t___0  , char const   * __restrict   ,
                           struct tm  const  * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strftime LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/time.h:58 */

/* BEGIN FUNCTION-DECL __builtin_powif LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powif LOC=BUILTIN */

/* BEGIN TYPEDEF div_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
typedef struct __anonstruct_div_t_109580352 div_t;
/* END TYPEDEF div_t LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN FUNCTION-DECL fsizesort LOC=UNKNOWN */
int fsizesort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL fsizesort LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF cmds LOC=UNKNOWN */
static struct __anonstruct_cmds_476363767 cmds[22]  ;
/* END VARIABLE-DEF cmds LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF topsort LOC=UNKNOWN */
int (*topsort)()  ;
/* END VARIABLE-DEF topsort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */
extern int printf(char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN printf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:119 */

/* BEGIN VARIABLE-DEF devflag LOC=UNKNOWN */
bool devflag  ;
/* END VARIABLE-DEF devflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_frexp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vsprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:130 */
extern long lrand48(void) ;
/* END FUNCTION-DECL-EXTERN lrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:130 */

/* BEGIN FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* END FUNCTION-DECL __builtin_atan2f LOC=BUILTIN */

/* BEGIN VARIABLE-DEF buf LOC=UNKNOWN */
static char buf[11]  ;
/* END VARIABLE-DEF buf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */
/* compiler builtin: 
   long long __builtin_bswap64(long long  ) ;  */
/* END FUNCTION-DECL __builtin_bswap64 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_clzll LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* END FUNCTION-DECL __builtin_clzll LOC=BUILTIN */

/* BEGIN VARIABLE-DEF path LOC=UNKNOWN */
static char *path  ;
/* END VARIABLE-DEF path LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF sp LOC=UNKNOWN */
char *sp  ;
/* END VARIABLE-DEF sp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_end LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_end LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtoul LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:33 */
extern unsigned long strtoul(char const   * __restrict   , char ** __restrict   ,
                             int  ) ;
/* END FUNCTION-DECL-EXTERN strtoul LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:33 */

/* BEGIN FUNCTION-DECL-EXTERN strcoll LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:42 */
extern int strcoll(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcoll LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:42 */

/* BEGIN FUNCTION-DECL strverscmp LOC=UNKNOWN */
int strverscmp(char const   *s1 , char const   *s2 ) ;
/* END FUNCTION-DECL strverscmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_exp LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* END FUNCTION-DECL __builtin_exp LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mktemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:141 */
extern char *mktemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mktemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:141 */

/* BEGIN VARIABLE-DEF sLevel LOC=UNKNOWN */
char *sLevel  ;
/* END VARIABLE-DEF sLevel LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN nrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:131 */
extern long nrand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN nrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:131 */

/* BEGIN FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* END FUNCTION-DECL __builtin_frexpf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN initstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:118 */
extern char *initstate(unsigned int  , char * , size_t  ) ;
/* END FUNCTION-DECL-EXTERN initstate LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:118 */

/* BEGIN FUNCTION-DECL html_intro LOC=UNKNOWN */
void html_intro(void) ;
/* END FUNCTION-DECL html_intro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF gflag LOC=UNKNOWN */
bool gflag  ;
/* END VARIABLE-DEF gflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL print_color LOC=UNKNOWN */
int print_color(int color___0 ) ;
/* END FUNCTION-DECL print_color LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL stat2info LOC=UNKNOWN */
struct _info *stat2info(struct stat *st ) ;
/* END FUNCTION-DECL stat2info LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:51 */
extern void quick_exit(int  ) ;
/* END FUNCTION-DECL-EXTERN quick_exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:51 */

/* BEGIN FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___fprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* END FUNCTION-DECL __builtin_bswap16 LOC=BUILTIN */

/* BEGIN TYPEDEF u_short LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:65 */
typedef unsigned short u_short;
/* END TYPEDEF u_short LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/types.h:65 */

/* BEGIN STRUCT ignorefile LOC=../tree.h:170 */
struct ignorefile {
   char *path ;
   struct pattern *remove ;
   struct pattern *reverse ;
   struct ignorefile *next ;
};
/* END STRUCT ignorefile LOC=../tree.h:170 */

/* BEGIN FUNCTION-DECL-EXTERN _Exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:49 */
extern void _Exit(int  ) ;
/* END FUNCTION-DECL-EXTERN _Exit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:49 */

/* BEGIN VARIABLE-DEF info___0 LOC=UNKNOWN */
static char info___0[512]  ;
/* END VARIABLE-DEF info___0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_error LOC=UNKNOWN */
int json_error(char *error ) ;
/* END FUNCTION-DECL json_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN srand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:134 */
extern void srand48(long  ) ;
/* END FUNCTION-DECL-EXTERN srand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:134 */

/* BEGIN VARIABLE-DEF inodeflag LOC=UNKNOWN */
bool inodeflag  ;
/* END VARIABLE-DEF inodeflag LOC=UNKNOWN */

/* BEGIN STRUCT inotable LOC=../tree.h:139 */
struct inotable {
   ino_t inode ;
   dev_t device ;
   struct inotable *nxt ;
};
/* END STRUCT inotable LOC=../tree.h:139 */

/* BEGIN STRUCT passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   uid_t pw_uid ;
   gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
/* END STRUCT passwd LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:20 */

/* BEGIN FUNCTION-DECL __builtin_powi LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_powi LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_expect LOC=BUILTIN */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* END FUNCTION-DECL __builtin_expect LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_logf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* END FUNCTION-DECL __builtin_logf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Fflag LOC=UNKNOWN */
bool Fflag  ;
/* END VARIABLE-DEF Fflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_printinfo LOC=UNKNOWN */
int json_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL json_printinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF windows LOC=UNKNOWN */
static char *windows[13]  ;
/* END VARIABLE-DEF windows LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nan LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nan LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_inf LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* END FUNCTION-DECL __builtin_inf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* END FUNCTION-DECL __builtin_va_arg_pack_len LOC=BUILTIN */

/* BEGIN VARIABLE-DEF linedraw LOC=UNKNOWN */
struct linedraw *linedraw  ;
/* END VARIABLE-DEF linedraw LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atoi LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:23 */
extern int atoi(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atoi LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:23 */

/* BEGIN FUNCTION-DECL __builtin_modff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* END FUNCTION-DECL __builtin_modff LOC=BUILTIN */

/* BEGIN VARIABLE-DEF colorize LOC=UNKNOWN */
bool colorize  ;
/* END VARIABLE-DEF colorize LOC=UNKNOWN */

/* BEGIN TYPEDEF wint_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:51 */
typedef unsigned int wint_t;
/* END TYPEDEF wint_t LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:51 */

/* BEGIN FUNCTION-DECL setoutput LOC=UNKNOWN */
void setoutput(char *filename ) ;
/* END FUNCTION-DECL setoutput LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */
extern int fputc(int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fputc LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:107 */

/* BEGIN FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___printf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_acosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_acosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL xml_printfile LOC=UNKNOWN */
int xml_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL xml_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_types_compatible_p LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN qsort_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:151 */
extern void qsort_r(void * , size_t  , size_t  , int (*)(void const   * , void const   * ,
                                                         void * ) , void * ) ;
/* END FUNCTION-DECL-EXTERN qsort_r LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:151 */

/* BEGIN VARIABLE-DEF errors LOC=UNKNOWN */
int errors  ;
/* END VARIABLE-DEF errors LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF fpattern LOC=UNKNOWN */
static char fpattern[4096]  ;
/* END VARIABLE-DEF fpattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_copy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_print LOC=UNKNOWN */
void html_print(char *s ) ;
/* END FUNCTION-DECL html_print LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN lcong48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:136 */
extern void lcong48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN lcong48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:136 */

/* BEGIN VARIABLE-DEF big5 LOC=UNKNOWN */
static char *big5[3]  ;
/* END VARIABLE-DEF big5 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_argc LOC=UNKNOWN */
int _global_argc  ;
/* END VARIABLE-DEF _global_argc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_trap LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* END FUNCTION-DECL __builtin_trap LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cosh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* END FUNCTION-DECL __builtin_cosh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinhl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10f LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* END FUNCTION-DECL __builtin_log10f LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mkstemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:104 */
extern int mkstemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mkstemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:104 */

/* BEGIN FUNCTION-DECL getinfo LOC=UNKNOWN */
struct _info *getinfo(char *name , char *path___0 ) ;
/* END FUNCTION-DECL getinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vprintf_chk LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */
struct __anonstruct_div_t_109580352 {
   int quot ;
   int rem ;
};
/* END STRUCT __anonstruct_div_t_109580352 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:64 */

/* BEGIN FUNCTION-DECL-EXTERN a64l LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:126 */
extern long a64l(char const   * ) ;
/* END FUNCTION-DECL-EXTERN a64l LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:126 */

/* BEGIN FUNCTION-DECL parse_dir_colors LOC=UNKNOWN */
void parse_dir_colors(void) ;
/* END FUNCTION-DECL parse_dir_colors LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mkostemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:143 */
extern int mkostemps(char * , int  , int  ) ;
/* END FUNCTION-DECL-EXTERN mkostemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:143 */

/* BEGIN FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */
extern int fprintf(FILE * , char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN fprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:120 */

/* BEGIN FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin___snprintf_chk LOC=BUILTIN */

/* BEGIN STRUCT comment LOC=../tree.h:177 */
struct comment {
   struct pattern *pattern ;
   char **desc ;
   struct comment *next ;
};
/* END STRUCT comment LOC=../tree.h:177 */

/* BEGIN FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_popcountl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Xflag LOC=UNKNOWN */
bool Xflag  ;
/* END VARIABLE-DEF Xflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_parity LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_parity LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN setenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:102 */
extern int setenv(char const   * , char const   * , int  ) ;
/* END FUNCTION-DECL-EXTERN setenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:102 */

/* BEGIN FUNCTION-DECL __builtin_cosl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_cosl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL xml_intro LOC=UNKNOWN */
void xml_intro(void) ;
/* END FUNCTION-DECL xml_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strtod LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:29 */
extern double strtod(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtod LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:29 */

/* BEGIN FUNCTION-DECL-EXTERN nl_langinfo LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/langinfo.h:91 */
extern char *nl_langinfo(nl_item  ) ;
/* END FUNCTION-DECL-EXTERN nl_langinfo LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/langinfo.h:91 */

/* BEGIN FUNCTION-DECL cond_lower LOC=UNKNOWN */
__inline static char cond_lower(char c ) ;
/* END FUNCTION-DECL cond_lower LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF iso2022jp LOC=UNKNOWN */
static char *iso2022jp[5]  ;
/* END VARIABLE-DEF iso2022jp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* END FUNCTION-DECL __builtin_prefetch LOC=BUILTIN */

/* BEGIN FUNCTION-DECL findino LOC=UNKNOWN */
int findino(ino_t inode , dev_t device ) ;
/* END FUNCTION-DECL findino LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:73 */
extern int stat(char const   * __restrict   , struct stat * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN stat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:73 */

/* BEGIN FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_mempcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN lstat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:75 */
extern int lstat(char const   * , struct stat * ) ;
/* END FUNCTION-DECL-EXTERN lstat LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/sys/stat.h:75 */

/* BEGIN FUNCTION-DECL-EXTERN unsetenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:103 */
extern int unsetenv(char const   * ) ;
/* END FUNCTION-DECL-EXTERN unsetenv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:103 */

/* BEGIN FUNCTION-DECL __builtin_inff LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* END FUNCTION-DECL __builtin_inff LOC=BUILTIN */

/* BEGIN VARIABLE-DEF showinfo LOC=UNKNOWN */
bool showinfo  ;
/* END VARIABLE-DEF showinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF errbuf LOC=UNKNOWN */
static char errbuf[256]  ;
/* END VARIABLE-DEF errbuf LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */
extern int isatty(int  ) ;
/* END FUNCTION-DECL-EXTERN isatty LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:118 */

/* BEGIN FUNCTION-DECL-EXTERN wcstombs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:76 */
extern size_t wcstombs(char * __restrict   , wchar_t const   * __restrict   , size_t  ) ;
/* END FUNCTION-DECL-EXTERN wcstombs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:76 */

/* BEGIN FUNCTION-DECL getcharset LOC=UNKNOWN */
char const   *getcharset(void) ;
/* END FUNCTION-DECL getcharset LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:24 */
extern long atol(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:24 */

/* BEGIN VARIABLE-DEF pruneflag LOC=UNKNOWN */
bool pruneflag  ;
/* END VARIABLE-DEF pruneflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN mbstowcs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:75 */
extern unsigned long mbstowcs(int * __restrict   , char const   * __restrict   , unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN mbstowcs LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:75 */

/* BEGIN FUNCTION-DECL-EXTERN mkstemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:142 */
extern int mkstemps(char * , int  ) ;
/* END FUNCTION-DECL-EXTERN mkstemps LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:142 */

/* BEGIN VARIABLE-DEF Hflag LOC=UNKNOWN */
bool Hflag  ;
/* END VARIABLE-DEF Hflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncpy_chk LOC=BUILTIN */

/* BEGIN VARIABLE-DEF cflag LOC=UNKNOWN */
bool cflag  ;
/* END VARIABLE-DEF cflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL fillinfo LOC=UNKNOWN */
char *fillinfo(char *buf___1 , struct _info *ent ) ;
/* END FUNCTION-DECL fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_indent LOC=UNKNOWN */
void xml_indent(int maxlevel ) ;
/* END FUNCTION-DECL xml_indent LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF hversion LOC=UNKNOWN */
char *hversion  ;
/* END VARIABLE-DEF hversion LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN l64a LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:125 */
extern char *l64a(long  ) ;
/* END FUNCTION-DECL-EXTERN l64a LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:125 */

/* BEGIN FUNCTION-DECL unix_printinfo LOC=UNKNOWN */
int unix_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL unix_printinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF latin1_3 LOC=UNKNOWN */
static char *latin1_3[15]  ;
/* END VARIABLE-DEF latin1_3 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF nolinks LOC=UNKNOWN */
bool nolinks  ;
/* END VARIABLE-DEF nolinks LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF euc_jp LOC=UNKNOWN */
static char *euc_jp[4]  ;
/* END VARIABLE-DEF euc_jp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL color LOC=UNKNOWN */
int color(u_short mode , char *name , bool orphan , bool islink ) ;
/* END FUNCTION-DECL color LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_newline LOC=UNKNOWN */
void json_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL json_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL json_report LOC=UNKNOWN */
void json_report(struct totals tot ) ;
/* END FUNCTION-DECL json_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL read_dir LOC=UNKNOWN */
struct _info **read_dir(char *dir , int *n , int infotop ) ;
/* END FUNCTION-DECL read_dir LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL new_ignorefile LOC=UNKNOWN */
struct ignorefile *new_ignorefile(char *path___0 ) ;
/* END FUNCTION-DECL new_ignorefile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */
extern int strncmp(char const   * , char const   * , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN strncmp LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:40 */

/* BEGIN VARIABLE-DEF Dflag LOC=UNKNOWN */
bool Dflag  ;
/* END VARIABLE-DEF Dflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_addps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN realloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:42 */
extern void *realloc(void * , unsigned long  ) ;
/* END FUNCTION-DECL-EXTERN realloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:42 */

/* BEGIN FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* END FUNCTION-DECL __builtin_frob_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strncat_chk LOC=BUILTIN */

/* BEGIN TYPEDEF wchar_t___1 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:74 */
typedef int wchar_t___1;
/* END TYPEDEF wchar_t___1 LOC=/usr/local/bin/emcc-non-obf/llvm/build/lib/clang/16/include/stddef.h:74 */

/* BEGIN VARIABLE-DEF qflag LOC=UNKNOWN */
bool qflag  ;
/* END VARIABLE-DEF qflag LOC=UNKNOWN */

/* BEGIN TYPEDEF size_t___1 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */
typedef unsigned long size_t___1;
/* END TYPEDEF size_t___1 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:139 */

/* BEGIN FUNCTION-DECL-EXTERN grantpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:122 */
extern int grantpt(int  ) ;
/* END FUNCTION-DECL-EXTERN grantpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:122 */

/* BEGIN FUNCTION-DECL json_indent LOC=UNKNOWN */
void json_indent(int maxlevel ) ;
/* END FUNCTION-DECL json_indent LOC=UNKNOWN */

/* BEGIN STRUCT _info LOC=../tree.h:91 */
struct _info {
   char *name ;
   char *lnk ;
   bool isdir ;
   bool issok ;
   bool isfifo ;
   bool isexe ;
   bool orphan ;
   mode_t mode ;
   mode_t lnkmode ;
   uid_t uid ;
   gid_t gid ;
   off_t size ;
   time_t atime ;
   time_t ctime ;
   time_t mtime ;
   dev_t dev ;
   dev_t ldev ;
   ino_t inode ;
   ino_t linode ;
   char *err ;
   char *tag ;
   char **comment ;
   struct _info **child ;
   struct _info *next ;
   struct _info *tchild ;
};
/* END STRUCT _info LOC=../tree.h:91 */

/* BEGIN VARIABLE-DEF info LOC=UNKNOWN */
static struct _info info  ;
/* END VARIABLE-DEF info LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL json_fillinfo LOC=UNKNOWN */
void json_fillinfo(struct _info *ent ) ;
/* END FUNCTION-DECL json_fillinfo LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF metafirst LOC=UNKNOWN */
bool metafirst  ;
/* END VARIABLE-DEF metafirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN jrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:133 */
extern long jrand48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN jrand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:133 */

/* BEGIN VARIABLE-DEF euc_kr LOC=UNKNOWN */
static char *euc_kr[3]  ;
/* END VARIABLE-DEF euc_kr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nanl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF gb LOC=UNKNOWN */
static char *gb[3]  ;
/* END VARIABLE-DEF gb LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_sin LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* END FUNCTION-DECL __builtin_sin LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN srand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:38 */
extern void srand(unsigned int  ) ;
/* END FUNCTION-DECL-EXTERN srand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:38 */

/* BEGIN FUNCTION-DECL uidtoname LOC=UNKNOWN */
char *uidtoname(uid_t uid ) ;
/* END FUNCTION-DECL uidtoname LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF buf___0 LOC=UNKNOWN */
static char buf___0[256]  ;
/* END VARIABLE-DEF buf___0 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atexit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:47 */
extern int atexit(void (*)(void) ) ;
/* END FUNCTION-DECL-EXTERN atexit LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:47 */

/* BEGIN FUNCTION-DECL-EXTERN fclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:82 */
extern int fclose(FILE * ) ;
/* END FUNCTION-DECL-EXTERN fclose LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:82 */

/* BEGIN FUNCTION-DECL-EXTERN strchr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:45 */
extern char *strchr(char const   * , int  ) ;
/* END FUNCTION-DECL-EXTERN strchr LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:45 */

/* BEGIN VARIABLE-DEF fmt LOC=UNKNOWN */
char fmt[9]  ;
/* END VARIABLE-DEF fmt LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL endcolor LOC=UNKNOWN */
void endcolor(void) ;
/* END FUNCTION-DECL endcolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___mempcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN qsort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:58 */
extern void qsort(void * , unsigned long  , unsigned long  , int (*)(void const   * ,
                                                                     void const   * ) ) ;
/* END FUNCTION-DECL-EXTERN qsort LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:58 */

/* BEGIN FUNCTION-DECL __builtin_strncat LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncat LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_maxps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memcpy_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:80 */
extern FILE *fopen(char const   * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN fopen LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:80 */

/* BEGIN FUNCTION-DECL-EXTERN strtol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:32 */
extern long strtol(char const   * __restrict   , char ** __restrict   , int  ) ;
/* END FUNCTION-DECL-EXTERN strtol LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:32 */

/* BEGIN FUNCTION-DECL __builtin_fabs LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* END FUNCTION-DECL __builtin_fabs LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mkdtemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:106 */
extern char *mkdtemp(char * ) ;
/* END FUNCTION-DECL-EXTERN mkdtemp LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:106 */

/* BEGIN VARIABLE-DEF force_color LOC=UNKNOWN */
bool force_color  ;
/* END VARIABLE-DEF force_color LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___memmove_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL filesfirst LOC=UNKNOWN */
int filesfirst(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL filesfirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL free_dir LOC=UNKNOWN */
void free_dir(struct _info **d ) ;
/* END FUNCTION-DECL free_dir LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF istty LOC=UNKNOWN */
char istty  ;
/* END VARIABLE-DEF istty LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL patmatch LOC=UNKNOWN */
int patmatch(char *buf___1 , char *pat , int isdir ) ;
/* END FUNCTION-DECL patmatch LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN atof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:26 */
extern double atof(char const   * ) ;
/* END FUNCTION-DECL-EXTERN atof LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:26 */

/* BEGIN VARIABLE-DEF ignorecase LOC=UNKNOWN */
bool ignorecase  ;
/* END VARIABLE-DEF ignorecase LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL patignore LOC=UNKNOWN */
int patignore(char *name , int isdir ) ;
/* END FUNCTION-DECL patignore LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_tanh LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* END FUNCTION-DECL __builtin_tanh LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_ffsl LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */
struct __anonstruct_ldiv_t_721778306 {
   long quot ;
   long rem ;
};
/* END STRUCT __anonstruct_ldiv_t_721778306 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:65 */

/* BEGIN FUNCTION-DECL-EXTERN readlink LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:74 */
extern ssize_t readlink(char const   * __restrict   , char * __restrict   , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN readlink LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/unistd.h:74 */

/* BEGIN FUNCTION-DECL unix_getfulltree LOC=UNKNOWN */
struct _info **unix_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) ;
/* END FUNCTION-DECL unix_getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_fmodl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_atanf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* END FUNCTION-DECL __builtin_atanf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sinl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_sinl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL xml_error LOC=UNKNOWN */
int xml_error(char *error ) ;
/* END FUNCTION-DECL xml_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL indent LOC=UNKNOWN */
void indent(int maxlevel ) ;
/* END FUNCTION-DECL indent LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF reverse LOC=UNKNOWN */
bool reverse  ;
/* END VARIABLE-DEF reverse LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL psize LOC=UNKNOWN */
int psize(char *buf___1 , off_t size ) ;
/* END FUNCTION-DECL psize LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL null_outtro LOC=UNKNOWN */
void null_outtro(void) ;
/* END FUNCTION-DECL null_outtro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF si_unit LOC=UNKNOWN */
static char *si_unit  ;
/* END VARIABLE-DEF si_unit LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF infostack LOC=UNKNOWN */
struct infofile *infostack  ;
/* END VARIABLE-DEF infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_mulps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL null_intro LOC=UNKNOWN */
void null_intro(void) ;
/* END FUNCTION-DECL null_intro LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ibm_gr LOC=UNKNOWN */
static char *ibm_gr[6]  ;
/* END VARIABLE-DEF ibm_gr LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_nansl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nansl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL Ftype LOC=UNKNOWN */
char Ftype(mode_t mode ) ;
/* END FUNCTION-DECL Ftype LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* END FUNCTION-DECL __builtin_ceilf LOC=BUILTIN */

/* BEGIN STRUCT xtable LOC=../tree.h:134 */
struct xtable {
   unsigned int xid ;
   char *name ;
   struct xtable *nxt ;
};
/* END STRUCT xtable LOC=../tree.h:134 */

/* BEGIN FUNCTION-DECL-EXTERN reallocarray LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:150 */
extern void *reallocarray(void * , size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN reallocarray LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:150 */

/* BEGIN FUNCTION-DECL __builtin_parityl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_parityl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ceil LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* END FUNCTION-DECL __builtin_ceil LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN seed48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:135 */
extern unsigned short *seed48(unsigned short * ) ;
/* END FUNCTION-DECL-EXTERN seed48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:135 */

/* BEGIN FUNCTION-DECL __builtin_strlen LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strlen LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN fgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:111 */
extern char *fgets(char * , int  , FILE * ) ;
/* END FUNCTION-DECL-EXTERN fgets LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:111 */

/* BEGIN FUNCTION-DECL new_infofile LOC=UNKNOWN */
struct infofile *new_infofile(char *path___0 ) ;
/* END FUNCTION-DECL new_infofile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:33 */
extern char *strcpy(char * , char const   * ) ;
/* END FUNCTION-DECL-EXTERN strcpy LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:33 */

/* BEGIN FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_frame_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* END FUNCTION-DECL __builtin_sqrtf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL json_close LOC=UNKNOWN */
void json_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL json_close LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF utf8 LOC=UNKNOWN */
static char *utf8[3]  ;
/* END VARIABLE-DEF utf8 LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_atanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_atanl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL push_files LOC=UNKNOWN */
void push_files(char *dir , struct ignorefile **ig , struct infofile **inf ) ;
/* END FUNCTION-DECL push_files LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* END FUNCTION-DECL __builtin_ldexpl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:145 */
extern void *memalign(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN memalign LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:145 */

/* BEGIN FUNCTION-DECL __builtin_fmod LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* END FUNCTION-DECL __builtin_fmod LOC=BUILTIN */

/* BEGIN VARIABLE-DEF cstable LOC=UNKNOWN */
static struct linedraw cstable[16]  ;
/* END VARIABLE-DEF cstable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN strtold LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:30 */
extern long double strtold(char const   * __restrict   , char ** __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtold LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:30 */

/* BEGIN FUNCTION-DECL printit LOC=UNKNOWN */
void printit(char *s ) ;
/* END FUNCTION-DECL printit LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN div LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:68 */
extern div_t div(int  , int  ) ;
/* END FUNCTION-DECL-EXTERN div LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:68 */

/* BEGIN FUNCTION-DECL-EXTERN bsearch LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:57 */
extern void *bsearch(void const   * , void const   * , size_t  , size_t  , int (*)(void const   * ,
                                                                                   void const   * ) ) ;
/* END FUNCTION-DECL-EXTERN bsearch LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:57 */

/* BEGIN VARIABLE-DEF Nflag LOC=UNKNOWN */
bool Nflag  ;
/* END VARIABLE-DEF Nflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_return_address LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_return_address LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* END FUNCTION-DECL __builtin_apply_args LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN strtok LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:52 */
extern char *strtok(char * __restrict   , char const   * __restrict   ) ;
/* END FUNCTION-DECL-EXTERN strtok LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:52 */

/* BEGIN FUNCTION-DECL __builtin_tanl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_tanl LOC=BUILTIN */

/* BEGIN STRUCT __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */
struct __anonstruct_lldiv_t_989260392 {
   long long quot ;
   long long rem ;
};
/* END STRUCT __anonstruct_lldiv_t_989260392 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:66 */

/* BEGIN VARIABLE-DEF fflag LOC=UNKNOWN */
bool fflag  ;
/* END VARIABLE-DEF fflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL file_getfulltree LOC=UNKNOWN */
struct _info **file_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) ;
/* END FUNCTION-DECL file_getfulltree LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF file_comment LOC=UNKNOWN */
char *file_comment  ;
/* END VARIABLE-DEF file_comment LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xmalloc LOC=UNKNOWN */
void *xmalloc(size_t___0 size ) ;
/* END FUNCTION-DECL xmalloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_expl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_expl LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_log10l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* END FUNCTION-DECL __builtin_log10l LOC=BUILTIN */

/* BEGIN VARIABLE-DEF aflag LOC=UNKNOWN */
bool aflag  ;
/* END VARIABLE-DEF aflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* END FUNCTION-DECL __builtin_constant_p LOC=BUILTIN */

/* BEGIN VARIABLE-DEF Level LOC=UNKNOWN */
int Level  ;
/* END VARIABLE-DEF Level LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcpy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN snprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:122 */
extern int snprintf(char * , size_t___0  , char const   *  , ...) ;
/* END FUNCTION-DECL-EXTERN snprintf LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:122 */

/* BEGIN FUNCTION-DECL alnumsort LOC=UNKNOWN */
int alnumsort(struct _info **a , struct _info **b ) ;
/* END FUNCTION-DECL alnumsort LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* END FUNCTION-DECL __builtin_strcspn LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_clz LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* END FUNCTION-DECL __builtin_clz LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_bzero LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bzero LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_nans LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* END FUNCTION-DECL __builtin_nans LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN mblen LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:72 */
extern int mblen(char const   * , size_t  ) ;
/* END FUNCTION-DECL-EXTERN mblen LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:72 */

/* BEGIN FUNCTION-DECL xrealloc LOC=UNKNOWN */
void *xrealloc(void *ptr , size_t___0 size ) ;
/* END FUNCTION-DECL xrealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_clzl LOC=BUILTIN */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_clzl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF lbufsize LOC=UNKNOWN */
static int lbufsize  ;
/* END VARIABLE-DEF lbufsize LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_ceill LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* END FUNCTION-DECL __builtin_ceill LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN aligned_alloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:44 */
extern void *aligned_alloc(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN aligned_alloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:44 */

/* BEGIN FUNCTION-DECL html_report LOC=UNKNOWN */
void html_report(struct totals tot ) ;
/* END FUNCTION-DECL html_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_return LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* END FUNCTION-DECL __builtin_return LOC=BUILTIN */

/* BEGIN FUNCTION-DECL url_encode LOC=UNKNOWN */
void url_encode(FILE *fd , char *s ) ;
/* END FUNCTION-DECL url_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL split LOC=UNKNOWN */
char **split(char *str , char *delim , int *nwrds ) ;
/* END FUNCTION-DECL split LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin___strcat_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_close LOC=UNKNOWN */
void html_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL html_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL null_close LOC=UNKNOWN */
void null_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL null_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN ldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:69 */
extern ldiv_t ldiv(long  , long  ) ;
/* END FUNCTION-DECL-EXTERN ldiv LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:69 */

/* BEGIN FUNCTION-DECL unix_printfile LOC=UNKNOWN */
int unix_printfile(char *dirname , char *filename , struct _info *file , int descend ) ;
/* END FUNCTION-DECL unix_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN calloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:41 */
extern void *calloc(size_t  , size_t  ) ;
/* END FUNCTION-DECL-EXTERN calloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:41 */

/* BEGIN VARIABLE-DEF ibm_ps2 LOC=UNKNOWN */
static char *ibm_ps2[9]  ;
/* END VARIABLE-DEF ibm_ps2 LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF perms LOC=UNKNOWN */
static char perms[10]  ;
/* END VARIABLE-DEF perms LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF _global_envp LOC=UNKNOWN */
char **_global_envp  ;
/* END VARIABLE-DEF _global_envp LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_bcopy LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN valloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:144 */
extern void *valloc(size_t  ) ;
/* END FUNCTION-DECL-EXTERN valloc LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:144 */

/* BEGIN VARIABLE-DEF gitignore LOC=UNKNOWN */
bool gitignore  ;
/* END VARIABLE-DEF gitignore LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ext LOC=UNKNOWN */
struct extensions *ext  ;
/* END VARIABLE-DEF ext LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_logl LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* END FUNCTION-DECL __builtin_logl LOC=BUILTIN */

/* BEGIN VARIABLE-DEF maxdirs LOC=UNKNOWN */
int maxdirs  ;
/* END VARIABLE-DEF maxdirs LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL gnu_getcwd LOC=UNKNOWN */
char *gnu_getcwd(void) ;
/* END FUNCTION-DECL gnu_getcwd LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_log LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* END FUNCTION-DECL __builtin_log LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_cos LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* END FUNCTION-DECL __builtin_cos LOC=BUILTIN */

/* BEGIN FUNCTION-DECL-EXTERN alloca LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h:11 */
extern void *alloca(size_t  ) ;
/* END FUNCTION-DECL-EXTERN alloca LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/alloca.h:11 */

/* BEGIN FUNCTION-DECL-EXTERN free LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:43 */
extern void free(void * ) ;
/* END FUNCTION-DECL-EXTERN free LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:43 */

/* BEGIN FUNCTION-DECL emit_tree LOC=UNKNOWN */
void emit_tree(char **dirname , bool needfulltree ) ;
/* END FUNCTION-DECL emit_tree LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) ;
/* END FUNCTION-DECL main LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_va_start LOC=BUILTIN */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin_va_start LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* END FUNCTION-DECL __builtin_sqrt LOC=BUILTIN */

/* BEGIN FUNCTION-DECL xml_newline LOC=UNKNOWN */
void xml_newline(struct _info *file , int level , int postdir , int needcomma ) ;
/* END FUNCTION-DECL xml_newline LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF filterstack LOC=UNKNOWN */
struct ignorefile *filterstack  ;
/* END VARIABLE-DEF filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN wctomb LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:74 */
extern int wctomb(char * , wchar_t  ) ;
/* END FUNCTION-DECL-EXTERN wctomb LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:74 */

/* BEGIN VARIABLE-DEF dirs LOC=UNKNOWN */
int *dirs  ;
/* END VARIABLE-DEF dirs LOC=UNKNOWN */

/* BEGIN VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */
extern FILE *stdin ;
/* END VARIABLE-DECL-EXTERN stdin LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/stdio.h:72 */

/* BEGIN VARIABLE-DEF siflag LOC=UNKNOWN */
bool siflag  ;
/* END VARIABLE-DEF siflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF sflag LOC=UNKNOWN */
bool sflag  ;
/* END VARIABLE-DEF sflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_fillinfo LOC=UNKNOWN */
void xml_fillinfo(struct _info *ent ) ;
/* END FUNCTION-DECL xml_fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN unlockpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:123 */
extern int unlockpt(int  ) ;
/* END FUNCTION-DECL-EXTERN unlockpt LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:123 */

/* BEGIN VARIABLE-DEF next_state LOC=UNKNOWN */
static unsigned int next_state[16]  ;
/* END VARIABLE-DEF next_state LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getgrgid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:26 */
extern struct group *getgrgid(gid_t  ) ;
/* END FUNCTION-DECL-EXTERN getgrgid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/grp.h:26 */

/* BEGIN FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* END FUNCTION-DECL __builtin_tanhf LOC=BUILTIN */

/* BEGIN VARIABLE-DEF color_code LOC=UNKNOWN */
char *color_code[26]  ;
/* END VARIABLE-DEF color_code LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF termmatch LOC=UNKNOWN */
char termmatch  ;
/* END VARIABLE-DEF termmatch LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_cosf LOC=BUILTIN */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* END FUNCTION-DECL __builtin_cosf LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* END FUNCTION-DECL __builtin_huge_vall LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_strncpy LOC=BUILTIN */

/* BEGIN VARIABLE-DEF title LOC=UNKNOWN */
char *title  ;
/* END VARIABLE-DEF title LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF dflag LOC=UNKNOWN */
bool dflag  ;
/* END VARIABLE-DEF dflag LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ifmt LOC=UNKNOWN */
int ifmt[8]  ;
/* END VARIABLE-DEF ifmt LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL html_printinfo LOC=UNKNOWN */
int html_printinfo(char *dirname , struct _info *file , int level ) ;
/* END FUNCTION-DECL html_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_close LOC=UNKNOWN */
void xml_close(struct _info *file , int level , int needcomma ) ;
/* END FUNCTION-DECL xml_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN getpwuid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:36 */
extern struct passwd *getpwuid(uid_t  ) ;
/* END FUNCTION-DECL-EXTERN getpwuid LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/pwd.h:36 */

/* BEGIN FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* END FUNCTION-DECL __builtin___vfprintf_chk LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2l LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_apply LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_apply LOC=BUILTIN */

/* BEGIN FUNCTION-DECL html_encode LOC=UNKNOWN */
void html_encode(FILE *fd , char *s ) ;
/* END FUNCTION-DECL html_encode LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ansilines LOC=UNKNOWN */
bool ansilines  ;
/* END VARIABLE-DEF ansilines LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN srandom LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:117 */
extern void srandom(unsigned int  ) ;
/* END FUNCTION-DECL-EXTERN srandom LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:117 */

/* BEGIN VARIABLE-DEF mb_cur_max LOC=UNKNOWN */
int mb_cur_max  ;
/* END VARIABLE-DEF mb_cur_max LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL usage LOC=UNKNOWN */
void usage(int n ) ;
/* END FUNCTION-DECL usage LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF prev LOC=UNKNOWN */
static char prev  ;
/* END VARIABLE-DEF prev LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF basesort LOC=UNKNOWN */
int (*basesort)()  ;
/* END VARIABLE-DEF basesort LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF pattern LOC=UNKNOWN */
int pattern  ;
/* END VARIABLE-DEF pattern LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF Jflag LOC=UNKNOWN */
bool Jflag  ;
/* END VARIABLE-DEF Jflag LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN rand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:37 */
extern int rand(void) ;
/* END FUNCTION-DECL-EXTERN rand LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:37 */

/* BEGIN VARIABLE-DEF nocolor LOC=UNKNOWN */
bool nocolor  ;
/* END VARIABLE-DEF nocolor LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN drand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:128 */
extern double drand48(void) ;
/* END FUNCTION-DECL-EXTERN drand48 LOC=/usr/lib/emsdk/upstream/emscripten/cache/sysroot/include/stdlib.h:128 */

/* BEGIN FUNCTION-DECL-EXTERN iswprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/wchar.h:187 */
extern int iswprint(wint_t  ) ;
/* END FUNCTION-DECL-EXTERN iswprint LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/wchar.h:187 */

/* BEGIN FUNCTION-DECL __builtin_alloca LOC=BUILTIN */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* END FUNCTION-DECL __builtin_alloca LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* END FUNCTION-DECL __builtin_ia32_unpcklps LOC=BUILTIN */

/* BEGIN FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* END FUNCTION-DECL __builtin_atan2 LOC=BUILTIN */

/* BEGIN TYPEDEF wchar_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:38 */
typedef int wchar_t___0;
/* END TYPEDEF wchar_t___0 LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/bits/alltypes.h:38 */

/* BEGIN FUNCTION-DECL patinclude LOC=UNKNOWN */
int patinclude(char *name , int isdir ) ;
/* END FUNCTION-DECL patinclude LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */
extern void *memset(void * , int  , size_t___0  ) ;
/* END FUNCTION-DECL-EXTERN memset LOC=/usr/local/bin/emcc-non-obf/emscripten/cache/sysroot/include/string.h:29 */

/* BEGIN VARIABLE-DEF itable LOC=UNKNOWN */
struct inotable *itable[256]  ;
/* END VARIABLE-DEF itable LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL xml_report LOC=UNKNOWN */
void xml_report(struct totals tot ) ;
/* END FUNCTION-DECL xml_report LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF htmldirlen LOC=UNKNOWN */
int htmldirlen  ;
/* END VARIABLE-DEF htmldirlen LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ipatterns LOC=UNKNOWN */
char **ipatterns  ;
/* END VARIABLE-DEF ipatterns LOC=UNKNOWN */

/* BEGIN FUNCTION-DECL __builtin_log10 LOC=BUILTIN */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* END FUNCTION-DECL __builtin_log10 LOC=BUILTIN */

/* BEGIN FUNCTION-DECL search LOC=UNKNOWN */
struct _info *search(struct _info **dir , char *name ) ;
/* END FUNCTION-DECL search LOC=UNKNOWN */

/* BEGIN VARIABLE-DEF ibm_pc LOC=UNKNOWN */
static char *ibm_pc[25]  ;
/* END VARIABLE-DEF ibm_pc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_comment LOC=UNKNOWN */
struct comment *new_comment(struct pattern *phead , char **line , int lines ) 
{ 
  struct comment *com ;
  void *tmp ;
  void *tmp___0 ;
  int i ;

  {
  tmp = xmalloc(sizeof(struct comment ));
  com = (struct comment *)tmp;
  com->pattern = phead;
  tmp___0 = xmalloc(sizeof(char *) * (unsigned long )(lines + 1));
  com->desc = (char **)tmp___0;
  i = 0;
  while (i < lines) {
    *(com->desc + i) = *(line + i);
    i ++;
  }
  *(com->desc + i) = (char *)((void *)0);
  com->next = (struct comment *)((void *)0);
  return (com);
}
}
/* END FUNCTION-DEF new_comment LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_close LOC=UNKNOWN */
void xml_close(struct _info *file , int level , int needcomma ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
  if (! noindent) {
    if (level >= 0) {
      xml_indent(level - 1);
    }
  }
  if (noindent) {
    tmp = (char *)"";
  } else {
    tmp = (char *)"\n";
  }
  if (file) {
    tmp___0 = file->tag;
  } else {
    tmp___0 = "unknown";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</%s>%s"),
          tmp___0, tmp);
  return;
}
}
/* END FUNCTION-DEF xml_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_outtro LOC=UNKNOWN */
void json_outtro(void) 
{ 
  char *tmp ;

  {
  if (noindent) {
    tmp = (char *)"";
  } else {
    tmp = _nl;
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s]\n"),
          tmp);
  return;
}
}
/* END FUNCTION-DEF json_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_close LOC=UNKNOWN */
void html_close(struct _info *file , int level , int needcomma ) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</%s><br>\n"),
          file->tag);
  return;
}
}
/* END FUNCTION-DEF html_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_encode LOC=UNKNOWN */
void html_encode(FILE *fd , char *s ) 
{ 


  {
  while (*s) {
    switch ((int )*s) {
    case 60: 
    fputs((char const   *)((char const   */* __restrict  */)"&lt;"), (FILE *)((FILE */* __restrict  */)fd));
    break;
    case 62: 
    fputs((char const   *)((char const   */* __restrict  */)"&gt;"), (FILE *)((FILE */* __restrict  */)fd));
    break;
    case 38: 
    fputs((char const   *)((char const   */* __restrict  */)"&amp;"), (FILE *)((FILE */* __restrict  */)fd));
    break;
    case 34: 
    fputs((char const   *)((char const   */* __restrict  */)"&quot;"), (FILE *)((FILE */* __restrict  */)fd));
    break;
    default: 
    fputc((int )*s, fd);
    break;
    }
    s ++;
  }
  return;
}
}
/* END FUNCTION-DEF html_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF push_filterstack LOC=UNKNOWN */
void push_filterstack(struct ignorefile *ig ) 
{ 


  {
  if ((unsigned long )ig == (unsigned long )((void *)0)) {
    return;
  }
  ig->next = filterstack;
  filterstack = ig;
  return;
}
}
/* END FUNCTION-DEF push_filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_print LOC=UNKNOWN */
void html_print(char *s ) 
{ 
  int i ;

  {
  i = 0;
  while (*(s + i)) {
    if ((int )*(s + i) == 32) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s"),
              sp);
    } else {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%c"),
              (int )*(s + i));
    }
    i ++;
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
          sp, sp);
  return;
}
}
/* END FUNCTION-DEF html_print LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF pop_infostack LOC=UNKNOWN */
struct infofile *pop_infostack(void) 
{ 
  struct infofile *inf ;
  struct comment *cn ;
  struct comment *cc ;
  struct pattern *p ;
  struct pattern *c ;
  int i ;

  {
  inf = infostack;
  infostack = infostack->next;
  if ((unsigned long )inf == (unsigned long )((void *)0)) {
    return ((struct infofile *)((void *)0));
  }
  cc = inf->comments;
  cn = cc;
  while ((unsigned long )cn != (unsigned long )((void *)0)) {
    cn = cn->next;
    c = cc->pattern;
    p = c;
    while ((unsigned long )p != (unsigned long )((void *)0)) {
      p = p->next;
      free((void *)c->pattern);
      c = p;
    }
    i = 0;
    while ((unsigned long )*(cc->desc + i) != (unsigned long )((void *)0)) {
      free((void *)*(cc->desc + i));
      i ++;
    }
    free((void *)cc->desc);
    free((void *)cc);
    cc = cn;
  }
  free((void *)inf->path);
  free((void *)inf);
  return ((struct infofile *)((void *)0));
}
}
/* END FUNCTION-DEF pop_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF getcharset LOC=UNKNOWN */
char const   *getcharset(void) 
{ 
  char *tmp ;

  {
  tmp = getenv("TREE_CHARSET");
  return ((char const   *)tmp);
}
}
/* END FUNCTION-DEF getcharset LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF null_outtro LOC=UNKNOWN */
void null_outtro(void) 
{ 


  {
  return;
}
}
/* END FUNCTION-DEF null_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF listdir LOC=UNKNOWN */
struct totals listdir(char *dirname , struct _info **dir , int lev , dev_t dev , bool hasfulltree ) 
{ 
  struct totals tot ;
  struct totals subtotal ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **subdir ;
  int descend ;
  int htmldescend ;
  int found ;
  int n ;
  int dirlen ;
  size_t___0 tmp ;
  int pathlen ;
  int needsclosed ;
  char *path___0 ;
  char *newpath ;
  char *filename ;
  char *err ;
  int es ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  FILE *outsave ;
  char *paths[2] ;
  char *output ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  int *dirsave ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tot.files = (u_long )0;
  tot.dirs = 0UL;
  tot.size = 0LL;
  ig = (struct ignorefile *)((void *)0);
  inf = (struct infofile *)((void *)0);
  subdir = (struct _info **)((void *)0);
  htmldescend = 0;
  tmp = strlen((char const   *)dirname);
  dirlen = (int )tmp;
  pathlen = dirlen + 257;
  err = (char *)((void *)0);
  tmp___0 = strlen((char const   *)dirname);
  es = (int )*(dirname + (tmp___0 - 1UL)) == 47;
  n = 0;
  while (*(dir + n)) {
    n ++;
  }
  if (topsort) {
    qsort((void *)dir, (size_t___1 )n, sizeof(struct _info *), (int (*)(void const   * ,
                                                                        void const   * ))topsort);
  }
  if (*(dir + 1)) {
    *(dirs + lev) = 1;
  } else {
    *(dirs + lev) = 2;
  }
  tmp___1 = xmalloc(sizeof(char ) * (unsigned long )pathlen);
  path___0 = (char *)tmp___1;
  while ((unsigned long )*dir != (unsigned long )((void *)0)) {
    (*(lc.printinfo))(dirname, *dir, lev);
    if (es) {
      sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
              dirname, (*dir)->name);
    } else {
      sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
              dirname, (*dir)->name);
    }
    if (fflag) {
      filename = path___0;
    } else {
      filename = (*dir)->name;
    }
    descend = 0;
    err = (char *)((void *)0);
    if ((*dir)->isdir) {
      (tot.dirs) ++;
      found = findino((*dir)->inode, (*dir)->dev);
      if (! found) {
        saveino((*dir)->inode, (*dir)->dev);
      }
      if (xdev) {
        if (! (dev != (*dir)->dev)) {
          goto _L___0;
        }
      } else
      _L___0: 
      if (! (*dir)->lnk) {
        goto _L;
      } else
      if ((*dir)->lnk) {
        if (lflag) {
          _L: 
          descend = 1;
          newpath = path___0;
          if ((*dir)->lnk) {
            if ((int )*((*dir)->lnk) == 47) {
              newpath = (*dir)->lnk;
            } else
            if (fflag) {
              tmp___2 = strcmp((char const   *)dirname, "/");
              if (tmp___2) {
                sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
                        dirname, (*dir)->lnk);
              } else {
                sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
                        dirname, (*dir)->lnk);
              }
            } else {
              sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
                      dirname, (*dir)->lnk);
            }
            if (found) {
              err = (char *)"recursive, not followed";
              descend = 0;
            }
          }
          if (Level >= 0) {
            if (lev > Level) {
              if (Rflag) {
                outsave = outfile;
                paths[0] = newpath;
                paths[1] = (char *)((void *)0);
                tmp___3 = strlen((char const   *)newpath);
                tmp___4 = xmalloc(tmp___3 + 13UL);
                output = (char *)tmp___4;
                tmp___5 = xmalloc(sizeof(int ) * (unsigned long )(lev + 2));
                dirsave = (int *)tmp___5;
                memcpy((void */* __restrict  */)dirsave, (void const   */* __restrict  */)dirs,
                       sizeof(int ) * (unsigned long )(lev + 1));
                sprintf((char *)((char */* __restrict  */)output), (char const   *)((char const   */* __restrict  */)"%s/00Tree.html"),
                        newpath);
                setoutput(output);
                emit_tree(paths, hasfulltree);
                free((void *)output);
                fclose(outfile);
                outfile = outsave;
                memcpy((void */* __restrict  */)dirs, (void const   */* __restrict  */)dirsave,
                       sizeof(int ) * (unsigned long )(lev + 1));
                free((void *)dirsave);
                htmldescend = 10;
              } else {
                htmldescend = 0;
              }
              descend = 0;
            }
          }
          if (descend) {
            if (hasfulltree) {
              subdir = (*dir)->child;
              err = (*dir)->err;
            } else {
              push_files(newpath, & ig, & inf);
              subdir = read_dir(newpath, & n, (unsigned long )inf != (unsigned long )((void *)0));
              if (! subdir) {
                if (n) {
                  err = (char *)"error opening dir";
                  errors ++;
                }
              }
              if (flimit > 0) {
                if (n > flimit) {
                  err = errbuf;
                  sprintf((char *)((char */* __restrict  */)err), (char const   *)((char const   */* __restrict  */)"%d entries exceeds filelimit, not opening dir"),
                          n);
                  errors ++;
                  free_dir(subdir);
                  subdir = (struct _info **)((void *)0);
                }
              }
            }
            if ((unsigned long )subdir == (unsigned long )((void *)0)) {
              descend = 0;
            }
          }
        }
      }
    } else {
      (tot.files) ++;
    }
    if (Jflag) {
      if (errors) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    } else {
      tmp___6 = 0;
    }
    needsclosed = (*(lc.printfile))(dirname, filename, *dir, (descend + htmldescend) + tmp___6);
    if (err) {
      (*(lc.error))(err);
    }
    if (descend) {
      (*(lc.newline))(*dir, lev, 0, 0);
      subtotal = listdir(newpath, subdir, lev + 1, dev, hasfulltree);
      tot.dirs += subtotal.dirs;
      tot.files += subtotal.files;
      tot.size += subtotal.size;
    } else
    if (! needsclosed) {
      (*(lc.newline))(*dir, lev, 0, (unsigned long )*(dir + 1) != (unsigned long )((void *)0));
    }
    if (subdir) {
      free_dir(subdir);
      subdir = (struct _info **)((void *)0);
    }
    if (needsclosed) {
      if (descend) {
        tmp___7 = lev;
      } else {
        tmp___7 = -1;
      }
      (*(lc.close))(*dir, tmp___7, (unsigned long )*(dir + 1) != (unsigned long )((void *)0));
    }
    if (*(dir + 1)) {
      if (! *(dir + 2)) {
        *(dirs + lev) = 2;
      }
    }
    tot.size += (*dir)->size;
    if ((unsigned long )ig != (unsigned long )((void *)0)) {
      ig = pop_filterstack();
    }
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
      inf = pop_infostack();
    }
    dir ++;
  }
  *(dirs + lev) = 0;
  free((void *)path___0);
  return (tot);
}
}
/* END FUNCTION-DEF listdir LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF class LOC=UNKNOWN */
char *class(struct _info *info___1 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if (info___1->isdir) {
    tmp___2 = (char *)"DIR";
  } else {
    if (info___1->isexe) {
      tmp___1 = (char *)"EXEC";
    } else {
      if (info___1->isfifo) {
        tmp___0 = (char *)"FIFO";
      } else {
        if (info___1->issok) {
          tmp = (char *)"SOCK";
        } else {
          tmp = (char *)"NORM";
        }
        tmp___0 = tmp;
      }
      tmp___1 = tmp___0;
    }
    tmp___2 = tmp___1;
  }
  return (tmp___2);
}
}
/* END FUNCTION-DEF class LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_outtro LOC=UNKNOWN */
void xml_outtro(void) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</tree>\n"));
  return;
}
}
/* END FUNCTION-DEF xml_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_report LOC=UNKNOWN */
void html_report(struct totals tot ) 
{ 
  char buf___1[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<br><br><p>\n\n"));
  if (duflag) {
    psize(buf___1, tot.size);
    if (hflag) {
      tmp = (char *)"";
    } else
    if (siflag) {
      tmp = (char *)"";
    } else {
      tmp = (char *)" bytes";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s used in "),
            buf___1, tmp);
  }
  if (dflag) {
    if (tot.dirs == 1UL) {
      tmp___0 = (char *)"y";
    } else {
      tmp___0 = (char *)"ies";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s\n"),
            tot.dirs, tmp___0);
  } else {
    if (tot.files == 1UL) {
      tmp___1 = (char *)"";
    } else {
      tmp___1 = (char *)"s";
    }
    if (tot.dirs == 1UL) {
      tmp___2 = (char *)"y";
    } else {
      tmp___2 = (char *)"ies";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s, %ld file%s\n"),
            tot.dirs, tmp___2, tot.files, tmp___1);
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n</p>\n"));
  return;
}
}
/* END FUNCTION-DEF html_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF psize LOC=UNKNOWN */
int psize(char *buf___1 , off_t size ) 
{ 
  char *unit ;
  char *tmp ;
  int idx ;
  int usize ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  if (siflag) {
    tmp = si_unit;
  } else {
    tmp = iec_unit;
  }
  unit = tmp;
  if (siflag) {
    tmp___0 = 1000;
  } else {
    tmp___0 = 1024;
  }
  usize = tmp___0;
  if (hflag) {
    goto _L;
  } else
  if (siflag) {
    _L: 
    if (size < (off_t )usize) {
      idx = 0;
    } else {
      idx = 1;
    }
    while (size >= (off_t )(usize * usize)) {
      idx ++;
      size /= (off_t )usize;
    }
    if (! idx) {
      tmp___1 = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)" %4d"),
                        (int )size);
      return (tmp___1);
    } else {
      if (size / (off_t )usize >= 10LL) {
        tmp___2 = (char *)" %3.0f%c";
      } else {
        tmp___2 = (char *)" %3.1f%c";
      }
      tmp___3 = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)tmp___2),
                        (double )((float )size / (float )usize), (int )*(unit + idx));
      return (tmp___3);
    }
  } else {
    if (sizeof(off_t ) == sizeof(long long )) {
      tmp___4 = (char *)" %11lld";
    } else {
      tmp___4 = (char *)" %9lld";
    }
    tmp___5 = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)tmp___4),
                      size);
    return (tmp___5);
  }
}
}
/* END FUNCTION-DEF psize LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_infofile LOC=UNKNOWN */
struct infofile *new_infofile(char *path___0 ) 
{ 
  char buf___1[4096] ;
  struct infofile *inf ;
  struct comment *chead ;
  struct comment *cend ;
  struct comment *com ;
  struct pattern *phead ;
  struct pattern *pend ;
  struct pattern *p ;
  char *line[4096] ;
  FILE *fp ;
  int lines ;
  int tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  struct comment *tmp___4 ;
  int i ;
  struct pattern *tmp___5 ;
  char *tmp___6 ;
  struct comment *tmp___7 ;
  int i___0 ;
  void *tmp___8 ;
  size_t___0 tmp___9 ;
  void *tmp___10 ;

  {
  chead = (struct comment *)((void *)0);
  cend = (struct comment *)((void *)0);
  phead = (struct pattern *)((void *)0);
  pend = (struct pattern *)((void *)0);
  lines = 0;
  tmp = strcmp((char const   *)path___0, "/usr/share/finfo/global_info");
  if (tmp == 0) {
    fp = fopen((char const   *)((char const   */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"r"));
  } else {
    snprintf((char *)((char */* __restrict  */)(buf___1)), (size_t___0 )4096, (char const   *)((char const   */* __restrict  */)"%s/.info"),
             path___0);
    fp = fopen((char const   *)((char const   */* __restrict  */)(buf___1)), (char const   *)((char const   */* __restrict  */)"r"));
  }
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return ((struct infofile *)((void *)0));
  }
  while (1) {
    tmp___6 = fgets((char *)((char */* __restrict  */)(buf___1)), 4096, (FILE *)((FILE */* __restrict  */)fp));
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
      break;
    }
    if ((int )buf___1[0] == 35) {
      continue;
    }
    gittrim(buf___1);
    tmp___0 = strlen((char const   *)(buf___1));
    if (tmp___0 < 1UL) {
      continue;
    }
    if ((int )buf___1[0] == 9) {
      tmp___1 = lines;
      lines ++;
      tmp___2 = strlen((char const   *)(buf___1 + 1));
      tmp___3 = xmalloc(tmp___2 + 1UL);
      line[tmp___1] = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(buf___1 + 1)));
    } else {
      if (lines) {
        if (phead) {
          com = new_comment(phead, line, lines);
          if (! chead) {
            cend = com;
            chead = cend;
          } else {
            tmp___4 = com;
            cend->next = tmp___4;
            cend = tmp___4;
          }
        } else {
          i = 0;
          while (i < lines) {
            free((void *)line[i]);
            i ++;
          }
        }
        pend = (struct pattern *)((void *)0);
        phead = pend;
        lines = 0;
      }
      p = new_pattern(buf___1);
      if ((unsigned long )phead == (unsigned long )((void *)0)) {
        pend = p;
        phead = pend;
      } else {
        tmp___5 = p;
        pend->next = tmp___5;
        pend = tmp___5;
      }
    }
  }
  if (phead) {
    com = new_comment(phead, line, lines);
    if (! chead) {
      cend = com;
      chead = cend;
    } else {
      tmp___7 = com;
      cend->next = tmp___7;
      cend = tmp___7;
    }
  } else {
    i___0 = 0;
    while (i___0 < lines) {
      free((void *)line[i___0]);
      i___0 ++;
    }
  }
  fclose(fp);
  tmp___8 = xmalloc(sizeof(struct infofile ));
  inf = (struct infofile *)tmp___8;
  inf->comments = chead;
  tmp___9 = strlen((char const   *)path___0);
  tmp___10 = xmalloc(tmp___9 + 1UL);
  inf->path = strcpy((char *)((char */* __restrict  */)tmp___10), (char const   *)((char const   */* __restrict  */)path___0));
  inf->next = (struct infofile *)((void *)0);
  return (inf);
}
}
/* END FUNCTION-DEF new_infofile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_getfulltree LOC=UNKNOWN */
struct _info **unix_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) 
{ 
  char *path___0 ;
  long pathsize___0 ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **dir ;
  struct _info **sav ;
  struct _info **p ;
  struct _info *sp___0 ;
  struct stat sb ;
  int n ;
  u_long lev_tmp ;
  int tmp_pattern ;
  char *start_rel_path ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t___0 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  size_t___0 tmp___10 ;
  size_t___0 tmp___11 ;
  void *tmp___12 ;
  size_t___0 tmp___13 ;
  size_t___0 tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t___0 tmp___17 ;
  size_t___0 tmp___18 ;
  void *tmp___19 ;
  size_t___0 tmp___20 ;
  size_t___0 tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  pathsize___0 = 0L;
  ig = (struct ignorefile *)((void *)0);
  inf = (struct infofile *)((void *)0);
  tmp_pattern = 0;
  *err = (char *)((void *)0);
  if (Level >= 0) {
    if (lev > (u_long )Level) {
      return ((struct _info **)((void *)0));
    }
  }
  if (xdev) {
    if (lev == 0UL) {
      stat((char const   */* __restrict  */)d, (struct stat */* __restrict  */)(& sb));
      dev = sb.st_dev;
    }
  }
  if (matchdirs) {
    if (pattern) {
      lev_tmp = lev;
      tmp = strlen((char const   *)d);
      start_rel_path = d + tmp;
      tmp___0 = strlen((char const   *)d);
      start_rel_path = d + tmp___0;
      while ((unsigned long )start_rel_path != (unsigned long )d) {
        if ((int )*start_rel_path == 47) {
          lev_tmp --;
        }
        if (lev_tmp <= 0UL) {
          if (*start_rel_path) {
            start_rel_path ++;
          }
          break;
        }
        start_rel_path --;
      }
      if (*start_rel_path) {
        tmp___1 = patinclude(start_rel_path, 1);
        if (tmp___1) {
          tmp_pattern = pattern;
          pattern = 0;
        }
      }
    }
  }
  push_files(d, & ig, & inf);
  dir = read_dir(d, & n, (unsigned long )inf != (unsigned long )((void *)0));
  sav = dir;
  if (tmp_pattern) {
    pattern = tmp_pattern;
    tmp_pattern = 0;
  }
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    if (n) {
      tmp___2 = strlen("error opening dir");
      tmp___3 = xmalloc(tmp___2 + 1UL);
      *err = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)"error opening dir"));
      errors ++;
      return ((struct _info **)((void *)0));
    }
  }
  if (n == 0) {
    if ((unsigned long )sav != (unsigned long )((void *)0)) {
      free_dir(sav);
    }
    return ((struct _info **)((void *)0));
  }
  pathsize___0 = 4096L;
  tmp___4 = xmalloc((size_t___0 )pathsize___0);
  path___0 = (char *)tmp___4;
  if (flimit > 0) {
    if (n > flimit) {
      sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%d entries exceeds filelimit, not opening dir"),
              n);
      tmp___5 = strlen((char const   *)path___0);
      tmp___6 = xmalloc(tmp___5 + 1UL);
      *err = strcpy((char *)((char */* __restrict  */)tmp___6), (char const   *)((char const   */* __restrict  */)path___0));
      free_dir(sav);
      free((void *)path___0);
      return ((struct _info **)((void *)0));
    }
  }
  if (lev >= (u_long )(maxdirs - 1)) {
    maxdirs += 1024;
    tmp___7 = xrealloc((void *)dirs, sizeof(int ) * (unsigned long )maxdirs);
    dirs = (int *)tmp___7;
  }
  while (*dir) {
    if ((*dir)->isdir) {
      if (xdev) {
        if (! (dev != (*dir)->dev)) {
          goto _L___1;
        }
      } else {
        _L___1: 
        if ((*dir)->lnk) {
          if (lflag) {
            tmp___16 = findino((*dir)->inode, (*dir)->dev);
            if (tmp___16) {
              tmp___8 = strlen("recursive, not followed");
              tmp___9 = xmalloc(tmp___8 + 1UL);
              (*dir)->err = strcpy((char *)((char */* __restrict  */)tmp___9), (char const   *)((char const   */* __restrict  */)"recursive, not followed"));
            } else {
              saveino((*dir)->inode, (*dir)->dev);
              if ((int )*((*dir)->lnk) == 47) {
                (*dir)->child = unix_getfulltree((*dir)->lnk, lev + 1UL, dev, & (*dir)->size,
                                                 & (*dir)->err);
              } else {
                tmp___13 = strlen((char const   *)d);
                tmp___14 = strlen((char const   *)(*dir)->lnk);
                if ((tmp___13 + tmp___14) + 2UL > (size_t___0 )pathsize___0) {
                  tmp___10 = strlen((char const   *)d);
                  tmp___11 = strlen((char const   *)(*dir)->name);
                  pathsize___0 = (long )((tmp___10 + tmp___11) + 1024UL);
                  tmp___12 = xrealloc((void *)path___0, (size_t___0 )pathsize___0);
                  path___0 = (char *)tmp___12;
                }
                if (fflag) {
                  tmp___15 = strcmp((char const   *)d, "/");
                  if (tmp___15) {
                    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
                            d, (*dir)->lnk);
                  } else {
                    sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
                            d, (*dir)->lnk);
                  }
                } else {
                  sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
                          d, (*dir)->lnk);
                }
                (*dir)->child = unix_getfulltree(path___0, lev + 1UL, dev, & (*dir)->size,
                                                 & (*dir)->err);
              }
            }
          }
        } else {
          tmp___20 = strlen((char const   *)d);
          tmp___21 = strlen((char const   *)(*dir)->name);
          if ((tmp___20 + tmp___21) + 2UL > (size_t___0 )pathsize___0) {
            tmp___17 = strlen((char const   *)d);
            tmp___18 = strlen((char const   *)(*dir)->name);
            pathsize___0 = (long )((tmp___17 + tmp___18) + 1024UL);
            tmp___19 = xrealloc((void *)path___0, (size_t___0 )pathsize___0);
            path___0 = (char *)tmp___19;
          }
          if (fflag) {
            tmp___22 = strcmp((char const   *)d, "/");
            if (tmp___22) {
              sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
                      d, (*dir)->name);
            } else {
              sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s%s"),
                      d, (*dir)->name);
            }
          } else {
            sprintf((char *)((char */* __restrict  */)path___0), (char const   *)((char const   */* __restrict  */)"%s/%s"),
                    d, (*dir)->name);
          }
          saveino((*dir)->inode, (*dir)->dev);
          (*dir)->child = unix_getfulltree(path___0, lev + 1UL, dev, & (*dir)->size,
                                           & (*dir)->err);
        }
        if (pruneflag) {
          if ((unsigned long )(*dir)->child == (unsigned long )((void *)0)) {
            if (matchdirs) {
              if (pattern) {
                tmp___23 = patinclude((*dir)->name, (int )(*dir)->isdir);
                if (! tmp___23) {
                  goto _L___0;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              sp___0 = *dir;
              p = dir;
              while (*p) {
                *p = *(p + 1);
                p ++;
              }
              n --;
              free((void *)sp___0->name);
              if (sp___0->lnk) {
                free((void *)sp___0->lnk);
              }
              free((void *)sp___0);
              continue;
            }
          }
        }
      }
    }
    if (duflag) {
      *size += (*dir)->size;
    }
    dir ++;
  }
  if (topsort) {
    qsort((void *)sav, (size_t___1 )n, sizeof(struct _info *), (int (*)(void const   * ,
                                                                        void const   * ))topsort);
  }
  free((void *)path___0);
  if (n == 0) {
    free_dir(sav);
    return ((struct _info **)((void *)0));
  }
  if ((unsigned long )ig != (unsigned long )((void *)0)) {
    pop_filterstack();
  }
  if ((unsigned long )inf != (unsigned long )((void *)0)) {
    pop_infostack();
  }
  return (sav);
}
}
/* END FUNCTION-DEF unix_getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fsizesort LOC=UNKNOWN */
int fsizesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = sizecmp((*a)->size, (*b)->size);
  v = tmp;
  if (v == 0) {
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
  }
  if (reverse) {
    tmp___0 = - v;
  } else {
    tmp___0 = v;
  }
  return (tmp___0);
}
}
/* END FUNCTION-DEF fsizesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fillinfo LOC=UNKNOWN */
char *fillinfo(char *buf___1 , struct _info *ent ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  n = 0;
  *(buf___1 + n) = (char)0;
  if (inodeflag) {
    tmp = sprintf((char *)((char */* __restrict  */)buf___1), (char const   *)((char const   */* __restrict  */)" %7ld"),
                  (long )ent->linode);
    n += tmp;
  }
  if (devflag) {
    tmp___0 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %3d"),
                      (int )ent->ldev);
    n += tmp___0;
  }
  if (pflag) {
    tmp___1 = prot(ent->mode);
    tmp___2 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %s"),
                      tmp___1);
    n += tmp___2;
  }
  if (uflag) {
    tmp___3 = uidtoname(ent->uid);
    tmp___4 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %-8.32s"),
                      tmp___3);
    n += tmp___4;
  }
  if (gflag) {
    tmp___5 = gidtoname(ent->gid);
    tmp___6 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %-8.32s"),
                      tmp___5);
    n += tmp___6;
  }
  if (sflag) {
    tmp___7 = psize(buf___1 + n, ent->size);
    n += tmp___7;
  }
  if (Dflag) {
    if (cflag) {
      tmp___8 = ent->ctime;
    } else {
      tmp___8 = ent->mtime;
    }
    tmp___9 = do_date(tmp___8);
    tmp___10 = sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)" %s"),
                       tmp___9);
    n += tmp___10;
  }
  if ((int )*(buf___1 + 0) == 32) {
    *(buf___1 + 0) = (char )'[';
    sprintf((char *)((char */* __restrict  */)(buf___1 + n)), (char const   *)((char const   */* __restrict  */)"]"));
  }
  return (buf___1);
}
}
/* END FUNCTION-DEF fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_printfile LOC=UNKNOWN */
int xml_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int t ;
  int mt ;
  int i ;

  {
  if (file) {
    if (file->lnk) {
      mt = (int )(file->mode & 61440U);
    } else {
      mt = (int )(file->mode & 61440U);
    }
  } else {
    mt = 0;
  }
  t = 0;
  while (ifmt[t]) {
    if (ifmt[t] == (int const   )mt) {
      break;
    }
    t ++;
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<%s"),
          ftype[t]);
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" name=\""));
  html_encode(outfile, filename);
  fputc('\"', outfile);
  if (file) {
    if (file->comment) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" info=\""));
      i = 0;
      while (*(file->comment + i)) {
        html_encode(outfile, *(file->comment + i));
        if (*(file->comment + (i + 1))) {
          fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
        }
        i ++;
      }
      fputc('\"', outfile);
    }
  }
  if (file) {
    if (file->lnk) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" target=\""));
      html_encode(outfile, file->lnk);
      fputc('\"', outfile);
    }
  }
  if (file) {
    xml_fillinfo(file);
  }
  fputc('>', outfile);
  return (1);
}
}
/* END FUNCTION-DEF xml_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF nextpc LOC=UNKNOWN */
char *nextpc(char **p , int *tok ) 
{ 
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  s = *p;
  if (! *(*p)) {
    *tok = 3;
    return ((char *)((void *)0));
  }
  if (prev) {
    prev = (char)0;
    *tok = 0;
    return ((char *)((void *)0));
  }
  tmp = strchr((char const   *)file_pathsep, (int )*(*p));
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    (*p) ++;
    *tok = 0;
    return ((char *)((void *)0));
  }
  while (1) {
    if (*(*p)) {
      tmp___0 = strchr((char const   *)file_pathsep, (int )*(*p));
      if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    (*p) ++;
  }
  if (*(*p)) {
    *tok = 1;
    prev = *(*p);
    tmp___1 = *p;
    (*p) ++;
    *tmp___1 = (char )'\000';
  } else {
    *tok = 2;
  }
  return (s);
}
}
/* END FUNCTION-DEF nextpc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_newline LOC=UNKNOWN */
void xml_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 


  {
  if (postdir >= 0) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
  }
  return;
}
}
/* END FUNCTION-DEF xml_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_indent LOC=UNKNOWN */
void xml_indent(int maxlevel ) 
{ 
  int i ;

  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
  i = 0;
  while (i < maxlevel) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
    i ++;
  }
  return;
}
}
/* END FUNCTION-DEF xml_indent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF emit_tree LOC=UNKNOWN */
void emit_tree(char **dirname , bool needfulltree ) 
{ 
  struct totals tot ;
  struct ignorefile *ig ;
  struct infofile *inf ;
  struct _info **dir ;
  struct _info *info___1 ;
  char *err ;
  int i ;
  int j ;
  int n ;
  int needsclosed ;
  struct stat st ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  int tmp___1 ;
  struct totals __constr_expr_0 ;

  {
  tot.files = (u_long )0;
  tot.dirs = 0UL;
  tot.size = 0LL;
  ig = (struct ignorefile *)((void *)0);
  inf = (struct infofile *)((void *)0);
  dir = (struct _info **)((void *)0);
  info___1 = (struct _info *)((void *)0);
  (*(lc.intro))();
  i = 0;
  while (*(dirname + i)) {
    if (fflag) {
      tmp = strlen((char const   *)*(dirname + i));
      j = (int )tmp;
      while (1) {
        if (j > 1) {
          if ((int )*(*(dirname + i) + (j - 1)) == 47) {
            j --;
            *(*(dirname + i) + j) = (char)0;
          }
        }
        if (j > 1) {
          if (! ((int )*(*(dirname + i) + (j - 1)) == 47)) {
            break;
          }
        } else {
          break;
        }
      }
    }
    if (Hflag) {
      tmp___0 = strlen((char const   *)*(dirname + i));
      htmldirlen = (int )tmp___0;
    }
    n = lstat((char const   *)((char const   */* __restrict  */)*(dirname + i)), (struct stat *)((struct stat */* __restrict  */)(& st)));
    if (n >= 0) {
      saveino(st.st_ino, st.st_dev);
      info___1 = stat2info(& st);
      info___1->name = *(dirname + i);
      if (needfulltree) {
        dir = (*getfulltree)(*(dirname + i), (u_long )0, st.st_dev, & info___1->size,
                             & err);
        if (err) {
          n = -1;
        } else {
          n = 0;
        }
      } else {
        push_files(*(dirname + i), & ig, & inf);
        dir = read_dir(*(dirname + i), & n, (unsigned long )inf != (unsigned long )((void *)0));
      }
      (*(lc.printinfo))(*(dirname + i), info___1, 0);
    } else {
      info___1 = (struct _info *)((void *)0);
    }
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
      tmp___1 = 1;
    } else
    if (! dir) {
      if (n) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    needsclosed = (*(lc.printfile))((char *)((void *)0), *(dirname + i), info___1,
                                    tmp___1);
    if (! dir) {
      if (n) {
        (*(lc.error))((char *)"error opening dir");
        (*(lc.newline))(info___1, 0, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
        errors ++;
      } else {
        goto _L___0;
      }
    } else
    _L___0: 
    if (flimit > 0) {
      if (n > flimit) {
        sprintf((char *)((char */* __restrict  */)(errbuf)), (char const   *)((char const   */* __restrict  */)"%d entries exceeds filelimit, not opening dir"),
                n);
        (*(lc.error))(errbuf);
        (*(lc.newline))(info___1, 0, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
        errors ++;
      } else {
        goto _L;
      }
    } else {
      _L: 
      (*(lc.newline))(info___1, 0, 0, 0);
      if (dir) {
        tot = listdir(*(dirname + i), dir, 1, st.st_dev, needfulltree);
      } else {
        __constr_expr_0.files = (u_long )0;
        __constr_expr_0.dirs = (u_long )0;
        __constr_expr_0.size = 0LL;
        tot = __constr_expr_0;
      }
    }
    if (dir) {
      free_dir(dir);
      dir = (struct _info **)((void *)0);
    }
    if (needsclosed) {
      (*(lc.close))(info___1, 0, (unsigned long )*(dirname + (i + 1)) != (unsigned long )((void *)0));
    }
    if (duflag) {
      tot.size = info___1->size;
    } else {
      tot.size += st.st_size;
    }
    if ((unsigned long )ig != (unsigned long )((void *)0)) {
      ig = pop_filterstack();
    }
    if ((unsigned long )inf != (unsigned long )((void *)0)) {
      inf = pop_infostack();
    }
    i ++;
  }
  if (! noreport) {
    (*(lc.report))(tot);
  }
  (*(lc.outtro))();
  return;
}
}
/* END FUNCTION-DEF emit_tree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF pop_filterstack LOC=UNKNOWN */
struct ignorefile *pop_filterstack(void) 
{ 
  struct ignorefile *ig ;
  struct pattern *p ;
  struct pattern *c ;

  {
  ig = filterstack;
  filterstack = filterstack->next;
  c = ig->remove;
  p = c;
  while ((unsigned long )p != (unsigned long )((void *)0)) {
    p = p->next;
    free((void *)c->pattern);
    c = p;
  }
  c = ig->reverse;
  p = c;
  while ((unsigned long )p != (unsigned long )((void *)0)) {
    p = p->next;
    free((void *)c->pattern);
    c = p;
  }
  free((void *)ig->path);
  free((void *)ig);
  return ((struct ignorefile *)((void *)0));
}
}
/* END FUNCTION-DEF pop_filterstack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xmalloc LOC=UNKNOWN */
void *xmalloc(size_t___0 size ) 
{ 
  register void *value ;
  void *tmp ;

  {
  tmp = malloc(size);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: virtual memory exhausted.\n"));
    exit(1);
  }
  return (value);
}
}
/* END FUNCTION-DEF xmalloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF patmatch LOC=UNKNOWN */
int patmatch(char *buf___1 , char *pat , int isdir ) 
{ 
  int match ;
  int m ;
  int n ;
  char *bar ;
  char *tmp ;
  char pprev ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  int f ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char tmp___10 ;
  char tmp___11 ;
  char *tmp___12 ;

  {
  match = 1;
  tmp = strchr((char const   *)pat, '|');
  bar = tmp;
  pprev = (char)0;
  if (bar) {
    if ((unsigned long )bar == (unsigned long )pat) {
      return (-1);
    } else
    if (! *(bar + 1)) {
      return (-1);
    }
    *bar = (char )'\000';
    match = patmatch(buf___1, pat, isdir);
    if (! match) {
      match = patmatch(buf___1, bar + 1, isdir);
    }
    *bar = (char )'|';
    return (match);
  }
  while (1) {
    if (*pat) {
      if (! match) {
        break;
      }
    } else {
      break;
    }
    switch ((int )*pat) {
    case 91: 
    pat ++;
    if ((int )*pat != 94) {
      n = 1;
      match = 0;
    } else {
      pat ++;
      n = 0;
    }
    while ((int )*pat != 93) {
      if ((int )*pat == 92) {
        pat ++;
      }
      if (! *pat) {
        return (-1);
      }
      if ((int )*(pat + 1) == 45) {
        m = (int )*pat;
        pat += 2;
        if ((int )*pat == 92) {
          if (*pat) {
            pat ++;
          }
        }
        tmp___0 = cond_lower(*buf___1);
        tmp___1 = cond_lower((char )m);
        if ((int )tmp___0 >= (int )tmp___1) {
          tmp___2 = cond_lower(*buf___1);
          tmp___3 = cond_lower(*pat);
          if ((int )tmp___2 <= (int )tmp___3) {
            match = n;
          }
        }
        if (! *pat) {
          pat --;
        }
      } else {
        tmp___4 = cond_lower(*buf___1);
        tmp___5 = cond_lower(*pat);
        if ((int )tmp___4 == (int )tmp___5) {
          match = n;
        }
      }
      pat ++;
    }
    buf___1 ++;
    break;
    case 42: 
    pat ++;
    if (! *pat) {
      tmp___6 = strchr((char const   *)buf___1, '/');
      f = (unsigned long )tmp___6 == (unsigned long )((void *)0);
      return (f);
    }
    match = 0;
    if ((int )*pat == 42) {
      pat ++;
      if (! *pat) {
        return (1);
      }
      while (1) {
        if (*buf___1) {
          match = patmatch(buf___1, pat, isdir);
          if (match) {
            break;
          }
        } else {
          break;
        }
        if ((int )pprev == 47) {
          if ((int )*pat == 47) {
            if (*(pat + 1)) {
              match = patmatch(buf___1, pat + 1, isdir);
              if (match) {
                return (match);
              }
            }
          }
        }
        buf___1 ++;
        while (1) {
          if (*buf___1) {
            if (! ((int )*buf___1 != 47)) {
              break;
            }
          } else {
            break;
          }
          buf___1 ++;
        }
      }
    } else {
      while (1) {
        if (*buf___1) {
          tmp___7 = buf___1;
          buf___1 ++;
          match = patmatch(tmp___7, pat, isdir);
          if (match) {
            break;
          }
        } else {
          break;
        }
        if ((int )*buf___1 == 47) {
          break;
        }
      }
    }
    if (! match) {
      if (! *buf___1) {
        match = patmatch(buf___1, pat, isdir);
      } else
      if ((int )*buf___1 == 47) {
        match = patmatch(buf___1, pat, isdir);
      }
    }
    return (match);
    case 63: 
    if (! *buf___1) {
      return (0);
    }
    buf___1 ++;
    break;
    case 47: 
    if (! *(pat + 1)) {
      if (! *buf___1) {
        return (isdir);
      }
    }
    tmp___8 = buf___1;
    buf___1 ++;
    match = (int )*tmp___8 == (int )*pat;
    break;
    case 92: 
    if (*pat) {
      pat ++;
    }
    default: 
    tmp___9 = buf___1;
    buf___1 ++;
    tmp___10 = cond_lower(*tmp___9);
    tmp___11 = cond_lower(*pat);
    match = (int )tmp___10 == (int )tmp___11;
    break;
    }
    tmp___12 = pat;
    pat ++;
    pprev = *tmp___12;
    if (match < 1) {
      return (match);
    }
  }
  if (! *buf___1) {
    return (match);
  }
  return (0);
}
}
/* END FUNCTION-DEF patmatch LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_newline LOC=UNKNOWN */
void html_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<br>\n"));
  return;
}
}
/* END FUNCTION-DEF html_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF infocheck LOC=UNKNOWN */
struct comment *infocheck(char *path___0 , char *name , int top , int isdir ) 
{ 
  struct infofile *inf ;
  struct comment *com ;
  struct pattern *p ;
  int tmp ;
  int tmp___0 ;

  {
  inf = infostack;
  if ((unsigned long )inf == (unsigned long )((void *)0)) {
    return ((struct comment *)((void *)0));
  }
  inf = infostack;
  while ((unsigned long )inf != (unsigned long )((void *)0)) {
    com = inf->comments;
    while ((unsigned long )com != (unsigned long )((void *)0)) {
      p = com->pattern;
      while ((unsigned long )p != (unsigned long )((void *)0)) {
        tmp = patmatch(path___0, p->pattern, isdir);
        if (tmp == 1) {
          return (com);
        }
        if (top) {
          tmp___0 = patmatch(name, p->pattern, isdir);
          if (tmp___0 == 1) {
            return (com);
          }
        }
        p = p->next;
      }
      com = com->next;
    }
    top = 0;
    inf = inf->next;
  }
  return ((struct comment *)((void *)0));
}
}
/* END FUNCTION-DEF infocheck LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_ignorefile LOC=UNKNOWN */
struct ignorefile *new_ignorefile(char *path___0 ) 
{ 
  char buf___1[4096] ;
  struct ignorefile *ig ;
  struct pattern *remove___0 ;
  struct pattern *remend ;
  struct pattern *p ;
  struct pattern *reverse___0 ;
  struct pattern *revend ;
  int rev ;
  FILE *fp ;
  size_t___0 tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;

  {
  remove___0 = (struct pattern *)((void *)0);
  reverse___0 = (struct pattern *)((void *)0);
  snprintf((char *)((char */* __restrict  */)(buf___1)), (size_t___0 )4096, (char const   *)((char const   */* __restrict  */)"%s/.gitignore"),
           path___0);
  fp = fopen((char const   *)((char const   */* __restrict  */)(buf___1)), (char const   *)((char const   */* __restrict  */)"r"));
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return ((struct ignorefile *)((void *)0));
  }
  while (1) {
    tmp___1 = fgets((char *)((char */* __restrict  */)(buf___1)), 4096, (FILE *)((FILE */* __restrict  */)fp));
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
      break;
    }
    if ((int )buf___1[0] == 35) {
      continue;
    }
    rev = (int )buf___1[0] == 33;
    gittrim(buf___1);
    tmp = strlen((char const   *)(buf___1));
    if (tmp == 0UL) {
      continue;
    }
    if (rev) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    p = new_pattern(buf___1 + tmp___0);
    if (rev) {
      if ((unsigned long )reverse___0 == (unsigned long )((void *)0)) {
        revend = p;
        reverse___0 = revend;
      } else {
        revend->next = p;
        revend = p;
      }
    } else
    if ((unsigned long )remove___0 == (unsigned long )((void *)0)) {
      remend = p;
      remove___0 = remend;
    } else {
      remend->next = p;
      remend = p;
    }
  }
  fclose(fp);
  tmp___2 = xmalloc(sizeof(struct ignorefile ));
  ig = (struct ignorefile *)tmp___2;
  ig->remove = remove___0;
  ig->reverse = reverse___0;
  tmp___3 = strlen((char const   *)path___0);
  tmp___4 = xmalloc(tmp___3 + 1UL);
  ig->path = strcpy((char *)((char */* __restrict  */)tmp___4), (char const   *)((char const   */* __restrict  */)path___0));
  ig->next = (struct ignorefile *)((void *)0);
  return (ig);
}
}
/* END FUNCTION-DEF new_ignorefile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF push_files LOC=UNKNOWN */
void push_files(char *dir , struct ignorefile **ig , struct infofile **inf ) 
{ 


  {
  if (gitignore) {
    *ig = new_ignorefile(dir);
    if ((unsigned long )*ig != (unsigned long )((void *)0)) {
      push_filterstack(*ig);
    }
  }
  if (showinfo) {
    *inf = new_infofile(dir);
    if ((unsigned long )*inf != (unsigned long )((void *)0)) {
      push_infostack(*inf);
    }
  }
  return;
}
}
/* END FUNCTION-DEF push_files LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF Ftype LOC=UNKNOWN */
char Ftype(mode_t mode ) 
{ 
  int m ;

  {
  m = (int )(mode & 61440U);
  if (! dflag) {
    if (m == 16384) {
      return ((char )'/');
    } else {
      goto _L;
    }
  } else
  _L: 
  if (m == 49152) {
    return ((char )'=');
  } else
  if (m == 4096) {
    return ((char )'|');
  } else
  if (m == 40960) {
    return ((char )'@');
  } else
  if (m == 32768) {
    if (mode & 73U) {
      return ((char )'*');
    }
  }
  return ((char)0);
}
}
/* END FUNCTION-DEF Ftype LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF url_encode LOC=UNKNOWN */
void url_encode(FILE *fd , char *s ) 
{ 
  char *tmp___0 ;
  int tmp___1 ;

  {
  while (*s) {
    switch ((int )*s) {
    case 32: 
    case 34: 
    case 35: 
    case 37: 
    case 60: 
    case 62: 
    case 91: 
    case 93: 
    case 94: 
    case 92: 
    case 63: 
    case 43: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"%%%02X"),
            (int )*s);
    break;
    case 38: 
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"&amp;"));
    break;
    default: 
    tmp___1 = isprint((int )((u_int )*s));
    if (tmp___1) {
      tmp___0 = (char *)"%c";
    } else {
      tmp___0 = (char *)"%%%02X";
    }
    fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)tmp___0),
            (int )((u_char )*s));
    break;
    }
    s ++;
  }
  return;
}
}
/* END FUNCTION-DEF url_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF split LOC=UNKNOWN */
char **split(char *str , char *delim , int *nwrds ) 
{ 
  int n ;
  char **w ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  n = 128;
  tmp = xmalloc(sizeof(char *) * (unsigned long )n);
  w = (char **)tmp;
  tmp___0 = 0;
  *nwrds = tmp___0;
  *(w + tmp___0) = strtok((char */* __restrict  */)str, (char const   */* __restrict  */)delim);
  while (*(w + *nwrds)) {
    if (*nwrds == n - 2) {
      n += 256;
      tmp___1 = xrealloc((void *)w, sizeof(char *) * (unsigned long )n);
      w = (char **)tmp___1;
    }
    (*nwrds) ++;
    *(w + *nwrds) = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)delim);
  }
  *(w + *nwrds) = (char *)((void *)0);
  return (w);
}
}
/* END FUNCTION-DEF split LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_printinfo LOC=UNKNOWN */
int html_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  char info___1[512] ;

  {
  fillinfo(info___1, file);
  if (metafirst) {
    if ((int )info___1[0] == 91) {
      html_print(info___1);
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
              sp, sp);
    }
    if (! noindent) {
      indent(level);
    }
  } else {
    if (! noindent) {
      indent(level);
    }
    if ((int )info___1[0] == 91) {
      html_print(info___1);
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
              sp, sp);
    }
  }
  return (0);
}
}
/* END FUNCTION-DEF html_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_newline LOC=UNKNOWN */
void json_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  char *tmp ;

  {
  if (needcomma) {
    tmp = (char *)",";
  } else {
    tmp = (char *)"";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s"),
          tmp, _nl);
  return;
}
}
/* END FUNCTION-DEF json_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xrealloc LOC=UNKNOWN */
void *xrealloc(void *ptr , size_t___0 size ) 
{ 
  register void *value ;
  void *tmp ;

  {
  tmp = realloc(ptr, size);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: virtual memory exhausted.\n"));
    exit(1);
  }
  return (value);
}
}
/* END FUNCTION-DEF xrealloc LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cond_lower LOC=UNKNOWN */
__inline static char cond_lower(char c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (ignorecase) {
    tmp = tolower((int )c);
    tmp___0 = tmp;
  } else {
    tmp___0 = (int )c;
  }
  return ((char )tmp___0);
}
}
/* END FUNCTION-DEF cond_lower LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF uidtoname LOC=UNKNOWN */
char *uidtoname(uid_t uid ) 
{ 
  struct xtable *o ;
  struct xtable *p ;
  struct xtable *t ;
  struct passwd *ent ;
  char ubuf[32] ;
  int uent ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;

  {
  uent = (int )(uid & 255U);
  p = utable[uent];
  o = p;
  while (p) {
    if (uid == p->xid) {
      return (p->name);
    } else
    if (uid < p->xid) {
      break;
    }
    o = p;
    p = p->nxt;
  }
  tmp = xmalloc(sizeof(struct xtable ));
  t = (struct xtable *)tmp;
  ent = getpwuid(uid);
  if ((unsigned long )ent != (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)ent->pw_name);
    tmp___1 = xmalloc(tmp___0 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___1), (char const   *)((char const   */* __restrict  */)ent->pw_name));
  } else {
    snprintf((char *)((char */* __restrict  */)(ubuf)), (size_t___0 )30, (char const   *)((char const   */* __restrict  */)"%d"),
             uid);
    ubuf[31] = (char)0;
    tmp___2 = strlen((char const   *)(ubuf));
    tmp___3 = xmalloc(tmp___2 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(ubuf)));
  }
  t->xid = uid;
  t->nxt = p;
  if ((unsigned long )p == (unsigned long )utable[uent]) {
    utable[uent] = t;
  } else {
    o->nxt = t;
  }
  return (t->name);
}
}
/* END FUNCTION-DEF uidtoname LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_error LOC=UNKNOWN */
int html_error(char *error ) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  [%s]"),
          error);
  return (0);
}
}
/* END FUNCTION-DEF html_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_printfile LOC=UNKNOWN */
int unix_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int colored ;
  int c ;
  char tmp ;
  char tmp___0 ;

  {
  colored = 0;
  if (file) {
    if (colorize) {
      if (file->lnk) {
        if (linktargetcolor) {
          colored = color((u_short )file->lnkmode, file->name, file->orphan, (bool )0);
        } else {
          colored = color((u_short )file->mode, file->name, file->orphan, (bool )0);
        }
      } else {
        colored = color((u_short )file->mode, file->name, file->orphan, (bool )0);
      }
    }
  }
  printit(filename);
  if (colored) {
    endcolor();
  }
  if (file) {
    if (Fflag) {
      if (! file->lnk) {
        tmp = Ftype(file->mode);
        c = (int )tmp;
        if (c) {
          fputc(c, outfile);
        }
      }
    }
    if (file->lnk) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" -> "));
      if (colorize) {
        colored = color((u_short )file->lnkmode, file->lnk, file->orphan, (bool )1);
      }
      printit(file->lnk);
      if (colored) {
        endcolor();
      }
      if (Fflag) {
        tmp___0 = Ftype(file->lnkmode);
        c = (int )tmp___0;
        if (c) {
          fputc(c, outfile);
        }
      }
    }
  }
  return (0);
}
}
/* END FUNCTION-DEF unix_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF print_color LOC=UNKNOWN */
int print_color(int color___0 ) 
{ 


  {
  if (! color_code[color___0]) {
    return (0);
  }
  fputs((char const   *)((char const   */* __restrict  */)color_code[22]), (FILE *)((FILE */* __restrict  */)outfile));
  fputs((char const   *)((char const   */* __restrict  */)color_code[color___0]),
        (FILE *)((FILE */* __restrict  */)outfile));
  fputs((char const   *)((char const   */* __restrict  */)color_code[23]), (FILE *)((FILE */* __restrict  */)outfile));
  return (1);
}
}
/* END FUNCTION-DEF print_color LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_report LOC=UNKNOWN */
void unix_report(struct totals tot ) 
{ 
  char buf___1[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  fputc('\n', outfile);
  if (duflag) {
    psize(buf___1, tot.size);
    if (hflag) {
      tmp = (char *)"";
    } else
    if (siflag) {
      tmp = (char *)"";
    } else {
      tmp = (char *)" bytes";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s used in "),
            buf___1, tmp);
  }
  if (dflag) {
    if (tot.dirs == 1UL) {
      tmp___0 = (char *)"y";
    } else {
      tmp___0 = (char *)"ies";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s\n"),
            tot.dirs, tmp___0);
  } else {
    if (tot.files == 1UL) {
      tmp___1 = (char *)"";
    } else {
      tmp___1 = (char *)"s";
    }
    if (tot.dirs == 1UL) {
      tmp___2 = (char *)"y";
    } else {
      tmp___2 = (char *)"ies";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%ld director%s, %ld file%s\n"),
            tot.dirs, tmp___2, tot.files, tmp___1);
  }
  return;
}
}
/* END FUNCTION-DEF unix_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_error LOC=UNKNOWN */
int xml_error(char *error ) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<error>%s</error>"),
          error);
  return (0);
}
}
/* END FUNCTION-DEF xml_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF freefiletree LOC=UNKNOWN */
void freefiletree(struct _info *ent ) 
{ 
  struct _info *ptr ;
  struct _info *t ;

  {
  ptr = ent;
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
    if (ptr->tchild) {
      freefiletree(ptr->tchild);
    }
    t = ptr;
    ptr = ptr->next;
    free((void *)t);
  }
  return;
}
}
/* END FUNCTION-DEF freefiletree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_intro LOC=UNKNOWN */
void html_intro(void) 
{ 
  char const   *tmp ;

  {
  if (charset) {
    tmp = charset;
  } else {
    tmp = "iso-8859-1";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<!DOCTYPE html>\n<html>\n<head>\n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=%s\">\n <meta name=\"Author\" content=\"Made by \'tree\'\">\n <meta name=\"GENERATOR\" content=\"%s\">\n <title>%s</title>\n <style type=\"text/css\">\n  BODY { font-family : monospace, sans-serif;  color: black;}\n  P { font-family : monospace, sans-serif; color: black; margin:0px; padding: 0px;}\n  A:visited { text-decoration : none; margin : 0px; padding : 0px;}\n  A:link    { text-decoration : none; margin : 0px; padding : 0px;}\n  A:hover   { text-decoration: underline; background-color : yellow; margin : 0px; padding : 0px;}\n  A:active  { margin : 0px; padding : 0px;}\n  .VERSION { font-size: small; font-family : arial, sans-serif; }\n  .NORM  { color: black;  }\n  .FIFO  { color: purple; }\n  .CHAR  { color: yellow; }\n  .DIR   { color: blue;   }\n  .BLOCK { color: yellow; }\n  .LINK  { color: aqua;   }\n  .SOCK  { color: fuchsia;}\n  .EXEC  { color: green;  }\n </style>\n</head>\n<body>\n\t<h1>%s</h1><p>\n"),
          tmp, version, title, title);
  return;
}
}
/* END FUNCTION-DEF html_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF setoutput LOC=UNKNOWN */
void setoutput(char *filename ) 
{ 


  {
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      outfile = stdout;
    }
  } else {
    outfile = fopen((char const   *)((char const   */* __restrict  */)filename), (char const   *)((char const   */* __restrict  */)"w"));
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: invalid filename \'%s\'\n"),
              filename);
      exit(1);
    }
  }
  return;
}
}
/* END FUNCTION-DEF setoutput LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_close LOC=UNKNOWN */
void json_close(struct _info *file , int level , int needcomma ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  if (! noindent) {
    json_indent(level - 1);
  }
  if (noindent) {
    tmp = (char *)"";
  } else {
    tmp = (char *)"\n";
  }
  if (needcomma) {
    tmp___0 = (char *)",";
  } else {
    tmp___0 = (char *)"";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"]}%s%s"),
          tmp___0, tmp);
  return;
}
}
/* END FUNCTION-DEF json_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF ctimesort LOC=UNKNOWN */
int ctimesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((*a)->ctime == (*b)->ctime) {
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
    if (reverse) {
      tmp = - v;
    } else {
      tmp = v;
    }
    return (tmp);
  }
  if ((*a)->ctime == (*b)->ctime) {
    v = 0;
  } else {
    if ((*a)->ctime < (*b)->ctime) {
      tmp___0 = -1;
    } else {
      tmp___0 = 1;
    }
    v = tmp___0;
  }
  if (reverse) {
    tmp___1 = - v;
  } else {
    tmp___1 = v;
  }
  return (tmp___1);
}
}
/* END FUNCTION-DEF ctimesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_printinfo LOC=UNKNOWN */
int unix_printinfo(char *dirname , struct _info *file , int level ) 
{ 


  {
  fillinfo(info___0, file);
  if (metafirst) {
    if ((int )info___0[0] == 91) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s  "),
              info___0);
    }
    if (! noindent) {
      indent(level);
    }
  } else {
    if (! noindent) {
      indent(level);
    }
    if ((int )info___0[0] == 91) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s  "),
              info___0);
    }
  }
  return (0);
}
}
/* END FUNCTION-DEF unix_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_printinfo LOC=UNKNOWN */
int xml_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  mode_t mt ;
  int t ;
  char const   *tmp ;

  {
  if (! noindent) {
    xml_indent(level);
  }
  if (file->lnk) {
    mt = file->mode & 61440U;
  } else {
    mt = file->mode & 61440U;
  }
  t = 0;
  while (ifmt[t]) {
    if ((mode_t )ifmt[t] == mt) {
      break;
    }
    t ++;
  }
  tmp = ftype[t];
  file->tag = tmp;
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<%s"),
          tmp);
  return (0);
}
}
/* END FUNCTION-DEF xml_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF usage LOC=UNKNOWN */
void usage(int n ) 
{ 
  FILE *tmp ;

  {
  if (n < 2) {
    tmp = stderr;
  } else {
    tmp = stdout;
  }
  fprintf((FILE *)((FILE */* __restrict  */)tmp), (char const   *)((char const   */* __restrict  */)"usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-L level [-R]] [-H  baseHREF]\n\t[-T title] [-o filename] [-P pattern] [-I pattern] [--gitignore]\n\t[--matchdirs] [--metafirst] [--ignore-case] [--nolinks] [--inodes]\n\t[--device] [--sort[=]<name>] [--dirsfirst] [--filesfirst]\n\t[--filelimit #] [--si] [--du] [--prune] [--charset X]\n\t[--timefmt[=]format] [--fromfile] [--noreport] [--version] [--help]\n\t[--] [directory ...]\n"));
  if (n < 2) {
    return;
  }
  fprintf((FILE *)((FILE */* __restrict  */)stdout), (char const   *)((char const   */* __restrict  */)"  ------- Listing options -------\n  -a            All files are listed.\n  -d            List directories only.\n  -l            Follow symbolic links like directories.\n  -f            Print the full path prefix for each file.\n  -x            Stay on current filesystem only.\n  -L level      Descend only level directories deep.\n  -R            Rerun tree when max dir level reached.\n  -P pattern    List only those files that match the pattern given.\n  -I pattern    Do not list files that match the given pattern.\n  --gitignore   Filter by using .gitignore files.\n  --ignore-case Ignore case when pattern matching.\n  --matchdirs   Include directory names in -P pattern matching.\n  --metafirst   Print meta-data at the beginning of each line.\n  --prune       Prune empty directories from the output.\n  --info        Print information about files found in .info files.\n  --noreport    Turn off file/directory count at end of tree listing.\n  --charset X   Use charset X for terminal/HTML and indentation line output.\n  --filelimit # Do not descend dirs with more than # files in them.\n  -o filename   Output to file instead of stdout.\n  ------- File options -------\n  -q            Print non-printable characters as \'?\'.\n  -N            Print non-printable characters as is.\n  -Q            Quote filenames with double quotes.\n  -p            Print the protections for each file.\n  -u            Displays file owner or UID number.\n  -g            Displays file group owner or GID number.\n  -s            Print the size in bytes of each file.\n  -h            Print the size in a more human readable way.\n  --si          Like -h, but use in SI units (powers of 1000).\n  --du          Compute size of directories by their contents.\n  -D            Print the date of last modification or (-c) status change.\n  --timefmt <f> Print and format time according to the format <f>.\n  -F            Appends \'/\', \'=\', \'*\', \'@\', \'|\' or \'>\' as per ls -F.\n  --inodes      Print inode number of each file.\n  --device      Print device ID number to which each file belongs.\n  ------- Sorting options -------\n  -v            Sort files alphanumerically by version.\n  -t            Sort files by last modification time.\n  -c            Sort files by last status change time.\n  -U            Leave files unsorted.\n  -r            Reverse the order of the sort.\n  --dirsfirst   List directories before files (-U disables).\n  --filesfirst  List files before directories (-U disables).\n  --sort X      Select sort: name,version,size,mtime,ctime.\n  ------- Graphics options -------\n  -i            Don\'t print indentation lines.\n  -A            Print ANSI lines graphic indentation lines.\n  -S            Print with CP437 (console) graphics indentation lines.\n  -n            Turn colorization off always (-C overrides).\n  -C            Turn colorization on always.\n  ------- XML/HTML/JSON options -------\n  -X            Prints out an XML representation of the tree.\n  -J            Prints out an JSON representation of the tree.\n  -H baseHREF   Prints out HTML format with baseHREF as top directory.\n  -T string     Replace the default HTML title and H1 header with string.\n  --nolinks     Turn off hyperlinks in HTML output.\n  ------- Input options -------\n  --fromfile    Reads paths from files (.=stdin)\n  ------- Miscellaneous options -------\n  --version     Print version and exit.\n  --help        Print usage and this help message and exit.\n  --            Options processing terminator.\n"));
  exit(0);
}
}
/* END FUNCTION-DEF usage LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_intro LOC=UNKNOWN */
void json_intro(void) 
{ 
  char *tmp ;

  {
  if (noindent) {
    tmp = (char *)"";
  } else {
    tmp = _nl;
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"[%s"),
          tmp);
  return;
}
}
/* END FUNCTION-DEF json_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF free_dir LOC=UNKNOWN */
void free_dir(struct _info **d ) 
{ 
  int i ;

  {
  i = 0;
  while (*(d + i)) {
    free((void *)(*(d + i))->name);
    if ((*(d + i))->lnk) {
      free((void *)(*(d + i))->lnk);
    }
    free((void *)*(d + i));
    i ++;
  }
  free((void *)d);
  return;
}
}
/* END FUNCTION-DEF free_dir LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF null_close LOC=UNKNOWN */
void null_close(struct _info *file , int level , int needcomma ) 
{ 


  {
  return;
}
}
/* END FUNCTION-DEF null_close LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF mtimesort LOC=UNKNOWN */
int mtimesort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((*a)->mtime == (*b)->mtime) {
    v = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
    if (reverse) {
      tmp = - v;
    } else {
      tmp = v;
    }
    return (tmp);
  }
  if ((*a)->mtime == (*b)->mtime) {
    v = 0;
  } else {
    if ((*a)->mtime < (*b)->mtime) {
      tmp___0 = -1;
    } else {
      tmp___0 = 1;
    }
    v = tmp___0;
  }
  if (reverse) {
    tmp___1 = - v;
  } else {
    tmp___1 = v;
  }
  return (tmp___1);
}
}
/* END FUNCTION-DEF mtimesort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_fillinfo LOC=UNKNOWN */
void json_fillinfo(struct _info *ent ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char nbuf[64] ;
  int i ;
  int tmp___2 ;
  time_t tmp___3 ;
  char *tmp___4 ;

  {
  if (inodeflag) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"inode\":%ld"),
            (long )ent->inode);
  }
  if (devflag) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"dev\":%d"),
            (int )ent->dev);
  }
  if (pflag) {
    tmp = prot(ent->mode);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"mode\":\"%04o\",\"prot\":\"%s\""),
            ent->mode & 4095U, tmp);
  }
  if (uflag) {
    tmp___0 = uidtoname(ent->uid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"user\":\"%s\""),
            tmp___0);
  }
  if (gflag) {
    tmp___1 = gidtoname(ent->gid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"group\":\"%s\""),
            tmp___1);
  }
  if (sflag) {
    if (hflag) {
      goto _L;
    } else
    if (siflag) {
      _L: 
      psize(nbuf, ent->size);
      i = 0;
      while (1) {
        tmp___2 = isspace((int )nbuf[i]);
        if (! tmp___2) {
          break;
        }
        i ++;
      }
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"size\":\"%s\""),
              nbuf + i);
    } else {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"size\":%lld"),
              ent->size);
    }
  }
  if (Dflag) {
    if (cflag) {
      tmp___3 = ent->ctime;
    } else {
      tmp___3 = ent->mtime;
    }
    tmp___4 = do_date(tmp___3);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"time\":\"%s\""),
            tmp___4);
  }
  return;
}
}
/* END FUNCTION-DEF json_fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF push_infostack LOC=UNKNOWN */
void push_infostack(struct infofile *inf ) 
{ 


  {
  if ((unsigned long )inf == (unsigned long )((void *)0)) {
    return;
  }
  inf->next = infostack;
  infostack = inf;
  return;
}
}
/* END FUNCTION-DEF push_infostack LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF versort LOC=UNKNOWN */
int versort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = strverscmp((char const   *)(*a)->name, (char const   *)(*b)->name);
  v = tmp;
  if (reverse) {
    tmp___0 = - v;
  } else {
    tmp___0 = v;
  }
  return (tmp___0);
}
}
/* END FUNCTION-DEF versort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF dirsfirst LOC=UNKNOWN */
int dirsfirst(struct _info **a , struct _info **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )(*a)->isdir != (unsigned int )(*b)->isdir) {
    if ((*a)->isdir) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
  tmp___0 = (*basesort)(a, b);
  return (tmp___0);
}
}
/* END FUNCTION-DEF dirsfirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_printfile LOC=UNKNOWN */
int html_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  char *tmp ;
  int i ;
  int len ;
  size_t___0 tmp___0 ;
  int off ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<a"));
  if (file) {
    if (force_color) {
      tmp = class(file);
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" class=\"%s\""),
              tmp);
    }
    if (file->comment) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" title=\""));
      i = 0;
      while (*(file->comment + i)) {
        html_encode(outfile, *(file->comment + i));
        if (*(file->comment + (i + 1))) {
          fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
        }
        i ++;
      }
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\""));
    }
    if (! nolinks) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" href=\"%s"),
              host);
      if ((unsigned long )dirname != (unsigned long )((void *)0)) {
        tmp___0 = strlen((char const   *)dirname);
        len = (int )tmp___0;
        if (len >= htmldirlen) {
          tmp___1 = htmldirlen;
        } else {
          tmp___1 = 0;
        }
        off = tmp___1;
        url_encode(outfile, dirname + off);
        putc('/', outfile);
        url_encode(outfile, filename);
        if (file->isdir) {
          tmp___2 = (char *)"/";
        } else {
          tmp___2 = (char *)"";
        }
        if (descend > 1) {
          tmp___3 = (char *)"/00Tree.html";
        } else {
          tmp___3 = (char *)"";
        }
        fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s%s\""),
                tmp___3, tmp___2);
      } else {
        if (descend > 1) {
          tmp___4 = (char *)"/00Tree.html";
        } else {
          tmp___4 = (char *)"";
        }
        fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s\""),
                tmp___4);
      }
    }
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)">"));
  if (dirname) {
    html_encode(outfile, filename);
  } else {
    html_encode(outfile, host);
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</a>"));
  return (0);
}
}
/* END FUNCTION-DEF html_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_report LOC=UNKNOWN */
void json_report(struct totals tot ) 
{ 
  char *tmp ;

  {
  if (noindent) {
    tmp = (char *)"";
  } else {
    tmp = (char *)"\n  ";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",%s{\"type\":\"report\""),
          tmp);
  if (duflag) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"size\":%lld"),
            tot.size);
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"directories\":%ld"),
          tot.dirs);
  if (! dflag) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"files\":%ld"),
            tot.files);
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"}"));
  return;
}
}
/* END FUNCTION-DEF json_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF sizecmp LOC=UNKNOWN */
int sizecmp(off_t a , off_t b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (a == b) {
    tmp___0 = 0;
  } else {
    if (a < b) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
/* END FUNCTION-DEF sizecmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF prot LOC=UNKNOWN */
char *prot(mode_t m ) 
{ 
  int i ;
  int b ;

  {
  i = 0;
  while (1) {
    if (ifmt[i]) {
      if (! ((m & 61440U) != (unsigned int )ifmt[i])) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  buf[0] = (char )fmt[i];
  b = 256;
  i = 0;
  while (i < 9) {
    if (m & (unsigned int )b) {
      buf[i + 1] = perms[i];
    } else {
      buf[i + 1] = (char )'-';
    }
    b >>= 1;
    i ++;
  }
  if (m & 2048U) {
    if ((int )buf[3] == 45) {
      buf[3] = (char )'S';
    } else {
      buf[3] = (char )'s';
    }
  }
  if (m & 1024U) {
    if ((int )buf[6] == 45) {
      buf[6] = (char )'S';
    } else {
      buf[6] = (char )'s';
    }
  }
  if (m & 512U) {
    if ((int )buf[9] == 45) {
      buf[9] = (char )'T';
    } else {
      buf[9] = (char )'t';
    }
  }
  buf[10] = (char)0;
  return (buf);
}
}
/* END FUNCTION-DEF prot LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_error LOC=UNKNOWN */
int unix_error(char *error ) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  [%s]"),
          error);
  return (0);
}
}
/* END FUNCTION-DEF unix_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gnu_getcwd LOC=UNKNOWN */
char *gnu_getcwd(void) 
{ 
  int size ;
  char *buffer ;
  void *tmp ;
  char *value ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  size = 100;
  tmp = xmalloc((size_t___0 )size);
  buffer = (char *)tmp;
  while (1) {
    tmp___0 = getcwd(buffer, (size_t___0 )size);
    value = tmp___0;
    if ((unsigned long )value != (unsigned long )((char *)0)) {
      return (buffer);
    }
    size *= 2;
    free((void *)buffer);
    tmp___1 = xmalloc((size_t___0 )size);
    buffer = (char *)tmp___1;
  }
}
}
/* END FUNCTION-DEF gnu_getcwd LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_encode LOC=UNKNOWN */
void json_encode(FILE *fd , char *s ) 
{ 
  char *ctrl ;

  {
  ctrl = (char *)"0-------btn-fr------------------";
  while (*s) {
    if ((int )((unsigned char )*s) < 32) {
      if ((int )*(ctrl + (int )((unsigned char )*s)) != 45) {
        fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\%c"),
                (int )*(ctrl + (int )((unsigned char )*s)));
      } else {
        fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\u%04x"),
                (int )((unsigned char )*s));
      }
    } else
    if ((int )*s == 34) {
      fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\%c"),
              (int )*s);
    } else
    if ((int )*s == 92) {
      fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"\\%c"),
              (int )*s);
    } else {
      fprintf((FILE *)((FILE */* __restrict  */)fd), (char const   *)((char const   */* __restrict  */)"%c"),
              (int )*s);
    }
    s ++;
  }
  return;
}
}
/* END FUNCTION-DEF json_encode LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_indent LOC=UNKNOWN */
void json_indent(int maxlevel ) 
{ 
  int i ;

  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
  i = 0;
  while (i < maxlevel) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"  "));
    i ++;
  }
  return;
}
}
/* END FUNCTION-DEF json_indent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF stat2info LOC=UNKNOWN */
struct _info *stat2info(struct stat *st ) 
{ 


  {
  info.linode = st->st_ino;
  info.ldev = st->st_dev;
  info.mode = st->st_mode;
  info.uid = st->st_uid;
  info.gid = st->st_gid;
  info.size = st->st_size;
  info.atime = st->st_atim.tv_sec;
  info.ctime = st->st_ctim.tv_sec;
  info.mtime = st->st_mtim.tv_sec;
  info.isdir = (bool )((st->st_mode & 61440U) == 16384U);
  info.issok = (bool )((st->st_mode & 61440U) == 49152U);
  info.isfifo = (bool )((st->st_mode & 61440U) == 4096U);
  if (st->st_mode & 73U) {
    info.isexe = (bool )1;
  } else {
    info.isexe = (bool )0;
  }
  return (& info);
}
}
/* END FUNCTION-DEF stat2info LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF saveino LOC=UNKNOWN */
void saveino(ino_t inode , dev_t device ) 
{ 
  struct inotable *it ;
  struct inotable *ip ;
  struct inotable *pp ;
  int hp ;
  void *tmp ;

  {
  hp = (int )(inode & 255ULL);
  ip = itable[hp];
  pp = ip;
  while (ip) {
    if (ip->inode > inode) {
      break;
    }
    if (ip->inode == inode) {
      if (ip->device >= device) {
        break;
      }
    }
    pp = ip;
    ip = ip->nxt;
  }
  if (ip) {
    if (ip->inode == inode) {
      if (ip->device == device) {
        return;
      }
    }
  }
  tmp = xmalloc(sizeof(struct inotable ));
  it = (struct inotable *)tmp;
  it->inode = inode;
  it->device = device;
  it->nxt = ip;
  if ((unsigned long )ip == (unsigned long )itable[hp]) {
    itable[hp] = it;
  } else {
    pp->nxt = it;
  }
  return;
}
}
/* END FUNCTION-DEF saveino LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_error LOC=UNKNOWN */
int json_error(char *error ) 
{ 
  char *tmp ;

  {
  if (noindent) {
    tmp = (char *)"";
  } else {
    tmp = (char *)"\n";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"{\"error\": \"%s\"}%s"),
          error, tmp);
  return (0);
}
}
/* END FUNCTION-DEF json_error LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_intro LOC=UNKNOWN */
void xml_intro(void) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"<?xml version=\"1.0\""));
  if (charset) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" encoding=\"%s\""),
            charset);
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"?>%s<tree>%s"),
          _nl, _nl);
  return;
}
}
/* END FUNCTION-DEF xml_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF patinclude LOC=UNKNOWN */
int patinclude(char *name , int isdir ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < pattern) {
    tmp = patmatch(name, *(patterns + i), isdir);
    if (tmp) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
/* END FUNCTION-DEF patinclude LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_printfile LOC=UNKNOWN */
int json_printfile(char *dirname , char *filename , struct _info *file , int descend ) 
{ 
  int i ;

  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"name\":\""));
  json_encode(outfile, filename);
  fputc('\"', outfile);
  if (file) {
    if (file->comment) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"info\":\""));
      i = 0;
      while (*(file->comment + i)) {
        json_encode(outfile, *(file->comment + i));
        if (*(file->comment + (i + 1))) {
          fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\\n"));
        }
        i ++;
      }
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\""));
    }
  }
  if (file) {
    if (file->lnk) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"target\":\""));
      json_encode(outfile, file->lnk);
      fputc('\"', outfile);
    }
  }
  if (file) {
    json_fillinfo(file);
  }
  if (file) {
    if (file->err) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"error\": \"%s\""),
              file->err);
    }
  }
  if (! descend) {
    fputc('}', outfile);
  } else {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)",\"contents\":["));
  }
  return (descend);
}
}
/* END FUNCTION-DEF json_printfile LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF cmd LOC=UNKNOWN */
int cmd(char *s ) 
{ 
  int i ;
  int tmp ;

  {
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (-1);
  }
  if ((int )*(s + 0) == 42) {
    return (25);
  }
  i = 0;
  while (cmds[i].cmdnum) {
    tmp = strcmp((char const   *)cmds[i].cmd, (char const   *)s);
    if (! tmp) {
      return ((int )cmds[i].cmdnum);
    }
    i ++;
  }
  return (-1);
}
}
/* END FUNCTION-DEF cmd LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF printit LOC=UNKNOWN */
void printit(char *s ) 
{ 
  int c ;
  wchar_t___1 *ws ;
  wchar_t___1 *tp ;
  size_t___0 tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t___1 tmp___2 ;
  int tmp___3 ;

  {
  if (Nflag) {
    if (Qflag) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\"%s\""),
              s);
    } else {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s"),
              s);
    }
    return;
  }
  if (mb_cur_max > 1) {
    tmp = strlen((char const   *)s);
    c = (int )(tmp + 1UL);
    tmp___0 = xmalloc(sizeof(wchar_t___1 ) * (unsigned long )c);
    ws = (wchar_t___1 *)tmp___0;
    tmp___2 = mbstowcs((wchar_t___0 */* __restrict  */)ws, (char const   */* __restrict  */)s,
                       (size_t___1 )c);
    if ((unsigned long long )tmp___2 != 0xffffffffffffffffULL) {
      if (Qflag) {
        putc('\"', outfile);
      }
      tp = ws;
      while (1) {
        if (*tp) {
          if (! (c > 1)) {
            break;
          }
        } else {
          break;
        }
        tmp___1 = iswprint((wint_t )*tp);
        if (tmp___1) {
          fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%lc"),
                  (wint_t )*tp);
        } else
        if (qflag) {
          putc('?', outfile);
        } else {
          fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\\%03o"),
                  (unsigned int )*tp);
        }
        tp ++;
        c --;
      }
      if (Qflag) {
        putc('\"', outfile);
      }
      free((void *)ws);
      return;
    }
    free((void *)ws);
  }
  if (Qflag) {
    putc('\"', outfile);
  }
  while (*s) {
    c = (int )((unsigned char )*s);
    if (c >= 7) {
      if (c <= 13) {
        goto _L;
      } else {
        goto _L___2;
      }
    } else
    _L___2: 
    if (c == 92) {
      goto _L;
    } else
    if (c == 34) {
      if (Qflag) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else
    _L___1: 
    if (c == 32) {
      if (! Qflag) {
        _L: 
        putc('\\', outfile);
        if (c > 13) {
          putc(c, outfile);
        } else {
          putc((int )*("abtnvfr" + (c - 7)), outfile);
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      tmp___3 = isprint(c);
      if (tmp___3) {
        putc(c, outfile);
      } else
      if (qflag) {
        if (mb_cur_max > 1) {
          if (c > 127) {
            putc(c, outfile);
          } else {
            putc('?', outfile);
          }
        } else {
          putc('?', outfile);
        }
      } else {
        fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\\%03o"),
                c);
      }
    }
    s ++;
  }
  if (Qflag) {
    putc('\"', outfile);
  }
  return;
}
}
/* END FUNCTION-DEF printit LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF printcomment LOC=UNKNOWN */
void printcomment(int line , int lines , char *s ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (lines == 1) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            linedraw->csingle);
  } else
  if (line == 0) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            linedraw->ctop);
  } else
  if (line < 2) {
    if (lines == 2) {
      tmp = (char const   *)linedraw->cbot;
    } else {
      tmp = (char const   *)linedraw->cmid;
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            tmp);
  } else {
    if (line == lines - 1) {
      tmp___0 = (char const   *)linedraw->cbot;
    } else {
      tmp___0 = (char const   *)linedraw->cext;
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
            tmp___0);
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s\n"),
          s);
  return;
}
}
/* END FUNCTION-DEF printcomment LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gittrim LOC=UNKNOWN */
void gittrim(char *s ) 
{ 
  int i ;
  int e ;
  size_t___0 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = strlen((char const   *)s);
  e = (int )(tmp - 1UL);
  if ((int )*(s + e) == 10) {
    e --;
  }
  i = e;
  while (i >= 0) {
    if ((int )*(s + i) != 32) {
      break;
    }
    if (i) {
      if ((int )*(s + (i - 1)) != 92) {
        e --;
      }
    }
    i --;
  }
  *(s + (e + 1)) = (char )'\000';
  e = 0;
  i = e;
  while ((int )*(s + i) != 0) {
    if ((int )*(s + i) == 92) {
      i ++;
    }
    tmp___0 = e;
    e ++;
    tmp___1 = i;
    i ++;
    *(s + tmp___0) = *(s + tmp___1);
  }
  *(s + e) = (char )'\000';
  return;
}
}
/* END FUNCTION-DEF gittrim LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF new_pattern LOC=UNKNOWN */
struct pattern *new_pattern(char *pattern___0 ) 
{ 
  struct pattern *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  tmp = xmalloc(sizeof(struct pattern ));
  p = (struct pattern *)tmp;
  if ((int )*(pattern___0 + 0) == 47) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  if ((int )*(pattern___0 + 0) == 47) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = strlen((char const   *)(pattern___0 + tmp___1));
  tmp___3 = xmalloc(tmp___2 + 1UL);
  p->pattern = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(pattern___0 + tmp___0)));
  tmp___4 = strchr((char const   *)pattern___0, '/');
  p->relative = (unsigned long )tmp___4 == (unsigned long )((void *)0);
  p->next = (struct pattern *)((void *)0);
  return (p);
}
}
/* END FUNCTION-DEF new_pattern LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF indent LOC=UNKNOWN */
void indent(int maxlevel ) 
{ 
  int i ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  if (ansilines) {
    if (*(dirs + 1)) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\033(0"));
    }
    i = 1;
    while (1) {
      if (i <= maxlevel) {
        if (! *(dirs + i)) {
          break;
        }
      } else {
        break;
      }
      if (*(dirs + (i + 1))) {
        if (*(dirs + i) == 1) {
          fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"x   "));
        } else {
          printf((char const   *)((char const   */* __restrict  */)"    "));
        }
      } else
      if (*(dirs + i) == 1) {
        fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"tqq "));
      } else {
        fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"mqq "));
      }
      i ++;
    }
    if (*(dirs + 1)) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\033(B"));
    }
  } else {
    if (Hflag) {
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t"));
    }
    i = 1;
    while (1) {
      if (i <= maxlevel) {
        if (! *(dirs + i)) {
          break;
        }
      } else {
        break;
      }
      if (*(dirs + (i + 1))) {
        if (*(dirs + i) == 1) {
          tmp___0 = (char const   *)linedraw->vert;
        } else {
          if (Hflag) {
            tmp = (char *)"&nbsp;&nbsp;&nbsp;";
          } else {
            tmp = (char *)"   ";
          }
          tmp___0 = (char const   *)tmp;
        }
        tmp___2 = tmp___0;
      } else {
        if (*(dirs + i) == 1) {
          tmp___1 = (char const   *)linedraw->vert_left;
        } else {
          tmp___1 = (char const   *)linedraw->corner;
        }
        tmp___2 = tmp___1;
      }
      fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s "),
              tmp___2);
      i ++;
    }
  }
  return;
}
}
/* END FUNCTION-DEF indent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF color LOC=UNKNOWN */
int color(u_short mode , char *name , bool orphan , bool islink ) 
{ 
  struct extensions *e ;
  int l ;
  int xl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t___0 tmp___13 ;
  size_t___0 tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  if (orphan) {
    if (islink) {
      tmp = print_color(21);
      if (tmp) {
        return (1);
      }
    } else {
      tmp___0 = print_color(13);
      if (tmp___0) {
        return (1);
      }
    }
  }
  switch ((int )mode & 61440) {
  case 4096: 
  tmp___1 = print_color(9);
  return (tmp___1);
  case 8192: 
  tmp___2 = print_color(12);
  return (tmp___2);
  case 16384: 
  if ((int )mode & 512) {
    if ((int )mode & 2) {
      tmp___3 = print_color(17);
      if (tmp___3) {
        return (1);
      }
    }
    if (! ((int )mode & 2)) {
      tmp___4 = print_color(19);
      if (tmp___4) {
        return (1);
      }
    }
  }
  if ((int )mode & 2) {
    tmp___5 = print_color(18);
    if (tmp___5) {
      return (1);
    }
  }
  tmp___6 = print_color(7);
  return (tmp___6);
  case 24576: 
  tmp___7 = print_color(11);
  return (tmp___7);
  case 40960: 
  tmp___8 = print_color(8);
  return (tmp___8);
  case 49152: 
  tmp___9 = print_color(14);
  return (tmp___9);
  case 32768: 
  if ((int )mode & 2048) {
    tmp___10 = print_color(15);
    if (tmp___10) {
      return (1);
    }
  }
  if ((int )mode & 1024) {
    tmp___11 = print_color(16);
    if (tmp___11) {
      return (1);
    }
  }
  if ((int )mode & 73) {
    tmp___12 = print_color(20);
    if (tmp___12) {
      return (1);
    }
  }
  tmp___13 = strlen((char const   *)name);
  l = (int )tmp___13;
  e = ext;
  while (e) {
    tmp___14 = strlen((char const   *)e->ext);
    xl = (int )tmp___14;
    if (l > xl) {
      tmp___15 = name + (l - xl);
    } else {
      tmp___15 = name;
    }
    tmp___16 = strcmp((char const   *)tmp___15, (char const   *)e->ext);
    if (! tmp___16) {
      fputs((char const   *)((char const   */* __restrict  */)color_code[22]), (FILE *)((FILE */* __restrict  */)outfile));
      fputs((char const   *)((char const   */* __restrict  */)e->term_flg), (FILE *)((FILE */* __restrict  */)outfile));
      fputs((char const   *)((char const   */* __restrict  */)color_code[23]), (FILE *)((FILE */* __restrict  */)outfile));
      return (1);
    }
    e = e->nxt;
  }
  tmp___17 = print_color(6);
  return (tmp___17);
  }
  tmp___18 = print_color(5);
  return (tmp___18);
}
}
/* END FUNCTION-DEF color LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF newent LOC=UNKNOWN */
struct _info *newent(char *name ) 
{ 
  struct _info *n ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  struct _info *tmp___2 ;

  {
  tmp = xmalloc(sizeof(struct _info ));
  n = (struct _info *)tmp;
  memset((void *)n, 0, sizeof(struct _info ));
  tmp___0 = strlen((char const   *)name);
  tmp___1 = xmalloc(tmp___0 + 1UL);
  n->name = strcpy((char *)((char */* __restrict  */)tmp___1), (char const   *)((char const   */* __restrict  */)name));
  n->child = (struct _info **)((void *)0);
  tmp___2 = (struct _info *)((void *)0);
  n->next = tmp___2;
  n->tchild = tmp___2;
  return (n);
}
}
/* END FUNCTION-DEF newent LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF json_printinfo LOC=UNKNOWN */
int json_printinfo(char *dirname , struct _info *file , int level ) 
{ 
  mode_t mt ;
  int t ;

  {
  if (! noindent) {
    json_indent(level);
  }
  if (file->lnk) {
    mt = file->mode & 61440U;
  } else {
    mt = file->mode & 61440U;
  }
  t = 0;
  while (ifmt[t]) {
    if ((mode_t )ifmt[t] == mt) {
      break;
    }
    t ++;
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"{\"type\":\"%s\""),
          ftype[t]);
  return (0);
}
}
/* END FUNCTION-DEF json_printinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF getinfo LOC=UNKNOWN */
struct _info *getinfo(char *name , char *path___0 ) 
{ 
  struct _info *ent ;
  struct stat st ;
  struct stat lst ;
  int len ;
  int rs ;
  void *tmp ;
  int tmp___0 ;
  int isdir ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t___0 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  size_t___0 tmp___10 ;
  void *tmp___11 ;
  ssize_t tmp___12 ;

  {
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
    lbufsize = 4096;
    tmp = xmalloc((size_t___0 )lbufsize);
    lbuf = (char *)tmp;
  }
  tmp___0 = lstat((char const   *)((char const   */* __restrict  */)path___0), (struct stat *)((struct stat */* __restrict  */)(& lst)));
  if (tmp___0 < 0) {
    return ((struct _info *)((void *)0));
  }
  if ((lst.st_mode & 61440U) == 40960U) {
    rs = stat((char const   */* __restrict  */)path___0, (struct stat */* __restrict  */)(& st));
    if (rs < 0) {
      memset((void *)(& st), 0, sizeof(st));
    }
  } else {
    rs = 0;
    st.st_mode = lst.st_mode;
    st.st_dev = lst.st_dev;
    st.st_ino = lst.st_ino;
  }
  isdir = (st.st_mode & 61440U) == 16384U;
  if (gitignore) {
    tmp___1 = filtercheck(path___0, name, isdir);
    if (tmp___1) {
      return ((struct _info *)((void *)0));
    }
  }
  if ((lst.st_mode & 61440U) != 16384U) {
    if (lflag) {
      if (! ((st.st_mode & 61440U) == 16384U)) {
        goto _L;
      }
    } else
    _L: 
    if (pattern) {
      tmp___2 = patinclude(name, isdir);
      if (! tmp___2) {
        return ((struct _info *)((void *)0));
      }
    }
  }
  if (ipattern) {
    tmp___3 = patignore(name, isdir);
    if (tmp___3) {
      return ((struct _info *)((void *)0));
    }
  }
  if (dflag) {
    if ((st.st_mode & 61440U) != 16384U) {
      return ((struct _info *)((void *)0));
    }
  }
  tmp___4 = xmalloc(sizeof(struct _info ));
  ent = (struct _info *)tmp___4;
  memset((void *)ent, 0, sizeof(struct _info ));
  tmp___5 = strlen((char const   *)name);
  tmp___6 = xmalloc(tmp___5 + 1UL);
  ent->name = strcpy((char *)((char */* __restrict  */)tmp___6), (char const   *)((char const   */* __restrict  */)name));
  ent->mode = lst.st_mode;
  ent->uid = lst.st_uid;
  ent->gid = lst.st_gid;
  ent->size = lst.st_size;
  ent->dev = st.st_dev;
  ent->inode = st.st_ino;
  ent->ldev = lst.st_dev;
  ent->linode = lst.st_ino;
  ent->lnk = (char *)((void *)0);
  ent->orphan = (bool )0;
  ent->err = (char *)((void *)0);
  ent->child = (struct _info **)((void *)0);
  ent->atime = lst.st_atim.tv_sec;
  ent->ctime = lst.st_ctim.tv_sec;
  ent->mtime = lst.st_mtim.tv_sec;
  ent->isdir = (bool )isdir;
  ent->issok = (bool )((st.st_mode & 61440U) == 49152U);
  ent->isfifo = (bool )((st.st_mode & 61440U) == 4096U);
  if (st.st_mode & 73U) {
    ent->isexe = (bool )1;
  } else {
    ent->isexe = (bool )0;
  }
  if ((lst.st_mode & 61440U) == 40960U) {
    if (lst.st_size + 1LL > (off_t )lbufsize) {
      lbufsize = (int )(lst.st_size + 8192LL);
      tmp___7 = xrealloc((void *)lbuf, (size_t___0 )lbufsize);
      lbuf = (char *)tmp___7;
    }
    tmp___12 = readlink((char const   */* __restrict  */)path___0, (char */* __restrict  */)lbuf,
                        (size_t___0 )(lbufsize - 1));
    len = (int )tmp___12;
    if (len < 0) {
      tmp___8 = strlen("[Error reading symbolic link information]");
      tmp___9 = xmalloc(tmp___8 + 1UL);
      ent->lnk = strcpy((char *)((char */* __restrict  */)tmp___9), (char const   *)((char const   */* __restrict  */)"[Error reading symbolic link information]"));
      ent->isdir = (bool )0;
      ent->lnkmode = st.st_mode;
    } else {
      *(lbuf + len) = (char)0;
      tmp___10 = strlen((char const   *)lbuf);
      tmp___11 = xmalloc(tmp___10 + 1UL);
      ent->lnk = strcpy((char *)((char */* __restrict  */)tmp___11), (char const   *)((char const   */* __restrict  */)lbuf));
      if (rs < 0) {
        ent->orphan = (bool )1;
      }
      ent->lnkmode = st.st_mode;
    }
  }
  ent->comment = (char **)((void *)0);
  return (ent);
}
}
/* END FUNCTION-DEF getinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF alnumsort LOC=UNKNOWN */
int alnumsort(struct _info **a , struct _info **b ) 
{ 
  int v ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = strcoll((char const   *)(*a)->name, (char const   *)(*b)->name);
  v = tmp;
  if (reverse) {
    tmp___0 = - v;
  } else {
    tmp___0 = v;
  }
  return (tmp___0);
}
}
/* END FUNCTION-DEF alnumsort LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF file_getfulltree LOC=UNKNOWN */
struct _info **file_getfulltree(char *d , u_long lev , dev_t dev , off_t *size , char **err ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  char *path___0 ;
  char *spath ;
  char *s ;
  long pathsize___0 ;
  struct _info *root ;
  struct _info **cwd ;
  struct _info *ent ;
  int l ;
  int tok ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t___0 tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  struct _info **tmp___8 ;

  {
  tmp___2 = strcmp((char const   *)d, ".");
  if (tmp___2) {
    tmp___0 = fopen((char const   *)((char const   */* __restrict  */)d), (char const   *)((char const   */* __restrict  */)"r"));
    tmp___1 = tmp___0;
  } else {
    tmp___1 = stdin;
  }
  fp = tmp___1;
  root = (struct _info *)((void *)0);
  size = (off_t *)0;
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"Error opening %s for reading.\n"),
            d);
    return ((struct _info **)((void *)0));
  }
  pathsize___0 = 65536L;
  tmp___3 = xmalloc(sizeof(char *) * (unsigned long )pathsize___0);
  path___0 = (char *)tmp___3;
  while (1) {
    tmp___7 = fgets((char *)((char */* __restrict  */)path___0), (int )pathsize___0,
                    (FILE *)((FILE */* __restrict  */)fp));
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
      break;
    }
    if ((unsigned long )file_comment != (unsigned long )((void *)0)) {
      tmp___4 = strcmp((char const   *)path___0, (char const   *)file_comment);
      if (tmp___4 == 0) {
        continue;
      }
    }
    tmp___5 = strlen((char const   *)path___0);
    l = (int )tmp___5;
    while (1) {
      if (l) {
        tmp___6 = isspace((int )*(path___0 + (l - 1)));
        if (! tmp___6) {
          break;
        }
      } else {
        break;
      }
      l --;
      *(path___0 + l) = (char )'\000';
    }
    if (l == 0) {
      continue;
    }
    spath = path___0;
    cwd = & root;
    while (1) {
      s = nextpc(& spath, & tok);
      if (tok == 0) {
        goto __Cont;
      }
      switch (tok) {
      case 0: 
      goto __Cont;
      case 2: 
      case 1: 
      ent = search(cwd, s);
      if (tok == 1) {
        ent->isdir = (bool )1;
        ent->mode = (mode_t )16384;
      } else {
        ent->mode = (mode_t )32768;
      }
      cwd = & ent->tchild;
      break;
      }
      __Cont: 
      if (tok != 2) {
        if (! (tok != 3)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  if ((unsigned long )fp != (unsigned long )stdin) {
    fclose(fp);
  }
  tmp___8 = fprune(root, (bool )0, (bool )1);
  return (tmp___8);
}
}
/* END FUNCTION-DEF file_getfulltree LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_fillinfo LOC=UNKNOWN */
void xml_fillinfo(struct _info *ent ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  time_t tmp___2 ;
  char *tmp___3 ;

  {
  if (inodeflag) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" inode=\"%ld\""),
            (long )ent->inode);
  }
  if (devflag) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" dev=\"%d\""),
            (int )ent->dev);
  }
  if (pflag) {
    tmp = prot(ent->mode);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" mode=\"%04o\" prot=\"%s\""),
            ent->mode & 4095U, tmp);
  }
  if (uflag) {
    tmp___0 = uidtoname(ent->uid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" user=\"%s\""),
            tmp___0);
  }
  if (gflag) {
    tmp___1 = gidtoname(ent->gid);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" group=\"%s\""),
            tmp___1);
  }
  if (sflag) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" size=\"%lld\""),
            ent->size);
  }
  if (Dflag) {
    if (cflag) {
      tmp___2 = ent->ctime;
    } else {
      tmp___2 = ent->mtime;
    }
    tmp___3 = do_date(tmp___2);
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)" time=\"%s\""),
            tmp___3);
  }
  return;
}
}
/* END FUNCTION-DEF xml_fillinfo LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF initlinedraw LOC=UNKNOWN */
void initlinedraw(int flag ) 
{ 
  char const   **s ;
  int tmp ;

  {
  if (flag) {
    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --charset, valid charsets include:\n"));
    linedraw = cstable;
    while (linedraw->name) {
      s = (char const   **)linedraw->name;
      while (*s) {
        fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"  %s\n"),
                *s);
        s ++;
      }
      linedraw ++;
    }
    return;
  }
  if (charset) {
    linedraw = cstable;
    while (linedraw->name) {
      s = (char const   **)linedraw->name;
      while (*s) {
        tmp = strcasecmp(charset, *s);
        if (! tmp) {
          return;
        }
        s ++;
      }
      linedraw ++;
    }
  }
  linedraw = (cstable + sizeof(cstable) / sizeof(cstable[0])) - 1;
  return;
}
}
/* END FUNCTION-DEF initlinedraw LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF html_outtro LOC=UNKNOWN */
void html_outtro(void) 
{ 


  {
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t<hr>\n"));
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t<p class=\"VERSION\">\n"));
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)hversion),
          linedraw->copy, linedraw->copy, linedraw->copy, linedraw->copy);
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\t</p>\n"));
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</body>\n"));
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"</html>\n"));
  return;
}
}
/* END FUNCTION-DEF html_outtro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF null_intro LOC=UNKNOWN */
void null_intro(void) 
{ 


  {
  return;
}
}
/* END FUNCTION-DEF null_intro LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF parse_dir_colors LOC=UNKNOWN */
void parse_dir_colors(void) 
{ 
  char buf___1[1025] ;
  char **arg ;
  char **c ;
  char *colors ;
  char *s ;
  char *cc ;
  int i ;
  int n ;
  int col ;
  struct extensions *e ;
  char *tmp ;
  char *tmp___0 ;
  size_t___0 tmp___1 ;
  int tmp___2 ;
  int i___0 ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  size_t___0 tmp___6 ;
  void *tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  size_t___0 tmp___11 ;
  void *tmp___12 ;
  size_t___0 tmp___13 ;
  void *tmp___14 ;
  size_t___0 tmp___15 ;
  void *tmp___16 ;
  size_t___0 tmp___17 ;
  void *tmp___18 ;
  size_t___0 tmp___19 ;
  void *tmp___20 ;

  {
  if (Hflag) {
    return;
  }
  tmp = getenv("TERM");
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    colorize = (bool )0;
    return;
  }
  s = getenv("TREE_COLORS");
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    s = getenv("LS_COLORS");
  }
  cc = getenv("CLICOLOR");
  tmp___0 = getenv("CLICOLOR_FORCE");
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    if (! nocolor) {
      force_color = (bool )1;
    }
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    goto _L;
  } else {
    tmp___1 = strlen((char const   *)s);
    if (tmp___1 == 0UL) {
      _L: 
      if (force_color) {
        s = (char *)":no=00:rs=0:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:";
      } else
      if ((unsigned long )cc != (unsigned long )((void *)0)) {
        s = (char *)":no=00:rs=0:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.bat=01;32:*.BAT=01;32:*.btm=01;32:*.BTM=01;32:*.cmd=01;32:*.CMD=01;32:*.com=01;32:*.COM=01;32:*.dll=01;32:*.DLL=01;32:*.exe=01;32:*.EXE=01;32:*.arj=01;31:*.bz2=01;31:*.deb=01;31:*.gz=01;31:*.lzh=01;31:*.rpm=01;31:*.tar=01;31:*.taz=01;31:*.tb2=01;31:*.tbz2=01;31:*.tbz=01;31:*.tgz=01;31:*.tz2=01;31:*.z=01;31:*.Z=01;31:*.zip=01;31:*.ZIP=01;31:*.zoo=01;31:*.asf=01;35:*.ASF=01;35:*.avi=01;35:*.AVI=01;35:*.bmp=01;35:*.BMP=01;35:*.flac=01;35:*.FLAC=01;35:*.gif=01;35:*.GIF=01;35:*.jpg=01;35:*.JPG=01;35:*.jpeg=01;35:*.JPEG=01;35:*.m2a=01;35:*.M2a=01;35:*.m2v=01;35:*.M2V=01;35:*.mov=01;35:*.MOV=01;35:*.mp3=01;35:*.MP3=01;35:*.mpeg=01;35:*.MPEG=01;35:*.mpg=01;35:*.MPG=01;35:*.ogg=01;35:*.OGG=01;35:*.ppm=01;35:*.rm=01;35:*.RM=01;35:*.tga=01;35:*.TGA=01;35:*.tif=01;35:*.TIF=01;35:*.wav=01;35:*.WAV=01;35:*.wmv=01;35:*.WMV=01;35:*.xbm=01;35:*.xpm=01;35:";
      }
    }
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    colorize = (bool )0;
    return;
  } else
  if (! force_color) {
    if (nocolor) {
      colorize = (bool )0;
      return;
    } else {
      tmp___2 = isatty(1);
      if (! tmp___2) {
        colorize = (bool )0;
        return;
      }
    }
  }
  colorize = (bool )1;
  i___0 = 0;
  while (i___0 < 25) {
    color_code[i___0] = (char *)((void *)0);
    i___0 ++;
  }
  tmp___3 = strlen((char const   *)s);
  tmp___4 = xmalloc(tmp___3 + 1UL);
  colors = strcpy((char *)((char */* __restrict  */)tmp___4), (char const   *)((char const   */* __restrict  */)s));
  arg = split(colors, (char *)":", & n);
  i = 0;
  while (*(arg + i)) {
    c = split(*(arg + i), (char *)"=", & n);
    col = cmd(*(c + 0));
    switch (col) {
    case -1: 
    break;
    case 25: 
    if (*(c + 1)) {
      tmp___5 = xmalloc(sizeof(struct extensions ));
      e = (struct extensions *)tmp___5;
      tmp___6 = strlen((char const   *)(*(c + 0) + 1));
      tmp___7 = xmalloc(tmp___6 + 1UL);
      e->ext = strcpy((char *)((char */* __restrict  */)tmp___7), (char const   *)((char const   */* __restrict  */)(*(c + 0) + 1)));
      tmp___8 = strlen((char const   *)*(c + 1));
      tmp___9 = xmalloc(tmp___8 + 1UL);
      e->term_flg = strcpy((char *)((char */* __restrict  */)tmp___9), (char const   *)((char const   */* __restrict  */)*(c + 1)));
      e->nxt = ext;
      ext = e;
    }
    break;
    case 8: 
    if (*(c + 1)) {
      tmp___10 = strcasecmp("target", (char const   *)*(c + 1));
      if (tmp___10 == 0) {
        linktargetcolor = (bool )1;
        color_code[8] = (char *)"01;36";
        break;
      }
    }
    default: 
    if (*(c + 1)) {
      tmp___11 = strlen((char const   *)*(c + 1));
      tmp___12 = xmalloc(tmp___11 + 1UL);
      color_code[col] = strcpy((char *)((char */* __restrict  */)tmp___12), (char const   *)((char const   */* __restrict  */)*(c + 1)));
    }
    break;
    }
    free((void *)c);
    i ++;
  }
  free((void *)arg);
  if (! color_code[22]) {
    tmp___13 = strlen("\033[");
    tmp___14 = xmalloc(tmp___13 + 1UL);
    color_code[22] = strcpy((char *)((char */* __restrict  */)tmp___14), (char const   *)((char const   */* __restrict  */)"\033["));
  }
  if (! color_code[23]) {
    tmp___15 = strlen("m");
    tmp___16 = xmalloc(tmp___15 + 1UL);
    color_code[23] = strcpy((char *)((char */* __restrict  */)tmp___16), (char const   *)((char const   */* __restrict  */)"m"));
  }
  if (! color_code[4]) {
    tmp___17 = strlen("0");
    tmp___18 = xmalloc(tmp___17 + 1UL);
    color_code[4] = strcpy((char *)((char */* __restrict  */)tmp___18), (char const   *)((char const   */* __restrict  */)"0"));
  }
  if (! color_code[24]) {
    sprintf((char *)((char */* __restrict  */)(buf___1)), (char const   *)((char const   */* __restrict  */)"%s%s%s"),
            color_code[22], color_code[4], color_code[23]);
    tmp___19 = strlen((char const   *)(buf___1));
    tmp___20 = xmalloc(tmp___19 + 1UL);
    color_code[24] = strcpy((char *)((char */* __restrict  */)tmp___20), (char const   *)((char const   */* __restrict  */)(buf___1)));
  }
  free((void *)colors);
  return;
}
}
/* END FUNCTION-DEF parse_dir_colors LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF read_dir LOC=UNKNOWN */
struct _info **read_dir(char *dir , int *n , int infotop ) 
{ 
  struct comment *com ;
  struct _info **dl ;
  struct _info *info___1 ;
  struct dirent *ent ;
  DIR *d ;
  int ne ;
  int p ;
  int i ;
  int es ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t___0 tmp___6 ;
  size_t___0 tmp___7 ;
  void *tmp___8 ;
  size_t___0 tmp___9 ;
  size_t___0 tmp___10 ;
  void *tmp___11 ;
  size_t___0 tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  struct dirent *tmp___16 ;
  int tmp___17 ;

  {
  p = 0;
  tmp = strlen((char const   *)dir);
  es = (int )*(dir + (tmp - 1UL)) == 47;
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)dir);
    pathsize = (long )(tmp___0 + 4096UL);
    tmp___1 = xmalloc((size_t___0 )pathsize);
    path = (char *)tmp___1;
  }
  *n = -1;
  d = opendir((char const   *)dir);
  if ((unsigned long )d == (unsigned long )((void *)0)) {
    return ((struct _info **)((void *)0));
  }
  ne = 30;
  tmp___2 = xmalloc(sizeof(struct _info *) * (unsigned long )ne);
  dl = (struct _info **)tmp___2;
  while (1) {
    tmp___16 = readdir(d);
    ent = tmp___16;
    if (! ent) {
      break;
    }
    tmp___3 = strcmp("..", (char const   *)(ent->d_name));
    if (tmp___3) {
      tmp___4 = strcmp(".", (char const   *)(ent->d_name));
      if (! tmp___4) {
        continue;
      }
    } else {
      continue;
    }
    if (Hflag) {
      tmp___5 = strcmp((char const   *)(ent->d_name), "00Tree.html");
      if (! tmp___5) {
        continue;
      }
    }
    if (! aflag) {
      if ((int )ent->d_name[0] == 46) {
        continue;
      }
    }
    tmp___9 = strlen((char const   *)dir);
    tmp___10 = strlen((char const   *)(ent->d_name));
    if ((tmp___9 + tmp___10) + 2UL > (size_t___0 )pathsize) {
      tmp___6 = strlen((char const   *)dir);
      tmp___7 = strlen((char const   *)(ent->d_name));
      pathsize = (long )((tmp___6 + tmp___7) + 4096UL);
      tmp___8 = xrealloc((void *)path, (size_t___0 )pathsize);
      path = (char *)tmp___8;
    }
    if (es) {
      sprintf((char *)((char */* __restrict  */)path), (char const   *)((char const   */* __restrict  */)"%s%s"),
              dir, ent->d_name);
    } else {
      sprintf((char *)((char */* __restrict  */)path), (char const   *)((char const   */* __restrict  */)"%s/%s"),
              dir, ent->d_name);
    }
    info___1 = getinfo(ent->d_name, path);
    if (info___1) {
      if (showinfo) {
        com = infocheck(path, ent->d_name, infotop, (int )info___1->isdir);
        if (com) {
          i = 0;
          while ((unsigned long )*(com->desc + i) != (unsigned long )((void *)0)) {
            i ++;
          }
          tmp___11 = xmalloc(sizeof(char *) * (unsigned long )(i + 1));
          info___1->comment = (char **)tmp___11;
          i = 0;
          while ((unsigned long )*(com->desc + i) != (unsigned long )((void *)0)) {
            tmp___12 = strlen((char const   *)*(com->desc + i));
            tmp___13 = xmalloc(tmp___12 + 1UL);
            *(info___1->comment + i) = strcpy((char *)((char */* __restrict  */)tmp___13),
                                              (char const   *)((char const   */* __restrict  */)*(com->desc + i)));
            i ++;
          }
          *(info___1->comment + i) = (char *)((void *)0);
        }
      }
      if (p == ne - 1) {
        ne += 20;
        tmp___14 = xrealloc((void *)dl, sizeof(struct _info *) * (unsigned long )ne);
        dl = (struct _info **)tmp___14;
      }
      tmp___15 = p;
      p ++;
      *(dl + tmp___15) = info___1;
    }
  }
  closedir(d);
  tmp___17 = p;
  *n = tmp___17;
  if (tmp___17 == 0) {
    free((void *)dl);
    return ((struct _info **)((void *)0));
  }
  *(dl + p) = (struct _info *)((void *)0);
  return (dl);
}
}
/* END FUNCTION-DEF read_dir LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF xml_report LOC=UNKNOWN */
void xml_report(struct totals tot ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  if (noindent) {
    tmp = (char *)"";
  } else {
    tmp = (char *)"  ";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<report>%s"),
          tmp, _nl);
  if (duflag) {
    if (noindent) {
      tmp___0 = (char *)"";
    } else {
      tmp___0 = (char *)"    ";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<size>%lld</size>%s"),
            tmp___0, tot.size, _nl);
  }
  if (noindent) {
    tmp___1 = (char *)"";
  } else {
    tmp___1 = (char *)"    ";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<directories>%ld</directories>%s"),
          tmp___1, tot.dirs, _nl);
  if (! dflag) {
    if (noindent) {
      tmp___2 = (char *)"";
    } else {
      tmp___2 = (char *)"    ";
    }
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s<files>%ld</files>%s"),
            tmp___2, tot.files, _nl);
  }
  if (noindent) {
    tmp___3 = (char *)"";
  } else {
    tmp___3 = (char *)"  ";
  }
  fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"%s</report>%s"),
          tmp___3, _nl);
  return;
}
}
/* END FUNCTION-DEF xml_report LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF fprune LOC=UNKNOWN */
struct _info **fprune(struct _info *head , bool matched , bool root ) 
{ 
  struct _info **dir ;
  struct _info *new ;
  struct _info *end ;
  struct _info *ent ;
  struct _info *t ;
  int show ;
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct _info *tmp___2 ;
  void *tmp___3 ;

  {
  new = (struct _info *)((void *)0);
  end = (struct _info *)((void *)0);
  count = 0;
  ent = head;
  while ((unsigned long )ent != (unsigned long )((void *)0)) {
    if (ent->tchild) {
      ent->isdir = (bool )1;
    }
    show = 1;
    if (dflag) {
      if (! ent->isdir) {
        show = 0;
      }
    }
    if (! aflag) {
      if (! root) {
        if ((int )*(ent->name + 0) == 46) {
          show = 0;
        }
      }
    }
    if (show) {
      if (! matched) {
        if (! ent->isdir) {
          if (pattern) {
            tmp = patinclude(ent->name, 0);
            if (! tmp) {
              show = 0;
            }
          }
          if (ipattern) {
            tmp___0 = patignore(ent->name, 0);
            if (tmp___0) {
              show = 0;
            }
          }
        }
        if (ent->isdir) {
          if (show) {
            if (matchdirs) {
              if (pattern) {
                tmp___1 = patinclude(ent->name, 1);
                if (tmp___1) {
                  matched = (bool )1;
                }
              }
            }
          }
        }
      }
    }
    if (pruneflag) {
      if (! matched) {
        if (ent->isdir) {
          if ((unsigned long )ent->tchild == (unsigned long )((void *)0)) {
            show = 0;
          }
        }
      }
    }
    if (show) {
      if ((unsigned long )ent->tchild != (unsigned long )((void *)0)) {
        ent->child = fprune(ent->tchild, matched, (bool )0);
      }
    }
    t = ent;
    ent = ent->next;
    if (show) {
      if (end) {
        tmp___2 = t;
        end->next = tmp___2;
        end = tmp___2;
      } else {
        end = t;
        new = end;
      }
      count ++;
    } else {
      t->next = (struct _info *)((void *)0);
      freefiletree(t);
    }
  }
  if (end) {
    end->next = (struct _info *)((void *)0);
  }
  tmp___3 = xmalloc(sizeof(struct _info *) * (unsigned long )(count + 1));
  dir = (struct _info **)tmp___3;
  count = 0;
  ent = new;
  while ((unsigned long )ent != (unsigned long )((void *)0)) {
    *(dir + count) = ent;
    ent = ent->next;
    count ++;
  }
  *(dir + count) = (struct _info *)((void *)0);
  if (topsort) {
    qsort((void *)dir, (size_t___1 )count, sizeof(struct _info *), (int (*)(void const   * ,
                                                                            void const   * ))topsort);
  }
  return (dir);
}
}
/* END FUNCTION-DEF fprune LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF do_date LOC=UNKNOWN */
char *do_date(time_t t ) 
{ 
  struct tm *tm ;
  time_t c ;
  time_t tmp ;

  {
  tm = localtime((time_t const   *)(& t));
  if (timefmt) {
    strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)timefmt,
             (struct tm  const  */* __restrict  */)tm);
    buf___0[255] = (char)0;
  } else {
    tmp = time((time_t *)0);
    c = tmp;
    if (t > c) {
      strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)"%b %e  %Y",
               (struct tm  const  */* __restrict  */)tm);
    } else
    if (t + 16070400LL < c) {
      strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)"%b %e  %Y",
               (struct tm  const  */* __restrict  */)tm);
    } else {
      strftime((char */* __restrict  */)(buf___0), (size_t___0 )255, (char const   */* __restrict  */)"%b %e %R",
               (struct tm  const  */* __restrict  */)tm);
    }
  }
  return (buf___0);
}
}
/* END FUNCTION-DEF do_date LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF patignore LOC=UNKNOWN */
int patignore(char *name , int isdir ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < ipattern) {
    tmp = patmatch(name, *(ipatterns + i), isdir);
    if (tmp) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
/* END FUNCTION-DEF patignore LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF search LOC=UNKNOWN */
struct _info *search(struct _info **dir , char *name ) 
{ 
  struct _info *ptr ;
  struct _info *prev___0 ;
  struct _info *n ;
  int cmp ;
  struct _info *tmp ;

  {
  if ((unsigned long )*dir == (unsigned long )((void *)0)) {
    tmp = newent(name);
    *dir = tmp;
    return (tmp);
  }
  ptr = *dir;
  prev___0 = ptr;
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
    cmp = strcmp((char const   *)ptr->name, (char const   *)name);
    if (cmp == 0) {
      return (ptr);
    }
    if (cmp > 0) {
      break;
    }
    prev___0 = ptr;
    ptr = ptr->next;
  }
  n = newent(name);
  n->next = ptr;
  if ((unsigned long )prev___0 == (unsigned long )ptr) {
    *dir = n;
  } else {
    prev___0->next = n;
  }
  return (n);
}
}
/* END FUNCTION-DEF search LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF gidtoname LOC=UNKNOWN */
char *gidtoname(gid_t gid ) 
{ 
  struct xtable *o ;
  struct xtable *p ;
  struct xtable *t ;
  struct group *ent ;
  char gbuf[32] ;
  int gent ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  size_t___0 tmp___2 ;
  void *tmp___3 ;

  {
  gent = (int )(gid & 255U);
  p = gtable[gent];
  o = p;
  while (p) {
    if (gid == p->xid) {
      return (p->name);
    } else
    if (gid < p->xid) {
      break;
    }
    o = p;
    p = p->nxt;
  }
  tmp = xmalloc(sizeof(struct xtable ));
  t = (struct xtable *)tmp;
  ent = getgrgid(gid);
  if ((unsigned long )ent != (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)ent->gr_name);
    tmp___1 = xmalloc(tmp___0 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___1), (char const   *)((char const   */* __restrict  */)ent->gr_name));
  } else {
    snprintf((char *)((char */* __restrict  */)(gbuf)), (size_t___0 )30, (char const   *)((char const   */* __restrict  */)"%d"),
             gid);
    gbuf[31] = (char)0;
    tmp___2 = strlen((char const   *)(gbuf));
    tmp___3 = xmalloc(tmp___2 + 1UL);
    t->name = strcpy((char *)((char */* __restrict  */)tmp___3), (char const   *)((char const   */* __restrict  */)(gbuf)));
  }
  t->xid = gid;
  t->nxt = p;
  if ((unsigned long )p == (unsigned long )gtable[gent]) {
    gtable[gent] = t;
  } else {
    o->nxt = t;
  }
  return (t->name);
}
}
/* END FUNCTION-DEF gidtoname LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF main LOC=UNKNOWN */
int main(int argc , char **argv , char **_formal_envp ) 
{ 
  int init_elems1_inline_0_inline_1 ;
  char **dirname ;
  int i ;
  int j ;
  int k ;
  int n ;
  int optf ;
  int p ;
  int q ;
  char *stmp ;
  char *outfilename ;
  bool needfulltree ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct listingcalls __constr_expr_0 ;
  size_t___1 tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct listingcalls __constr_expr_1 ;
  struct listingcalls __constr_expr_2 ;
  struct listingcalls __constr_expr_3 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *v ;
  size_t___0 tmp___18 ;
  int tmp___19 ;
  size_t___0 tmp___20 ;
  int tmp___21 ;
  size_t___0 tmp___22 ;
  int tmp___23 ;
  size_t___0 tmp___24 ;
  int tmp___25 ;
  size_t___0 tmp___26 ;
  int tmp___27 ;
  size_t___0 tmp___28 ;
  int tmp___29 ;
  size_t___0 tmp___30 ;
  int tmp___31 ;
  size_t___0 tmp___32 ;
  int tmp___33 ;
  size_t___0 tmp___34 ;
  int tmp___35 ;
  size_t___0 tmp___36 ;
  int tmp___37 ;
  size_t___0 tmp___38 ;
  int tmp___39 ;
  size_t___0 tmp___40 ;
  int tmp___41 ;
  size_t___0 tmp___42 ;
  int tmp___43 ;
  size_t___0 tmp___44 ;
  int tmp___45 ;
  size_t___0 tmp___46 ;
  void *tmp___47 ;
  size_t___0 tmp___48 ;
  size_t___0 tmp___49 ;
  void *tmp___50 ;
  size_t___0 tmp___51 ;
  int tmp___52 ;
  size_t___0 tmp___53 ;
  int tmp___54 ;
  size_t___0 tmp___55 ;
  int tmp___56 ;
  size_t___0 tmp___57 ;
  int tmp___58 ;
  size_t___0 tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t___0 tmp___63 ;
  int tmp___64 ;
  size_t___0 tmp___65 ;
  int tmp___66 ;
  size_t___0 tmp___67 ;
  int tmp___68 ;
  size_t___0 tmp___69 ;
  int tmp___70 ;
  void *tmp___71 ;
  void *tmp___72 ;
  int tmp___73 ;
  size_t___0 tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  size_t___0 tmp___77 ;
  void *tmp___78 ;
  char *path___0 ;
  void *tmp___79 ;
  struct ignorefile *tmp___80 ;
  struct infofile *tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int _BARRIER_0 ;

  {
  {
  {
  {
  {
  init_elems1_inline_0_inline_1 = 0;
  while (init_elems1_inline_0_inline_1 < 512) {
    info___0[init_elems1_inline_0_inline_1] = (char)0;
    init_elems1_inline_0_inline_1 ++;
  }
  goto info___0_i$nit_INLINE_info___0_i$nit;
  }
  info___0_i$nit_INLINE_info___0_i$nit: /* CIL Label */ ;
  }
  {
  {
  si_unit = (char *)"dkMGTPEZY";
  goto si_unit_i$nit_INLINE_si_unit_i$nit;
  }
  si_unit_i$nit_INLINE_si_unit_i$nit: /* CIL Label */ ;
  }
  {
  {
  iec_unit = (char *)"BKMGTPEZY";
  goto iec_unit_i$nit_INLINE_iec_unit_i$nit;
  }
  iec_unit_i$nit_INLINE_iec_unit_i$nit: /* CIL Label */ ;
  }
  {
  {
  perms[0] = (char )'r';
  perms[1] = (char )'w';
  perms[2] = (char )'x';
  perms[3] = (char )'r';
  perms[4] = (char )'w';
  perms[5] = (char )'x';
  perms[6] = (char )'r';
  perms[7] = (char )'w';
  perms[8] = (char )'x';
  perms[9] = (char )'\000';
  goto perms_i$nit_INLINE_perms_i$nit;
  }
  perms_i$nit_INLINE_perms_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto path_i$nit_INLINE_path_i$nit;
  }
  path_i$nit_INLINE_path_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto lbufsize_i$nit_INLINE_lbufsize_i$nit;
  }
  lbufsize_i$nit_INLINE_lbufsize_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto lbuf_i$nit_INLINE_lbuf_i$nit;
  }
  lbuf_i$nit_INLINE_lbuf_i$nit: /* CIL Label */ ;
  }
  {
  {
  sorts[0].name = (char *)"name";
  sorts[0].cmpfunc = (int (*)())(& alnumsort);
  sorts[1].name = (char *)"version";
  sorts[1].cmpfunc = (int (*)())(& versort);
  sorts[2].name = (char *)"size";
  sorts[2].cmpfunc = (int (*)())(& fsizesort);
  sorts[3].name = (char *)"mtime";
  sorts[3].cmpfunc = (int (*)())(& mtimesort);
  sorts[4].name = (char *)"ctime";
  sorts[4].cmpfunc = (int (*)())(& ctimesort);
  sorts[5].name = (char *)((void *)0);
  sorts[5].cmpfunc = (int (*)())((void *)0);
  goto sorts_i$nit_INLINE_sorts_i$nit;
  }
  sorts_i$nit_INLINE_sorts_i$nit: /* CIL Label */ ;
  }
  {
  {
  ftype[0] = "file";
  ftype[1] = "directory";
  ftype[2] = "link";
  ftype[3] = "char";
  ftype[4] = "block";
  ftype[5] = "socket";
  ftype[6] = "fifo";
  ftype[7] = "unknown";
  ftype[8] = (char const   *)((void *)0);
  goto ftype_i$nit_INLINE_ftype_i$nit;
  }
  ftype_i$nit_INLINE_ftype_i$nit: /* CIL Label */ ;
  }
  {
  {
  fmt[0] = (char const   )'-';
  fmt[1] = (char const   )'d';
  fmt[2] = (char const   )'l';
  fmt[3] = (char const   )'c';
  fmt[4] = (char const   )'b';
  fmt[5] = (char const   )'s';
  fmt[6] = (char const   )'p';
  fmt[7] = (char const   )'?';
  fmt[8] = (char const   )'\000';
  goto fmt_i$nit_INLINE_fmt_i$nit;
  }
  fmt_i$nit_INLINE_fmt_i$nit: /* CIL Label */ ;
  }
  {
  {
  ifmt[0] = (int const   )32768;
  ifmt[1] = (int const   )16384;
  ifmt[2] = (int const   )40960;
  ifmt[3] = (int const   )8192;
  ifmt[4] = (int const   )24576;
  ifmt[5] = (int const   )49152;
  ifmt[6] = (int const   )4096;
  ifmt[7] = (int const   )0;
  goto ifmt_i$nit_INLINE_ifmt_i$nit;
  }
  ifmt_i$nit_INLINE_ifmt_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto outfile_i$nit_INLINE_outfile_i$nit;
  }
  outfile_i$nit_INLINE_outfile_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto topsort_i$nit_INLINE_topsort_i$nit;
  }
  topsort_i$nit_INLINE_topsort_i$nit: /* CIL Label */ ;
  }
  {
  {
  basesort = (int (*)())(& alnumsort);
  goto basesort_i$nit_INLINE_basesort_i$nit;
  }
  basesort_i$nit_INLINE_basesort_i$nit: /* CIL Label */ ;
  }
  {
  {
  getfulltree = & unix_getfulltree;
  goto getfulltree_i$nit_INLINE_getfulltree_i$nit;
  }
  getfulltree_i$nit_INLINE_getfulltree_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto charset_i$nit_INLINE_charset_i$nit;
  }
  charset_i$nit_INLINE_charset_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto timefmt_i$nit_INLINE_timefmt_i$nit;
  }
  timefmt_i$nit_INLINE_timefmt_i$nit: /* CIL Label */ ;
  }
  {
  {
  file_pathsep = (char *)"/";
  goto file_pathsep_i$nit_INLINE_file_pathsep_i$nit;
  }
  file_pathsep_i$nit_INLINE_file_pathsep_i$nit: /* CIL Label */ ;
  }
  {
  {
  file_comment = (char *)"#";
  goto file_comment_i$nit_INLINE_file_comment_i$nit;
  }
  file_comment_i$nit_INLINE_file_comment_i$nit: /* CIL Label */ ;
  }
  {
  {
  _nl = (char *)"\n";
  goto _nl_i$nit_INLINE__nl_i$nit;
  }
  _nl_i$nit_INLINE__nl_i$nit: /* CIL Label */ ;
  }
  {
  {
  sp = (char *)" ";
  goto sp_i$nit_INLINE_sp_i$nit;
  }
  sp_i$nit_INLINE_sp_i$nit: /* CIL Label */ ;
  }
  {
  {
  title = (char *)"Directory Tree";
  goto title_i$nit_INLINE_title_i$nit;
  }
  title_i$nit_INLINE_title_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto host_i$nit_INLINE_host_i$nit;
  }
  host_i$nit_INLINE_host_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ipatterns_i$nit_INLINE_ipatterns_i$nit;
  }
  ipatterns_i$nit_INLINE_ipatterns_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto patterns_i$nit_INLINE_patterns_i$nit;
  }
  patterns_i$nit_INLINE_patterns_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto maxipattern_i$nit_INLINE_maxipattern_i$nit;
  }
  maxipattern_i$nit_INLINE_maxipattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ipattern_i$nit_INLINE_ipattern_i$nit;
  }
  ipattern_i$nit_INLINE_ipattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto maxpattern_i$nit_INLINE_maxpattern_i$nit;
  }
  maxpattern_i$nit_INLINE_maxpattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto pattern_i$nit_INLINE_pattern_i$nit;
  }
  pattern_i$nit_INLINE_pattern_i$nit: /* CIL Label */ ;
  }
  {
  {
  hversion = (char *)"\t\t tree v2.0.4 %s 1996 - 2022 by Steve Baker and Thomas Moore <br>\n\t\t HTML output hacked and copyleft %s 1998 by Francesc Rocher <br>\n\t\t JSON output hacked and copyleft %s 2014 by Florian Sesser <br>\n\t\t Charsets / OS/2 support %s 2001 by Kyosuke Tokoro\n";
  goto hversion_i$nit_INLINE_hversion_i$nit;
  }
  hversion_i$nit_INLINE_hversion_i$nit: /* CIL Label */ ;
  }
  {
  {
  version = (char *)"$Version: $ tree v2.0.4 (c) 1996 - 2022 by Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro $";
  goto version_i$nit_INLINE_version_i$nit;
  }
  version_i$nit_INLINE_version_i$nit: /* CIL Label */ ;
  }
  {
  {
  result_type[0] = (int const   )2;
  result_type[1] = (int const   )2;
  result_type[2] = (int const   )2;
  result_type[3] = (int const   )2;
  result_type[4] = (int const   )2;
  result_type[5] = (int const   )3;
  result_type[6] = (int const   )2;
  result_type[7] = (int const   )2;
  result_type[8] = (int const   )2;
  result_type[9] = (int const   )2;
  result_type[10] = (int const   )2;
  result_type[11] = (int const   )2;
  result_type[12] = (int const   )2;
  result_type[13] = (int const   )2;
  result_type[14] = (int const   )2;
  result_type[15] = (int const   )2;
  result_type[16] = (int const   )2;
  result_type[17] = (int const   )-1;
  result_type[18] = (int const   )-1;
  result_type[19] = (int const   )2;
  result_type[20] = (int const   )1;
  result_type[21] = (int const   )3;
  result_type[22] = (int const   )3;
  result_type[23] = (int const   )2;
  result_type[24] = (int const   )1;
  result_type[25] = (int const   )3;
  result_type[26] = (int const   )3;
  result_type[27] = (int const   )2;
  result_type[28] = (int const   )2;
  result_type[29] = (int const   )2;
  result_type[30] = (int const   )2;
  result_type[31] = (int const   )2;
  result_type[32] = (int const   )2;
  result_type[33] = (int const   )2;
  result_type[34] = (int const   )2;
  result_type[35] = (int const   )2;
  result_type[36] = (int const   )2;
  result_type[37] = (int const   )3;
  result_type[38] = (int const   )2;
  result_type[39] = (int const   )2;
  result_type[40] = (int const   )2;
  result_type[41] = (int const   )2;
  result_type[42] = (int const   )2;
  result_type[43] = (int const   )2;
  result_type[44] = (int const   )2;
  result_type[45] = (int const   )2;
  result_type[46] = (int const   )2;
  result_type[47] = (int const   )2;
  result_type[48] = (int const   )2;
  result_type[49] = (int const   )1;
  result_type[50] = (int const   )1;
  result_type[51] = (int const   )2;
  result_type[52] = (int const   )-1;
  result_type[53] = (int const   )2;
  result_type[54] = (int const   )2;
  result_type[55] = (int const   )2;
  result_type[56] = (int const   )-1;
  result_type[57] = (int const   )2;
  result_type[58] = (int const   )2;
  result_type[59] = (int const   )2;
  goto result_type_i$nit_INLINE_result_type_i$nit;
  }
  result_type_i$nit_INLINE_result_type_i$nit: /* CIL Label */ ;
  }
  {
  {
  next_state[0] = (unsigned int const   )0;
  next_state[1] = (unsigned int const   )4;
  next_state[2] = (unsigned int const   )12;
  next_state[3] = (unsigned int const   )0;
  next_state[4] = (unsigned int const   )0;
  next_state[5] = (unsigned int const   )4;
  next_state[6] = (unsigned int const   )4;
  next_state[7] = (unsigned int const   )4;
  next_state[8] = (unsigned int const   )0;
  next_state[9] = (unsigned int const   )8;
  next_state[10] = (unsigned int const   )8;
  next_state[11] = (unsigned int const   )8;
  next_state[12] = (unsigned int const   )0;
  next_state[13] = (unsigned int const   )8;
  next_state[14] = (unsigned int const   )12;
  next_state[15] = (unsigned int const   )12;
  goto next_state_i$nit_INLINE_next_state_i$nit;
  }
  next_state_i$nit_INLINE_next_state_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto infostack_i$nit_INLINE_infostack_i$nit;
  }
  infostack_i$nit_INLINE_infostack_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto htmldirlen_i$nit_INLINE_htmldirlen_i$nit;
  }
  htmldirlen_i$nit_INLINE_htmldirlen_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto filterstack_i$nit_INLINE_filterstack_i$nit;
  }
  filterstack_i$nit_INLINE_filterstack_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto prev_i$nit_INLINE_prev_i$nit;
  }
  prev_i$nit_INLINE_prev_i$nit: /* CIL Label */ ;
  }
  {
  {
  cstable[0].name = latin1_3;
  cstable[0].vert = "|  ";
  cstable[0].vert_left = "|--";
  cstable[0].corner = "&middot;--";
  cstable[0].copy = "&copy;";
  cstable[0].ctop = " [";
  cstable[0].cbot = " [";
  cstable[0].cmid = " [";
  cstable[0].cext = " [";
  cstable[0].csingle = " [";
  cstable[1].name = iso8859_789;
  cstable[1].vert = "|  ";
  cstable[1].vert_left = "|--";
  cstable[1].corner = "&middot;--";
  cstable[1].copy = "(c)";
  cstable[1].ctop = " [";
  cstable[1].cbot = " [";
  cstable[1].cmid = " [";
  cstable[1].cext = " [";
  cstable[1].csingle = " [";
  cstable[2].name = shift_jis;
  cstable[2].vert = "\204\240 ";
  cstable[2].vert_left = "\204\245";
  cstable[2].corner = "\204\244";
  cstable[2].copy = "(c)";
  cstable[2].ctop = " [";
  cstable[2].cbot = " [";
  cstable[2].cmid = " [";
  cstable[2].cext = " [";
  cstable[2].csingle = " [";
  cstable[3].name = euc_jp;
  cstable[3].vert = "\250\242 ";
  cstable[3].vert_left = "\250\247";
  cstable[3].corner = "\250\246";
  cstable[3].copy = "(c)";
  cstable[3].ctop = " [";
  cstable[3].cbot = " [";
  cstable[3].cmid = " [";
  cstable[3].cext = " [";
  cstable[3].csingle = " [";
  cstable[4].name = euc_kr;
  cstable[4].vert = "\246\242 ";
  cstable[4].vert_left = "\246\247";
  cstable[4].corner = "\246\246";
  cstable[4].copy = "(c)";
  cstable[4].ctop = " [";
  cstable[4].cbot = " [";
  cstable[4].cmid = " [";
  cstable[4].cext = " [";
  cstable[4].csingle = " [";
  cstable[5].name = iso2022jp;
  cstable[5].vert = "\033$B(\"\033(B ";
  cstable[5].vert_left = "\033$B(\'\033(B";
  cstable[5].corner = "\033$B(&\033(B";
  cstable[5].copy = "(c)";
  cstable[5].ctop = " [";
  cstable[5].cbot = " [";
  cstable[5].cmid = " [";
  cstable[5].cext = " [";
  cstable[5].csingle = " [";
  cstable[6].name = ibm_pc;
  cstable[6].vert = "\263  ";
  cstable[6].vert_left = "\303\304\304";
  cstable[6].corner = "\300\304\304";
  cstable[6].copy = "(c)";
  cstable[6].ctop = " [";
  cstable[6].cbot = " [";
  cstable[6].cmid = " [";
  cstable[6].cext = " [";
  cstable[6].csingle = " [";
  cstable[7].name = ibm_ps2;
  cstable[7].vert = "\263  ";
  cstable[7].vert_left = "\303\304\304";
  cstable[7].corner = "\300\304\304";
  cstable[7].copy = "\227";
  cstable[7].ctop = " [";
  cstable[7].cbot = " [";
  cstable[7].cmid = " [";
  cstable[7].cext = " [";
  cstable[7].csingle = " [";
  cstable[8].name = ibm_gr;
  cstable[8].vert = "\263  ";
  cstable[8].vert_left = "\303\304\304";
  cstable[8].corner = "\300\304\304";
  cstable[8].copy = "\270";
  cstable[8].ctop = " [";
  cstable[8].cbot = " [";
  cstable[8].cmid = " [";
  cstable[8].cext = " [";
  cstable[8].csingle = " [";
  cstable[9].name = gb;
  cstable[9].vert = "\251\246 ";
  cstable[9].vert_left = "\251\300";
  cstable[9].corner = "\251\270";
  cstable[9].copy = "(c)";
  cstable[9].ctop = " [";
  cstable[9].cbot = " [";
  cstable[9].cmid = " [";
  cstable[9].cext = " [";
  cstable[9].csingle = " [";
  cstable[10].name = utf8;
  cstable[10].vert = "\342\224\202\302\240\302\240";
  cstable[10].vert_left = "\342\224\234\342\224\200\342\224\200";
  cstable[10].corner = "\342\224\224\342\224\200\342\224\200";
  cstable[10].copy = "\302\251";
  cstable[10].ctop = " \342\216\247";
  cstable[10].cbot = " \342\216\251";
  cstable[10].cmid = " \342\216\250";
  cstable[10].cext = " \342\216\252";
  cstable[10].csingle = " {";
  cstable[11].name = big5;
  cstable[11].vert = "\242x ";
  cstable[11].vert_left = "\242u";
  cstable[11].corner = "\242|";
  cstable[11].copy = "(c)";
  cstable[11].ctop = " [";
  cstable[11].cbot = " [";
  cstable[11].cmid = " [";
  cstable[11].cext = " [";
  cstable[11].csingle = " [";
  cstable[12].name = viscii;
  cstable[12].vert = "|  ";
  cstable[12].vert_left = "|--";
  cstable[12].corner = "`--";
  cstable[12].copy = "\371";
  cstable[12].ctop = " [";
  cstable[12].cbot = " [";
  cstable[12].cmid = " [";
  cstable[12].cext = " [";
  cstable[12].csingle = " [";
  cstable[13].name = koi8ru;
  cstable[13].vert = "\201  ";
  cstable[13].vert_left = "\206\200\200";
  cstable[13].corner = "\204\200\200";
  cstable[13].copy = "\277";
  cstable[13].ctop = " [";
  cstable[13].cbot = " [";
  cstable[13].cmid = " [";
  cstable[13].cext = " [";
  cstable[13].csingle = " [";
  cstable[14].name = windows;
  cstable[14].vert = "|  ";
  cstable[14].vert_left = "|--";
  cstable[14].corner = "`--";
  cstable[14].copy = "\251";
  cstable[14].ctop = " [";
  cstable[14].cbot = " [";
  cstable[14].cmid = " [";
  cstable[14].cext = " [";
  cstable[14].csingle = " [";
  cstable[15].name = (char const   **)((void *)0);
  cstable[15].vert = "|  ";
  cstable[15].vert_left = "|--";
  cstable[15].corner = "`--";
  cstable[15].copy = "(c)";
  cstable[15].ctop = " [";
  cstable[15].cbot = " [";
  cstable[15].cmid = " [";
  cstable[15].cext = " [";
  cstable[15].csingle = " [";
  goto cstable_i$nit_INLINE_cstable_i$nit;
  }
  cstable_i$nit_INLINE_cstable_i$nit: /* CIL Label */ ;
  }
  {
  {
  windows[0] = "ISO-8859-1-Windows-3.1-Latin-1";
  windows[1] = "csWindows31Latin1";
  windows[2] = "ISO-8859-2-Windows-Latin-2";
  windows[3] = "csWindows31Latin2";
  windows[4] = "windows-1250";
  windows[5] = "windows-1251";
  windows[6] = "windows-1253";
  windows[7] = "windows-1254";
  windows[8] = "windows-1255";
  windows[9] = "windows-1256";
  windows[10] = "windows-1256";
  windows[11] = "windows-1257";
  windows[12] = (char const   *)((void *)0);
  goto windows_i$nit_INLINE_windows_i$nit;
  }
  windows_i$nit_INLINE_windows_i$nit: /* CIL Label */ ;
  }
  {
  {
  koi8ru[0] = "KOI8-R";
  koi8ru[1] = "csKOI8R";
  koi8ru[2] = "KOI8-U";
  koi8ru[3] = (char const   *)((void *)0);
  goto koi8ru_i$nit_INLINE_koi8ru_i$nit;
  }
  koi8ru_i$nit_INLINE_koi8ru_i$nit: /* CIL Label */ ;
  }
  {
  {
  viscii[0] = "VISCII";
  viscii[1] = "csVISCII";
  viscii[2] = (char const   *)((void *)0);
  goto viscii_i$nit_INLINE_viscii_i$nit;
  }
  viscii_i$nit_INLINE_viscii_i$nit: /* CIL Label */ ;
  }
  {
  {
  big5[0] = "Big5";
  big5[1] = "csBig5";
  big5[2] = (char const   *)((void *)0);
  goto big5_i$nit_INLINE_big5_i$nit;
  }
  big5_i$nit_INLINE_big5_i$nit: /* CIL Label */ ;
  }
  {
  {
  utf8[0] = "UTF-8";
  utf8[1] = "utf8";
  utf8[2] = (char const   *)((void *)0);
  goto utf8_i$nit_INLINE_utf8_i$nit;
  }
  utf8_i$nit_INLINE_utf8_i$nit: /* CIL Label */ ;
  }
  {
  {
  gb[0] = "GB2312";
  gb[1] = "csGB2312";
  gb[2] = (char const   *)((void *)0);
  goto gb_i$nit_INLINE_gb_i$nit;
  }
  gb_i$nit_INLINE_gb_i$nit: /* CIL Label */ ;
  }
  {
  {
  ibm_gr[0] = "IBM869";
  ibm_gr[1] = "cp869";
  ibm_gr[2] = "869";
  ibm_gr[3] = "cp-gr";
  ibm_gr[4] = "csIBM869";
  ibm_gr[5] = (char const   *)((void *)0);
  goto ibm_gr_i$nit_INLINE_ibm_gr_i$nit;
  }
  ibm_gr_i$nit_INLINE_ibm_gr_i$nit: /* CIL Label */ ;
  }
  {
  {
  ibm_ps2[0] = "IBM850";
  ibm_ps2[1] = "cp850";
  ibm_ps2[2] = "850";
  ibm_ps2[3] = "csPC850Multilingual";
  ibm_ps2[4] = "IBM00858";
  ibm_ps2[5] = "CCSID00858";
  ibm_ps2[6] = "CP00858";
  ibm_ps2[7] = "PC-Multilingual-850+euro";
  ibm_ps2[8] = (char const   *)((void *)0);
  goto ibm_ps2_i$nit_INLINE_ibm_ps2_i$nit;
  }
  ibm_ps2_i$nit_INLINE_ibm_ps2_i$nit: /* CIL Label */ ;
  }
  {
  {
  ibm_pc[0] = "IBM437";
  ibm_pc[1] = "cp437";
  ibm_pc[2] = "437";
  ibm_pc[3] = "csPC8CodePage437";
  ibm_pc[4] = "IBM852";
  ibm_pc[5] = "cp852";
  ibm_pc[6] = "852";
  ibm_pc[7] = "csPCp852";
  ibm_pc[8] = "IBM863";
  ibm_pc[9] = "cp863";
  ibm_pc[10] = "863";
  ibm_pc[11] = "csIBM863";
  ibm_pc[12] = "IBM855";
  ibm_pc[13] = "cp855";
  ibm_pc[14] = "855";
  ibm_pc[15] = "csIBM855";
  ibm_pc[16] = "IBM865";
  ibm_pc[17] = "cp865";
  ibm_pc[18] = "865";
  ibm_pc[19] = "csIBM865";
  ibm_pc[20] = "IBM866";
  ibm_pc[21] = "cp866";
  ibm_pc[22] = "866";
  ibm_pc[23] = "csIBM866";
  ibm_pc[24] = (char const   *)((void *)0);
  goto ibm_pc_i$nit_INLINE_ibm_pc_i$nit;
  }
  ibm_pc_i$nit_INLINE_ibm_pc_i$nit: /* CIL Label */ ;
  }
  {
  {
  iso2022jp[0] = "ISO-2022-JP";
  iso2022jp[1] = "csISO2022JP";
  iso2022jp[2] = "ISO-2022-JP-2";
  iso2022jp[3] = "csISO2022JP2";
  iso2022jp[4] = (char const   *)((void *)0);
  goto iso2022jp_i$nit_INLINE_iso2022jp_i$nit;
  }
  iso2022jp_i$nit_INLINE_iso2022jp_i$nit: /* CIL Label */ ;
  }
  {
  {
  euc_kr[0] = "EUC-KR";
  euc_kr[1] = "csEUCKR";
  euc_kr[2] = (char const   *)((void *)0);
  goto euc_kr_i$nit_INLINE_euc_kr_i$nit;
  }
  euc_kr_i$nit_INLINE_euc_kr_i$nit: /* CIL Label */ ;
  }
  {
  {
  euc_jp[0] = "EUC-JP";
  euc_jp[1] = "Extended_UNIX_Code_Packed_Format_for_Japanese";
  euc_jp[2] = "csEUCPkdFmtJapanese";
  euc_jp[3] = (char const   *)((void *)0);
  goto euc_jp_i$nit_INLINE_euc_jp_i$nit;
  }
  euc_jp_i$nit_INLINE_euc_jp_i$nit: /* CIL Label */ ;
  }
  {
  {
  shift_jis[0] = "Shift_JIS";
  shift_jis[1] = "MS_Kanji";
  shift_jis[2] = "csShiftJIS";
  shift_jis[3] = (char const   *)((void *)0);
  goto shift_jis_i$nit_INLINE_shift_jis_i$nit;
  }
  shift_jis_i$nit_INLINE_shift_jis_i$nit: /* CIL Label */ ;
  }
  {
  {
  iso8859_789[0] = "ISO-8859-7";
  iso8859_789[1] = "ISO_8859-7:1987";
  iso8859_789[2] = "ISO_8859-7";
  iso8859_789[3] = "ELOT_928";
  iso8859_789[4] = "ECMA-118";
  iso8859_789[5] = "greek";
  iso8859_789[6] = "greek8";
  iso8859_789[7] = "csISOLatinGreek";
  iso8859_789[8] = "ISO-8859-8";
  iso8859_789[9] = "ISO_8859-8:1988";
  iso8859_789[10] = "iso-ir-138";
  iso8859_789[11] = "ISO_8859-8";
  iso8859_789[12] = "hebrew";
  iso8859_789[13] = "csISOLatinHebrew";
  iso8859_789[14] = "ISO-8859-9";
  iso8859_789[15] = "ISO_8859-9:1989";
  iso8859_789[16] = "iso-ir-148";
  iso8859_789[17] = "ISO_8859-9";
  iso8859_789[18] = "latin5";
  iso8859_789[19] = "l5";
  iso8859_789[20] = "csISOLatin5";
  iso8859_789[21] = (char const   *)((void *)0);
  goto iso8859_789_i$nit_INLINE_iso8859_789_i$nit;
  }
  iso8859_789_i$nit_INLINE_iso8859_789_i$nit: /* CIL Label */ ;
  }
  {
  {
  latin1_3[0] = "ISO-8859-1";
  latin1_3[1] = "ISO-8859-1:1987";
  latin1_3[2] = "ISO_8859-1";
  latin1_3[3] = "latin1";
  latin1_3[4] = "l1";
  latin1_3[5] = "IBM819";
  latin1_3[6] = "CP819";
  latin1_3[7] = "csISOLatin1";
  latin1_3[8] = "ISO-8859-3";
  latin1_3[9] = "ISO_8859-3:1988";
  latin1_3[10] = "ISO_8859-3";
  latin1_3[11] = "latin3";
  latin1_3[12] = "ls";
  latin1_3[13] = "csISOLatin3";
  latin1_3[14] = (char const   *)((void *)0);
  goto latin1_3_i$nit_INLINE_latin1_3_i$nit;
  }
  latin1_3_i$nit_INLINE_latin1_3_i$nit: /* CIL Label */ ;
  }
  {
  {
  cmds[0].cmd = (char *)"rs";
  cmds[0].cmdnum = (char)4;
  cmds[1].cmd = (char *)"no";
  cmds[1].cmdnum = (char)5;
  cmds[2].cmd = (char *)"fi";
  cmds[2].cmdnum = (char)6;
  cmds[3].cmd = (char *)"di";
  cmds[3].cmdnum = (char)7;
  cmds[4].cmd = (char *)"ln";
  cmds[4].cmdnum = (char)8;
  cmds[5].cmd = (char *)"pi";
  cmds[5].cmdnum = (char)9;
  cmds[6].cmd = (char *)"do";
  cmds[6].cmdnum = (char)10;
  cmds[7].cmd = (char *)"bd";
  cmds[7].cmdnum = (char)11;
  cmds[8].cmd = (char *)"cd";
  cmds[8].cmdnum = (char)12;
  cmds[9].cmd = (char *)"or";
  cmds[9].cmdnum = (char)13;
  cmds[10].cmd = (char *)"so";
  cmds[10].cmdnum = (char)14;
  cmds[11].cmd = (char *)"su";
  cmds[11].cmdnum = (char)15;
  cmds[12].cmd = (char *)"sg";
  cmds[12].cmdnum = (char)16;
  cmds[13].cmd = (char *)"tw";
  cmds[13].cmdnum = (char)17;
  cmds[14].cmd = (char *)"ow";
  cmds[14].cmdnum = (char)18;
  cmds[15].cmd = (char *)"st";
  cmds[15].cmdnum = (char)19;
  cmds[16].cmd = (char *)"ex";
  cmds[16].cmdnum = (char)20;
  cmds[17].cmd = (char *)"mi";
  cmds[17].cmdnum = (char)21;
  cmds[18].cmd = (char *)"lc";
  cmds[18].cmdnum = (char)22;
  cmds[19].cmd = (char *)"rc";
  cmds[19].cmdnum = (char)23;
  cmds[20].cmd = (char *)"ec";
  cmds[20].cmdnum = (char)24;
  cmds[21].cmd = (char *)((void *)0);
  cmds[21].cmdnum = (char)0;
  goto cmds_i$nit_INLINE_cmds_i$nit;
  }
  cmds_i$nit_INLINE_cmds_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ext_i$nit_INLINE_ext_i$nit;
  }
  ext_i$nit_INLINE_ext_i$nit: /* CIL Label */ ;
  }
  {
  {
  vgacolor[0] = (char *)"black";
  vgacolor[1] = (char *)"red";
  vgacolor[2] = (char *)"green";
  vgacolor[3] = (char *)"yellow";
  vgacolor[4] = (char *)"blue";
  vgacolor[5] = (char *)"fuchsia";
  vgacolor[6] = (char *)"aqua";
  vgacolor[7] = (char *)"white";
  vgacolor[8] = (char *)((void *)0);
  vgacolor[9] = (char *)((void *)0);
  vgacolor[10] = (char *)"transparent";
  vgacolor[11] = (char *)"red";
  vgacolor[12] = (char *)"green";
  vgacolor[13] = (char *)"yellow";
  vgacolor[14] = (char *)"blue";
  vgacolor[15] = (char *)"fuchsia";
  vgacolor[16] = (char *)"aqua";
  vgacolor[17] = (char *)"black";
  goto vgacolor_i$nit_INLINE_vgacolor_i$nit;
  }
  vgacolor_i$nit_INLINE_vgacolor_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto color_code_i$nit_INLINE_color_code_i$nit;
  }
  color_code_i$nit_INLINE_color_code_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto termmatch_i$nit_INLINE_termmatch_i$nit;
  }
  termmatch_i$nit_INLINE_termmatch_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto linktargetcolor_i$nit_INLINE_linktargetcolor_i$nit;
  }
  linktargetcolor_i$nit_INLINE_linktargetcolor_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto ansilines_i$nit_INLINE_ansilines_i$nit;
  }
  ansilines_i$nit_INLINE_ansilines_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto colorize_i$nit_INLINE_colorize_i$nit;
  }
  colorize_i$nit_INLINE_colorize_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_envp_i$nit_INLINE__global_envp_i$nit;
  }
  _global_envp_i$nit_INLINE__global_envp_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argv_i$nit_INLINE__global_argv_i$nit;
  }
  _global_argv_i$nit_INLINE__global_argv_i$nit: /* CIL Label */ ;
  }
  {
  {
  goto _global_argc_i$nit_INLINE__global_argc_i$nit;
  }
  _global_argc_i$nit_INLINE__global_argc_i$nit: /* CIL Label */ ;
  }
  goto megaInit_INLINE_megaInit;
  }
  megaInit_INLINE_megaInit: /* CIL Label */ ;
  }
  _global_argc = argc;
  _global_argv = argv;
  _global_envp = _formal_envp;
  _BARRIER_0 = 1;
  dirname = (char **)((void *)0);
  j = 0;
  p = 0;
  q = 0;
  outfilename = (char *)((void *)0);
  gflag = (bool )0;
  uflag = gflag;
  Fflag = uflag;
  sflag = Fflag;
  pflag = sflag;
  lflag = pflag;
  fflag = lflag;
  dflag = fflag;
  aflag = dflag;
  cflag = (bool )0;
  siflag = cflag;
  Hflag = siflag;
  hflag = Hflag;
  Rflag = hflag;
  Qflag = Rflag;
  Nflag = Qflag;
  qflag = Nflag;
  Dflag = qflag;
  reverse = (bool )0;
  nolinks = reverse;
  noreport = nolinks;
  xdev = noreport;
  nocolor = xdev;
  force_color = nocolor;
  noindent = force_color;
  Jflag = (bool )0;
  Xflag = Jflag;
  devflag = Xflag;
  inodeflag = devflag;
  matchdirs = inodeflag;
  ignorecase = matchdirs;
  gitignore = (bool )0;
  metafirst = gitignore;
  pruneflag = metafirst;
  duflag = pruneflag;
  flimit = 0;
  maxdirs = 4096;
  tmp = xmalloc(sizeof(int ) * (unsigned long )maxdirs);
  dirs = (int *)tmp;
  memset((void *)dirs, 0, sizeof(int ) * (unsigned long )maxdirs);
  *(dirs + 0) = 0;
  Level = -1;
  setlocale(0, "");
  setlocale(3, "");
  charset = (char *)getcharset();
  if ((unsigned long )charset == (unsigned long )((void *)0)) {
    tmp___0 = nl_langinfo(14);
    tmp___1 = strcmp((char const   *)tmp___0, "UTF-8");
    if (tmp___1 == 0) {
      charset = "UTF-8";
    } else {
      tmp___2 = nl_langinfo(14);
      tmp___3 = strcmp((char const   *)tmp___2, "utf8");
      if (tmp___3 == 0) {
        charset = "UTF-8";
      }
    }
  }
  __constr_expr_0.intro = & null_intro;
  __constr_expr_0.outtro = & null_outtro;
  __constr_expr_0.printinfo = & unix_printinfo;
  __constr_expr_0.printfile = & unix_printfile;
  __constr_expr_0.error = & unix_error;
  __constr_expr_0.newline = & unix_newline;
  __constr_expr_0.close = & null_close;
  __constr_expr_0.report = & unix_report;
  lc = __constr_expr_0;
  tmp___4 = __ctype_get_mb_cur_max();
  mb_cur_max = (int )tmp___4;
  memset((void *)(utable), 0, sizeof(utable));
  memset((void *)(gtable), 0, sizeof(gtable));
  memset((void *)(itable), 0, sizeof(itable));
  optf = 1;
  i = 1;
  n = i;
  while (i < argc) {
    n ++;
    if (optf) {
      if ((int )*(*(argv + i) + 0) == 45) {
        if (*(*(argv + i) + 1)) {
          j = 1;
          while (*(*(argv + i) + j)) {
            switch ((int )*(*(argv + i) + j)) {
            case 78: 
            Nflag = (bool )1;
            break;
            case 113: 
            qflag = (bool )1;
            break;
            case 81: 
            Qflag = (bool )1;
            break;
            case 100: 
            dflag = (bool )1;
            break;
            case 108: 
            lflag = (bool )1;
            break;
            case 115: 
            sflag = (bool )1;
            break;
            case 104: 
            hflag = (bool )1;
            sflag = (bool )1;
            break;
            case 117: 
            uflag = (bool )1;
            break;
            case 103: 
            gflag = (bool )1;
            break;
            case 102: 
            fflag = (bool )1;
            break;
            case 70: 
            Fflag = (bool )1;
            break;
            case 97: 
            aflag = (bool )1;
            break;
            case 112: 
            pflag = (bool )1;
            break;
            case 105: 
            noindent = (bool )1;
            _nl = (char *)"";
            break;
            case 67: 
            force_color = (bool )1;
            break;
            case 110: 
            nocolor = (bool )1;
            break;
            case 120: 
            xdev = (bool )1;
            break;
            case 80: 
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -P option.\n"));
              exit(1);
            }
            if (pattern >= maxpattern - 1) {
              maxpattern += 10;
              tmp___5 = xrealloc((void *)patterns, sizeof(char *) * (unsigned long )maxpattern);
              patterns = (char **)tmp___5;
            }
            tmp___6 = pattern;
            pattern ++;
            tmp___7 = n;
            n ++;
            *(patterns + tmp___6) = *(argv + tmp___7);
            *(patterns + pattern) = (char *)((void *)0);
            break;
            case 73: 
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -I option.\n"));
              exit(1);
            }
            if (ipattern >= maxipattern - 1) {
              maxipattern += 10;
              tmp___8 = xrealloc((void *)ipatterns, sizeof(char *) * (unsigned long )maxipattern);
              ipatterns = (char **)tmp___8;
            }
            tmp___9 = ipattern;
            ipattern ++;
            tmp___10 = n;
            n ++;
            *(ipatterns + tmp___9) = *(argv + tmp___10);
            *(ipatterns + ipattern) = (char *)((void *)0);
            break;
            case 65: 
            ansilines = (bool )1;
            break;
            case 83: 
            charset = "IBM437";
            break;
            case 68: 
            Dflag = (bool )1;
            break;
            case 116: 
            basesort = (int (*)())(& mtimesort);
            break;
            case 99: 
            basesort = (int (*)())(& ctimesort);
            cflag = (bool )1;
            break;
            case 114: 
            reverse = (bool )1;
            break;
            case 118: 
            basesort = (int (*)())(& versort);
            break;
            case 85: 
            basesort = (int (*)())((void *)0);
            break;
            case 88: 
            Xflag = (bool )1;
            Jflag = (bool )0;
            Hflag = Jflag;
            __constr_expr_1.intro = & xml_intro;
            __constr_expr_1.outtro = & xml_outtro;
            __constr_expr_1.printinfo = & xml_printinfo;
            __constr_expr_1.printfile = & xml_printfile;
            __constr_expr_1.error = & xml_error;
            __constr_expr_1.newline = & xml_newline;
            __constr_expr_1.close = & xml_close;
            __constr_expr_1.report = & xml_report;
            lc = __constr_expr_1;
            break;
            case 74: 
            Jflag = (bool )1;
            Hflag = (bool )0;
            Xflag = Hflag;
            __constr_expr_2.intro = & json_intro;
            __constr_expr_2.outtro = & json_outtro;
            __constr_expr_2.printinfo = & json_printinfo;
            __constr_expr_2.printfile = & json_printfile;
            __constr_expr_2.error = & json_error;
            __constr_expr_2.newline = & json_newline;
            __constr_expr_2.close = & json_close;
            __constr_expr_2.report = & json_report;
            lc = __constr_expr_2;
            break;
            case 72: 
            Hflag = (bool )1;
            Jflag = (bool )0;
            Xflag = Jflag;
            __constr_expr_3.intro = & html_intro;
            __constr_expr_3.outtro = & html_outtro;
            __constr_expr_3.printinfo = & html_printinfo;
            __constr_expr_3.printfile = & html_printfile;
            __constr_expr_3.error = & html_error;
            __constr_expr_3.newline = & html_newline;
            __constr_expr_3.close = & html_close;
            __constr_expr_3.report = & html_report;
            lc = __constr_expr_3;
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -H option.\n"));
              exit(1);
            }
            tmp___11 = n;
            n ++;
            host = *(argv + tmp___11);
            sp = (char *)"&nbsp;";
            break;
            case 84: 
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -T option.\n"));
              exit(1);
            }
            tmp___12 = n;
            n ++;
            title = *(argv + tmp___12);
            break;
            case 82: 
            Rflag = (bool )1;
            break;
            case 76: 
            tmp___13 = n;
            n ++;
            sLevel = *(argv + tmp___13);
            if ((unsigned long )sLevel == (unsigned long )((void *)0)) {
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Missing argument to -L option.\n"));
              exit(1);
            }
            tmp___14 = strtoul((char const   */* __restrict  */)sLevel, (char **/* __restrict  */)((void *)0),
                               0);
            Level = (int )(tmp___14 - 1UL);
            if (Level < 0) {
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Invalid level, must be greater than 0.\n"));
              exit(1);
            }
            break;
            case 111: 
            if ((unsigned long )*(argv + n) == (unsigned long )((void *)0)) {
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to -o option.\n"));
              exit(1);
            }
            tmp___15 = n;
            n ++;
            outfilename = *(argv + tmp___15);
            break;
            case 45: 
            if (j == 1) {
              tmp___16 = strcmp("--", (char const   *)*(argv + i));
              if (! tmp___16) {
                optf = 0;
                break;
              }
              tmp___17 = strcmp("--help", (char const   *)*(argv + i));
              if (! tmp___17) {
                usage(2);
                exit(0);
              }
              tmp___19 = strcmp("--version", (char const   *)*(argv + i));
              if (! tmp___19) {
                v = version + 12;
                tmp___18 = strlen((char const   *)v);
                printf((char const   *)((char const   */* __restrict  */)"%.*s\n"),
                       (int )tmp___18 - 1, v);
                exit(0);
              }
              tmp___21 = strcmp("--inodes", (char const   *)*(argv + i));
              if (! tmp___21) {
                tmp___20 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___20 - 1UL);
                inodeflag = (bool )1;
                break;
              }
              tmp___23 = strcmp("--device", (char const   *)*(argv + i));
              if (! tmp___23) {
                tmp___22 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___22 - 1UL);
                devflag = (bool )1;
                break;
              }
              tmp___25 = strcmp("--noreport", (char const   *)*(argv + i));
              if (! tmp___25) {
                tmp___24 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___24 - 1UL);
                noreport = (bool )1;
                break;
              }
              tmp___27 = strcmp("--nolinks", (char const   *)*(argv + i));
              if (! tmp___27) {
                tmp___26 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___26 - 1UL);
                nolinks = (bool )1;
                break;
              }
              tmp___29 = strcmp("--dirsfirst", (char const   *)*(argv + i));
              if (! tmp___29) {
                tmp___28 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___28 - 1UL);
                topsort = (int (*)())(& dirsfirst);
                break;
              }
              tmp___31 = strcmp("--filesfirst", (char const   *)*(argv + i));
              if (! tmp___31) {
                tmp___30 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___30 - 1UL);
                topsort = (int (*)())(& filesfirst);
                break;
              }
              tmp___35 = strncmp("--filelimit", (char const   *)*(argv + i), (size_t___0 )11);
              if (! tmp___35) {
                j = 11;
                if ((int )*(*(argv + i) + 11) == 61) {
                  if (*(*(argv + i) + 12)) {
                    flimit = atoi((char const   *)(*(argv + i) + 12));
                    tmp___32 = strlen((char const   *)*(argv + i));
                    j = (int )(tmp___32 - 1UL);
                    break;
                  } else {
                    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --filelimit=\n"));
                    exit(1);
                  }
                }
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
                  tmp___33 = n;
                  n ++;
                  flimit = atoi((char const   *)*(argv + tmp___33));
                  tmp___34 = strlen((char const   *)*(argv + i));
                  j = (int )(tmp___34 - 1UL);
                } else {
                  fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --filelimit\n"));
                  exit(1);
                }
                break;
              }
              tmp___39 = strncmp("--charset", (char const   *)*(argv + i), (size_t___0 )9);
              if (! tmp___39) {
                j = 9;
                if ((int )*(*(argv + i) + j) == 61) {
                  charset = (char const   *)(*(argv + i) + 10);
                  if (*charset) {
                    tmp___36 = strlen((char const   *)*(argv + i));
                    j = (int )(tmp___36 - 1UL);
                    break;
                  } else {
                    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --charset=\n"));
                    exit(1);
                  }
                }
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
                  tmp___37 = n;
                  n ++;
                  charset = (char const   *)*(argv + tmp___37);
                  tmp___38 = strlen((char const   *)*(argv + i));
                  j = (int )(tmp___38 - 1UL);
                } else {
                  initlinedraw(1);
                  exit(1);
                }
                break;
              }
              tmp___41 = strncmp("--si", (char const   *)*(argv + i), (size_t___0 )4);
              if (! tmp___41) {
                tmp___40 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___40 - 1UL);
                sflag = (bool )1;
                hflag = (bool )1;
                siflag = (bool )1;
                break;
              }
              tmp___43 = strncmp("--du", (char const   *)*(argv + i), (size_t___0 )4);
              if (! tmp___43) {
                tmp___42 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___42 - 1UL);
                sflag = (bool )1;
                duflag = (bool )1;
                break;
              }
              tmp___45 = strncmp("--prune", (char const   *)*(argv + i), (size_t___0 )7);
              if (! tmp___45) {
                tmp___44 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___44 - 1UL);
                pruneflag = (bool )1;
                break;
              }
              tmp___52 = strncmp("--timefmt", (char const   *)*(argv + i), (size_t___0 )9);
              if (! tmp___52) {
                j = 9;
                if ((int )*(*(argv + i) + j) == 61) {
                  j ++;
                  if (*(*(argv + i) + j)) {
                    tmp___46 = strlen((char const   *)(*(argv + i) + j));
                    tmp___47 = xmalloc(tmp___46 + 1UL);
                    timefmt = strcpy((char *)((char */* __restrict  */)tmp___47),
                                     (char const   *)((char const   */* __restrict  */)(*(argv + i) + j)));
                    tmp___48 = strlen((char const   *)*(argv + i));
                    j = (int )(tmp___48 - 1UL);
                    break;
                  } else {
                    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --timefmt=\n"));
                    exit(1);
                  }
                } else
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
                  tmp___49 = strlen((char const   *)*(argv + n));
                  tmp___50 = xmalloc(tmp___49 + 1UL);
                  timefmt = strcpy((char *)((char */* __restrict  */)tmp___50), (char const   *)((char const   */* __restrict  */)*(argv + n)));
                  n ++;
                  tmp___51 = strlen((char const   *)*(argv + i));
                  j = (int )(tmp___51 - 1UL);
                } else {
                  fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --timefmt\n"));
                  exit(1);
                }
                Dflag = (bool )1;
                break;
              }
              tmp___54 = strncmp("--ignore-case", (char const   *)*(argv + i), (size_t___0 )13);
              if (! tmp___54) {
                tmp___53 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___53 - 1UL);
                ignorecase = (bool )1;
                break;
              }
              tmp___56 = strncmp("--matchdirs", (char const   *)*(argv + i), (size_t___0 )11);
              if (! tmp___56) {
                tmp___55 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___55 - 1UL);
                matchdirs = (bool )1;
                break;
              }
              tmp___62 = strncmp("--sort", (char const   *)*(argv + i), (size_t___0 )6);
              if (! tmp___62) {
                j = 6;
                if ((int )*(*(argv + i) + j) == 61) {
                  j ++;
                  if (*(*(argv + i) + j)) {
                    stmp = *(argv + i) + j;
                    tmp___57 = strlen((char const   *)*(argv + i));
                    j = (int )(tmp___57 - 1UL);
                  } else {
                    fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --sort=\n"));
                    exit(1);
                  }
                } else
                if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
                  tmp___58 = n;
                  n ++;
                  stmp = *(argv + tmp___58);
                  tmp___59 = strlen((char const   *)*(argv + i));
                  j = (int )(tmp___59 - 1UL);
                } else {
                  fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: missing argument to --sort\n"));
                  exit(1);
                }
                basesort = (int (*)())((void *)0);
                k = 0;
                while (sorts[k].name) {
                  tmp___60 = strcasecmp((char const   *)sorts[k].name, (char const   *)stmp);
                  if (tmp___60 == 0) {
                    basesort = sorts[k].cmpfunc;
                    break;
                  }
                  k ++;
                }
                if ((unsigned long )basesort == (unsigned long )((void *)0)) {
                  fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: sort type \'%s\' not valid, should be one of: "),
                          stmp);
                  k = 0;
                  while (sorts[k].name) {
                    if (sorts[k + 1].name) {
                      tmp___61 = ',';
                    } else {
                      tmp___61 = '\n';
                    }
                    printf((char const   *)((char const   */* __restrict  */)"%s%c"),
                           sorts[k].name, tmp___61);
                    k ++;
                  }
                  exit(1);
                }
                break;
              }
              tmp___64 = strncmp("--fromfile", (char const   *)*(argv + i), (size_t___0 )10);
              if (! tmp___64) {
                tmp___63 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___63 - 1UL);
                fromfile = (bool )1;
                getfulltree = & file_getfulltree;
                break;
              }
              tmp___66 = strncmp("--metafirst", (char const   *)*(argv + i), (size_t___0 )11);
              if (! tmp___66) {
                tmp___65 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___65 - 1UL);
                metafirst = (bool )1;
                break;
              }
              tmp___68 = strncmp("--gitignore", (char const   *)*(argv + i), (size_t___0 )11);
              if (! tmp___68) {
                tmp___67 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___67 - 1UL);
                gitignore = (bool )1;
                break;
              }
              tmp___70 = strncmp("--info", (char const   *)*(argv + i), (size_t___0 )6);
              if (! tmp___70) {
                tmp___69 = strlen((char const   *)*(argv + i));
                j = (int )(tmp___69 - 1UL);
                showinfo = (bool )1;
                break;
              }
              fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Invalid argument `%s\'.\n"),
                      *(argv + i));
              usage(1);
              exit(1);
            }
            default: 
            printf((char const   *)((char const   */* __restrict  */)"here i = %d, n = %d\n"),
                   i, n);
            fprintf((FILE *)((FILE */* __restrict  */)stderr), (char const   *)((char const   */* __restrict  */)"tree: Invalid argument -`%c\'.\n"),
                    (int )*(*(argv + i) + j));
            usage(1);
            exit(1);
            break;
            }
            j ++;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (! dirname) {
        q = 30;
        tmp___71 = xmalloc(sizeof(char *) * (unsigned long )q);
        dirname = (char **)tmp___71;
      } else
      if (p == q - 2) {
        q += 20;
        tmp___72 = xrealloc((void *)dirname, sizeof(char *) * (unsigned long )q);
        dirname = (char **)tmp___72;
      }
      tmp___73 = p;
      p ++;
      tmp___74 = strlen((char const   *)*(argv + i));
      tmp___75 = xmalloc(tmp___74 + 1UL);
      *(dirname + tmp___73) = strcpy((char *)((char */* __restrict  */)tmp___75),
                                     (char const   *)((char const   */* __restrict  */)*(argv + i)));
    }
    i = n;
  }
  if (p) {
    *(dirname + p) = (char *)((void *)0);
  }
  setoutput(outfilename);
  parse_dir_colors();
  initlinedraw(0);
  if ((unsigned long )dirname == (unsigned long )((void *)0)) {
    tmp___76 = xmalloc(sizeof(char *) * 2UL);
    dirname = (char **)tmp___76;
    tmp___77 = strlen(".");
    tmp___78 = xmalloc(tmp___77 + 1UL);
    *(dirname + 0) = strcpy((char *)((char */* __restrict  */)tmp___78), (char const   *)((char const   */* __restrict  */)"."));
    *(dirname + 1) = (char *)((void *)0);
  }
  if ((unsigned long )topsort == (unsigned long )((void *)0)) {
    topsort = basesort;
  }
  if (timefmt) {
    setlocale(2, "");
  }
  if (dflag) {
    pruneflag = (bool )0;
  }
  if (Rflag) {
    if (Level == -1) {
      Rflag = (bool )0;
    }
  }
  if (gitignore) {
    stmp = getenv("GIT_DIR");
    if (stmp) {
      tmp___79 = xmalloc((size_t___0 )4096);
      path___0 = (char *)tmp___79;
      snprintf((char *)((char */* __restrict  */)path___0), (size_t___0 )4096, (char const   *)((char const   */* __restrict  */)"%s/info/exclude"),
               stmp);
      tmp___80 = new_ignorefile(path___0);
      push_filterstack(tmp___80);
      free((void *)path___0);
    }
  }
  if (showinfo) {
    tmp___81 = new_infofile((char *)"/usr/share/finfo/global_info");
    push_infostack(tmp___81);
  }
  if (duflag) {
    tmp___82 = 1;
  } else
  if (pruneflag) {
    tmp___82 = 1;
  } else
  if (matchdirs) {
    tmp___82 = 1;
  } else
  if (fromfile) {
    tmp___82 = 1;
  } else {
    tmp___82 = 0;
  }
  needfulltree = (bool )tmp___82;
  emit_tree(dirname, needfulltree);
  if ((unsigned long )outfilename != (unsigned long )((void *)0)) {
    fclose(outfile);
  }
  if (errors) {
    tmp___83 = 2;
  } else {
    tmp___83 = 0;
  }
  return (tmp___83);
}
}
/* END FUNCTION-DEF main LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF unix_newline LOC=UNKNOWN */
void unix_newline(struct _info *file , int level , int postdir , int needcomma ) 
{ 
  int infosize ;
  int line ;
  int lines ;
  size_t___0 tmp ;

  {
  if (postdir <= 0) {
    fprintf((FILE *)((FILE */* __restrict  */)outfile), (char const   *)((char const   */* __restrict  */)"\n"));
  }
  if (file) {
    if (file->comment) {
      infosize = 0;
      if (metafirst) {
        if ((int )info___0[0] == 91) {
          tmp = strlen((char const   *)(info___0));
          infosize = (int )(tmp + 2UL);
        } else {
          infosize = 0;
        }
      }
      lines = 0;
      while (*(file->comment + lines)) {
        lines ++;
      }
      *(dirs + (level + 1)) = 1;
      line = 0;
      while (line < lines) {
        if (metafirst) {
          printf((char const   *)((char const   */* __restrict  */)"%*s"), infosize,
                 "");
        }
        indent(level);
        printcomment(line, lines, *(file->comment + line));
        line ++;
      }
      *(dirs + (level + 1)) = 0;
    }
  }
  return;
}
}
/* END FUNCTION-DEF unix_newline LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF filesfirst LOC=UNKNOWN */
int filesfirst(struct _info **a , struct _info **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )(*a)->isdir != (unsigned int )(*b)->isdir) {
    if ((*a)->isdir) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    return (tmp);
  }
  tmp___0 = (*basesort)(a, b);
  return (tmp___0);
}
}
/* END FUNCTION-DEF filesfirst LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF findino LOC=UNKNOWN */
int findino(ino_t inode , dev_t device ) 
{ 
  struct inotable *it ;

  {
  it = itable[inode & 255ULL];
  while (it) {
    if (it->inode > inode) {
      break;
    }
    if (it->inode == inode) {
      if (it->device >= device) {
        break;
      }
    }
    it = it->nxt;
  }
  if (it) {
    if (it->inode == inode) {
      if (it->device == device) {
        return (1);
      }
    }
  }
  return (0);
}
}
/* END FUNCTION-DEF findino LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF strverscmp LOC=UNKNOWN */
int strverscmp(char const   *s1 , char const   *s2 ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int state ;
  int diff ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char const   *tmp___6 ;
  int tmp___7 ;
  unsigned char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  p1 = (unsigned char const   *)s1;
  p2 = (unsigned char const   *)s2;
  if ((unsigned long )p1 == (unsigned long )p2) {
    return (0);
  }
  tmp = p1;
  p1 ++;
  c1 = (unsigned char )*tmp;
  tmp___0 = p2;
  p2 ++;
  c2 = (unsigned char )*tmp___0;
  tmp___1 = isdigit((int )c1);
  state = ((int )c1 == 48) + (tmp___1 != 0);
  while (1) {
    diff = (int )c1 - (int )c2;
    if (diff == 0) {
      if (! ((int )c1 != 0)) {
        break;
      }
    } else {
      break;
    }
    state = (int )next_state[state];
    tmp___2 = p1;
    p1 ++;
    c1 = (unsigned char )*tmp___2;
    tmp___3 = p2;
    p2 ++;
    c2 = (unsigned char )*tmp___3;
    tmp___4 = isdigit((int )c1);
    state |= ((int )c1 == 48) + (tmp___4 != 0);
  }
  tmp___5 = isdigit((int )c2);
  state = (int )result_type[(state << 2) | (((int )c2 == 48) + (tmp___5 != 0))];
  switch (state) {
  case 2: 
  return (diff);
  case 3: 
  while (1) {
    tmp___8 = p1;
    p1 ++;
    tmp___9 = isdigit((int )*tmp___8);
    if (! tmp___9) {
      break;
    }
    tmp___6 = p2;
    p2 ++;
    tmp___7 = isdigit((int )*tmp___6);
    if (! tmp___7) {
      return (1);
    }
  }
  tmp___12 = isdigit((int )*p2);
  if (tmp___12) {
    tmp___11 = -1;
  } else {
    tmp___11 = diff;
  }
  return (tmp___11);
  default: 
  return (state);
  }
}
}
/* END FUNCTION-DEF strverscmp LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF filtercheck LOC=UNKNOWN */
int filtercheck(char *path___0 , char *name , int isdir ) 
{ 
  int filter ;
  struct ignorefile *ig ;
  struct pattern *p ;
  int fpos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int fpos___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  filter = 0;
  ig = filterstack;
  while (1) {
    if (! filter) {
      if (! ig) {
        break;
      }
    } else {
      break;
    }
    tmp = sprintf((char *)((char */* __restrict  */)(fpattern)), (char const   *)((char const   */* __restrict  */)"%s/"),
                  ig->path);
    fpos = tmp;
    p = ig->remove;
    while ((unsigned long )p != (unsigned long )((void *)0)) {
      if (p->relative) {
        tmp___0 = patmatch(name, p->pattern, isdir);
        if (tmp___0 == 1) {
          filter = 1;
          break;
        }
      } else {
        sprintf((char *)((char */* __restrict  */)(fpattern + fpos)), (char const   *)((char const   */* __restrict  */)"%s"),
                p->pattern);
        tmp___1 = patmatch(path___0, fpattern, isdir);
        if (tmp___1 == 1) {
          filter = 1;
          break;
        }
      }
      p = p->next;
    }
    ig = ig->next;
  }
  if (! filter) {
    return (0);
  }
  ig = filterstack;
  while (ig) {
    tmp___2 = sprintf((char *)((char */* __restrict  */)(fpattern)), (char const   *)((char const   */* __restrict  */)"%s/"),
                      ig->path);
    fpos___0 = tmp___2;
    p = ig->reverse;
    while ((unsigned long )p != (unsigned long )((void *)0)) {
      if (p->relative) {
        tmp___3 = patmatch(name, p->pattern, isdir);
        if (tmp___3 == 1) {
          return (0);
        }
      } else {
        sprintf((char *)((char */* __restrict  */)(fpattern + fpos___0)), (char const   *)((char const   */* __restrict  */)"%s"),
                p->pattern);
        tmp___4 = patmatch(path___0, fpattern, isdir);
        if (tmp___4 == 1) {
          return (0);
        }
      }
      p = p->next;
    }
    ig = ig->next;
  }
  return (1);
}
}
/* END FUNCTION-DEF filtercheck LOC=UNKNOWN */

/* BEGIN FUNCTION-DEF endcolor LOC=UNKNOWN */
void endcolor(void) 
{ 


  {
  if (color_code[24]) {
    fputs((char const   *)((char const   */* __restrict  */)color_code[24]), (FILE *)((FILE */* __restrict  */)outfile));
  }
  return;
}
}
/* END FUNCTION-DEF endcolor LOC=UNKNOWN */
